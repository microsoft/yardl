// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#ifdef _MSC_VER
#define unlikely(x) x
#else
#define unlikely(x) __builtin_expect((x), 0)
#endif

namespace sketch {
namespace {
void MyProtocolWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteHeader()"; break;
  case 1: expected_method = "WriteSamples() or EndSamples()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteHeader()"; break;
  case 1: attempted_method = end ? "EndSamples()" : "WriteSamples()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void MyProtocolReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadHeader()";
    case 1: return "ReadSamples()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string MyProtocolWriterBase::schema_ = R"({"protocol":{"name":"MyProtocol","sequence":[{"name":"header","type":"Sketch.Header"},{"name":"samples","type":{"stream":{"items":"Sketch.Sample"}}}]},"types":[{"name":"Header","fields":[{"name":"subject","type":"string"}]},{"name":"Sample","fields":[{"name":"id","type":"uint32"},{"name":"data","type":{"vector":{"items":"int32"}}}]}]})";

std::vector<std::string> MyProtocolWriterBase::previous_schemas_ = {
};

std::string MyProtocolWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return MyProtocolWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol MyProtocol.");
  }

}

void MyProtocolWriterBase::WriteHeader(sketch::Header const& value) {
  if (unlikely(state_ != 0)) {
    MyProtocolWriterBaseInvalidState(0, false, state_);
  }

  WriteHeaderImpl(value);
  state_ = 1;
}

void MyProtocolWriterBase::WriteSamples(sketch::Sample const& value) {
  if (unlikely(state_ != 1)) {
    MyProtocolWriterBaseInvalidState(1, false, state_);
  }

  WriteSamplesImpl(value);
}

void MyProtocolWriterBase::WriteSamples(std::vector<sketch::Sample> const& values) {
  if (unlikely(state_ != 1)) {
    MyProtocolWriterBaseInvalidState(1, false, state_);
  }

  WriteSamplesImpl(values);
}

void MyProtocolWriterBase::EndSamples() {
  if (unlikely(state_ != 1)) {
    MyProtocolWriterBaseInvalidState(1, true, state_);
  }

  EndSamplesImpl();
  state_ = 2;
}

// fallback implementation
void MyProtocolWriterBase::WriteSamplesImpl(std::vector<sketch::Sample> const& values) {
  for (auto const& v : values) {
    WriteSamplesImpl(v);
  }
}

void MyProtocolWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    MyProtocolWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string MyProtocolReaderBase::schema_ = MyProtocolWriterBase::schema_;

std::vector<std::string> MyProtocolReaderBase::previous_schemas_ = MyProtocolWriterBase::previous_schemas_;

Version MyProtocolReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == MyProtocolWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol MyProtocol.");
}

void MyProtocolReaderBase::ReadHeader(sketch::Header& value) {
  if (unlikely(state_ != 0)) {
    MyProtocolReaderBaseInvalidState(0, state_);
  }

  ReadHeaderImpl(value);
  state_ = 2;
}

bool MyProtocolReaderBase::ReadSamples(sketch::Sample& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    MyProtocolReaderBaseInvalidState(2, state_);
  }

  bool result = ReadSamplesImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool MyProtocolReaderBase::ReadSamples(std::vector<sketch::Sample>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    MyProtocolReaderBaseInvalidState(2, state_);
  }

  if (!ReadSamplesImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool MyProtocolReaderBase::ReadSamplesImpl(std::vector<sketch::Sample>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadSamplesImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void MyProtocolReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      MyProtocolReaderBaseInvalidState(4, state_);
    }
  }

  CloseImpl();
}
void MyProtocolReaderBase::CopyTo(MyProtocolWriterBase& writer, size_t samples_buffer_size) {
  {
    sketch::Header value;
    ReadHeader(value);
    writer.WriteHeader(value);
  }
  if (samples_buffer_size > 1) {
    std::vector<sketch::Sample> values;
    values.reserve(samples_buffer_size);
    while(ReadSamples(values)) {
      writer.WriteSamples(values);
    }
    writer.EndSamples();
  } else {
    sketch::Sample value;
    while(ReadSamples(value)) {
      writer.WriteSamples(value);
    }
    writer.EndSamples();
  }
}

std::string MyProtocolIndexedReaderBase::schema_ = MyProtocolWriterBase::schema_;

std::vector<std::string> MyProtocolIndexedReaderBase::previous_schemas_ = MyProtocolWriterBase::previous_schemas_;

Version MyProtocolIndexedReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == MyProtocolWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol MyProtocol.");
}

void MyProtocolIndexedReaderBase::ReadHeader(sketch::Header& value) {
  ReadHeaderImpl(value);
}

bool MyProtocolIndexedReaderBase::ReadSamples(sketch::Sample& value, size_t idx) {
  return ReadSamplesImpl(value, idx);
}

bool MyProtocolIndexedReaderBase::ReadSamples(std::vector<sketch::Sample>& values, size_t idx) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (!ReadSamplesImpl(values, idx)) {
    return values.size() > 0;
  }
  return true;
}

size_t MyProtocolIndexedReaderBase::CountSamples() {
  return CountSamplesImpl();
}

void MyProtocolIndexedReaderBase::Close() {
  CloseImpl();
}
} // namespace sketch
