// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "../yardl/detail/ndjson/serializers.h"
#include "protocols.h"

namespace tuples {
using ordered_json = nlohmann::ordered_json;

template <typename T1, typename T2>
void to_json(ordered_json& j, tuples::Tuple<T1, T2> const& value);
template <typename T1, typename T2>
void from_json(ordered_json const& j, tuples::Tuple<T1, T2>& value);

} // namespace tuples

namespace basic_types {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, basic_types::Fruits const& value);
void from_json(ordered_json const& j, basic_types::Fruits& value);

void to_json(ordered_json& j, basic_types::DaysOfWeek const& value);
void from_json(ordered_json const& j, basic_types::DaysOfWeek& value);

void to_json(ordered_json& j, basic_types::TextFormat const& value);
void from_json(ordered_json const& j, basic_types::TextFormat& value);

void to_json(ordered_json& j, basic_types::RecordWithUnions const& value);
void from_json(ordered_json const& j, basic_types::RecordWithUnions& value);

template <typename T0, typename T1>
void to_json(ordered_json& j, basic_types::GenericRecordWithComputedFields<T0, T1> const& value);
template <typename T0, typename T1>
void from_json(ordered_json const& j, basic_types::GenericRecordWithComputedFields<T0, T1>& value);

} // namespace basic_types

namespace image {
using ordered_json = nlohmann::ordered_json;

} // namespace image

namespace test_model {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, test_model::SmallBenchmarkRecord const& value);
void from_json(ordered_json const& j, test_model::SmallBenchmarkRecord& value);

void to_json(ordered_json& j, test_model::SimpleEncodingCounters const& value);
void from_json(ordered_json const& j, test_model::SimpleEncodingCounters& value);

void to_json(ordered_json& j, test_model::SimpleAcquisition const& value);
void from_json(ordered_json const& j, test_model::SimpleAcquisition& value);

void to_json(ordered_json& j, test_model::SimpleRecord const& value);
void from_json(ordered_json const& j, test_model::SimpleRecord& value);

void to_json(ordered_json& j, test_model::RecordWithPrimitives const& value);
void from_json(ordered_json const& j, test_model::RecordWithPrimitives& value);

void to_json(ordered_json& j, test_model::RecordWithPrimitiveAliases const& value);
void from_json(ordered_json const& j, test_model::RecordWithPrimitiveAliases& value);

void to_json(ordered_json& j, test_model::TupleWithRecords const& value);
void from_json(ordered_json const& j, test_model::TupleWithRecords& value);

void to_json(ordered_json& j, test_model::RecordWithVectors const& value);
void from_json(ordered_json const& j, test_model::RecordWithVectors& value);

void to_json(ordered_json& j, test_model::RecordWithVectorOfTimes const& value);
void from_json(ordered_json const& j, test_model::RecordWithVectorOfTimes& value);

void to_json(ordered_json& j, test_model::RecordWithArrays const& value);
void from_json(ordered_json const& j, test_model::RecordWithArrays& value);

void to_json(ordered_json& j, test_model::RecordWithArraysSimpleSyntax const& value);
void from_json(ordered_json const& j, test_model::RecordWithArraysSimpleSyntax& value);

void to_json(ordered_json& j, test_model::RecordWithOptionalFields const& value);
void from_json(ordered_json const& j, test_model::RecordWithOptionalFields& value);

void to_json(ordered_json& j, test_model::RecordWithVlens const& value);
void from_json(ordered_json const& j, test_model::RecordWithVlens& value);

void to_json(ordered_json& j, test_model::RecordWithStrings const& value);
void from_json(ordered_json const& j, test_model::RecordWithStrings& value);

void to_json(ordered_json& j, test_model::RecordWithOptionalVector const& value);
void from_json(ordered_json const& j, test_model::RecordWithOptionalVector& value);

void to_json(ordered_json& j, test_model::RecordWithFixedVectors const& value);
void from_json(ordered_json const& j, test_model::RecordWithFixedVectors& value);

void to_json(ordered_json& j, test_model::RecordWithFixedArrays const& value);
void from_json(ordered_json const& j, test_model::RecordWithFixedArrays& value);

void to_json(ordered_json& j, test_model::RecordWithNDArrays const& value);
void from_json(ordered_json const& j, test_model::RecordWithNDArrays& value);

void to_json(ordered_json& j, test_model::RecordWithNDArraysSingleDimension const& value);
void from_json(ordered_json const& j, test_model::RecordWithNDArraysSingleDimension& value);

void to_json(ordered_json& j, test_model::RecordWithDynamicNDArrays const& value);
void from_json(ordered_json const& j, test_model::RecordWithDynamicNDArrays& value);

void to_json(ordered_json& j, test_model::RecordWithFixedCollections const& value);
void from_json(ordered_json const& j, test_model::RecordWithFixedCollections& value);

void to_json(ordered_json& j, test_model::RecordWithVlenCollections const& value);
void from_json(ordered_json const& j, test_model::RecordWithVlenCollections& value);

void to_json(ordered_json& j, test_model::UInt64Enum const& value);
void from_json(ordered_json const& j, test_model::UInt64Enum& value);

void to_json(ordered_json& j, test_model::Int64Enum const& value);
void from_json(ordered_json const& j, test_model::Int64Enum& value);

void to_json(ordered_json& j, test_model::SizeBasedEnum const& value);
void from_json(ordered_json const& j, test_model::SizeBasedEnum& value);

void to_json(ordered_json& j, test_model::RecordWithEnums const& value);
void from_json(ordered_json const& j, test_model::RecordWithEnums& value);

template <typename T1, typename T2>
void to_json(ordered_json& j, test_model::GenericRecord<T1, T2> const& value);
template <typename T1, typename T2>
void from_json(ordered_json const& j, test_model::GenericRecord<T1, T2>& value);

void to_json(ordered_json& j, test_model::RecordWithAliasedGenerics const& value);
void from_json(ordered_json const& j, test_model::RecordWithAliasedGenerics& value);

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithOptionalGenericField<T> const& value);
template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithOptionalGenericField<T>& value);

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithAliasedOptionalGenericField<T> const& value);
template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithAliasedOptionalGenericField<T>& value);

template <typename U, typename V>
void to_json(ordered_json& j, test_model::RecordWithOptionalGenericUnionField<U, V> const& value);
template <typename U, typename V>
void from_json(ordered_json const& j, test_model::RecordWithOptionalGenericUnionField<U, V>& value);

template <typename U, typename V>
void to_json(ordered_json& j, test_model::RecordWithAliasedOptionalGenericUnionField<U, V> const& value);
template <typename U, typename V>
void from_json(ordered_json const& j, test_model::RecordWithAliasedOptionalGenericUnionField<U, V>& value);

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithGenericVectors<T> const& value);
template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithGenericVectors<T>& value);

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithGenericFixedVectors<T> const& value);
template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithGenericFixedVectors<T>& value);

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithGenericArrays<T> const& value);
template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithGenericArrays<T>& value);

template <typename T, typename U>
void to_json(ordered_json& j, test_model::RecordWithGenericMaps<T, U> const& value);
template <typename T, typename U>
void from_json(ordered_json const& j, test_model::RecordWithGenericMaps<T, U>& value);

template <typename A, typename B>
void to_json(ordered_json& j, test_model::RecordContainingGenericRecords<A, B> const& value);
template <typename A, typename B>
void from_json(ordered_json const& j, test_model::RecordContainingGenericRecords<A, B>& value);

void to_json(ordered_json& j, test_model::RecordContainingNestedGenericRecords const& value);
void from_json(ordered_json const& j, test_model::RecordContainingNestedGenericRecords& value);

void to_json(ordered_json& j, test_model::RecordWithComputedFields const& value);
void from_json(ordered_json const& j, test_model::RecordWithComputedFields& value);

void to_json(ordered_json& j, test_model::RecordNotUsedInProtocol const& value);
void from_json(ordered_json const& j, test_model::RecordNotUsedInProtocol& value);

void to_json(ordered_json& j, test_model::EnumWithKeywordSymbols const& value);
void from_json(ordered_json const& j, test_model::EnumWithKeywordSymbols& value);

void to_json(ordered_json& j, test_model::RecordWithKeywordFields const& value);
void from_json(ordered_json const& j, test_model::RecordWithKeywordFields& value);

} // namespace test_model

NLOHMANN_JSON_NAMESPACE_BEGIN

template <typename T1, typename T2>
struct adl_serializer<std::variant<T1, T2>> {
  static void to_json(ordered_json& j, std::variant<T1, T2> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"T1", std::get<T1>(value)} };
        break;
      case 1:
        j = ordered_json{ {"T2", std::get<T2>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<T1, T2>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "T1") {
      value = it.value().get<T1>();
      return;
    }
    if (tag == "T2") {
      value = it.value().get<T2>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<std::monostate, int32_t, std::string>> {
  static void to_json(ordered_json& j, std::variant<std::monostate, int32_t, std::string> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<std::monostate, int32_t, std::string>& value) {
    if ((j.is_null())) {
      value = j.get<std::monostate>();
      return;
    }
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    if ((j.is_string())) {
      value = j.get<std::string>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<yardl::Time, yardl::DateTime>> {
  static void to_json(ordered_json& j, std::variant<yardl::Time, yardl::DateTime> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"time", std::get<yardl::Time>(value)} };
        break;
      case 1:
        j = ordered_json{ {"datetime", std::get<yardl::DateTime>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<yardl::Time, yardl::DateTime>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "time") {
      value = it.value().get<yardl::Time>();
      return;
    }
    if (tag == "datetime") {
      value = it.value().get<yardl::DateTime>();
      return;
    }
  }
};

template <typename T1, typename T2>
struct adl_serializer<std::variant<std::monostate, T1, T2>> {
  static void to_json(ordered_json& j, std::variant<std::monostate, T1, T2> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"null", std::get<std::monostate>(value)} };
        break;
      case 1:
        j = ordered_json{ {"T", std::get<T1>(value)} };
        break;
      case 2:
        j = ordered_json{ {"U", std::get<T2>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<std::monostate, T1, T2>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "null") {
      value = it.value().get<std::monostate>();
      return;
    }
    if (tag == "T") {
      value = it.value().get<T1>();
      return;
    }
    if (tag == "U") {
      value = it.value().get<T2>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<std::monostate, std::string, int32_t>> {
  static void to_json(ordered_json& j, std::variant<std::monostate, std::string, int32_t> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<std::monostate, std::string, int32_t>& value) {
    if ((j.is_null())) {
      value = j.get<std::monostate>();
      return;
    }
    if ((j.is_string())) {
      value = j.get<std::string>();
      return;
    }
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<int32_t, test_model::SimpleRecord>> {
  static void to_json(ordered_json& j, std::variant<int32_t, test_model::SimpleRecord> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<int32_t, test_model::SimpleRecord>& value) {
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    if ((j.is_object())) {
      value = j.get<test_model::SimpleRecord>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> {
  static void to_json(ordered_json& j, std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
    if ((j.is_null())) {
      value = j.get<std::monostate>();
      return;
    }
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    if ((j.is_object())) {
      value = j.get<test_model::SimpleRecord>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<int32_t, float>> {
  static void to_json(ordered_json& j, std::variant<int32_t, float> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"int32", std::get<int32_t>(value)} };
        break;
      case 1:
        j = ordered_json{ {"float32", std::get<float>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<int32_t, float>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "int32") {
      value = it.value().get<int32_t>();
      return;
    }
    if (tag == "float32") {
      value = it.value().get<float>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<std::monostate, int32_t, float>> {
  static void to_json(ordered_json& j, std::variant<std::monostate, int32_t, float> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"null", std::get<std::monostate>(value)} };
        break;
      case 1:
        j = ordered_json{ {"int32", std::get<int32_t>(value)} };
        break;
      case 2:
        j = ordered_json{ {"float32", std::get<float>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<std::monostate, int32_t, float>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "null") {
      value = it.value().get<std::monostate>();
      return;
    }
    if (tag == "int32") {
      value = it.value().get<int32_t>();
      return;
    }
    if (tag == "float32") {
      value = it.value().get<float>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<int32_t, basic_types::GenericRecordWithComputedFields<std::string, float>>> {
  static void to_json(ordered_json& j, std::variant<int32_t, basic_types::GenericRecordWithComputedFields<std::string, float>> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<int32_t, basic_types::GenericRecordWithComputedFields<std::string, float>>& value) {
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    if ((j.is_object())) {
      value = j.get<basic_types::GenericRecordWithComputedFields<std::string, float>>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<std::string, float>> {
  static void to_json(ordered_json& j, std::variant<std::string, float> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<std::string, float>& value) {
    if ((j.is_string())) {
      value = j.get<std::string>();
      return;
    }
    if ((j.is_number())) {
      value = j.get<float>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <typename T1, typename T2, typename T3>
struct adl_serializer<std::variant<T1, T2, T3>> {
  static void to_json(ordered_json& j, std::variant<T1, T2, T3> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"T", std::get<T1>(value)} };
        break;
      case 1:
        j = ordered_json{ {"U", std::get<T2>(value)} };
        break;
      case 2:
        j = ordered_json{ {"V", std::get<T3>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<T1, T2, T3>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "T") {
      value = it.value().get<T1>();
      return;
    }
    if (tag == "U") {
      value = it.value().get<T2>();
      return;
    }
    if (tag == "V") {
      value = it.value().get<T3>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<int32_t, float, std::string>> {
  static void to_json(ordered_json& j, std::variant<int32_t, float, std::string> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"T", std::get<int32_t>(value)} };
        break;
      case 1:
        j = ordered_json{ {"U", std::get<float>(value)} };
        break;
      case 2:
        j = ordered_json{ {"V", std::get<std::string>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<int32_t, float, std::string>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "T") {
      value = it.value().get<int32_t>();
      return;
    }
    if (tag == "U") {
      value = it.value().get<float>();
      return;
    }
    if (tag == "V") {
      value = it.value().get<std::string>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<test_model::SimpleAcquisition, image::Image<float>>> {
  static void to_json(ordered_json& j, std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"acquisition", std::get<test_model::SimpleAcquisition>(value)} };
        break;
      case 1:
        j = ordered_json{ {"image", std::get<image::Image<float>>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<test_model::SimpleAcquisition, image::Image<float>>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "acquisition") {
      value = it.value().get<test_model::SimpleAcquisition>();
      return;
    }
    if (tag == "image") {
      value = it.value().get<image::Image<float>>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<std::string, int32_t>> {
  static void to_json(ordered_json& j, std::variant<std::string, int32_t> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<std::string, int32_t>& value) {
    if ((j.is_string())) {
      value = j.get<std::string>();
      return;
    }
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<int32_t, test_model::RecordWithVlens>> {
  static void to_json(ordered_json& j, std::variant<int32_t, test_model::RecordWithVlens> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  static void from_json(ordered_json const& j, std::variant<int32_t, test_model::RecordWithVlens>& value) {
    if ((j.is_number())) {
      value = j.get<int32_t>();
      return;
    }
    if ((j.is_object())) {
      value = j.get<test_model::RecordWithVlens>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

template <>
struct adl_serializer<std::variant<image::FloatImage, test_model::Image<double>>> {
  static void to_json(ordered_json& j, std::variant<image::FloatImage, test_model::Image<double>> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"imageFloat", std::get<image::FloatImage>(value)} };
        break;
      case 1:
        j = ordered_json{ {"imageDouble", std::get<test_model::Image<double>>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<image::FloatImage, test_model::Image<double>>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "imageFloat") {
      value = it.value().get<image::FloatImage>();
      return;
    }
    if (tag == "imageDouble") {
      value = it.value().get<test_model::Image<double>>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<test_model::AliasedString, test_model::AliasedEnum>> {
  static void to_json(ordered_json& j, std::variant<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"T1", std::get<test_model::AliasedString>(value)} };
        break;
      case 1:
        j = ordered_json{ {"T2", std::get<test_model::AliasedEnum>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<test_model::AliasedString, test_model::AliasedEnum>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "T1") {
      value = it.value().get<test_model::AliasedString>();
      return;
    }
    if (tag == "T2") {
      value = it.value().get<test_model::AliasedEnum>();
      return;
    }
  }
};

NLOHMANN_JSON_NAMESPACE_END

namespace tuples {
using ordered_json = nlohmann::ordered_json;

template <typename T1, typename T2>
void to_json(ordered_json& j, tuples::Tuple<T1, T2> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v1)) {
    j.push_back({"v1", value.v1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v2)) {
    j.push_back({"v2", value.v2});
  }
}

template <typename T1, typename T2>
void from_json(ordered_json const& j, tuples::Tuple<T1, T2>& value) {
  if (auto it = j.find("v1"); it != j.end()) {
    it->get_to(value.v1);
  }
  if (auto it = j.find("v2"); it != j.end()) {
    it->get_to(value.v2);
  }
}

} // namespace tuples

namespace basic_types {
using ordered_json = nlohmann::ordered_json;

namespace {
std::unordered_map<std::string, basic_types::Fruits> const __Fruits_values = {
  {"apple", basic_types::Fruits::kApple},
  {"banana", basic_types::Fruits::kBanana},
  {"pear", basic_types::Fruits::kPear},
};
} //namespace

void to_json(ordered_json& j, basic_types::Fruits const& value) {
  switch (value) {
    case basic_types::Fruits::kApple:
      j = "apple";
      break;
    case basic_types::Fruits::kBanana:
      j = "banana";
      break;
    case basic_types::Fruits::kPear:
      j = "pear";
      break;
    default:
      using underlying_type = typename std::underlying_type<basic_types::Fruits>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, basic_types::Fruits& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __Fruits_values.find(symbol); res != __Fruits_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum basic_types::Fruits");
  }
  using underlying_type = typename std::underlying_type<basic_types::Fruits>::type;
  value = static_cast<basic_types::Fruits>(j.get<underlying_type>());
}

namespace {
std::unordered_map<std::string, basic_types::DaysOfWeek> const __DaysOfWeek_values = {
  {"monday", basic_types::DaysOfWeek::kMonday},
  {"tuesday", basic_types::DaysOfWeek::kTuesday},
  {"wednesday", basic_types::DaysOfWeek::kWednesday},
  {"thursday", basic_types::DaysOfWeek::kThursday},
  {"friday", basic_types::DaysOfWeek::kFriday},
  {"saturday", basic_types::DaysOfWeek::kSaturday},
  {"sunday", basic_types::DaysOfWeek::kSunday},
};
} //namespace

void to_json(ordered_json& j, basic_types::DaysOfWeek const& value) {
  auto arr = ordered_json::array();
  if (value == 0) {
    j = arr;
    return;
  }
  auto remaining = value;
  if (remaining.HasFlags(basic_types::DaysOfWeek::kMonday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kMonday);
    arr.push_back("monday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::DaysOfWeek::kTuesday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kTuesday);
    arr.push_back("tuesday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::DaysOfWeek::kWednesday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kWednesday);
    arr.push_back("wednesday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::DaysOfWeek::kThursday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kThursday);
    arr.push_back("thursday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::DaysOfWeek::kFriday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kFriday);
    arr.push_back("friday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::DaysOfWeek::kSaturday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kSaturday);
    arr.push_back("saturday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::DaysOfWeek::kSunday)) {
    remaining.UnsetFlags(basic_types::DaysOfWeek::kSunday);
    arr.push_back("sunday");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  j = value.Value();
}

void from_json(ordered_json const& j, basic_types::DaysOfWeek& value) {
  if (j.is_number()) {
    using underlying_type = typename basic_types::DaysOfWeek::value_type;
    value = j.get<underlying_type>();
    return;
  }
  std::vector<std::string> arr = j;
  value = {};
  for (auto const& item : arr) {
    if (auto res = __DaysOfWeek_values.find(item); res != __DaysOfWeek_values.end()) {
      value |= res->second;
      continue;
    }
    throw std::runtime_error("Invalid enum value '" + item + "' for enum basic_types::DaysOfWeek");
  }
}

namespace {
std::unordered_map<std::string, basic_types::TextFormat> const __TextFormat_values = {
  {"regular", basic_types::TextFormat::kRegular},
  {"bold", basic_types::TextFormat::kBold},
  {"italic", basic_types::TextFormat::kItalic},
  {"underline", basic_types::TextFormat::kUnderline},
  {"strikethrough", basic_types::TextFormat::kStrikethrough},
};
} //namespace

void to_json(ordered_json& j, basic_types::TextFormat const& value) {
  auto arr = ordered_json::array();
  if (value == 0) {
    arr.push_back("regular");
    j = arr;
    return;
  }
  auto remaining = value;
  if (remaining.HasFlags(basic_types::TextFormat::kBold)) {
    remaining.UnsetFlags(basic_types::TextFormat::kBold);
    arr.push_back("bold");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::TextFormat::kItalic)) {
    remaining.UnsetFlags(basic_types::TextFormat::kItalic);
    arr.push_back("italic");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::TextFormat::kUnderline)) {
    remaining.UnsetFlags(basic_types::TextFormat::kUnderline);
    arr.push_back("underline");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(basic_types::TextFormat::kStrikethrough)) {
    remaining.UnsetFlags(basic_types::TextFormat::kStrikethrough);
    arr.push_back("strikethrough");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  j = value.Value();
}

void from_json(ordered_json const& j, basic_types::TextFormat& value) {
  if (j.is_number()) {
    using underlying_type = typename basic_types::TextFormat::value_type;
    value = j.get<underlying_type>();
    return;
  }
  std::vector<std::string> arr = j;
  value = {};
  for (auto const& item : arr) {
    if (auto res = __TextFormat_values.find(item); res != __TextFormat_values.end()) {
      value |= res->second;
      continue;
    }
    throw std::runtime_error("Invalid enum value '" + item + "' for enum basic_types::TextFormat");
  }
}

void to_json(ordered_json& j, basic_types::RecordWithUnions const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.null_or_int_or_string)) {
    j.push_back({"nullOrIntOrString", value.null_or_int_or_string});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.date_or_datetime)) {
    j.push_back({"dateOrDatetime", value.date_or_datetime});
  }
}

void from_json(ordered_json const& j, basic_types::RecordWithUnions& value) {
  if (auto it = j.find("nullOrIntOrString"); it != j.end()) {
    it->get_to(value.null_or_int_or_string);
  }
  if (auto it = j.find("dateOrDatetime"); it != j.end()) {
    it->get_to(value.date_or_datetime);
  }
}

template <typename T0, typename T1>
void to_json(ordered_json& j, basic_types::GenericRecordWithComputedFields<T0, T1> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.f1)) {
    j.push_back({"f1", value.f1});
  }
}

template <typename T0, typename T1>
void from_json(ordered_json const& j, basic_types::GenericRecordWithComputedFields<T0, T1>& value) {
  if (auto it = j.find("f1"); it != j.end()) {
    it->get_to(value.f1);
  }
}

} // namespace basic_types

namespace image {
using ordered_json = nlohmann::ordered_json;

} // namespace image

namespace test_model {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, test_model::SmallBenchmarkRecord const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.a)) {
    j.push_back({"a", value.a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.b)) {
    j.push_back({"b", value.b});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.c)) {
    j.push_back({"c", value.c});
  }
}

void from_json(ordered_json const& j, test_model::SmallBenchmarkRecord& value) {
  if (auto it = j.find("a"); it != j.end()) {
    it->get_to(value.a);
  }
  if (auto it = j.find("b"); it != j.end()) {
    it->get_to(value.b);
  }
  if (auto it = j.find("c"); it != j.end()) {
    it->get_to(value.c);
  }
}

void to_json(ordered_json& j, test_model::SimpleEncodingCounters const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.e1)) {
    j.push_back({"e1", value.e1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.e2)) {
    j.push_back({"e2", value.e2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.slice)) {
    j.push_back({"slice", value.slice});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.repetition)) {
    j.push_back({"repetition", value.repetition});
  }
}

void from_json(ordered_json const& j, test_model::SimpleEncodingCounters& value) {
  if (auto it = j.find("e1"); it != j.end()) {
    it->get_to(value.e1);
  }
  if (auto it = j.find("e2"); it != j.end()) {
    it->get_to(value.e2);
  }
  if (auto it = j.find("slice"); it != j.end()) {
    it->get_to(value.slice);
  }
  if (auto it = j.find("repetition"); it != j.end()) {
    it->get_to(value.repetition);
  }
}

void to_json(ordered_json& j, test_model::SimpleAcquisition const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flags)) {
    j.push_back({"flags", value.flags});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.idx)) {
    j.push_back({"idx", value.idx});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.trajectory)) {
    j.push_back({"trajectory", value.trajectory});
  }
}

void from_json(ordered_json const& j, test_model::SimpleAcquisition& value) {
  if (auto it = j.find("flags"); it != j.end()) {
    it->get_to(value.flags);
  }
  if (auto it = j.find("idx"); it != j.end()) {
    it->get_to(value.idx);
  }
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("trajectory"); it != j.end()) {
    it->get_to(value.trajectory);
  }
}

void to_json(ordered_json& j, test_model::SimpleRecord const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.x)) {
    j.push_back({"x", value.x});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.y)) {
    j.push_back({"y", value.y});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.z)) {
    j.push_back({"z", value.z});
  }
}

void from_json(ordered_json const& j, test_model::SimpleRecord& value) {
  if (auto it = j.find("x"); it != j.end()) {
    it->get_to(value.x);
  }
  if (auto it = j.find("y"); it != j.end()) {
    it->get_to(value.y);
  }
  if (auto it = j.find("z"); it != j.end()) {
    it->get_to(value.z);
  }
}

void to_json(ordered_json& j, test_model::RecordWithPrimitives const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.bool_field)) {
    j.push_back({"boolField", value.bool_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int8_field)) {
    j.push_back({"int8Field", value.int8_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint8_field)) {
    j.push_back({"uint8Field", value.uint8_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int16_field)) {
    j.push_back({"int16Field", value.int16_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint16_field)) {
    j.push_back({"uint16Field", value.uint16_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int32_field)) {
    j.push_back({"int32Field", value.int32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint32_field)) {
    j.push_back({"uint32Field", value.uint32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int64_field)) {
    j.push_back({"int64Field", value.int64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint64_field)) {
    j.push_back({"uint64Field", value.uint64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.size_field)) {
    j.push_back({"sizeField", value.size_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.float32_field)) {
    j.push_back({"float32Field", value.float32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.float64_field)) {
    j.push_back({"float64Field", value.float64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.complexfloat32_field)) {
    j.push_back({"complexfloat32Field", value.complexfloat32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.complexfloat64_field)) {
    j.push_back({"complexfloat64Field", value.complexfloat64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.date_field)) {
    j.push_back({"dateField", value.date_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.time_field)) {
    j.push_back({"timeField", value.time_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.datetime_field)) {
    j.push_back({"datetimeField", value.datetime_field});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithPrimitives& value) {
  if (auto it = j.find("boolField"); it != j.end()) {
    it->get_to(value.bool_field);
  }
  if (auto it = j.find("int8Field"); it != j.end()) {
    it->get_to(value.int8_field);
  }
  if (auto it = j.find("uint8Field"); it != j.end()) {
    it->get_to(value.uint8_field);
  }
  if (auto it = j.find("int16Field"); it != j.end()) {
    it->get_to(value.int16_field);
  }
  if (auto it = j.find("uint16Field"); it != j.end()) {
    it->get_to(value.uint16_field);
  }
  if (auto it = j.find("int32Field"); it != j.end()) {
    it->get_to(value.int32_field);
  }
  if (auto it = j.find("uint32Field"); it != j.end()) {
    it->get_to(value.uint32_field);
  }
  if (auto it = j.find("int64Field"); it != j.end()) {
    it->get_to(value.int64_field);
  }
  if (auto it = j.find("uint64Field"); it != j.end()) {
    it->get_to(value.uint64_field);
  }
  if (auto it = j.find("sizeField"); it != j.end()) {
    it->get_to(value.size_field);
  }
  if (auto it = j.find("float32Field"); it != j.end()) {
    it->get_to(value.float32_field);
  }
  if (auto it = j.find("float64Field"); it != j.end()) {
    it->get_to(value.float64_field);
  }
  if (auto it = j.find("complexfloat32Field"); it != j.end()) {
    it->get_to(value.complexfloat32_field);
  }
  if (auto it = j.find("complexfloat64Field"); it != j.end()) {
    it->get_to(value.complexfloat64_field);
  }
  if (auto it = j.find("dateField"); it != j.end()) {
    it->get_to(value.date_field);
  }
  if (auto it = j.find("timeField"); it != j.end()) {
    it->get_to(value.time_field);
  }
  if (auto it = j.find("datetimeField"); it != j.end()) {
    it->get_to(value.datetime_field);
  }
}

void to_json(ordered_json& j, test_model::RecordWithPrimitiveAliases const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.byte_field)) {
    j.push_back({"byteField", value.byte_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int_field)) {
    j.push_back({"intField", value.int_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint_field)) {
    j.push_back({"uintField", value.uint_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.long_field)) {
    j.push_back({"longField", value.long_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ulong_field)) {
    j.push_back({"ulongField", value.ulong_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.float_field)) {
    j.push_back({"floatField", value.float_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.double_field)) {
    j.push_back({"doubleField", value.double_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.complexfloat_field)) {
    j.push_back({"complexfloatField", value.complexfloat_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.complexdouble_field)) {
    j.push_back({"complexdoubleField", value.complexdouble_field});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithPrimitiveAliases& value) {
  if (auto it = j.find("byteField"); it != j.end()) {
    it->get_to(value.byte_field);
  }
  if (auto it = j.find("intField"); it != j.end()) {
    it->get_to(value.int_field);
  }
  if (auto it = j.find("uintField"); it != j.end()) {
    it->get_to(value.uint_field);
  }
  if (auto it = j.find("longField"); it != j.end()) {
    it->get_to(value.long_field);
  }
  if (auto it = j.find("ulongField"); it != j.end()) {
    it->get_to(value.ulong_field);
  }
  if (auto it = j.find("floatField"); it != j.end()) {
    it->get_to(value.float_field);
  }
  if (auto it = j.find("doubleField"); it != j.end()) {
    it->get_to(value.double_field);
  }
  if (auto it = j.find("complexfloatField"); it != j.end()) {
    it->get_to(value.complexfloat_field);
  }
  if (auto it = j.find("complexdoubleField"); it != j.end()) {
    it->get_to(value.complexdouble_field);
  }
}

void to_json(ordered_json& j, test_model::TupleWithRecords const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.a)) {
    j.push_back({"a", value.a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.b)) {
    j.push_back({"b", value.b});
  }
}

void from_json(ordered_json const& j, test_model::TupleWithRecords& value) {
  if (auto it = j.find("a"); it != j.end()) {
    it->get_to(value.a);
  }
  if (auto it = j.find("b"); it != j.end()) {
    it->get_to(value.b);
  }
}

void to_json(ordered_json& j, test_model::RecordWithVectors const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.default_vector)) {
    j.push_back({"defaultVector", value.default_vector});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.default_vector_fixed_length)) {
    j.push_back({"defaultVectorFixedLength", value.default_vector_fixed_length});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.vector_of_vectors)) {
    j.push_back({"vectorOfVectors", value.vector_of_vectors});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithVectors& value) {
  if (auto it = j.find("defaultVector"); it != j.end()) {
    it->get_to(value.default_vector);
  }
  if (auto it = j.find("defaultVectorFixedLength"); it != j.end()) {
    it->get_to(value.default_vector_fixed_length);
  }
  if (auto it = j.find("vectorOfVectors"); it != j.end()) {
    it->get_to(value.vector_of_vectors);
  }
}

void to_json(ordered_json& j, test_model::RecordWithVectorOfTimes const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.times)) {
    j.push_back({"times", value.times});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithVectorOfTimes& value) {
  if (auto it = j.find("times"); it != j.end()) {
    it->get_to(value.times);
  }
}

void to_json(ordered_json& j, test_model::RecordWithArrays const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.default_array)) {
    j.push_back({"defaultArray", value.default_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.default_array_with_empty_dimension)) {
    j.push_back({"defaultArrayWithEmptyDimension", value.default_array_with_empty_dimension});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_1_array)) {
    j.push_back({"rank1Array", value.rank_1_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_array)) {
    j.push_back({"rank2Array", value.rank_2_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_array_with_named_dimensions)) {
    j.push_back({"rank2ArrayWithNamedDimensions", value.rank_2_array_with_named_dimensions});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_fixed_array)) {
    j.push_back({"rank2FixedArray", value.rank_2_fixed_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_fixed_array_with_named_dimensions)) {
    j.push_back({"rank2FixedArrayWithNamedDimensions", value.rank_2_fixed_array_with_named_dimensions});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.dynamic_array)) {
    j.push_back({"dynamicArray", value.dynamic_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.array_of_vectors)) {
    j.push_back({"arrayOfVectors", value.array_of_vectors});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithArrays& value) {
  if (auto it = j.find("defaultArray"); it != j.end()) {
    it->get_to(value.default_array);
  }
  if (auto it = j.find("defaultArrayWithEmptyDimension"); it != j.end()) {
    it->get_to(value.default_array_with_empty_dimension);
  }
  if (auto it = j.find("rank1Array"); it != j.end()) {
    it->get_to(value.rank_1_array);
  }
  if (auto it = j.find("rank2Array"); it != j.end()) {
    it->get_to(value.rank_2_array);
  }
  if (auto it = j.find("rank2ArrayWithNamedDimensions"); it != j.end()) {
    it->get_to(value.rank_2_array_with_named_dimensions);
  }
  if (auto it = j.find("rank2FixedArray"); it != j.end()) {
    it->get_to(value.rank_2_fixed_array);
  }
  if (auto it = j.find("rank2FixedArrayWithNamedDimensions"); it != j.end()) {
    it->get_to(value.rank_2_fixed_array_with_named_dimensions);
  }
  if (auto it = j.find("dynamicArray"); it != j.end()) {
    it->get_to(value.dynamic_array);
  }
  if (auto it = j.find("arrayOfVectors"); it != j.end()) {
    it->get_to(value.array_of_vectors);
  }
}

void to_json(ordered_json& j, test_model::RecordWithArraysSimpleSyntax const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.default_array)) {
    j.push_back({"defaultArray", value.default_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.default_array_with_empty_dimension)) {
    j.push_back({"defaultArrayWithEmptyDimension", value.default_array_with_empty_dimension});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_1_array)) {
    j.push_back({"rank1Array", value.rank_1_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_array)) {
    j.push_back({"rank2Array", value.rank_2_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_array_with_named_dimensions)) {
    j.push_back({"rank2ArrayWithNamedDimensions", value.rank_2_array_with_named_dimensions});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_fixed_array)) {
    j.push_back({"rank2FixedArray", value.rank_2_fixed_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rank_2_fixed_array_with_named_dimensions)) {
    j.push_back({"rank2FixedArrayWithNamedDimensions", value.rank_2_fixed_array_with_named_dimensions});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.dynamic_array)) {
    j.push_back({"dynamicArray", value.dynamic_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.array_of_vectors)) {
    j.push_back({"arrayOfVectors", value.array_of_vectors});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithArraysSimpleSyntax& value) {
  if (auto it = j.find("defaultArray"); it != j.end()) {
    it->get_to(value.default_array);
  }
  if (auto it = j.find("defaultArrayWithEmptyDimension"); it != j.end()) {
    it->get_to(value.default_array_with_empty_dimension);
  }
  if (auto it = j.find("rank1Array"); it != j.end()) {
    it->get_to(value.rank_1_array);
  }
  if (auto it = j.find("rank2Array"); it != j.end()) {
    it->get_to(value.rank_2_array);
  }
  if (auto it = j.find("rank2ArrayWithNamedDimensions"); it != j.end()) {
    it->get_to(value.rank_2_array_with_named_dimensions);
  }
  if (auto it = j.find("rank2FixedArray"); it != j.end()) {
    it->get_to(value.rank_2_fixed_array);
  }
  if (auto it = j.find("rank2FixedArrayWithNamedDimensions"); it != j.end()) {
    it->get_to(value.rank_2_fixed_array_with_named_dimensions);
  }
  if (auto it = j.find("dynamicArray"); it != j.end()) {
    it->get_to(value.dynamic_array);
  }
  if (auto it = j.find("arrayOfVectors"); it != j.end()) {
    it->get_to(value.array_of_vectors);
  }
}

void to_json(ordered_json& j, test_model::RecordWithOptionalFields const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.optional_int)) {
    j.push_back({"optionalInt", value.optional_int});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.optional_int_alternate_syntax)) {
    j.push_back({"optionalIntAlternateSyntax", value.optional_int_alternate_syntax});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.optional_time)) {
    j.push_back({"optionalTime", value.optional_time});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithOptionalFields& value) {
  if (auto it = j.find("optionalInt"); it != j.end()) {
    it->get_to(value.optional_int);
  }
  if (auto it = j.find("optionalIntAlternateSyntax"); it != j.end()) {
    it->get_to(value.optional_int_alternate_syntax);
  }
  if (auto it = j.find("optionalTime"); it != j.end()) {
    it->get_to(value.optional_time);
  }
}

void to_json(ordered_json& j, test_model::RecordWithVlens const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.a)) {
    j.push_back({"a", value.a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.b)) {
    j.push_back({"b", value.b});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.c)) {
    j.push_back({"c", value.c});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithVlens& value) {
  if (auto it = j.find("a"); it != j.end()) {
    it->get_to(value.a);
  }
  if (auto it = j.find("b"); it != j.end()) {
    it->get_to(value.b);
  }
  if (auto it = j.find("c"); it != j.end()) {
    it->get_to(value.c);
  }
}

void to_json(ordered_json& j, test_model::RecordWithStrings const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.a)) {
    j.push_back({"a", value.a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.b)) {
    j.push_back({"b", value.b});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithStrings& value) {
  if (auto it = j.find("a"); it != j.end()) {
    it->get_to(value.a);
  }
  if (auto it = j.find("b"); it != j.end()) {
    it->get_to(value.b);
  }
}

void to_json(ordered_json& j, test_model::RecordWithOptionalVector const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.optional_vector)) {
    j.push_back({"optionalVector", value.optional_vector});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithOptionalVector& value) {
  if (auto it = j.find("optionalVector"); it != j.end()) {
    it->get_to(value.optional_vector);
  }
}

void to_json(ordered_json& j, test_model::RecordWithFixedVectors const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_int_vector)) {
    j.push_back({"fixedIntVector", value.fixed_int_vector});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_simple_record_vector)) {
    j.push_back({"fixedSimpleRecordVector", value.fixed_simple_record_vector});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_record_with_vlens_vector)) {
    j.push_back({"fixedRecordWithVlensVector", value.fixed_record_with_vlens_vector});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithFixedVectors& value) {
  if (auto it = j.find("fixedIntVector"); it != j.end()) {
    it->get_to(value.fixed_int_vector);
  }
  if (auto it = j.find("fixedSimpleRecordVector"); it != j.end()) {
    it->get_to(value.fixed_simple_record_vector);
  }
  if (auto it = j.find("fixedRecordWithVlensVector"); it != j.end()) {
    it->get_to(value.fixed_record_with_vlens_vector);
  }
}

void to_json(ordered_json& j, test_model::RecordWithFixedArrays const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ints)) {
    j.push_back({"ints", value.ints});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_simple_record_array)) {
    j.push_back({"fixedSimpleRecordArray", value.fixed_simple_record_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_record_with_vlens_array)) {
    j.push_back({"fixedRecordWithVlensArray", value.fixed_record_with_vlens_array});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithFixedArrays& value) {
  if (auto it = j.find("ints"); it != j.end()) {
    it->get_to(value.ints);
  }
  if (auto it = j.find("fixedSimpleRecordArray"); it != j.end()) {
    it->get_to(value.fixed_simple_record_array);
  }
  if (auto it = j.find("fixedRecordWithVlensArray"); it != j.end()) {
    it->get_to(value.fixed_record_with_vlens_array);
  }
}

void to_json(ordered_json& j, test_model::RecordWithNDArrays const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ints)) {
    j.push_back({"ints", value.ints});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_simple_record_array)) {
    j.push_back({"fixedSimpleRecordArray", value.fixed_simple_record_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_record_with_vlens_array)) {
    j.push_back({"fixedRecordWithVlensArray", value.fixed_record_with_vlens_array});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithNDArrays& value) {
  if (auto it = j.find("ints"); it != j.end()) {
    it->get_to(value.ints);
  }
  if (auto it = j.find("fixedSimpleRecordArray"); it != j.end()) {
    it->get_to(value.fixed_simple_record_array);
  }
  if (auto it = j.find("fixedRecordWithVlensArray"); it != j.end()) {
    it->get_to(value.fixed_record_with_vlens_array);
  }
}

void to_json(ordered_json& j, test_model::RecordWithNDArraysSingleDimension const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ints)) {
    j.push_back({"ints", value.ints});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_simple_record_array)) {
    j.push_back({"fixedSimpleRecordArray", value.fixed_simple_record_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_record_with_vlens_array)) {
    j.push_back({"fixedRecordWithVlensArray", value.fixed_record_with_vlens_array});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithNDArraysSingleDimension& value) {
  if (auto it = j.find("ints"); it != j.end()) {
    it->get_to(value.ints);
  }
  if (auto it = j.find("fixedSimpleRecordArray"); it != j.end()) {
    it->get_to(value.fixed_simple_record_array);
  }
  if (auto it = j.find("fixedRecordWithVlensArray"); it != j.end()) {
    it->get_to(value.fixed_record_with_vlens_array);
  }
}

void to_json(ordered_json& j, test_model::RecordWithDynamicNDArrays const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ints)) {
    j.push_back({"ints", value.ints});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.simple_record_array)) {
    j.push_back({"simpleRecordArray", value.simple_record_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.record_with_vlens_array)) {
    j.push_back({"recordWithVlensArray", value.record_with_vlens_array});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithDynamicNDArrays& value) {
  if (auto it = j.find("ints"); it != j.end()) {
    it->get_to(value.ints);
  }
  if (auto it = j.find("simpleRecordArray"); it != j.end()) {
    it->get_to(value.simple_record_array);
  }
  if (auto it = j.find("recordWithVlensArray"); it != j.end()) {
    it->get_to(value.record_with_vlens_array);
  }
}

void to_json(ordered_json& j, test_model::RecordWithFixedCollections const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_vector)) {
    j.push_back({"fixedVector", value.fixed_vector});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_array)) {
    j.push_back({"fixedArray", value.fixed_array});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithFixedCollections& value) {
  if (auto it = j.find("fixedVector"); it != j.end()) {
    it->get_to(value.fixed_vector);
  }
  if (auto it = j.find("fixedArray"); it != j.end()) {
    it->get_to(value.fixed_array);
  }
}

void to_json(ordered_json& j, test_model::RecordWithVlenCollections const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.vector)) {
    j.push_back({"vector", value.vector});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.array)) {
    j.push_back({"array", value.array});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithVlenCollections& value) {
  if (auto it = j.find("vector"); it != j.end()) {
    it->get_to(value.vector);
  }
  if (auto it = j.find("array"); it != j.end()) {
    it->get_to(value.array);
  }
}

namespace {
std::unordered_map<std::string, test_model::UInt64Enum> const __UInt64Enum_values = {
  {"a", test_model::UInt64Enum::kA},
};
} //namespace

void to_json(ordered_json& j, test_model::UInt64Enum const& value) {
  switch (value) {
    case test_model::UInt64Enum::kA:
      j = "a";
      break;
    default:
      using underlying_type = typename std::underlying_type<test_model::UInt64Enum>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, test_model::UInt64Enum& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __UInt64Enum_values.find(symbol); res != __UInt64Enum_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum test_model::UInt64Enum");
  }
  using underlying_type = typename std::underlying_type<test_model::UInt64Enum>::type;
  value = static_cast<test_model::UInt64Enum>(j.get<underlying_type>());
}

namespace {
std::unordered_map<std::string, test_model::Int64Enum> const __Int64Enum_values = {
  {"b", test_model::Int64Enum::kB},
};
} //namespace

void to_json(ordered_json& j, test_model::Int64Enum const& value) {
  switch (value) {
    case test_model::Int64Enum::kB:
      j = "b";
      break;
    default:
      using underlying_type = typename std::underlying_type<test_model::Int64Enum>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, test_model::Int64Enum& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __Int64Enum_values.find(symbol); res != __Int64Enum_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum test_model::Int64Enum");
  }
  using underlying_type = typename std::underlying_type<test_model::Int64Enum>::type;
  value = static_cast<test_model::Int64Enum>(j.get<underlying_type>());
}

namespace {
std::unordered_map<std::string, test_model::SizeBasedEnum> const __SizeBasedEnum_values = {
  {"a", test_model::SizeBasedEnum::kA},
  {"b", test_model::SizeBasedEnum::kB},
  {"c", test_model::SizeBasedEnum::kC},
};
} //namespace

void to_json(ordered_json& j, test_model::SizeBasedEnum const& value) {
  switch (value) {
    case test_model::SizeBasedEnum::kA:
      j = "a";
      break;
    case test_model::SizeBasedEnum::kB:
      j = "b";
      break;
    case test_model::SizeBasedEnum::kC:
      j = "c";
      break;
    default:
      using underlying_type = typename std::underlying_type<test_model::SizeBasedEnum>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, test_model::SizeBasedEnum& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __SizeBasedEnum_values.find(symbol); res != __SizeBasedEnum_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum test_model::SizeBasedEnum");
  }
  using underlying_type = typename std::underlying_type<test_model::SizeBasedEnum>::type;
  value = static_cast<test_model::SizeBasedEnum>(j.get<underlying_type>());
}

void to_json(ordered_json& j, test_model::RecordWithEnums const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.enum_field)) {
    j.push_back({"enum", value.enum_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flags)) {
    j.push_back({"flags", value.flags});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flags_2)) {
    j.push_back({"flags2", value.flags_2});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithEnums& value) {
  if (auto it = j.find("enum"); it != j.end()) {
    it->get_to(value.enum_field);
  }
  if (auto it = j.find("flags"); it != j.end()) {
    it->get_to(value.flags);
  }
  if (auto it = j.find("flags2"); it != j.end()) {
    it->get_to(value.flags_2);
  }
}

template <typename T1, typename T2>
void to_json(ordered_json& j, test_model::GenericRecord<T1, T2> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.scalar_1)) {
    j.push_back({"scalar1", value.scalar_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.scalar_2)) {
    j.push_back({"scalar2", value.scalar_2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.vector_1)) {
    j.push_back({"vector1", value.vector_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.image_2)) {
    j.push_back({"image2", value.image_2});
  }
}

template <typename T1, typename T2>
void from_json(ordered_json const& j, test_model::GenericRecord<T1, T2>& value) {
  if (auto it = j.find("scalar1"); it != j.end()) {
    it->get_to(value.scalar_1);
  }
  if (auto it = j.find("scalar2"); it != j.end()) {
    it->get_to(value.scalar_2);
  }
  if (auto it = j.find("vector1"); it != j.end()) {
    it->get_to(value.vector_1);
  }
  if (auto it = j.find("image2"); it != j.end()) {
    it->get_to(value.image_2);
  }
}

void to_json(ordered_json& j, test_model::RecordWithAliasedGenerics const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.my_strings)) {
    j.push_back({"myStrings", value.my_strings});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.aliased_strings)) {
    j.push_back({"aliasedStrings", value.aliased_strings});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithAliasedGenerics& value) {
  if (auto it = j.find("myStrings"); it != j.end()) {
    it->get_to(value.my_strings);
  }
  if (auto it = j.find("aliasedStrings"); it != j.end()) {
    it->get_to(value.aliased_strings);
  }
}

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithOptionalGenericField<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v)) {
    j.push_back({"v", value.v});
  }
}

template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithOptionalGenericField<T>& value) {
  if (auto it = j.find("v"); it != j.end()) {
    it->get_to(value.v);
  }
}

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithAliasedOptionalGenericField<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v)) {
    j.push_back({"v", value.v});
  }
}

template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithAliasedOptionalGenericField<T>& value) {
  if (auto it = j.find("v"); it != j.end()) {
    it->get_to(value.v);
  }
}

template <typename U, typename V>
void to_json(ordered_json& j, test_model::RecordWithOptionalGenericUnionField<U, V> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v)) {
    j.push_back({"v", value.v});
  }
}

template <typename U, typename V>
void from_json(ordered_json const& j, test_model::RecordWithOptionalGenericUnionField<U, V>& value) {
  if (auto it = j.find("v"); it != j.end()) {
    it->get_to(value.v);
  }
}

template <typename U, typename V>
void to_json(ordered_json& j, test_model::RecordWithAliasedOptionalGenericUnionField<U, V> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v)) {
    j.push_back({"v", value.v});
  }
}

template <typename U, typename V>
void from_json(ordered_json const& j, test_model::RecordWithAliasedOptionalGenericUnionField<U, V>& value) {
  if (auto it = j.find("v"); it != j.end()) {
    it->get_to(value.v);
  }
}

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithGenericVectors<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.v)) {
    j.push_back({"v", value.v});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.av)) {
    j.push_back({"av", value.av});
  }
}

template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithGenericVectors<T>& value) {
  if (auto it = j.find("v"); it != j.end()) {
    it->get_to(value.v);
  }
  if (auto it = j.find("av"); it != j.end()) {
    it->get_to(value.av);
  }
}

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithGenericFixedVectors<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fv)) {
    j.push_back({"fv", value.fv});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.afv)) {
    j.push_back({"afv", value.afv});
  }
}

template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithGenericFixedVectors<T>& value) {
  if (auto it = j.find("fv"); it != j.end()) {
    it->get_to(value.fv);
  }
  if (auto it = j.find("afv"); it != j.end()) {
    it->get_to(value.afv);
  }
}

template <typename T>
void to_json(ordered_json& j, test_model::RecordWithGenericArrays<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.nd)) {
    j.push_back({"nd", value.nd});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_nd)) {
    j.push_back({"fixedNd", value.fixed_nd});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.dynamic_nd)) {
    j.push_back({"dynamicNd", value.dynamic_nd});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.aliased_nd)) {
    j.push_back({"aliasedNd", value.aliased_nd});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.aliased_fixed_nd)) {
    j.push_back({"aliasedFixedNd", value.aliased_fixed_nd});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.aliased_dynamic_nd)) {
    j.push_back({"aliasedDynamicNd", value.aliased_dynamic_nd});
  }
}

template <typename T>
void from_json(ordered_json const& j, test_model::RecordWithGenericArrays<T>& value) {
  if (auto it = j.find("nd"); it != j.end()) {
    it->get_to(value.nd);
  }
  if (auto it = j.find("fixedNd"); it != j.end()) {
    it->get_to(value.fixed_nd);
  }
  if (auto it = j.find("dynamicNd"); it != j.end()) {
    it->get_to(value.dynamic_nd);
  }
  if (auto it = j.find("aliasedNd"); it != j.end()) {
    it->get_to(value.aliased_nd);
  }
  if (auto it = j.find("aliasedFixedNd"); it != j.end()) {
    it->get_to(value.aliased_fixed_nd);
  }
  if (auto it = j.find("aliasedDynamicNd"); it != j.end()) {
    it->get_to(value.aliased_dynamic_nd);
  }
}

template <typename T, typename U>
void to_json(ordered_json& j, test_model::RecordWithGenericMaps<T, U> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.m)) {
    j.push_back({"m", value.m});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.am)) {
    j.push_back({"am", value.am});
  }
}

template <typename T, typename U>
void from_json(ordered_json const& j, test_model::RecordWithGenericMaps<T, U>& value) {
  if (auto it = j.find("m"); it != j.end()) {
    it->get_to(value.m);
  }
  if (auto it = j.find("am"); it != j.end()) {
    it->get_to(value.am);
  }
}

template <typename A, typename B>
void to_json(ordered_json& j, test_model::RecordContainingGenericRecords<A, B> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g1)) {
    j.push_back({"g1", value.g1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g1a)) {
    j.push_back({"g1a", value.g1a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g2)) {
    j.push_back({"g2", value.g2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g2a)) {
    j.push_back({"g2a", value.g2a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g3)) {
    j.push_back({"g3", value.g3});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g3a)) {
    j.push_back({"g3a", value.g3a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g4)) {
    j.push_back({"g4", value.g4});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g5)) {
    j.push_back({"g5", value.g5});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g6)) {
    j.push_back({"g6", value.g6});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.g7)) {
    j.push_back({"g7", value.g7});
  }
}

template <typename A, typename B>
void from_json(ordered_json const& j, test_model::RecordContainingGenericRecords<A, B>& value) {
  if (auto it = j.find("g1"); it != j.end()) {
    it->get_to(value.g1);
  }
  if (auto it = j.find("g1a"); it != j.end()) {
    it->get_to(value.g1a);
  }
  if (auto it = j.find("g2"); it != j.end()) {
    it->get_to(value.g2);
  }
  if (auto it = j.find("g2a"); it != j.end()) {
    it->get_to(value.g2a);
  }
  if (auto it = j.find("g3"); it != j.end()) {
    it->get_to(value.g3);
  }
  if (auto it = j.find("g3a"); it != j.end()) {
    it->get_to(value.g3a);
  }
  if (auto it = j.find("g4"); it != j.end()) {
    it->get_to(value.g4);
  }
  if (auto it = j.find("g5"); it != j.end()) {
    it->get_to(value.g5);
  }
  if (auto it = j.find("g6"); it != j.end()) {
    it->get_to(value.g6);
  }
  if (auto it = j.find("g7"); it != j.end()) {
    it->get_to(value.g7);
  }
}

void to_json(ordered_json& j, test_model::RecordContainingNestedGenericRecords const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.f1)) {
    j.push_back({"f1", value.f1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.f1a)) {
    j.push_back({"f1a", value.f1a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.f2)) {
    j.push_back({"f2", value.f2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.f2a)) {
    j.push_back({"f2a", value.f2a});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.nested)) {
    j.push_back({"nested", value.nested});
  }
}

void from_json(ordered_json const& j, test_model::RecordContainingNestedGenericRecords& value) {
  if (auto it = j.find("f1"); it != j.end()) {
    it->get_to(value.f1);
  }
  if (auto it = j.find("f1a"); it != j.end()) {
    it->get_to(value.f1a);
  }
  if (auto it = j.find("f2"); it != j.end()) {
    it->get_to(value.f2);
  }
  if (auto it = j.find("f2a"); it != j.end()) {
    it->get_to(value.f2a);
  }
  if (auto it = j.find("nested"); it != j.end()) {
    it->get_to(value.nested);
  }
}

void to_json(ordered_json& j, test_model::RecordWithComputedFields const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.array_field)) {
    j.push_back({"arrayField", value.array_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.array_field_map_dimensions)) {
    j.push_back({"arrayFieldMapDimensions", value.array_field_map_dimensions});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.dynamic_array_field)) {
    j.push_back({"dynamicArrayField", value.dynamic_array_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_array_field)) {
    j.push_back({"fixedArrayField", value.fixed_array_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int_field)) {
    j.push_back({"intField", value.int_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int8_field)) {
    j.push_back({"int8Field", value.int8_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint8_field)) {
    j.push_back({"uint8Field", value.uint8_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int16_field)) {
    j.push_back({"int16Field", value.int16_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint16_field)) {
    j.push_back({"uint16Field", value.uint16_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint32_field)) {
    j.push_back({"uint32Field", value.uint32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int64_field)) {
    j.push_back({"int64Field", value.int64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.uint64_field)) {
    j.push_back({"uint64Field", value.uint64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.size_field)) {
    j.push_back({"sizeField", value.size_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.float32_field)) {
    j.push_back({"float32Field", value.float32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.float64_field)) {
    j.push_back({"float64Field", value.float64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.complexfloat32_field)) {
    j.push_back({"complexfloat32Field", value.complexfloat32_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.complexfloat64_field)) {
    j.push_back({"complexfloat64Field", value.complexfloat64_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.string_field)) {
    j.push_back({"stringField", value.string_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.tuple_field)) {
    j.push_back({"tupleField", value.tuple_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.vector_field)) {
    j.push_back({"vectorField", value.vector_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.vector_of_vectors_field)) {
    j.push_back({"vectorOfVectorsField", value.vector_of_vectors_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fixed_vector_field)) {
    j.push_back({"fixedVectorField", value.fixed_vector_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.optional_named_array)) {
    j.push_back({"optionalNamedArray", value.optional_named_array});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int_float_union)) {
    j.push_back({"intFloatUnion", value.int_float_union});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.nullable_int_float_union)) {
    j.push_back({"nullableIntFloatUnion", value.nullable_int_float_union});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.union_with_nested_generic_union)) {
    j.push_back({"unionWithNestedGenericUnion", value.union_with_nested_generic_union});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.map_field)) {
    j.push_back({"mapField", value.map_field});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithComputedFields& value) {
  if (auto it = j.find("arrayField"); it != j.end()) {
    it->get_to(value.array_field);
  }
  if (auto it = j.find("arrayFieldMapDimensions"); it != j.end()) {
    it->get_to(value.array_field_map_dimensions);
  }
  if (auto it = j.find("dynamicArrayField"); it != j.end()) {
    it->get_to(value.dynamic_array_field);
  }
  if (auto it = j.find("fixedArrayField"); it != j.end()) {
    it->get_to(value.fixed_array_field);
  }
  if (auto it = j.find("intField"); it != j.end()) {
    it->get_to(value.int_field);
  }
  if (auto it = j.find("int8Field"); it != j.end()) {
    it->get_to(value.int8_field);
  }
  if (auto it = j.find("uint8Field"); it != j.end()) {
    it->get_to(value.uint8_field);
  }
  if (auto it = j.find("int16Field"); it != j.end()) {
    it->get_to(value.int16_field);
  }
  if (auto it = j.find("uint16Field"); it != j.end()) {
    it->get_to(value.uint16_field);
  }
  if (auto it = j.find("uint32Field"); it != j.end()) {
    it->get_to(value.uint32_field);
  }
  if (auto it = j.find("int64Field"); it != j.end()) {
    it->get_to(value.int64_field);
  }
  if (auto it = j.find("uint64Field"); it != j.end()) {
    it->get_to(value.uint64_field);
  }
  if (auto it = j.find("sizeField"); it != j.end()) {
    it->get_to(value.size_field);
  }
  if (auto it = j.find("float32Field"); it != j.end()) {
    it->get_to(value.float32_field);
  }
  if (auto it = j.find("float64Field"); it != j.end()) {
    it->get_to(value.float64_field);
  }
  if (auto it = j.find("complexfloat32Field"); it != j.end()) {
    it->get_to(value.complexfloat32_field);
  }
  if (auto it = j.find("complexfloat64Field"); it != j.end()) {
    it->get_to(value.complexfloat64_field);
  }
  if (auto it = j.find("stringField"); it != j.end()) {
    it->get_to(value.string_field);
  }
  if (auto it = j.find("tupleField"); it != j.end()) {
    it->get_to(value.tuple_field);
  }
  if (auto it = j.find("vectorField"); it != j.end()) {
    it->get_to(value.vector_field);
  }
  if (auto it = j.find("vectorOfVectorsField"); it != j.end()) {
    it->get_to(value.vector_of_vectors_field);
  }
  if (auto it = j.find("fixedVectorField"); it != j.end()) {
    it->get_to(value.fixed_vector_field);
  }
  if (auto it = j.find("optionalNamedArray"); it != j.end()) {
    it->get_to(value.optional_named_array);
  }
  if (auto it = j.find("intFloatUnion"); it != j.end()) {
    it->get_to(value.int_float_union);
  }
  if (auto it = j.find("nullableIntFloatUnion"); it != j.end()) {
    it->get_to(value.nullable_int_float_union);
  }
  if (auto it = j.find("unionWithNestedGenericUnion"); it != j.end()) {
    it->get_to(value.union_with_nested_generic_union);
  }
  if (auto it = j.find("mapField"); it != j.end()) {
    it->get_to(value.map_field);
  }
}

void to_json(ordered_json& j, test_model::RecordNotUsedInProtocol const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.u1)) {
    j.push_back({"u1", value.u1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.u2)) {
    j.push_back({"u2", value.u2});
  }
}

void from_json(ordered_json const& j, test_model::RecordNotUsedInProtocol& value) {
  if (auto it = j.find("u1"); it != j.end()) {
    it->get_to(value.u1);
  }
  if (auto it = j.find("u2"); it != j.end()) {
    it->get_to(value.u2);
  }
}

namespace {
std::unordered_map<std::string, test_model::EnumWithKeywordSymbols> const __EnumWithKeywordSymbols_values = {
  {"try", test_model::EnumWithKeywordSymbols::kTry},
  {"catch", test_model::EnumWithKeywordSymbols::kCatch},
};
} //namespace

void to_json(ordered_json& j, test_model::EnumWithKeywordSymbols const& value) {
  switch (value) {
    case test_model::EnumWithKeywordSymbols::kTry:
      j = "try";
      break;
    case test_model::EnumWithKeywordSymbols::kCatch:
      j = "catch";
      break;
    default:
      using underlying_type = typename std::underlying_type<test_model::EnumWithKeywordSymbols>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, test_model::EnumWithKeywordSymbols& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __EnumWithKeywordSymbols_values.find(symbol); res != __EnumWithKeywordSymbols_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum test_model::EnumWithKeywordSymbols");
  }
  using underlying_type = typename std::underlying_type<test_model::EnumWithKeywordSymbols>::type;
  value = static_cast<test_model::EnumWithKeywordSymbols>(j.get<underlying_type>());
}

void to_json(ordered_json& j, test_model::RecordWithKeywordFields const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.int_field)) {
    j.push_back({"int", value.int_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sizeof_field)) {
    j.push_back({"sizeof", value.sizeof_field});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.if_field)) {
    j.push_back({"if", value.if_field});
  }
}

void from_json(ordered_json const& j, test_model::RecordWithKeywordFields& value) {
  if (auto it = j.find("int"); it != j.end()) {
    it->get_to(value.int_field);
  }
  if (auto it = j.find("sizeof"); it != j.end()) {
    it->get_to(value.sizeof_field);
  }
  if (auto it = j.find("if"); it != j.end()) {
    it->get_to(value.if_field);
  }
}

} // namespace test_model

namespace test_model::ndjson {
void BenchmarkFloat256x256Writer::WriteFloat256x256Impl(yardl::FixedNDArray<float, 256, 256> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "float256x256", json_value);}

void BenchmarkFloat256x256Writer::Flush() {
  stream_.flush();
}

void BenchmarkFloat256x256Writer::CloseImpl() {
  stream_.flush();
}

bool BenchmarkFloat256x256Reader::ReadFloat256x256Impl(yardl::FixedNDArray<float, 256, 256>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "float256x256", false, unused_step_, value);
}

void BenchmarkFloat256x256Reader::CloseImpl() {
  VerifyFinished();
}

void BenchmarkInt256x256Writer::WriteInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "int256x256", json_value);}

void BenchmarkInt256x256Writer::Flush() {
  stream_.flush();
}

void BenchmarkInt256x256Writer::CloseImpl() {
  stream_.flush();
}

bool BenchmarkInt256x256Reader::ReadInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "int256x256", false, unused_step_, value);
}

void BenchmarkInt256x256Reader::CloseImpl() {
  VerifyFinished();
}

void BenchmarkFloatVlenWriter::WriteFloatArrayImpl(yardl::NDArray<float, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "floatArray", json_value);}

void BenchmarkFloatVlenWriter::Flush() {
  stream_.flush();
}

void BenchmarkFloatVlenWriter::CloseImpl() {
  stream_.flush();
}

bool BenchmarkFloatVlenReader::ReadFloatArrayImpl(yardl::NDArray<float, 2>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "floatArray", false, unused_step_, value);
}

void BenchmarkFloatVlenReader::CloseImpl() {
  VerifyFinished();
}

void BenchmarkSmallRecordWriter::WriteSmallRecordImpl(test_model::SmallBenchmarkRecord const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "smallRecord", json_value);}

void BenchmarkSmallRecordWriter::Flush() {
  stream_.flush();
}

void BenchmarkSmallRecordWriter::CloseImpl() {
  stream_.flush();
}

bool BenchmarkSmallRecordReader::ReadSmallRecordImpl(test_model::SmallBenchmarkRecord& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "smallRecord", false, unused_step_, value);
}

void BenchmarkSmallRecordReader::CloseImpl() {
  VerifyFinished();
}

void BenchmarkSmallRecordWithOptionalsWriter::WriteSmallRecordImpl(test_model::SimpleEncodingCounters const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "smallRecord", json_value);}

void BenchmarkSmallRecordWithOptionalsWriter::Flush() {
  stream_.flush();
}

void BenchmarkSmallRecordWithOptionalsWriter::CloseImpl() {
  stream_.flush();
}

bool BenchmarkSmallRecordWithOptionalsReader::ReadSmallRecordImpl(test_model::SimpleEncodingCounters& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "smallRecord", false, unused_step_, value);
}

void BenchmarkSmallRecordWithOptionalsReader::CloseImpl() {
  VerifyFinished();
}

void BenchmarkSimpleMrdWriter::WriteDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "data", json_value);}

void BenchmarkSimpleMrdWriter::Flush() {
  stream_.flush();
}

void BenchmarkSimpleMrdWriter::CloseImpl() {
  stream_.flush();
}

bool BenchmarkSimpleMrdReader::ReadDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "data", false, unused_step_, value);
}

void BenchmarkSimpleMrdReader::CloseImpl() {
  VerifyFinished();
}

void ScalarsWriter::WriteInt32Impl(int32_t const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "int32", json_value);}

void ScalarsWriter::WriteRecordImpl(test_model::RecordWithPrimitives const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "record", json_value);}

void ScalarsWriter::Flush() {
  stream_.flush();
}

void ScalarsWriter::CloseImpl() {
  stream_.flush();
}

void ScalarsReader::ReadInt32Impl(int32_t& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "int32", true, unused_step_, value);
}

void ScalarsReader::ReadRecordImpl(test_model::RecordWithPrimitives& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "record", true, unused_step_, value);
}

void ScalarsReader::CloseImpl() {
  VerifyFinished();
}

void ScalarOptionalsWriter::WriteOptionalIntImpl(std::optional<int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "optionalInt", json_value);}

void ScalarOptionalsWriter::WriteOptionalRecordImpl(std::optional<test_model::SimpleRecord> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "optionalRecord", json_value);}

void ScalarOptionalsWriter::WriteRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithOptionalFields", json_value);}

void ScalarOptionalsWriter::WriteOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "optionalRecordWithOptionalFields", json_value);}

void ScalarOptionalsWriter::Flush() {
  stream_.flush();
}

void ScalarOptionalsWriter::CloseImpl() {
  stream_.flush();
}

void ScalarOptionalsReader::ReadOptionalIntImpl(std::optional<int32_t>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "optionalInt", true, unused_step_, value);
}

void ScalarOptionalsReader::ReadOptionalRecordImpl(std::optional<test_model::SimpleRecord>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "optionalRecord", true, unused_step_, value);
}

void ScalarOptionalsReader::ReadRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithOptionalFields", true, unused_step_, value);
}

void ScalarOptionalsReader::ReadOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "optionalRecordWithOptionalFields", true, unused_step_, value);
}

void ScalarOptionalsReader::CloseImpl() {
  VerifyFinished();
}

void NestedRecordsWriter::WriteTupleWithRecordsImpl(test_model::TupleWithRecords const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "tupleWithRecords", json_value);}

void NestedRecordsWriter::Flush() {
  stream_.flush();
}

void NestedRecordsWriter::CloseImpl() {
  stream_.flush();
}

void NestedRecordsReader::ReadTupleWithRecordsImpl(test_model::TupleWithRecords& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "tupleWithRecords", true, unused_step_, value);
}

void NestedRecordsReader::CloseImpl() {
  VerifyFinished();
}

void VlensWriter::WriteIntVectorImpl(std::vector<int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intVector", json_value);}

void VlensWriter::WriteComplexVectorImpl(std::vector<std::complex<float>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "complexVector", json_value);}

void VlensWriter::WriteRecordWithVlensImpl(test_model::RecordWithVlens const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithVlens", json_value);}

void VlensWriter::WriteVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "vlenOfRecordWithVlens", json_value);}

void VlensWriter::Flush() {
  stream_.flush();
}

void VlensWriter::CloseImpl() {
  stream_.flush();
}

void VlensReader::ReadIntVectorImpl(std::vector<int32_t>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intVector", true, unused_step_, value);
}

void VlensReader::ReadComplexVectorImpl(std::vector<std::complex<float>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "complexVector", true, unused_step_, value);
}

void VlensReader::ReadRecordWithVlensImpl(test_model::RecordWithVlens& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithVlens", true, unused_step_, value);
}

void VlensReader::ReadVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "vlenOfRecordWithVlens", true, unused_step_, value);
}

void VlensReader::CloseImpl() {
  VerifyFinished();
}

void StringsWriter::WriteSingleStringImpl(std::string const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "singleString", json_value);}

void StringsWriter::WriteRecWithStringImpl(test_model::RecordWithStrings const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recWithString", json_value);}

void StringsWriter::Flush() {
  stream_.flush();
}

void StringsWriter::CloseImpl() {
  stream_.flush();
}

void StringsReader::ReadSingleStringImpl(std::string& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "singleString", true, unused_step_, value);
}

void StringsReader::ReadRecWithStringImpl(test_model::RecordWithStrings& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recWithString", true, unused_step_, value);
}

void StringsReader::CloseImpl() {
  VerifyFinished();
}

void OptionalVectorsWriter::WriteRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithOptionalVector", json_value);}

void OptionalVectorsWriter::Flush() {
  stream_.flush();
}

void OptionalVectorsWriter::CloseImpl() {
  stream_.flush();
}

void OptionalVectorsReader::ReadRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithOptionalVector", true, unused_step_, value);
}

void OptionalVectorsReader::CloseImpl() {
  VerifyFinished();
}

void FixedVectorsWriter::WriteFixedIntVectorImpl(std::array<int32_t, 5> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedIntVector", json_value);}

void FixedVectorsWriter::WriteFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedSimpleRecordVector", json_value);}

void FixedVectorsWriter::WriteFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedRecordWithVlensVector", json_value);}

void FixedVectorsWriter::WriteRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithFixedVectors", json_value);}

void FixedVectorsWriter::Flush() {
  stream_.flush();
}

void FixedVectorsWriter::CloseImpl() {
  stream_.flush();
}

void FixedVectorsReader::ReadFixedIntVectorImpl(std::array<int32_t, 5>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedIntVector", true, unused_step_, value);
}

void FixedVectorsReader::ReadFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedSimpleRecordVector", true, unused_step_, value);
}

void FixedVectorsReader::ReadFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedRecordWithVlensVector", true, unused_step_, value);
}

void FixedVectorsReader::ReadRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithFixedVectors", true, unused_step_, value);
}

void FixedVectorsReader::CloseImpl() {
  VerifyFinished();
}

void StreamsWriter::WriteIntDataImpl(int32_t const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intData", json_value);}

void StreamsWriter::WriteOptionalIntDataImpl(std::optional<int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "optionalIntData", json_value);}

void StreamsWriter::WriteRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithOptionalVectorData", json_value);}

void StreamsWriter::WriteFixedVectorImpl(std::array<int32_t, 3> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedVector", json_value);}

void StreamsWriter::Flush() {
  stream_.flush();
}

void StreamsWriter::CloseImpl() {
  stream_.flush();
}

bool StreamsReader::ReadIntDataImpl(int32_t& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "intData", false, unused_step_, value);
}

bool StreamsReader::ReadOptionalIntDataImpl(std::optional<int32_t>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "optionalIntData", false, unused_step_, value);
}

bool StreamsReader::ReadRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithOptionalVectorData", false, unused_step_, value);
}

bool StreamsReader::ReadFixedVectorImpl(std::array<int32_t, 3>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedVector", false, unused_step_, value);
}

void StreamsReader::CloseImpl() {
  VerifyFinished();
}

void FixedArraysWriter::WriteIntsImpl(yardl::FixedNDArray<int32_t, 2, 3> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "ints", json_value);}

void FixedArraysWriter::WriteFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedSimpleRecordArray", json_value);}

void FixedArraysWriter::WriteFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedRecordWithVlensArray", json_value);}

void FixedArraysWriter::WriteRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithFixedArrays", json_value);}

void FixedArraysWriter::WriteNamedArrayImpl(test_model::NamedFixedNDArray const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "namedArray", json_value);}

void FixedArraysWriter::Flush() {
  stream_.flush();
}

void FixedArraysWriter::CloseImpl() {
  stream_.flush();
}

void FixedArraysReader::ReadIntsImpl(yardl::FixedNDArray<int32_t, 2, 3>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "ints", true, unused_step_, value);
}

void FixedArraysReader::ReadFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedSimpleRecordArray", true, unused_step_, value);
}

void FixedArraysReader::ReadFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedRecordWithVlensArray", true, unused_step_, value);
}

void FixedArraysReader::ReadRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithFixedArrays", true, unused_step_, value);
}

void FixedArraysReader::ReadNamedArrayImpl(test_model::NamedFixedNDArray& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "namedArray", true, unused_step_, value);
}

void FixedArraysReader::CloseImpl() {
  VerifyFinished();
}

void SubarraysWriter::WriteDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "dynamicWithFixedIntSubarray", json_value);}

void SubarraysWriter::WriteDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "dynamicWithFixedFloatSubarray", json_value);}

void SubarraysWriter::WriteKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "knownDimCountWithFixedIntSubarray", json_value);}

void SubarraysWriter::WriteKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "knownDimCountWithFixedFloatSubarray", json_value);}

void SubarraysWriter::WriteFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedWithFixedIntSubarray", json_value);}

void SubarraysWriter::WriteFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "fixedWithFixedFloatSubarray", json_value);}

void SubarraysWriter::WriteNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "nestedSubarray", json_value);}

void SubarraysWriter::WriteDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "dynamicWithFixedVectorSubarray", json_value);}

void SubarraysWriter::WriteGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "genericSubarray", json_value);}

void SubarraysWriter::Flush() {
  stream_.flush();
}

void SubarraysWriter::CloseImpl() {
  stream_.flush();
}

void SubarraysReader::ReadDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "dynamicWithFixedIntSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "dynamicWithFixedFloatSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "knownDimCountWithFixedIntSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "knownDimCountWithFixedFloatSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedWithFixedIntSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "fixedWithFixedFloatSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "nestedSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "dynamicWithFixedVectorSubarray", true, unused_step_, value);
}

void SubarraysReader::ReadGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "genericSubarray", true, unused_step_, value);
}

void SubarraysReader::CloseImpl() {
  VerifyFinished();
}

void SubarraysInRecordsWriter::WriteWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "withFixedSubarrays", json_value);}

void SubarraysInRecordsWriter::WriteWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "withVlenSubarrays", json_value);}

void SubarraysInRecordsWriter::Flush() {
  stream_.flush();
}

void SubarraysInRecordsWriter::CloseImpl() {
  stream_.flush();
}

void SubarraysInRecordsReader::ReadWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "withFixedSubarrays", true, unused_step_, value);
}

void SubarraysInRecordsReader::ReadWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "withVlenSubarrays", true, unused_step_, value);
}

void SubarraysInRecordsReader::CloseImpl() {
  VerifyFinished();
}

void NDArraysWriter::WriteIntsImpl(yardl::NDArray<int32_t, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "ints", json_value);}

void NDArraysWriter::WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "simpleRecordArray", json_value);}

void NDArraysWriter::WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithVlensArray", json_value);}

void NDArraysWriter::WriteRecordWithNDArraysImpl(test_model::RecordWithNDArrays const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithNDArrays", json_value);}

void NDArraysWriter::WriteNamedArrayImpl(test_model::NamedNDArray const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "namedArray", json_value);}

void NDArraysWriter::Flush() {
  stream_.flush();
}

void NDArraysWriter::CloseImpl() {
  stream_.flush();
}

void NDArraysReader::ReadIntsImpl(yardl::NDArray<int32_t, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "ints", true, unused_step_, value);
}

void NDArraysReader::ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "simpleRecordArray", true, unused_step_, value);
}

void NDArraysReader::ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithVlensArray", true, unused_step_, value);
}

void NDArraysReader::ReadRecordWithNDArraysImpl(test_model::RecordWithNDArrays& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithNDArrays", true, unused_step_, value);
}

void NDArraysReader::ReadNamedArrayImpl(test_model::NamedNDArray& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "namedArray", true, unused_step_, value);
}

void NDArraysReader::CloseImpl() {
  VerifyFinished();
}

void NDArraysSingleDimensionWriter::WriteIntsImpl(yardl::NDArray<int32_t, 1> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "ints", json_value);}

void NDArraysSingleDimensionWriter::WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "simpleRecordArray", json_value);}

void NDArraysSingleDimensionWriter::WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithVlensArray", json_value);}

void NDArraysSingleDimensionWriter::WriteRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithNDArrays", json_value);}

void NDArraysSingleDimensionWriter::Flush() {
  stream_.flush();
}

void NDArraysSingleDimensionWriter::CloseImpl() {
  stream_.flush();
}

void NDArraysSingleDimensionReader::ReadIntsImpl(yardl::NDArray<int32_t, 1>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "ints", true, unused_step_, value);
}

void NDArraysSingleDimensionReader::ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "simpleRecordArray", true, unused_step_, value);
}

void NDArraysSingleDimensionReader::ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithVlensArray", true, unused_step_, value);
}

void NDArraysSingleDimensionReader::ReadRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithNDArrays", true, unused_step_, value);
}

void NDArraysSingleDimensionReader::CloseImpl() {
  VerifyFinished();
}

void DynamicNDArraysWriter::WriteIntsImpl(yardl::DynamicNDArray<int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "ints", json_value);}

void DynamicNDArraysWriter::WriteSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "simpleRecordArray", json_value);}

void DynamicNDArraysWriter::WriteRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithVlensArray", json_value);}

void DynamicNDArraysWriter::WriteRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithDynamicNDArrays", json_value);}

void DynamicNDArraysWriter::Flush() {
  stream_.flush();
}

void DynamicNDArraysWriter::CloseImpl() {
  stream_.flush();
}

void DynamicNDArraysReader::ReadIntsImpl(yardl::DynamicNDArray<int32_t>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "ints", true, unused_step_, value);
}

void DynamicNDArraysReader::ReadSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "simpleRecordArray", true, unused_step_, value);
}

void DynamicNDArraysReader::ReadRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithVlensArray", true, unused_step_, value);
}

void DynamicNDArraysReader::ReadRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithDynamicNDArrays", true, unused_step_, value);
}

void DynamicNDArraysReader::CloseImpl() {
  VerifyFinished();
}

void MapsWriter::WriteStringToIntImpl(std::unordered_map<std::string, int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "stringToInt", json_value);}

void MapsWriter::WriteIntToStringImpl(std::unordered_map<int32_t, std::string> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intToString", json_value);}

void MapsWriter::WriteStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "stringToUnion", json_value);}

void MapsWriter::WriteAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedGeneric", json_value);}

void MapsWriter::Flush() {
  stream_.flush();
}

void MapsWriter::CloseImpl() {
  stream_.flush();
}

void MapsReader::ReadStringToIntImpl(std::unordered_map<std::string, int32_t>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "stringToInt", true, unused_step_, value);
}

void MapsReader::ReadIntToStringImpl(std::unordered_map<int32_t, std::string>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intToString", true, unused_step_, value);
}

void MapsReader::ReadStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "stringToUnion", true, unused_step_, value);
}

void MapsReader::ReadAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedGeneric", true, unused_step_, value);
}

void MapsReader::CloseImpl() {
  VerifyFinished();
}

void UnionsWriter::WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intOrSimpleRecord", json_value);}

void UnionsWriter::WriteIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intOrRecordWithVlens", json_value);}

void UnionsWriter::WriteMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "monosotateOrIntOrSimpleRecord", json_value);}

void UnionsWriter::WriteRecordWithUnionsImpl(basic_types::RecordWithUnions const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithUnions", json_value);}

void UnionsWriter::Flush() {
  stream_.flush();
}

void UnionsWriter::CloseImpl() {
  stream_.flush();
}

void UnionsReader::ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intOrSimpleRecord", true, unused_step_, value);
}

void UnionsReader::ReadIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intOrRecordWithVlens", true, unused_step_, value);
}

void UnionsReader::ReadMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "monosotateOrIntOrSimpleRecord", true, unused_step_, value);
}

void UnionsReader::ReadRecordWithUnionsImpl(basic_types::RecordWithUnions& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithUnions", true, unused_step_, value);
}

void UnionsReader::CloseImpl() {
  VerifyFinished();
}

void StreamsOfUnionsWriter::WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intOrSimpleRecord", json_value);}

void StreamsOfUnionsWriter::WriteNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "nullableIntOrSimpleRecord", json_value);}

void StreamsOfUnionsWriter::Flush() {
  stream_.flush();
}

void StreamsOfUnionsWriter::CloseImpl() {
  stream_.flush();
}

bool StreamsOfUnionsReader::ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "intOrSimpleRecord", false, unused_step_, value);
}

bool StreamsOfUnionsReader::ReadNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "nullableIntOrSimpleRecord", false, unused_step_, value);
}

void StreamsOfUnionsReader::CloseImpl() {
  VerifyFinished();
}

void EnumsWriter::WriteSingleImpl(test_model::Fruits const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "single", json_value);}

void EnumsWriter::WriteVecImpl(std::vector<test_model::Fruits> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "vec", json_value);}

void EnumsWriter::WriteSizeImpl(test_model::SizeBasedEnum const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "size", json_value);}

void EnumsWriter::Flush() {
  stream_.flush();
}

void EnumsWriter::CloseImpl() {
  stream_.flush();
}

void EnumsReader::ReadSingleImpl(test_model::Fruits& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "single", true, unused_step_, value);
}

void EnumsReader::ReadVecImpl(std::vector<test_model::Fruits>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "vec", true, unused_step_, value);
}

void EnumsReader::ReadSizeImpl(test_model::SizeBasedEnum& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "size", true, unused_step_, value);
}

void EnumsReader::CloseImpl() {
  VerifyFinished();
}

void FlagsWriter::WriteDaysImpl(test_model::DaysOfWeek const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "days", json_value);}

void FlagsWriter::WriteFormatsImpl(test_model::TextFormat const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "formats", json_value);}

void FlagsWriter::Flush() {
  stream_.flush();
}

void FlagsWriter::CloseImpl() {
  stream_.flush();
}

bool FlagsReader::ReadDaysImpl(test_model::DaysOfWeek& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "days", false, unused_step_, value);
}

bool FlagsReader::ReadFormatsImpl(test_model::TextFormat& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "formats", false, unused_step_, value);
}

void FlagsReader::CloseImpl() {
  VerifyFinished();
}

void StateTestWriter::WriteAnIntImpl(int32_t const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "anInt", json_value);}

void StateTestWriter::WriteAStreamImpl(int32_t const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aStream", json_value);}

void StateTestWriter::WriteAnotherIntImpl(int32_t const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "anotherInt", json_value);}

void StateTestWriter::Flush() {
  stream_.flush();
}

void StateTestWriter::CloseImpl() {
  stream_.flush();
}

void StateTestReader::ReadAnIntImpl(int32_t& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "anInt", true, unused_step_, value);
}

bool StateTestReader::ReadAStreamImpl(int32_t& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "aStream", false, unused_step_, value);
}

void StateTestReader::ReadAnotherIntImpl(int32_t& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "anotherInt", true, unused_step_, value);
}

void StateTestReader::CloseImpl() {
  VerifyFinished();
}

void SimpleGenericsWriter::WriteFloatImageImpl(image::FloatImage const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "floatImage", json_value);}

void SimpleGenericsWriter::WriteIntImageImpl(image::IntImage const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intImage", json_value);}

void SimpleGenericsWriter::WriteIntImageAlternateSyntaxImpl(test_model::Image<int32_t> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intImageAlternateSyntax", json_value);}

void SimpleGenericsWriter::WriteStringImageImpl(test_model::Image<std::string> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "stringImage", json_value);}

void SimpleGenericsWriter::WriteIntFloatTupleImpl(tuples::Tuple<int32_t, float> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intFloatTuple", json_value);}

void SimpleGenericsWriter::WriteFloatFloatTupleImpl(tuples::Tuple<float, float> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "floatFloatTuple", json_value);}

void SimpleGenericsWriter::WriteIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intFloatTupleAlternateSyntax", json_value);}

void SimpleGenericsWriter::WriteIntStringTupleImpl(tuples::Tuple<int32_t, std::string> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intStringTuple", json_value);}

void SimpleGenericsWriter::WriteStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "streamOfTypeVariants", json_value);}

void SimpleGenericsWriter::Flush() {
  stream_.flush();
}

void SimpleGenericsWriter::CloseImpl() {
  stream_.flush();
}

void SimpleGenericsReader::ReadFloatImageImpl(image::FloatImage& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "floatImage", true, unused_step_, value);
}

void SimpleGenericsReader::ReadIntImageImpl(image::IntImage& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intImage", true, unused_step_, value);
}

void SimpleGenericsReader::ReadIntImageAlternateSyntaxImpl(test_model::Image<int32_t>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intImageAlternateSyntax", true, unused_step_, value);
}

void SimpleGenericsReader::ReadStringImageImpl(test_model::Image<std::string>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "stringImage", true, unused_step_, value);
}

void SimpleGenericsReader::ReadIntFloatTupleImpl(tuples::Tuple<int32_t, float>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intFloatTuple", true, unused_step_, value);
}

void SimpleGenericsReader::ReadFloatFloatTupleImpl(tuples::Tuple<float, float>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "floatFloatTuple", true, unused_step_, value);
}

void SimpleGenericsReader::ReadIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intFloatTupleAlternateSyntax", true, unused_step_, value);
}

void SimpleGenericsReader::ReadIntStringTupleImpl(tuples::Tuple<int32_t, std::string>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "intStringTuple", true, unused_step_, value);
}

bool SimpleGenericsReader::ReadStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "streamOfTypeVariants", false, unused_step_, value);
}

void SimpleGenericsReader::CloseImpl() {
  VerifyFinished();
}

void AdvancedGenericsWriter::WriteFloatImageImageImpl(test_model::Image<test_model::Image<float>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "floatImageImage", json_value);}

void AdvancedGenericsWriter::WriteGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "genericRecord1", json_value);}

void AdvancedGenericsWriter::WriteTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "tupleOfOptionals", json_value);}

void AdvancedGenericsWriter::WriteTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "tupleOfOptionalsAlternateSyntax", json_value);}

void AdvancedGenericsWriter::WriteTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "tupleOfVectors", json_value);}

void AdvancedGenericsWriter::Flush() {
  stream_.flush();
}

void AdvancedGenericsWriter::CloseImpl() {
  stream_.flush();
}

void AdvancedGenericsReader::ReadFloatImageImageImpl(test_model::Image<test_model::Image<float>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "floatImageImage", true, unused_step_, value);
}

void AdvancedGenericsReader::ReadGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "genericRecord1", true, unused_step_, value);
}

void AdvancedGenericsReader::ReadTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "tupleOfOptionals", true, unused_step_, value);
}

void AdvancedGenericsReader::ReadTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "tupleOfOptionalsAlternateSyntax", true, unused_step_, value);
}

void AdvancedGenericsReader::ReadTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "tupleOfVectors", true, unused_step_, value);
}

void AdvancedGenericsReader::CloseImpl() {
  VerifyFinished();
}

void AliasesWriter::WriteAliasedStringImpl(test_model::AliasedString const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedString", json_value);}

void AliasesWriter::WriteAliasedEnumImpl(test_model::AliasedEnum const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedEnum", json_value);}

void AliasesWriter::WriteAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedOpenGeneric", json_value);}

void AliasesWriter::WriteAliasedClosedGenericImpl(test_model::AliasedClosedGeneric const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedClosedGeneric", json_value);}

void AliasesWriter::WriteAliasedOptionalImpl(test_model::AliasedOptional const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedOptional", json_value);}

void AliasesWriter::WriteAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedGenericOptional", json_value);}

void AliasesWriter::WriteAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedGenericUnion2", json_value);}

void AliasesWriter::WriteAliasedGenericVectorImpl(test_model::AliasedGenericVector<float> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedGenericVector", json_value);}

void AliasesWriter::WriteAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "aliasedGenericFixedVector", json_value);}

void AliasesWriter::WriteStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "streamOfAliasedGenericUnion2", json_value);}

void AliasesWriter::Flush() {
  stream_.flush();
}

void AliasesWriter::CloseImpl() {
  stream_.flush();
}

void AliasesReader::ReadAliasedStringImpl(test_model::AliasedString& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedString", true, unused_step_, value);
}

void AliasesReader::ReadAliasedEnumImpl(test_model::AliasedEnum& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedEnum", true, unused_step_, value);
}

void AliasesReader::ReadAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedOpenGeneric", true, unused_step_, value);
}

void AliasesReader::ReadAliasedClosedGenericImpl(test_model::AliasedClosedGeneric& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedClosedGeneric", true, unused_step_, value);
}

void AliasesReader::ReadAliasedOptionalImpl(test_model::AliasedOptional& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedOptional", true, unused_step_, value);
}

void AliasesReader::ReadAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedGenericOptional", true, unused_step_, value);
}

void AliasesReader::ReadAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedGenericUnion2", true, unused_step_, value);
}

void AliasesReader::ReadAliasedGenericVectorImpl(test_model::AliasedGenericVector<float>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedGenericVector", true, unused_step_, value);
}

void AliasesReader::ReadAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "aliasedGenericFixedVector", true, unused_step_, value);
}

bool AliasesReader::ReadStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "streamOfAliasedGenericUnion2", false, unused_step_, value);
}

void AliasesReader::CloseImpl() {
  VerifyFinished();
}

void StreamsOfAliasedUnionsWriter::WriteIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "intOrSimpleRecord", json_value);}

void StreamsOfAliasedUnionsWriter::WriteNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "nullableIntOrSimpleRecord", json_value);}

void StreamsOfAliasedUnionsWriter::Flush() {
  stream_.flush();
}

void StreamsOfAliasedUnionsWriter::CloseImpl() {
  stream_.flush();
}

bool StreamsOfAliasedUnionsReader::ReadIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "intOrSimpleRecord", false, unused_step_, value);
}

bool StreamsOfAliasedUnionsReader::ReadNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "nullableIntOrSimpleRecord", false, unused_step_, value);
}

void StreamsOfAliasedUnionsReader::CloseImpl() {
  VerifyFinished();
}

void ProtocolWithComputedFieldsWriter::WriteRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "recordWithComputedFields", json_value);}

void ProtocolWithComputedFieldsWriter::Flush() {
  stream_.flush();
}

void ProtocolWithComputedFieldsWriter::CloseImpl() {
  stream_.flush();
}

void ProtocolWithComputedFieldsReader::ReadRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "recordWithComputedFields", true, unused_step_, value);
}

void ProtocolWithComputedFieldsReader::CloseImpl() {
  VerifyFinished();
}

void ProtocolWithKeywordStepsWriter::WriteIntImpl(test_model::RecordWithKeywordFields const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "int", json_value);}

void ProtocolWithKeywordStepsWriter::WriteFloatImpl(test_model::EnumWithKeywordSymbols const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "float", json_value);}

void ProtocolWithKeywordStepsWriter::Flush() {
  stream_.flush();
}

void ProtocolWithKeywordStepsWriter::CloseImpl() {
  stream_.flush();
}

bool ProtocolWithKeywordStepsReader::ReadIntImpl(test_model::RecordWithKeywordFields& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "int", false, unused_step_, value);
}

void ProtocolWithKeywordStepsReader::ReadFloatImpl(test_model::EnumWithKeywordSymbols& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "float", true, unused_step_, value);
}

void ProtocolWithKeywordStepsReader::CloseImpl() {
  VerifyFinished();
}

} // namespace test_model::ndjson

