// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#ifdef _MSC_VER
#define unlikely(x) x
#else
#define unlikely(x) __builtin_expect((x), 0)
#endif

namespace sketch {
std::string MyProtocolWriterBase::schema_ = R"({"protocol":{"name":"MyProtocol","sequence":[{"name":"tree","type":"Sketch.BinaryTree"},{"name":"ptree","type":"Sketch.BinaryTree"},{"name":"list","type":[null,{"name":"Sketch.LinkedList","typeArguments":["string"]}]},{"name":"cwd","type":{"stream":{"items":"Sketch.DirectoryEntry"}}}]},"types":[{"name":"BinaryTree","fields":[{"name":"value","type":"int32"},{"name":"left","type":"Sketch.BinaryTree"},{"name":"right","type":"Sketch.BinaryTree"}]},{"name":"Directory","fields":[{"name":"name","type":"string"},{"name":"entries","type":{"vector":{"items":"Sketch.DirectoryEntry"}}}]},{"name":"DirectoryEntry","type":[{"tag":"File","type":"Sketch.File"},{"tag":"Directory","type":"Sketch.Directory"}]},{"name":"File","fields":[{"name":"name","type":"string"},{"name":"data","type":{"vector":{"items":"uint8"}}}]},{"name":"LinkedList","typeParameters":["T"],"fields":[{"name":"value","type":"T"},{"name":"next","type":{"name":"Sketch.LinkedList","typeArguments":["T"]}}]}]})";

std::vector<std::string> MyProtocolWriterBase::previous_schemas_ = {
};

std::string MyProtocolWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return MyProtocolWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol MyProtocol.");
  }

}

void MyProtocolWriterBase::WriteTree(sketch::BinaryTree const& value) {
  if (unlikely(state_ != 0)) {
    InvalidState(0, false);
  }

  WriteTreeImpl(value);
  state_ = 1;
}

void MyProtocolWriterBase::WritePtree(std::unique_ptr<sketch::BinaryTree> const& value) {
  if (unlikely(state_ != 1)) {
    InvalidState(1, false);
  }

  WritePtreeImpl(value);
  state_ = 2;
}

void MyProtocolWriterBase::WriteList(std::optional<sketch::LinkedList<std::string>> const& value) {
  if (unlikely(state_ != 2)) {
    InvalidState(2, false);
  }

  WriteListImpl(value);
  state_ = 3;
}

void MyProtocolWriterBase::WriteCwd(sketch::DirectoryEntry const& value) {
  if (unlikely(state_ != 3)) {
    InvalidState(3, false);
  }

  WriteCwdImpl(value);
}

void MyProtocolWriterBase::WriteCwd(std::vector<sketch::DirectoryEntry> const& values) {
  if (unlikely(state_ != 3)) {
    InvalidState(3, false);
  }

  WriteCwdImpl(values);
}

void MyProtocolWriterBase::EndCwd() {
  if (unlikely(state_ != 3)) {
    InvalidState(3, true);
  }

  EndCwdImpl();
  state_ = 4;
}

// fallback implementation
void MyProtocolWriterBase::WriteCwdImpl(std::vector<sketch::DirectoryEntry> const& values) {
  for (auto const& v : values) {
    WriteCwdImpl(v);
  }
}

void MyProtocolWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    InvalidState(4, false);
  }

  CloseImpl();
}

void MyProtocolWriterBase::InvalidState(uint8_t attempted, [[maybe_unused]] bool end) {
  std::string expected_method;
  switch (state_) {
  case 0: expected_method = "WriteTree()"; break;
  case 1: expected_method = "WritePtree()"; break;
  case 2: expected_method = "WriteList()"; break;
  case 3: expected_method = "WriteCwd() or EndCwd()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteTree()"; break;
  case 1: attempted_method = "WritePtree()"; break;
  case 2: attempted_method = "WriteList()"; break;
  case 3: attempted_method = end ? "EndCwd()" : "WriteCwd()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

std::string MyProtocolReaderBase::schema_ = MyProtocolWriterBase::schema_;

std::vector<std::string> MyProtocolReaderBase::previous_schemas_ = MyProtocolWriterBase::previous_schemas_;

Version MyProtocolReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == MyProtocolWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol MyProtocol.");
}

void MyProtocolReaderBase::ReadTree(sketch::BinaryTree& value) {
  if (unlikely(state_ != 0)) {
    InvalidState(0);
  }

  ReadTreeImpl(value);
  state_ = 2;
}

void MyProtocolReaderBase::ReadPtree(std::unique_ptr<sketch::BinaryTree>& value) {
  if (unlikely(state_ != 2)) {
    InvalidState(2);
  }

  ReadPtreeImpl(value);
  state_ = 4;
}

void MyProtocolReaderBase::ReadList(std::optional<sketch::LinkedList<std::string>>& value) {
  if (unlikely(state_ != 4)) {
    InvalidState(4);
  }

  ReadListImpl(value);
  state_ = 6;
}

bool MyProtocolReaderBase::ReadCwd(sketch::DirectoryEntry& value) {
  if (unlikely(state_ != 6)) {
    if (state_ == 7) {
      state_ = 8;
      return false;
    }
    InvalidState(6);
  }

  bool result = ReadCwdImpl(value);
  if (!result) {
    state_ = 8;
  }
  return result;
}

bool MyProtocolReaderBase::ReadCwd(std::vector<sketch::DirectoryEntry>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 6)) {
    if (state_ == 7) {
      state_ = 8;
      values.clear();
      return false;
    }
    InvalidState(6);
  }

  if (!ReadCwdImpl(values)) {
    state_ = 7;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool MyProtocolReaderBase::ReadCwdImpl(std::vector<sketch::DirectoryEntry>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadCwdImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void MyProtocolReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    if (state_ == 7) {
      state_ = 8;
    } else {
      InvalidState(8);
    }
  }

  CloseImpl();
}

void MyProtocolReaderBase::CopyTo(MyProtocolWriterBase& writer, size_t cwd_buffer_size) {
  {
    sketch::BinaryTree value;
    ReadTree(value);
    writer.WriteTree(value);
  }
  {
    std::unique_ptr<sketch::BinaryTree> value;
    ReadPtree(value);
    writer.WritePtree(value);
  }
  {
    std::optional<sketch::LinkedList<std::string>> value;
    ReadList(value);
    writer.WriteList(value);
  }
  if (cwd_buffer_size > 1) {
    std::vector<sketch::DirectoryEntry> values;
    values.reserve(cwd_buffer_size);
    while(ReadCwd(values)) {
      writer.WriteCwd(values);
    }
    writer.EndCwd();
  } else {
    sketch::DirectoryEntry value;
    while(ReadCwd(value)) {
      writer.WriteCwd(value);
    }
    writer.EndCwd();
  }
}

void MyProtocolReaderBase::InvalidState(uint8_t attempted) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadTree()";
    case 1: return "ReadPtree()";
    case 2: return "ReadList()";
    case 3: return "ReadCwd()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(state_) + " but received call to " + f(attempted) + " instead.");
}

bool MyProtocolIndexedReaderBase::ReadCwd(sketch::DirectoryEntry& value, size_t idx) {
  return ReadCwdImpl(value, idx);
}

bool MyProtocolIndexedReaderBase::ReadCwd(std::vector<sketch::DirectoryEntry>& values, size_t idx) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (!ReadCwdImpl(values, idx)) {
    return values.size() > 0;
  }
  return true;
}

size_t MyProtocolIndexedReaderBase::CountCwd() {
  return CountCwdImpl();
}

void MyProtocolIndexedReaderBase::InvalidState(uint8_t attempted) {
  (void)(attempted);
  return;
}

} // namespace sketch
