# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import datetime
import enum
import types
import typing

import numpy as np
import numpy.typing as npt

from .. import yardl_types as yardl
from .. import _dtypes

from .. import tuples

K = typing.TypeVar("K")
K_NP = typing.TypeVar("K_NP", bound=np.generic)
V = typing.TypeVar("V")
V_NP = typing.TypeVar("V_NP", bound=np.generic)
T1 = typing.TypeVar("T1")
T1_NP = typing.TypeVar("T1_NP", bound=np.generic)
T2 = typing.TypeVar("T2")
T2_NP = typing.TypeVar("T2_NP", bound=np.generic)
T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)
T0 = typing.TypeVar("T0")
T0_NP = typing.TypeVar("T0_NP", bound=np.generic)


class Fruits(yardl.OutOfRangeEnum):
    APPLE = 0
    BANANA = 1
    PEAR = 2

class DaysOfWeek(enum.IntFlag):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 4
    THURSDAY = 8
    FRIDAY = 16
    SATURDAY = 32
    SUNDAY = 64

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DaysOfWeek) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

    __str__ = enum.Flag.__str__ # type: ignore

class TextFormat(enum.IntFlag):
    REGULAR = 0
    BOLD = 1
    ITALIC = 2
    UNDERLINE = 4
    STRIKETHROUGH = 8

    def __eq__(self, other: object) -> bool:
        return isinstance(other, TextFormat) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

    __str__ = enum.Flag.__str__ # type: ignore

AliasedMap = dict[K, V]

MyTuple = tuples.Tuple

_T = typing.TypeVar('_T')

class GenericUnion2(typing.Generic[T1, T2]):
    T1: type["GenericUnion2UnionCase[T1, T2, T1]"]
    T2: type["GenericUnion2UnionCase[T1, T2, T2]"]

class GenericUnion2UnionCase(GenericUnion2[T1, T2], yardl.UnionCase[_T]):
    pass

GenericUnion2.T1 = type("GenericUnion2.T1", (GenericUnion2UnionCase,), {"index": 0, "tag": "T1"})
GenericUnion2.T2 = type("GenericUnion2.T2", (GenericUnion2UnionCase,), {"index": 1, "tag": "T2"})
del GenericUnion2UnionCase

class GenericNullableUnion2(typing.Generic[T1, T2]):
    T1: type["GenericNullableUnion2UnionCase[T1, T2, T1]"]
    T2: type["GenericNullableUnion2UnionCase[T1, T2, T2]"]

class GenericNullableUnion2UnionCase(GenericNullableUnion2[T1, T2], yardl.UnionCase[_T]):
    pass

GenericNullableUnion2.T1 = type("GenericNullableUnion2.T1", (GenericNullableUnion2UnionCase,), {"index": 0, "tag": "T1"})
GenericNullableUnion2.T2 = type("GenericNullableUnion2.T2", (GenericNullableUnion2UnionCase,), {"index": 1, "tag": "T2"})
del GenericNullableUnion2UnionCase

GenericVector = list[T]

class Int32OrString:
    Int32: typing.ClassVar[type["Int32OrStringUnionCase[yardl.Int32]"]]
    String: typing.ClassVar[type["Int32OrStringUnionCase[str]"]]

class Int32OrStringUnionCase(Int32OrString, yardl.UnionCase[_T]):
    pass

Int32OrString.Int32 = type("Int32OrString.Int32", (Int32OrStringUnionCase,), {"index": 0, "tag": "int32"})
Int32OrString.String = type("Int32OrString.String", (Int32OrStringUnionCase,), {"index": 1, "tag": "string"})
del Int32OrStringUnionCase

class TimeOrDatetime:
    Time: typing.ClassVar[type["TimeOrDatetimeUnionCase[yardl.Time]"]]
    Datetime: typing.ClassVar[type["TimeOrDatetimeUnionCase[yardl.DateTime]"]]

class TimeOrDatetimeUnionCase(TimeOrDatetime, yardl.UnionCase[_T]):
    pass

TimeOrDatetime.Time = type("TimeOrDatetime.Time", (TimeOrDatetimeUnionCase,), {"index": 0, "tag": "time"})
TimeOrDatetime.Datetime = type("TimeOrDatetime.Datetime", (TimeOrDatetimeUnionCase,), {"index": 1, "tag": "datetime"})
del TimeOrDatetimeUnionCase

class RecordWithUnions:
    null_or_int_or_string: typing.Optional[Int32OrString]
    date_or_datetime: TimeOrDatetime
    null_or_fruits_or_days_of_week: typing.Optional[GenericNullableUnion2[Fruits, DaysOfWeek]]

    def __init__(self, *,
        null_or_int_or_string: typing.Optional[Int32OrString] = None,
        date_or_datetime: TimeOrDatetime = TimeOrDatetime.Time(yardl.Time()),
        null_or_fruits_or_days_of_week: typing.Optional[GenericNullableUnion2[Fruits, DaysOfWeek]] = None,
    ):
        self.null_or_int_or_string = null_or_int_or_string
        self.date_or_datetime = date_or_datetime
        self.null_or_fruits_or_days_of_week = null_or_fruits_or_days_of_week

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithUnions)
            and self.null_or_int_or_string == other.null_or_int_or_string
            and self.date_or_datetime == other.date_or_datetime
            and self.null_or_fruits_or_days_of_week == other.null_or_fruits_or_days_of_week
        )

    def __str__(self) -> str:
        return f"RecordWithUnions(nullOrIntOrString={self.null_or_int_or_string}, dateOrDatetime={self.date_or_datetime}, nullOrFruitsOrDaysOfWeek={self.null_or_fruits_or_days_of_week})"

    def __repr__(self) -> str:
        return f"RecordWithUnions(nullOrIntOrString={repr(self.null_or_int_or_string)}, dateOrDatetime={repr(self.date_or_datetime)}, nullOrFruitsOrDaysOfWeek={repr(self.null_or_fruits_or_days_of_week)})"


class T0OrT1(typing.Generic[T0, T1]):
    T0: type["T0OrT1UnionCase[T0, T1, T0]"]
    T1: type["T0OrT1UnionCase[T0, T1, T1]"]

class T0OrT1UnionCase(T0OrT1[T0, T1], yardl.UnionCase[_T]):
    pass

T0OrT1.T0 = type("T0OrT1.T0", (T0OrT1UnionCase,), {"index": 0, "tag": "T0"})
T0OrT1.T1 = type("T0OrT1.T1", (T0OrT1UnionCase,), {"index": 1, "tag": "T1"})
del T0OrT1UnionCase

class GenericRecordWithComputedFields(typing.Generic[T0, T1]):
    f1: T0OrT1[T0, T1]

    def __init__(self, *,
        f1: T0OrT1[T0, T1],
    ):
        self.f1 = f1

    def type_index(self) -> yardl.UInt8:
        _var0 = self.f1
        if isinstance(_var0, T0OrT1.T0):
            return 0
        if isinstance(_var0, T0OrT1.T1):
            return 1
        raise RuntimeError("Unexpected union case")

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GenericRecordWithComputedFields)
            and yardl.structural_equal(self.f1, other.f1)
        )

    def __str__(self) -> str:
        return f"GenericRecordWithComputedFields(f1={self.f1})"

    def __repr__(self) -> str:
        return f"GenericRecordWithComputedFields(f1={repr(self.f1)})"


def _mk_get_dtype():
    dtype_map: dict[typing.Union[type, types.GenericAlias], typing.Union[np.dtype[typing.Any], typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map.setdefault(tuples.Tuple, lambda type_args: np.dtype([('v1', get_dtype(type_args[0])), ('v2', get_dtype(type_args[1]))], align=True))
    dtype_map.setdefault(Fruits, np.dtype(np.int32))
    dtype_map.setdefault(DaysOfWeek, np.dtype(np.int32))
    dtype_map.setdefault(TextFormat, np.dtype(np.uint64))
    dtype_map.setdefault(MyTuple, lambda type_args: get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],))))
    dtype_map.setdefault(GenericUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(GenericNullableUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(GenericNullableUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(Int32OrString, np.dtype(np.object_))
    dtype_map.setdefault(TimeOrDatetime, np.dtype(np.object_))
    dtype_map.setdefault(RecordWithUnions, np.dtype([('null_or_int_or_string', np.dtype(np.object_)), ('date_or_datetime', np.dtype(np.object_)), ('null_or_fruits_or_days_of_week', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(T0OrT1, np.dtype(np.object_))
    dtype_map.setdefault(GenericRecordWithComputedFields, lambda type_args: np.dtype([('f1', np.dtype(np.object_))], align=True))

    return get_dtype

get_dtype = _mk_get_dtype()

