# This file was generated by the "yardl" tool. DO NOT EDIT.


import dataclasses
import datetime
import enum
import types
import typing
import numpy as np
import numpy.typing as npt
from . import yardl_types as yardl
from . import _dtypes

K = typing.TypeVar("K")
K_NP = typing.TypeVar("K_NP", bound=np.generic)
V = typing.TypeVar("V")
V_NP = typing.TypeVar("V_NP", bound=np.generic)
T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)
T1 = typing.TypeVar("T1")
T1_NP = typing.TypeVar("T1_NP", bound=np.generic)
T2 = typing.TypeVar("T2")
T2_NP = typing.TypeVar("T2_NP", bound=np.generic)
T0 = typing.TypeVar("T0")
T0_NP = typing.TypeVar("T0_NP", bound=np.generic)


class SmallBenchmarkRecord:
    a: yardl.Float64
    b: yardl.Float32
    c: yardl.Float32

    def __init__(self, *,
        a: yardl.Float64 = 0.0,
        b: yardl.Float32 = 0.0,
        c: yardl.Float32 = 0.0,
    ):
        self.a = a
        self.b = b
        self.c = c

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SmallBenchmarkRecord)
            and self.a == other.a
            and self.b == other.b
            and self.c == other.c
        )


class SimpleEncodingCounters:
    e1: typing.Optional[yardl.UInt32]
    e2: typing.Optional[yardl.UInt32]
    slice: typing.Optional[yardl.UInt32]
    repetition: typing.Optional[yardl.UInt32]

    def __init__(self, *,
        e1: typing.Optional[yardl.UInt32] = None,
        e2: typing.Optional[yardl.UInt32] = None,
        slice: typing.Optional[yardl.UInt32] = None,
        repetition: typing.Optional[yardl.UInt32] = None,
    ):
        self.e1 = e1
        self.e2 = e2
        self.slice = slice
        self.repetition = repetition

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SimpleEncodingCounters)
            and self.e1 == other.e1
            and self.e2 == other.e2
            and self.slice == other.slice
            and self.repetition == other.repetition
        )


class SimpleAcquisition:
    flags: yardl.UInt64
    idx: SimpleEncodingCounters
    data: npt.NDArray[np.complex64]
    trajectory: npt.NDArray[np.float32]

    def __init__(self, *,
        flags: yardl.UInt64 = 0,
        idx: typing.Optional[SimpleEncodingCounters] = None,
        data: typing.Optional[npt.NDArray[np.complex64]] = None,
        trajectory: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.flags = flags
        self.idx = idx if idx is not None else SimpleEncodingCounters()
        self.data = data if data is not None else np.zeros((0, 0), dtype=np.dtype(np.complex64))
        self.trajectory = trajectory if trajectory is not None else np.zeros((0, 0), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SimpleAcquisition)
            and self.flags == other.flags
            and self.idx == other.idx
            and yardl.structural_equal(self.data, other.data)
            and yardl.structural_equal(self.trajectory, other.trajectory)
        )


class SimpleRecord:
    x: yardl.Int32
    y: yardl.Int32
    z: yardl.Int32

    def __init__(self, *,
        x: yardl.Int32 = 0,
        y: yardl.Int32 = 0,
        z: yardl.Int32 = 0,
    ):
        self.x = x
        self.y = y
        self.z = z

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SimpleRecord)
            and self.x == other.x
            and self.y == other.y
            and self.z == other.z
        )


class RecordWithPrimitives:
    bool_field: bool
    int8_field: yardl.Int8
    uint8_field: yardl.UInt8
    int16_field: yardl.Int16
    uint16_field: yardl.UInt16
    int32_field: yardl.Int32
    uint32_field: yardl.UInt32
    int64_field: yardl.Int64
    uint64_field: yardl.UInt64
    size_field: yardl.Size
    float32_field: yardl.Float32
    float64_field: yardl.Float64
    complexfloat32_field: yardl.ComplexFloat
    complexfloat64_field: yardl.ComplexDouble
    date_field: datetime.date
    time_field: yardl.Time
    datetime_field: yardl.DateTime

    def __init__(self, *,
        bool_field: bool = False,
        int8_field: yardl.Int8 = 0,
        uint8_field: yardl.UInt8 = 0,
        int16_field: yardl.Int16 = 0,
        uint16_field: yardl.UInt16 = 0,
        int32_field: yardl.Int32 = 0,
        uint32_field: yardl.UInt32 = 0,
        int64_field: yardl.Int64 = 0,
        uint64_field: yardl.UInt64 = 0,
        size_field: yardl.Size = 0,
        float32_field: yardl.Float32 = 0.0,
        float64_field: yardl.Float64 = 0.0,
        complexfloat32_field: yardl.ComplexFloat = 0j,
        complexfloat64_field: yardl.ComplexDouble = 0j,
        date_field: datetime.date = datetime.date(1970, 1, 1),
        time_field: yardl.Time = yardl.Time(),
        datetime_field: yardl.DateTime = yardl.DateTime(),
    ):
        self.bool_field = bool_field
        self.int8_field = int8_field
        self.uint8_field = uint8_field
        self.int16_field = int16_field
        self.uint16_field = uint16_field
        self.int32_field = int32_field
        self.uint32_field = uint32_field
        self.int64_field = int64_field
        self.uint64_field = uint64_field
        self.size_field = size_field
        self.float32_field = float32_field
        self.float64_field = float64_field
        self.complexfloat32_field = complexfloat32_field
        self.complexfloat64_field = complexfloat64_field
        self.date_field = date_field
        self.time_field = time_field
        self.datetime_field = datetime_field

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithPrimitives)
            and self.bool_field == other.bool_field
            and self.int8_field == other.int8_field
            and self.uint8_field == other.uint8_field
            and self.int16_field == other.int16_field
            and self.uint16_field == other.uint16_field
            and self.int32_field == other.int32_field
            and self.uint32_field == other.uint32_field
            and self.int64_field == other.int64_field
            and self.uint64_field == other.uint64_field
            and self.size_field == other.size_field
            and self.float32_field == other.float32_field
            and self.float64_field == other.float64_field
            and self.complexfloat32_field == other.complexfloat32_field
            and self.complexfloat64_field == other.complexfloat64_field
            and self.date_field == other.date_field
            and self.time_field == other.time_field
            and self.datetime_field == other.datetime_field
        )


class RecordWithPrimitiveAliases:
    byte_field: yardl.UInt8
    int_field: yardl.Int32
    uint_field: yardl.UInt32
    long_field: yardl.Int64
    ulong_field: yardl.UInt64
    float_field: yardl.Float32
    double_field: yardl.Float64
    complexfloat_field: yardl.ComplexFloat
    complexdouble_field: yardl.ComplexDouble

    def __init__(self, *,
        byte_field: yardl.UInt8 = 0,
        int_field: yardl.Int32 = 0,
        uint_field: yardl.UInt32 = 0,
        long_field: yardl.Int64 = 0,
        ulong_field: yardl.UInt64 = 0,
        float_field: yardl.Float32 = 0.0,
        double_field: yardl.Float64 = 0.0,
        complexfloat_field: yardl.ComplexFloat = 0j,
        complexdouble_field: yardl.ComplexDouble = 0j,
    ):
        self.byte_field = byte_field
        self.int_field = int_field
        self.uint_field = uint_field
        self.long_field = long_field
        self.ulong_field = ulong_field
        self.float_field = float_field
        self.double_field = double_field
        self.complexfloat_field = complexfloat_field
        self.complexdouble_field = complexdouble_field

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithPrimitiveAliases)
            and self.byte_field == other.byte_field
            and self.int_field == other.int_field
            and self.uint_field == other.uint_field
            and self.long_field == other.long_field
            and self.ulong_field == other.ulong_field
            and self.float_field == other.float_field
            and self.double_field == other.double_field
            and self.complexfloat_field == other.complexfloat_field
            and self.complexdouble_field == other.complexdouble_field
        )


class TupleWithRecords:
    a: SimpleRecord
    b: SimpleRecord

    def __init__(self, *,
        a: typing.Optional[SimpleRecord] = None,
        b: typing.Optional[SimpleRecord] = None,
    ):
        self.a = a if a is not None else SimpleRecord()
        self.b = b if b is not None else SimpleRecord()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TupleWithRecords)
            and self.a == other.a
            and self.b == other.b
        )


class RecordWithVectors:
    default_vector: list[yardl.Int32]
    default_vector_fixed_length: list[yardl.Int32]
    vector_of_vectors: list[list[yardl.Int32]]

    def __init__(self, *,
        default_vector: typing.Optional[list[yardl.Int32]] = None,
        default_vector_fixed_length: typing.Optional[list[yardl.Int32]] = None,
        vector_of_vectors: typing.Optional[list[list[yardl.Int32]]] = None,
    ):
        self.default_vector = default_vector if default_vector is not None else []
        self.default_vector_fixed_length = default_vector_fixed_length if default_vector_fixed_length is not None else [0] * 3
        self.vector_of_vectors = vector_of_vectors if vector_of_vectors is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVectors)
            and self.default_vector == other.default_vector
            and self.default_vector_fixed_length == other.default_vector_fixed_length
            and self.vector_of_vectors == other.vector_of_vectors
        )


class RecordWithVectorOfTimes:
    times: list[yardl.Time]

    def __init__(self, *,
        times: typing.Optional[list[yardl.Time]] = None,
    ):
        self.times = times if times is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVectorOfTimes)
            and self.times == other.times
        )


class RecordWithArrays:
    default_array: npt.NDArray[np.int32]
    default_array_with_empty_dimension: npt.NDArray[np.int32]
    rank_1_array: npt.NDArray[np.int32]
    rank_2_array: npt.NDArray[np.int32]
    rank_2_array_with_named_dimensions: npt.NDArray[np.int32]
    rank_2_fixed_array: npt.NDArray[np.int32]
    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32]
    dynamic_array: npt.NDArray[np.int32]
    array_of_vectors: npt.NDArray[np.int32]

    def __init__(self, *,
        default_array: typing.Optional[npt.NDArray[np.int32]] = None,
        default_array_with_empty_dimension: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_1_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        dynamic_array: typing.Optional[npt.NDArray[np.int32]] = None,
        array_of_vectors: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.default_array = default_array if default_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.default_array_with_empty_dimension = default_array_with_empty_dimension if default_array_with_empty_dimension is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.rank_1_array = rank_1_array if rank_1_array is not None else np.zeros((0), dtype=np.dtype(np.int32))
        self.rank_2_array = rank_2_array if rank_2_array is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_array_with_named_dimensions = rank_2_array_with_named_dimensions if rank_2_array_with_named_dimensions is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array = rank_2_fixed_array if rank_2_fixed_array is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array_with_named_dimensions = rank_2_fixed_array_with_named_dimensions if rank_2_fixed_array_with_named_dimensions is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.dynamic_array = dynamic_array if dynamic_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.array_of_vectors = array_of_vectors if array_of_vectors is not None else np.zeros((5,), dtype=np.dtype(np.object_))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithArrays)
            and yardl.structural_equal(self.default_array, other.default_array)
            and yardl.structural_equal(self.default_array_with_empty_dimension, other.default_array_with_empty_dimension)
            and yardl.structural_equal(self.rank_1_array, other.rank_1_array)
            and yardl.structural_equal(self.rank_2_array, other.rank_2_array)
            and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other.rank_2_array_with_named_dimensions)
            and yardl.structural_equal(self.rank_2_fixed_array, other.rank_2_fixed_array)
            and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other.rank_2_fixed_array_with_named_dimensions)
            and yardl.structural_equal(self.dynamic_array, other.dynamic_array)
            and yardl.structural_equal(self.array_of_vectors, other.array_of_vectors)
        )


class RecordWithArraysSimpleSyntax:
    default_array: npt.NDArray[np.int32]
    default_array_with_empty_dimension: npt.NDArray[np.int32]
    rank_1_array: npt.NDArray[np.int32]
    rank_2_array: npt.NDArray[np.int32]
    rank_2_array_with_named_dimensions: npt.NDArray[np.int32]
    rank_2_fixed_array: npt.NDArray[np.int32]
    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32]
    dynamic_array: npt.NDArray[np.int32]
    array_of_vectors: npt.NDArray[np.int32]

    def __init__(self, *,
        default_array: typing.Optional[npt.NDArray[np.int32]] = None,
        default_array_with_empty_dimension: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_1_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        dynamic_array: typing.Optional[npt.NDArray[np.int32]] = None,
        array_of_vectors: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.default_array = default_array if default_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.default_array_with_empty_dimension = default_array_with_empty_dimension if default_array_with_empty_dimension is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.rank_1_array = rank_1_array if rank_1_array is not None else np.zeros((0), dtype=np.dtype(np.int32))
        self.rank_2_array = rank_2_array if rank_2_array is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_array_with_named_dimensions = rank_2_array_with_named_dimensions if rank_2_array_with_named_dimensions is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array = rank_2_fixed_array if rank_2_fixed_array is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array_with_named_dimensions = rank_2_fixed_array_with_named_dimensions if rank_2_fixed_array_with_named_dimensions is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.dynamic_array = dynamic_array if dynamic_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.array_of_vectors = array_of_vectors if array_of_vectors is not None else np.zeros((5,), dtype=np.dtype(np.object_))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithArraysSimpleSyntax)
            and yardl.structural_equal(self.default_array, other.default_array)
            and yardl.structural_equal(self.default_array_with_empty_dimension, other.default_array_with_empty_dimension)
            and yardl.structural_equal(self.rank_1_array, other.rank_1_array)
            and yardl.structural_equal(self.rank_2_array, other.rank_2_array)
            and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other.rank_2_array_with_named_dimensions)
            and yardl.structural_equal(self.rank_2_fixed_array, other.rank_2_fixed_array)
            and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other.rank_2_fixed_array_with_named_dimensions)
            and yardl.structural_equal(self.dynamic_array, other.dynamic_array)
            and yardl.structural_equal(self.array_of_vectors, other.array_of_vectors)
        )


class RecordWithOptionalFields:
    optional_int: typing.Optional[yardl.Int32]
    optional_int_alternate_syntax: typing.Optional[yardl.Int32]
    optional_time: typing.Optional[yardl.Time]

    def __init__(self, *,
        optional_int: typing.Optional[yardl.Int32] = None,
        optional_int_alternate_syntax: typing.Optional[yardl.Int32] = None,
        optional_time: typing.Optional[yardl.Time] = None,
    ):
        self.optional_int = optional_int
        self.optional_int_alternate_syntax = optional_int_alternate_syntax
        self.optional_time = optional_time

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalFields)
            and self.optional_int == other.optional_int
            and self.optional_int_alternate_syntax == other.optional_int_alternate_syntax
            and self.optional_time == other.optional_time
        )


class RecordWithVlens:
    a: list[SimpleRecord]
    b: yardl.Int32
    c: yardl.Int32

    def __init__(self, *,
        a: typing.Optional[list[SimpleRecord]] = None,
        b: yardl.Int32 = 0,
        c: yardl.Int32 = 0,
    ):
        self.a = a if a is not None else []
        self.b = b
        self.c = c

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVlens)
            and self.a == other.a
            and self.b == other.b
            and self.c == other.c
        )


class RecordWithStrings:
    a: str
    b: str

    def __init__(self, *,
        a: str = "",
        b: str = "",
    ):
        self.a = a
        self.b = b

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithStrings)
            and self.a == other.a
            and self.b == other.b
        )


class RecordWithOptionalVector:
    optional_vector: typing.Optional[list[yardl.Int32]]

    def __init__(self, *,
        optional_vector: typing.Optional[list[yardl.Int32]] = None,
    ):
        self.optional_vector = optional_vector

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalVector)
            and self.optional_vector == other.optional_vector
        )


class RecordWithFixedVectors:
    fixed_int_vector: list[yardl.Int32]
    fixed_simple_record_vector: list[SimpleRecord]
    fixed_record_with_vlens_vector: list[RecordWithVlens]

    def __init__(self, *,
        fixed_int_vector: typing.Optional[list[yardl.Int32]] = None,
        fixed_simple_record_vector: typing.Optional[list[SimpleRecord]] = None,
        fixed_record_with_vlens_vector: typing.Optional[list[RecordWithVlens]] = None,
    ):
        self.fixed_int_vector = fixed_int_vector if fixed_int_vector is not None else [0] * 5
        self.fixed_simple_record_vector = fixed_simple_record_vector if fixed_simple_record_vector is not None else [SimpleRecord() for _ in range(3)]
        self.fixed_record_with_vlens_vector = fixed_record_with_vlens_vector if fixed_record_with_vlens_vector is not None else [RecordWithVlens() for _ in range(2)]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithFixedVectors)
            and self.fixed_int_vector == other.fixed_int_vector
            and self.fixed_simple_record_vector == other.fixed_simple_record_vector
            and self.fixed_record_with_vlens_vector == other.fixed_record_with_vlens_vector
        )


class RecordWithFixedArrays:
    ints: npt.NDArray[np.int32]
    fixed_simple_record_array: npt.NDArray[np.void]
    fixed_record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        fixed_record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((2, 3,), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((3, 2,), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((2, 2,), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithFixedArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )


class RecordWithNDArrays:
    ints: npt.NDArray[np.int32]
    fixed_simple_record_array: npt.NDArray[np.void]
    fixed_record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        fixed_record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((0, 0), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((0, 0), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithNDArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )


class RecordWithNDArraysSingleDimension:
    ints: npt.NDArray[np.int32]
    fixed_simple_record_array: npt.NDArray[np.void]
    fixed_record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        fixed_record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((0), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((0), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((0), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithNDArraysSingleDimension)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )


class RecordWithDynamicNDArrays:
    ints: npt.NDArray[np.int32]
    simple_record_array: npt.NDArray[np.void]
    record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.simple_record_array = simple_record_array if simple_record_array is not None else np.zeros((), dtype=get_dtype(SimpleRecord))
        self.record_with_vlens_array = record_with_vlens_array if record_with_vlens_array is not None else np.zeros((), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithDynamicNDArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.simple_record_array, other.simple_record_array)
            and yardl.structural_equal(self.record_with_vlens_array, other.record_with_vlens_array)
        )


NamedFixedNDArray = npt.NDArray[np.int32]

class RecordWithFixedCollections:
    fixed_vector: list[yardl.Int32]
    fixed_array: npt.NDArray[np.int32]

    def __init__(self, *,
        fixed_vector: typing.Optional[list[yardl.Int32]] = None,
        fixed_array: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.fixed_vector = fixed_vector if fixed_vector is not None else [0] * 3
        self.fixed_array = fixed_array if fixed_array is not None else np.zeros((2, 3,), dtype=np.dtype(np.int32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithFixedCollections)
            and self.fixed_vector == other.fixed_vector
            and yardl.structural_equal(self.fixed_array, other.fixed_array)
        )


class RecordWithVlenCollections:
    vector: list[yardl.Int32]
    array: npt.NDArray[np.int32]

    def __init__(self, *,
        vector: typing.Optional[list[yardl.Int32]] = None,
        array: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.vector = vector if vector is not None else []
        self.array = array if array is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVlenCollections)
            and self.vector == other.vector
            and yardl.structural_equal(self.array, other.array)
        )


NamedNDArray = npt.NDArray[np.int32]

AliasedMap = dict[K, V]

_T = typing.TypeVar('_T')

class Int32OrString:
    Int32: typing.ClassVar[type["Int32OrStringUnionCase[yardl.Int32]"]]
    String: typing.ClassVar[type["Int32OrStringUnionCase[str]"]]

class Int32OrStringUnionCase(Int32OrString, yardl.UnionCase[_T]):
    pass

Int32OrString.Int32 = type("Int32OrString.Int32", (Int32OrStringUnionCase,), {"_index": 0})
Int32OrString.String = type("Int32OrString.String", (Int32OrStringUnionCase,), {"_index": 1})
del Int32OrStringUnionCase

class TimeOrDatetime:
    Time: typing.ClassVar[type["TimeOrDatetimeUnionCase[yardl.Time]"]]
    Datetime: typing.ClassVar[type["TimeOrDatetimeUnionCase[yardl.DateTime]"]]

class TimeOrDatetimeUnionCase(TimeOrDatetime, yardl.UnionCase[_T]):
    pass

TimeOrDatetime.Time = type("TimeOrDatetime.Time", (TimeOrDatetimeUnionCase,), {"_index": 0})
TimeOrDatetime.Datetime = type("TimeOrDatetime.Datetime", (TimeOrDatetimeUnionCase,), {"_index": 1})
del TimeOrDatetimeUnionCase

class RecordWithUnions:
    null_or_int_or_string: typing.Optional[Int32OrString]
    date_or_datetime: TimeOrDatetime

    def __init__(self, *,
        null_or_int_or_string: typing.Optional[Int32OrString] = None,
        date_or_datetime: TimeOrDatetime = TimeOrDatetime.Time(yardl.Time()),
    ):
        self.null_or_int_or_string = null_or_int_or_string
        self.date_or_datetime = date_or_datetime

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithUnions)
            and self.null_or_int_or_string == other.null_or_int_or_string
            and self.date_or_datetime == other.date_or_datetime
        )


class Fruits(yardl.OutOfRangeEnum):
    APPLE = 0
    BANANA = 1
    PEAR = 2

class UInt64Enum(yardl.OutOfRangeEnum):
    A = 9223372036854775808

class Int64Enum(yardl.OutOfRangeEnum):
    B = -4611686018427387904

class SizeBasedEnum(yardl.OutOfRangeEnum):
    A = 0
    B = 1
    C = 2

class DaysOfWeek(enum.IntFlag):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 4
    THURSDAY = 8
    FRIDAY = 16
    SATURDAY = 32
    SUNDAY = 64

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DaysOfWeek) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

class TextFormat(enum.IntFlag):
    REGULAR = 0
    BOLD = 1
    ITALIC = 2
    UNDERLINE = 4
    STRIKETHROUGH = 8

    def __eq__(self, other: object) -> bool:
        return isinstance(other, TextFormat) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

class RecordWithEnums:
    enum: Fruits
    flags: DaysOfWeek
    flags_2: TextFormat

    def __init__(self, *,
        enum: Fruits = Fruits.APPLE,
        flags: DaysOfWeek = DaysOfWeek(0),
        flags_2: TextFormat = TextFormat.REGULAR,
    ):
        self.enum = enum
        self.flags = flags
        self.flags_2 = flags_2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithEnums)
            and self.enum == other.enum
            and self.flags == other.flags
            and self.flags_2 == other.flags_2
        )


Image = npt.NDArray[T_NP]

class GenericRecord(typing.Generic[T1, T2, T2_NP]):
    scalar_1: T1
    scalar_2: T2
    vector_1: list[T1]
    image_2: Image[T2_NP]

    def __init__(self, *,
        scalar_1: T1,
        scalar_2: T2,
        vector_1: list[T1],
        image_2: Image[T2_NP],
    ):
        self.scalar_1 = scalar_1
        self.scalar_2 = scalar_2
        self.vector_1 = vector_1
        self.image_2 = image_2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GenericRecord)
            and yardl.structural_equal(self.scalar_1, other.scalar_1)
            and yardl.structural_equal(self.scalar_2, other.scalar_2)
            and len(self.vector_1) == len(other.vector_1) and all(yardl.structural_equal(a, b) for a, b in zip(self.vector_1, other.vector_1))
            and yardl.structural_equal(self.image_2, other.image_2)
        )


class MyTuple(typing.Generic[T1, T2]):
    v1: T1
    v2: T2

    def __init__(self, *,
        v1: T1,
        v2: T2,
    ):
        self.v1 = v1
        self.v2 = v2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, MyTuple)
            and yardl.structural_equal(self.v1, other.v1)
            and yardl.structural_equal(self.v2, other.v2)
        )


AliasedString = str

AliasedEnum = Fruits

AliasedOpenGeneric = MyTuple[T1, T2]

AliasedClosedGeneric = MyTuple[AliasedString, AliasedEnum]

AliasedOptional = typing.Optional[yardl.Int32]

AliasedGenericOptional = typing.Optional[T]

class T1OrT2(typing.Generic[T1, T2]):
    T1: type["T1OrT2UnionCase[T1, T2, T1]"]
    T2: type["T1OrT2UnionCase[T1, T2, T2]"]

class T1OrT2UnionCase(T1OrT2[T1, T2], yardl.UnionCase[_T]):
    pass

T1OrT2.T1 = type("T1OrT2.T1", (T1OrT2UnionCase,), {"_index": 0})
T1OrT2.T2 = type("T1OrT2.T2", (T1OrT2UnionCase,), {"_index": 1})
del T1OrT2UnionCase

AliasedGenericUnion2 = T1OrT2[T1, T2]

AliasedGenericVector = list[T]

AliasedGenericFixedVector = list[T]

class Int32OrSimpleRecord:
    Int32: typing.ClassVar[type["Int32OrSimpleRecordUnionCase[yardl.Int32]"]]
    SimpleRecord: typing.ClassVar[type["Int32OrSimpleRecordUnionCase[SimpleRecord]"]]

class Int32OrSimpleRecordUnionCase(Int32OrSimpleRecord, yardl.UnionCase[_T]):
    pass

Int32OrSimpleRecord.Int32 = type("Int32OrSimpleRecord.Int32", (Int32OrSimpleRecordUnionCase,), {"_index": 0})
Int32OrSimpleRecord.SimpleRecord = type("Int32OrSimpleRecord.SimpleRecord", (Int32OrSimpleRecordUnionCase,), {"_index": 1})
del Int32OrSimpleRecordUnionCase

AliasedIntOrSimpleRecord = Int32OrSimpleRecord

AliasedNullableIntSimpleRecord = typing.Optional[Int32OrSimpleRecord]

class T0OrT1(typing.Generic[T0, T1]):
    T0: type["T0OrT1UnionCase[T0, T1, T0]"]
    T1: type["T0OrT1UnionCase[T0, T1, T1]"]

class T0OrT1UnionCase(T0OrT1[T0, T1], yardl.UnionCase[_T]):
    pass

T0OrT1.T0 = type("T0OrT1.T0", (T0OrT1UnionCase,), {"_index": 0})
T0OrT1.T1 = type("T0OrT1.T1", (T0OrT1UnionCase,), {"_index": 1})
del T0OrT1UnionCase

class GenericRecordWithComputedFields(typing.Generic[T0, T1]):
    f1: T0OrT1[T0, T1]

    def __init__(self, *,
        f1: T0OrT1[T0, T1],
    ):
        self.f1 = f1

    def type_index(self) -> yardl.UInt8:
        _var0 = self.f1
        if isinstance(_var0, T0OrT1.T0):
            return 0
        if isinstance(_var0, T0OrT1.T1):
            return 1
        raise RuntimeError("Unexpected union case")

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GenericRecordWithComputedFields)
            and yardl.structural_equal(self.f1, other.f1)
        )


class Int32OrFloat32:
    Int32: typing.ClassVar[type["Int32OrFloat32UnionCase[yardl.Int32]"]]
    Float32: typing.ClassVar[type["Int32OrFloat32UnionCase[yardl.Float32]"]]

class Int32OrFloat32UnionCase(Int32OrFloat32, yardl.UnionCase[_T]):
    pass

Int32OrFloat32.Int32 = type("Int32OrFloat32.Int32", (Int32OrFloat32UnionCase,), {"_index": 0})
Int32OrFloat32.Float32 = type("Int32OrFloat32.Float32", (Int32OrFloat32UnionCase,), {"_index": 1})
del Int32OrFloat32UnionCase

class IntOrGenericRecordWithComputedFields:
    Int: typing.ClassVar[type["IntOrGenericRecordWithComputedFieldsUnionCase[yardl.Int32]"]]
    GenericRecordWithComputedFields: typing.ClassVar[type["IntOrGenericRecordWithComputedFieldsUnionCase[GenericRecordWithComputedFields[str, yardl.Float32]]"]]

class IntOrGenericRecordWithComputedFieldsUnionCase(IntOrGenericRecordWithComputedFields, yardl.UnionCase[_T]):
    pass

IntOrGenericRecordWithComputedFields.Int = type("IntOrGenericRecordWithComputedFields.Int", (IntOrGenericRecordWithComputedFieldsUnionCase,), {"_index": 0})
IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields = type("IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields", (IntOrGenericRecordWithComputedFieldsUnionCase,), {"_index": 1})
del IntOrGenericRecordWithComputedFieldsUnionCase

class RecordWithComputedFields:
    array_field: npt.NDArray[np.int32]
    array_field_map_dimensions: npt.NDArray[np.int32]
    dynamic_array_field: npt.NDArray[np.int32]
    fixed_array_field: npt.NDArray[np.int32]
    int_field: yardl.Int32
    string_field: str
    tuple_field: MyTuple[yardl.Int32, yardl.Int32]
    vector_field: list[yardl.Int32]
    vector_of_vectors_field: list[list[yardl.Int32]]
    fixed_vector_field: list[yardl.Int32]
    optional_named_array: typing.Optional[NamedNDArray]
    int_float_union: Int32OrFloat32
    nullable_int_float_union: typing.Optional[Int32OrFloat32]
    union_with_nested_generic_union: IntOrGenericRecordWithComputedFields
    map_field: dict[str, str]

    def __init__(self, *,
        array_field: typing.Optional[npt.NDArray[np.int32]] = None,
        array_field_map_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        dynamic_array_field: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_array_field: typing.Optional[npt.NDArray[np.int32]] = None,
        int_field: yardl.Int32 = 0,
        string_field: str = "",
        tuple_field: typing.Optional[MyTuple[yardl.Int32, yardl.Int32]] = None,
        vector_field: typing.Optional[list[yardl.Int32]] = None,
        vector_of_vectors_field: typing.Optional[list[list[yardl.Int32]]] = None,
        fixed_vector_field: typing.Optional[list[yardl.Int32]] = None,
        optional_named_array: typing.Optional[NamedNDArray] = None,
        int_float_union: Int32OrFloat32 = Int32OrFloat32.Int32(0),
        nullable_int_float_union: typing.Optional[Int32OrFloat32] = None,
        union_with_nested_generic_union: IntOrGenericRecordWithComputedFields = IntOrGenericRecordWithComputedFields.Int(0),
        map_field: typing.Optional[dict[str, str]] = None,
    ):
        self.array_field = array_field if array_field is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.array_field_map_dimensions = array_field_map_dimensions if array_field_map_dimensions is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.dynamic_array_field = dynamic_array_field if dynamic_array_field is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.fixed_array_field = fixed_array_field if fixed_array_field is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.int_field = int_field
        self.string_field = string_field
        self.tuple_field = tuple_field if tuple_field is not None else MyTuple(v1=0, v2=0)
        self.vector_field = vector_field if vector_field is not None else []
        self.vector_of_vectors_field = vector_of_vectors_field if vector_of_vectors_field is not None else []
        self.fixed_vector_field = fixed_vector_field if fixed_vector_field is not None else [0] * 3
        self.optional_named_array = optional_named_array
        self.int_float_union = int_float_union
        self.nullable_int_float_union = nullable_int_float_union
        self.union_with_nested_generic_union = union_with_nested_generic_union
        self.map_field = map_field if map_field is not None else {}

    def int_literal(self) -> yardl.UInt8:
        return 42

    def large_negative_int64_literal(self) -> yardl.Int64:
        return -4611686018427387904

    def large_u_int64_literal(self) -> yardl.UInt64:
        return 9223372036854775808

    def string_literal(self) -> str:
        return "hello"

    def string_literal_2(self) -> str:
        return "hello"

    def string_literal_3(self) -> str:
        return "hello"

    def string_literal_4(self) -> str:
        return "hello"

    def access_other_computed_field(self) -> yardl.Int32:
        return self.int_field

    def access_int_field(self) -> yardl.Int32:
        return self.int_field

    def access_string_field(self) -> str:
        return self.string_field

    def access_tuple_field(self) -> MyTuple[yardl.Int32, yardl.Int32]:
        return self.tuple_field

    def access_nested_tuple_field(self) -> yardl.Int32:
        return self.tuple_field.v2

    def access_array_field(self) -> npt.NDArray[np.int32]:
        return self.array_field

    def access_array_field_element(self) -> yardl.Int32:
        return typing.cast(yardl.Int32, self.array_field[0, 1])

    def access_array_field_element_by_name(self) -> yardl.Int32:
        return typing.cast(yardl.Int32, self.array_field[0, 1])

    def access_vector_field(self) -> list[yardl.Int32]:
        return self.vector_field

    def access_vector_field_element(self) -> yardl.Int32:
        return self.vector_field[1]

    def access_vector_of_vectors_field(self) -> yardl.Int32:
        return self.vector_of_vectors_field[1][2]

    def array_size(self) -> yardl.Size:
        return self.array_field.size

    def array_x_size(self) -> yardl.Size:
        return self.array_field.shape[0]

    def array_y_size(self) -> yardl.Size:
        return self.array_field.shape[1]

    def array_0_size(self) -> yardl.Size:
        return self.array_field.shape[0]

    def array_1_size(self) -> yardl.Size:
        return self.array_field.shape[1]

    def array_size_from_int_field(self) -> yardl.Size:
        return self.array_field.shape[self.int_field]

    def array_size_from_string_field(self) -> yardl.Size:
        def _helper_0(dim_name: str) -> int:
            if dim_name == "x":
                return 0
            if dim_name == "y":
                return 1
            raise KeyError(f"Unknown dimension name: '{dim_name}'")

        return self.array_field.shape[_helper_0(self.string_field)]

    def array_size_from_nested_int_field(self) -> yardl.Size:
        return self.array_field.shape[self.tuple_field.v1]

    def array_field_map_dimensions_x_size(self) -> yardl.Size:
        return self.array_field_map_dimensions.shape[0]

    def fixed_array_size(self) -> yardl.Size:
        return 12

    def fixed_array_x_size(self) -> yardl.Size:
        return 3

    def fixed_array_0_size(self) -> yardl.Size:
        return 3

    def vector_size(self) -> yardl.Size:
        return len(self.vector_field)

    def fixed_vector_size(self) -> yardl.Size:
        return 3

    def array_dimension_x_index(self) -> yardl.Size:
        return 0

    def array_dimension_y_index(self) -> yardl.Size:
        return 1

    def array_dimension_index_from_string_field(self) -> yardl.Size:
        def _helper_0(dim_name: str) -> int:
            if dim_name == "x":
                return 0
            if dim_name == "y":
                return 1
            raise KeyError(f"Unknown dimension name: '{dim_name}'")

        return _helper_0(self.string_field)

    def array_dimension_count(self) -> yardl.Size:
        return 2

    def dynamic_array_dimension_count(self) -> yardl.Size:
        return self.dynamic_array_field.ndim

    def access_map(self) -> dict[str, str]:
        return self.map_field

    def map_size(self) -> yardl.Size:
        return len(self.map_field)

    def access_map_entry(self) -> str:
        return self.map_field["hello"]

    def string_computed_field(self) -> str:
        return "hello"

    def access_map_entry_with_computed_field(self) -> str:
        return self.map_field[self.string_computed_field()]

    def access_map_entry_with_computed_field_nested(self) -> str:
        return self.map_field[self.map_field[self.string_computed_field()]]

    def access_missing_map_entry(self) -> str:
        return self.map_field["missing"]

    def optional_named_array_length(self) -> yardl.Size:
        _var0 = self.optional_named_array
        if _var0 is not None:
            arr = _var0
            return arr.size
        return 0

    def optional_named_array_length_with_discard(self) -> yardl.Size:
        _var0 = self.optional_named_array
        if _var0 is not None:
            arr = _var0
            return arr.size
        return 0

    def int_float_union_as_float(self) -> yardl.Float32:
        _var0 = self.int_float_union
        if isinstance(_var0, Int32OrFloat32.Int32):
            i_foo = _var0.value
            return float(i_foo)
        if isinstance(_var0, Int32OrFloat32.Float32):
            f = _var0.value
            return f
        raise RuntimeError("Unexpected union case")

    def nullable_int_float_union_string(self) -> str:
        _var0 = self.nullable_int_float_union
        if _var0 is None:
            return "null"
        if isinstance(_var0, Int32OrFloat32.Int32):
            return "int"
        return "float"
        raise RuntimeError("Unexpected union case")

    def nested_switch(self) -> yardl.Int16:
        _var0 = self.union_with_nested_generic_union
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.Int):
            return -1
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields):
            rec = _var0.value
            _var1 = rec.f1
            if isinstance(_var1, T0OrT1.T1):
                return int(20)
            if isinstance(_var1, T0OrT1.T0):
                return int(10)
            raise RuntimeError("Unexpected union case")
        raise RuntimeError("Unexpected union case")

    def use_nested_computed_field(self) -> yardl.Int16:
        _var0 = self.union_with_nested_generic_union
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.Int):
            return -1
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields):
            rec = _var0.value
            return int(rec.type_index())
        raise RuntimeError("Unexpected union case")

    def switch_over_sigle_value(self) -> yardl.Int32:
        _var0 = self.int_field
        i = _var0
        return i

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithComputedFields)
            and yardl.structural_equal(self.array_field, other.array_field)
            and yardl.structural_equal(self.array_field_map_dimensions, other.array_field_map_dimensions)
            and yardl.structural_equal(self.dynamic_array_field, other.dynamic_array_field)
            and yardl.structural_equal(self.fixed_array_field, other.fixed_array_field)
            and self.int_field == other.int_field
            and self.string_field == other.string_field
            and self.tuple_field == other.tuple_field
            and self.vector_field == other.vector_field
            and self.vector_of_vectors_field == other.vector_of_vectors_field
            and self.fixed_vector_field == other.fixed_vector_field
            and (other.optional_named_array is None if self.optional_named_array is None else (other.optional_named_array is not None and yardl.structural_equal(self.optional_named_array, other.optional_named_array)))
            and self.int_float_union == other.int_float_union
            and self.nullable_int_float_union == other.nullable_int_float_union
            and self.union_with_nested_generic_union == other.union_with_nested_generic_union
            and self.map_field == other.map_field
        )


ArrayWithKeywordDimensionNames = npt.NDArray[np.int32]

class EnumWithKeywordSymbols(yardl.OutOfRangeEnum):
    TRY = 2
    CATCH = 1

class RecordWithKeywordFields:
    int_: str
    sizeof: ArrayWithKeywordDimensionNames
    if_: EnumWithKeywordSymbols

    def __init__(self, *,
        int_: str = "",
        sizeof: typing.Optional[ArrayWithKeywordDimensionNames] = None,
        if_: EnumWithKeywordSymbols,
    ):
        self.int_ = int_
        self.sizeof = sizeof if sizeof is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.if_ = if_

    def float_(self) -> str:
        return self.int_

    def double(self) -> str:
        return self.float_()

    def return_(self) -> yardl.Int32:
        return self.sizeof[1, 2]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithKeywordFields)
            and self.int_ == other.int_
            and yardl.structural_equal(self.sizeof, other.sizeof)
            and self.if_ == other.if_
        )


class AcquisitionOrImage:
    Acquisition: typing.ClassVar[type["AcquisitionOrImageUnionCase[SimpleAcquisition]"]]
    Image: typing.ClassVar[type["AcquisitionOrImageUnionCase[Image[np.float32]]"]]

class AcquisitionOrImageUnionCase(AcquisitionOrImage, yardl.UnionCase[_T]):
    pass

AcquisitionOrImage.Acquisition = type("AcquisitionOrImage.Acquisition", (AcquisitionOrImageUnionCase,), {"_index": 0})
AcquisitionOrImage.Image = type("AcquisitionOrImage.Image", (AcquisitionOrImageUnionCase,), {"_index": 1})
del AcquisitionOrImageUnionCase

class StringOrInt32:
    String: typing.ClassVar[type["StringOrInt32UnionCase[str]"]]
    Int32: typing.ClassVar[type["StringOrInt32UnionCase[yardl.Int32]"]]

class StringOrInt32UnionCase(StringOrInt32, yardl.UnionCase[_T]):
    pass

StringOrInt32.String = type("StringOrInt32.String", (StringOrInt32UnionCase,), {"_index": 0})
StringOrInt32.Int32 = type("StringOrInt32.Int32", (StringOrInt32UnionCase,), {"_index": 1})
del StringOrInt32UnionCase

class Int32OrRecordWithVlens:
    Int32: typing.ClassVar[type["Int32OrRecordWithVlensUnionCase[yardl.Int32]"]]
    RecordWithVlens: typing.ClassVar[type["Int32OrRecordWithVlensUnionCase[RecordWithVlens]"]]

class Int32OrRecordWithVlensUnionCase(Int32OrRecordWithVlens, yardl.UnionCase[_T]):
    pass

Int32OrRecordWithVlens.Int32 = type("Int32OrRecordWithVlens.Int32", (Int32OrRecordWithVlensUnionCase,), {"_index": 0})
Int32OrRecordWithVlens.RecordWithVlens = type("Int32OrRecordWithVlens.RecordWithVlens", (Int32OrRecordWithVlensUnionCase,), {"_index": 1})
del Int32OrRecordWithVlensUnionCase

class ImageFloatOrImageDouble:
    ImageFloat: typing.ClassVar[type["ImageFloatOrImageDoubleUnionCase[Image[np.float32]]"]]
    ImageDouble: typing.ClassVar[type["ImageFloatOrImageDoubleUnionCase[Image[np.float64]]"]]

class ImageFloatOrImageDoubleUnionCase(ImageFloatOrImageDouble, yardl.UnionCase[_T]):
    pass

ImageFloatOrImageDouble.ImageFloat = type("ImageFloatOrImageDouble.ImageFloat", (ImageFloatOrImageDoubleUnionCase,), {"_index": 0})
ImageFloatOrImageDouble.ImageDouble = type("ImageFloatOrImageDouble.ImageDouble", (ImageFloatOrImageDoubleUnionCase,), {"_index": 1})
del ImageFloatOrImageDoubleUnionCase

def _mk_get_dtype():
    dtype_map: dict[typing.Union[type, types.GenericAlias], typing.Union[np.dtype[typing.Any], typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map[SmallBenchmarkRecord] = np.dtype([('a', np.dtype(np.float64)), ('b', np.dtype(np.float32)), ('c', np.dtype(np.float32))], align=True)
    dtype_map[SimpleEncodingCounters] = np.dtype([('e1', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('e2', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('slice', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('repetition', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True))], align=True)
    dtype_map[SimpleAcquisition] = np.dtype([('flags', np.dtype(np.uint64)), ('idx', get_dtype(SimpleEncodingCounters)), ('data', np.dtype(np.object_)), ('trajectory', np.dtype(np.object_))], align=True)
    dtype_map[SimpleRecord] = np.dtype([('x', np.dtype(np.int32)), ('y', np.dtype(np.int32)), ('z', np.dtype(np.int32))], align=True)
    dtype_map[RecordWithPrimitives] = np.dtype([('bool_field', np.dtype(np.bool_)), ('int8_field', np.dtype(np.int8)), ('uint8_field', np.dtype(np.uint8)), ('int16_field', np.dtype(np.int16)), ('uint16_field', np.dtype(np.uint16)), ('int32_field', np.dtype(np.int32)), ('uint32_field', np.dtype(np.uint32)), ('int64_field', np.dtype(np.int64)), ('uint64_field', np.dtype(np.uint64)), ('size_field', np.dtype(np.uint64)), ('float32_field', np.dtype(np.float32)), ('float64_field', np.dtype(np.float64)), ('complexfloat32_field', np.dtype(np.complex64)), ('complexfloat64_field', np.dtype(np.complex128)), ('date_field', np.dtype(np.datetime64)), ('time_field', np.dtype(np.timedelta64)), ('datetime_field', np.dtype(np.datetime64))], align=True)
    dtype_map[RecordWithPrimitiveAliases] = np.dtype([('byte_field', np.dtype(np.uint8)), ('int_field', np.dtype(np.int32)), ('uint_field', np.dtype(np.uint32)), ('long_field', np.dtype(np.int64)), ('ulong_field', np.dtype(np.uint64)), ('float_field', np.dtype(np.float32)), ('double_field', np.dtype(np.float64)), ('complexfloat_field', np.dtype(np.complex64)), ('complexdouble_field', np.dtype(np.complex128))], align=True)
    dtype_map[TupleWithRecords] = np.dtype([('a', get_dtype(SimpleRecord)), ('b', get_dtype(SimpleRecord))], align=True)
    dtype_map[RecordWithVectors] = np.dtype([('default_vector', np.dtype(np.object_)), ('default_vector_fixed_length', np.dtype(np.int32), (3,)), ('vector_of_vectors', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithVectorOfTimes] = np.dtype([('times', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithArrays] = np.dtype([('default_array', np.dtype(np.object_)), ('default_array_with_empty_dimension', np.dtype(np.object_)), ('rank_1_array', np.dtype(np.object_)), ('rank_2_array', np.dtype(np.object_)), ('rank_2_array_with_named_dimensions', np.dtype(np.object_)), ('rank_2_fixed_array', np.dtype(np.int32), (3, 4,)), ('rank_2_fixed_array_with_named_dimensions', np.dtype(np.int32), (3, 4,)), ('dynamic_array', np.dtype(np.object_)), ('array_of_vectors', np.dtype(np.object_), (5,))], align=True)
    dtype_map[RecordWithArraysSimpleSyntax] = np.dtype([('default_array', np.dtype(np.object_)), ('default_array_with_empty_dimension', np.dtype(np.object_)), ('rank_1_array', np.dtype(np.object_)), ('rank_2_array', np.dtype(np.object_)), ('rank_2_array_with_named_dimensions', np.dtype(np.object_)), ('rank_2_fixed_array', np.dtype(np.int32), (3, 4,)), ('rank_2_fixed_array_with_named_dimensions', np.dtype(np.int32), (3, 4,)), ('dynamic_array', np.dtype(np.object_)), ('array_of_vectors', np.dtype(np.object_), (5,))], align=True)
    dtype_map[RecordWithOptionalFields] = np.dtype([('optional_int', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optional_int_alternate_syntax', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optional_time', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.timedelta64))], align=True))], align=True)
    dtype_map[RecordWithVlens] = np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.int32)), ('c', np.dtype(np.int32))], align=True)
    dtype_map[RecordWithStrings] = np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithOptionalVector] = np.dtype([('optional_vector', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True)
    dtype_map[RecordWithFixedVectors] = np.dtype([('fixed_int_vector', np.dtype(np.int32), (5,)), ('fixed_simple_record_vector', get_dtype(SimpleRecord), (3,)), ('fixed_record_with_vlens_vector', get_dtype(RecordWithVlens), (2,))], align=True)
    dtype_map[RecordWithFixedArrays] = np.dtype([('ints', np.dtype(np.int32), (2, 3,)), ('fixed_simple_record_array', get_dtype(SimpleRecord), (3, 2,)), ('fixed_record_with_vlens_array', get_dtype(RecordWithVlens), (2, 2,))], align=True)
    dtype_map[RecordWithNDArrays] = np.dtype([('ints', np.dtype(np.object_)), ('fixed_simple_record_array', np.dtype(np.object_)), ('fixed_record_with_vlens_array', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithNDArraysSingleDimension] = np.dtype([('ints', np.dtype(np.object_)), ('fixed_simple_record_array', np.dtype(np.object_)), ('fixed_record_with_vlens_array', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithDynamicNDArrays] = np.dtype([('ints', np.dtype(np.object_)), ('simple_record_array', np.dtype(np.object_)), ('record_with_vlens_array', np.dtype(np.object_))], align=True)
    dtype_map[NamedFixedNDArray] = np.dtype(np.int32)
    dtype_map[RecordWithFixedCollections] = np.dtype([('fixed_vector', np.dtype(np.int32), (3,)), ('fixed_array', np.dtype(np.int32), (2, 3,))], align=True)
    dtype_map[RecordWithVlenCollections] = np.dtype([('vector', np.dtype(np.object_)), ('array', np.dtype(np.object_))], align=True)
    dtype_map[NamedNDArray] = np.dtype(np.object_)
    dtype_map[AliasedMap] = lambda type_args: np.dtype(np.object_)
    dtype_map[RecordWithUnions] = np.dtype([('null_or_int_or_string', np.dtype(np.object_)), ('date_or_datetime', np.dtype(np.object_))], align=True)
    dtype_map[Fruits] = np.dtype(np.int32)
    dtype_map[UInt64Enum] = np.dtype(np.uint64)
    dtype_map[Int64Enum] = np.dtype(np.int64)
    dtype_map[SizeBasedEnum] = np.dtype(np.uint64)
    dtype_map[DaysOfWeek] = np.dtype(np.int32)
    dtype_map[TextFormat] = np.dtype(np.uint64)
    dtype_map[RecordWithEnums] = np.dtype([('enum', get_dtype(Fruits)), ('flags', get_dtype(DaysOfWeek)), ('flags_2', get_dtype(TextFormat))], align=True)
    dtype_map[Image] = lambda type_args: np.dtype(np.object_)
    dtype_map[GenericRecord] = lambda type_args: np.dtype([('scalar_1', get_dtype(type_args[0])), ('scalar_2', get_dtype(type_args[1])), ('vector_1', np.dtype(np.object_)), ('image_2', get_dtype(types.GenericAlias(Image, (type_args[1],))))], align=True)
    dtype_map[MyTuple] = lambda type_args: np.dtype([('v1', get_dtype(type_args[0])), ('v2', get_dtype(type_args[1]))], align=True)
    dtype_map[AliasedString] = np.dtype(np.object_)
    dtype_map[AliasedEnum] = get_dtype(Fruits)
    dtype_map[AliasedOpenGeneric] = lambda type_args: get_dtype(types.GenericAlias(MyTuple, (type_args[0], type_args[1],)))
    dtype_map[AliasedClosedGeneric] = get_dtype(types.GenericAlias(MyTuple, (AliasedString, AliasedEnum,)))
    dtype_map[AliasedOptional] = np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)
    dtype_map[AliasedGenericOptional] = lambda type_args: np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(type_args[0]))], align=True)
    dtype_map[AliasedGenericUnion2] = lambda type_args: np.dtype(np.object_)
    dtype_map[AliasedGenericVector] = lambda type_args: np.dtype(np.object_)
    dtype_map[AliasedGenericFixedVector] = lambda type_args: get_dtype(type_args[0])
    dtype_map[AliasedIntOrSimpleRecord] = np.dtype(np.object_)
    dtype_map[AliasedNullableIntSimpleRecord] = np.dtype(np.object_)
    dtype_map[GenericRecordWithComputedFields] = lambda type_args: np.dtype([('f1', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithComputedFields] = np.dtype([('array_field', np.dtype(np.object_)), ('array_field_map_dimensions', np.dtype(np.object_)), ('dynamic_array_field', np.dtype(np.object_)), ('fixed_array_field', np.dtype(np.int32), (3, 4,)), ('int_field', np.dtype(np.int32)), ('string_field', np.dtype(np.object_)), ('tuple_field', get_dtype(types.GenericAlias(MyTuple, (yardl.Int32, yardl.Int32,)))), ('vector_field', np.dtype(np.object_)), ('vector_of_vectors_field', np.dtype(np.object_)), ('fixed_vector_field', np.dtype(np.int32), (3,)), ('optional_named_array', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(NamedNDArray))], align=True)), ('int_float_union', np.dtype(np.object_)), ('nullable_int_float_union', np.dtype(np.object_)), ('union_with_nested_generic_union', np.dtype(np.object_)), ('map_field', np.dtype(np.object_))], align=True)
    dtype_map[ArrayWithKeywordDimensionNames] = np.dtype(np.object_)
    dtype_map[EnumWithKeywordSymbols] = np.dtype(np.int32)
    dtype_map[RecordWithKeywordFields] = np.dtype([('int_', np.dtype(np.object_)), ('sizeof', get_dtype(ArrayWithKeywordDimensionNames)), ('if_', get_dtype(EnumWithKeywordSymbols))], align=True)

    return get_dtype

get_dtype = _mk_get_dtype()

