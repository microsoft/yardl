# This file was generated by the "yardl" tool. DO NOT EDIT.

import abc
import collections.abc
import datetime
import typing

import numpy as np
import numpy.typing as npt

from .types import *
from .yardl_types import ProtocolError
from . import yardl_types as yardl

class BenchmarkFloat256x256WriterBase(abc.ABC):
    """Abstract writer for the BenchmarkFloat256x256 protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"BenchmarkFloat256x256","sequence":[{"name":"float256x256","type":{"stream":{"items":{"array":{"items":"float32","dimensions":[{"length":256},{"length":256}]}}}}}]},"types":null}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 1:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_float256x256(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_float256x256(value)
        self._state = 1

    @abc.abstractmethod
    def _write_float256x256(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_float256x256'
        return "<unknown>"

class BenchmarkFloat256x256ReaderBase(abc.ABC):
    """Abstract reader for the BenchmarkFloat256x256 protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = BenchmarkFloat256x256WriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_float256x256(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_float256x256()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def copy_to(self, writer: BenchmarkFloat256x256WriterBase) -> None:
        writer.write_float256x256(self.read_float256x256())

    @abc.abstractmethod
    def _read_float256x256(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_float256x256'
        return "<unknown>"

class BenchmarkInt256x256WriterBase(abc.ABC):
    """Abstract writer for the BenchmarkInt256x256 protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"BenchmarkInt256x256","sequence":[{"name":"int256x256","type":{"stream":{"items":{"array":{"items":"int32","dimensions":[{"length":256},{"length":256}]}}}}}]},"types":null}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 1:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int256x256(self, value: collections.abc.Iterable[npt.NDArray[np.int32]]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_int256x256(value)
        self._state = 1

    @abc.abstractmethod
    def _write_int256x256(self, value: collections.abc.Iterable[npt.NDArray[np.int32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int256x256'
        return "<unknown>"

class BenchmarkInt256x256ReaderBase(abc.ABC):
    """Abstract reader for the BenchmarkInt256x256 protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = BenchmarkInt256x256WriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int256x256(self) -> collections.abc.Iterable[npt.NDArray[np.int32]]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int256x256()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def copy_to(self, writer: BenchmarkInt256x256WriterBase) -> None:
        writer.write_int256x256(self.read_int256x256())

    @abc.abstractmethod
    def _read_int256x256(self) -> collections.abc.Iterable[npt.NDArray[np.int32]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int256x256'
        return "<unknown>"

class BenchmarkFloatVlenWriterBase(abc.ABC):
    """Abstract writer for the BenchmarkFloatVlen protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"BenchmarkFloatVlen","sequence":[{"name":"floatArray","type":{"stream":{"items":{"array":{"items":"float32","dimensions":2}}}}}]},"types":null}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 1:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_float_array(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_float_array(value)
        self._state = 1

    @abc.abstractmethod
    def _write_float_array(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_float_array'
        return "<unknown>"

class BenchmarkFloatVlenReaderBase(abc.ABC):
    """Abstract reader for the BenchmarkFloatVlen protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = BenchmarkFloatVlenWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_float_array(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_float_array()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def copy_to(self, writer: BenchmarkFloatVlenWriterBase) -> None:
        writer.write_float_array(self.read_float_array())

    @abc.abstractmethod
    def _read_float_array(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_float_array'
        return "<unknown>"

class BenchmarkSmallRecordWriterBase(abc.ABC):
    """Abstract writer for the BenchmarkSmallRecord protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"BenchmarkSmallRecord","sequence":[{"name":"smallRecord","type":{"stream":{"items":"TestModel.SmallBenchmarkRecord"}}}]},"types":[{"name":"SmallBenchmarkRecord","fields":[{"name":"a","type":"float64"},{"name":"b","type":"float32"},{"name":"c","type":"float32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 1:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_small_record(self, value: collections.abc.Iterable[SmallBenchmarkRecord]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_small_record(value)
        self._state = 1

    @abc.abstractmethod
    def _write_small_record(self, value: collections.abc.Iterable[SmallBenchmarkRecord]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_small_record'
        return "<unknown>"

class BenchmarkSmallRecordReaderBase(abc.ABC):
    """Abstract reader for the BenchmarkSmallRecord protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = BenchmarkSmallRecordWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_small_record(self) -> collections.abc.Iterable[SmallBenchmarkRecord]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_small_record()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def copy_to(self, writer: BenchmarkSmallRecordWriterBase) -> None:
        writer.write_small_record(self.read_small_record())

    @abc.abstractmethod
    def _read_small_record(self) -> collections.abc.Iterable[SmallBenchmarkRecord]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_small_record'
        return "<unknown>"

class BenchmarkSmallRecordWithOptionalsWriterBase(abc.ABC):
    """Abstract writer for the BenchmarkSmallRecordWithOptionals protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"BenchmarkSmallRecordWithOptionals","sequence":[{"name":"smallRecord","type":{"stream":{"items":"TestModel.SimpleEncodingCounters"}}}]},"types":[{"name":"SimpleEncodingCounters","fields":[{"name":"e1","type":[null,"uint32"]},{"name":"e2","type":[null,"uint32"]},{"name":"slice","type":[null,"uint32"]},{"name":"repetition","type":[null,"uint32"]}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 1:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_small_record(self, value: collections.abc.Iterable[SimpleEncodingCounters]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_small_record(value)
        self._state = 1

    @abc.abstractmethod
    def _write_small_record(self, value: collections.abc.Iterable[SimpleEncodingCounters]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_small_record'
        return "<unknown>"

class BenchmarkSmallRecordWithOptionalsReaderBase(abc.ABC):
    """Abstract reader for the BenchmarkSmallRecordWithOptionals protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = BenchmarkSmallRecordWithOptionalsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_small_record(self) -> collections.abc.Iterable[SimpleEncodingCounters]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_small_record()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def copy_to(self, writer: BenchmarkSmallRecordWithOptionalsWriterBase) -> None:
        writer.write_small_record(self.read_small_record())

    @abc.abstractmethod
    def _read_small_record(self) -> collections.abc.Iterable[SimpleEncodingCounters]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_small_record'
        return "<unknown>"

class BenchmarkSimpleMrdWriterBase(abc.ABC):
    """Abstract writer for the BenchmarkSimpleMrd protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"BenchmarkSimpleMrd","sequence":[{"name":"data","type":{"stream":{"items":[{"tag":"acquisition","explicitTag":true,"type":"TestModel.SimpleAcquisition"},{"tag":"image","explicitTag":true,"type":{"name":"TestModel.Image","typeArguments":["float32"]}}]}}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"SimpleAcquisition","fields":[{"name":"flags","type":"uint64"},{"name":"idx","type":"TestModel.SimpleEncodingCounters"},{"name":"data","type":{"array":{"items":"complexfloat32","dimensions":2}}},{"name":"trajectory","type":{"array":{"items":"float32","dimensions":2}}}]},{"name":"SimpleEncodingCounters","fields":[{"name":"e1","type":[null,"uint32"]},{"name":"e2","type":[null,"uint32"]},{"name":"slice","type":[null,"uint32"]},{"name":"repetition","type":[null,"uint32"]}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 1:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_data(self, value: collections.abc.Iterable[AcquisitionOrImage]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_data(value)
        self._state = 1

    @abc.abstractmethod
    def _write_data(self, value: collections.abc.Iterable[AcquisitionOrImage]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_data'
        return "<unknown>"

class BenchmarkSimpleMrdReaderBase(abc.ABC):
    """Abstract reader for the BenchmarkSimpleMrd protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = BenchmarkSimpleMrdWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_data(self) -> collections.abc.Iterable[AcquisitionOrImage]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_data()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def copy_to(self, writer: BenchmarkSimpleMrdWriterBase) -> None:
        writer.write_data(self.read_data())

    @abc.abstractmethod
    def _read_data(self) -> collections.abc.Iterable[AcquisitionOrImage]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_data'
        return "<unknown>"

class ScalarsWriterBase(abc.ABC):
    """Abstract writer for the Scalars protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Scalars","sequence":[{"name":"int32","type":"int32"},{"name":"record","type":"TestModel.RecordWithPrimitives"}]},"types":[{"name":"RecordWithPrimitives","fields":[{"name":"boolField","type":"bool"},{"name":"int8Field","type":"int8"},{"name":"uint8Field","type":"uint8"},{"name":"int16Field","type":"int16"},{"name":"uint16Field","type":"uint16"},{"name":"int32Field","type":"int32"},{"name":"uint32Field","type":"uint32"},{"name":"int64Field","type":"int64"},{"name":"uint64Field","type":"uint64"},{"name":"sizeField","type":"size"},{"name":"float32Field","type":"float32"},{"name":"float64Field","type":"float64"},{"name":"complexfloat32Field","type":"complexfloat32"},{"name":"complexfloat64Field","type":"complexfloat64"},{"name":"dateField","type":"date"},{"name":"timeField","type":"time"},{"name":"datetimeField","type":"datetime"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int32(self, value: yardl.Int32) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_int32(value)
        self._state = 2

    def write_record(self, value: RecordWithPrimitives) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_record(value)
        self._state = 4

    @abc.abstractmethod
    def _write_int32(self, value: yardl.Int32) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record(self, value: RecordWithPrimitives) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int32'
        if state == 2:
            return 'write_record'
        return "<unknown>"

class ScalarsReaderBase(abc.ABC):
    """Abstract reader for the Scalars protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = ScalarsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int32(self) -> yardl.Int32:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int32()
        self._state = 2
        return value

    def read_record(self) -> RecordWithPrimitives:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_record()
        self._state = 4
        return value

    def copy_to(self, writer: ScalarsWriterBase) -> None:
        writer.write_int32(self.read_int32())
        writer.write_record(self.read_record())

    @abc.abstractmethod
    def _read_int32(self) -> yardl.Int32:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record(self) -> RecordWithPrimitives:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int32'
        if state == 2:
            return 'read_record'
        return "<unknown>"

class ScalarOptionalsWriterBase(abc.ABC):
    """Abstract writer for the ScalarOptionals protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"ScalarOptionals","sequence":[{"name":"optionalInt","type":[null,"int32"]},{"name":"optionalRecord","type":[null,"TestModel.SimpleRecord"]},{"name":"recordWithOptionalFields","type":"TestModel.RecordWithOptionalFields"},{"name":"optionalRecordWithOptionalFields","type":[null,"TestModel.RecordWithOptionalFields"]}]},"types":[{"name":"RecordWithOptionalFields","fields":[{"name":"optionalInt","type":[null,"int32"]},{"name":"optionalIntAlternateSyntax","type":[null,"int32"]},{"name":"optionalTime","type":[null,"time"]}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_optional_int(self, value: typing.Optional[yardl.Int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_optional_int(value)
        self._state = 2

    def write_optional_record(self, value: typing.Optional[SimpleRecord]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_optional_record(value)
        self._state = 4

    def write_record_with_optional_fields(self, value: RecordWithOptionalFields) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_record_with_optional_fields(value)
        self._state = 6

    def write_optional_record_with_optional_fields(self, value: typing.Optional[RecordWithOptionalFields]) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_optional_record_with_optional_fields(value)
        self._state = 8

    @abc.abstractmethod
    def _write_optional_int(self, value: typing.Optional[yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_optional_record(self, value: typing.Optional[SimpleRecord]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_optional_fields(self, value: RecordWithOptionalFields) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_optional_record_with_optional_fields(self, value: typing.Optional[RecordWithOptionalFields]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_optional_int'
        if state == 2:
            return 'write_optional_record'
        if state == 4:
            return 'write_record_with_optional_fields'
        if state == 6:
            return 'write_optional_record_with_optional_fields'
        return "<unknown>"

class ScalarOptionalsReaderBase(abc.ABC):
    """Abstract reader for the ScalarOptionals protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = ScalarOptionalsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_optional_int(self) -> typing.Optional[yardl.Int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_optional_int()
        self._state = 2
        return value

    def read_optional_record(self) -> typing.Optional[SimpleRecord]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_optional_record()
        self._state = 4
        return value

    def read_record_with_optional_fields(self) -> RecordWithOptionalFields:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_record_with_optional_fields()
        self._state = 6
        return value

    def read_optional_record_with_optional_fields(self) -> typing.Optional[RecordWithOptionalFields]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_optional_record_with_optional_fields()
        self._state = 8
        return value

    def copy_to(self, writer: ScalarOptionalsWriterBase) -> None:
        writer.write_optional_int(self.read_optional_int())
        writer.write_optional_record(self.read_optional_record())
        writer.write_record_with_optional_fields(self.read_record_with_optional_fields())
        writer.write_optional_record_with_optional_fields(self.read_optional_record_with_optional_fields())

    @abc.abstractmethod
    def _read_optional_int(self) -> typing.Optional[yardl.Int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_optional_record(self) -> typing.Optional[SimpleRecord]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_optional_fields(self) -> RecordWithOptionalFields:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_optional_record_with_optional_fields(self) -> typing.Optional[RecordWithOptionalFields]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_optional_int'
        if state == 2:
            return 'read_optional_record'
        if state == 4:
            return 'read_record_with_optional_fields'
        if state == 6:
            return 'read_optional_record_with_optional_fields'
        return "<unknown>"

class NestedRecordsWriterBase(abc.ABC):
    """Abstract writer for the NestedRecords protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"NestedRecords","sequence":[{"name":"tupleWithRecords","type":"TestModel.TupleWithRecords"}]},"types":[{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]},{"name":"TupleWithRecords","fields":[{"name":"a","type":"TestModel.SimpleRecord"},{"name":"b","type":"TestModel.SimpleRecord"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_tuple_with_records(self, value: TupleWithRecords) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_tuple_with_records(value)
        self._state = 2

    @abc.abstractmethod
    def _write_tuple_with_records(self, value: TupleWithRecords) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_tuple_with_records'
        return "<unknown>"

class NestedRecordsReaderBase(abc.ABC):
    """Abstract reader for the NestedRecords protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = NestedRecordsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_tuple_with_records(self) -> TupleWithRecords:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_tuple_with_records()
        self._state = 2
        return value

    def copy_to(self, writer: NestedRecordsWriterBase) -> None:
        writer.write_tuple_with_records(self.read_tuple_with_records())

    @abc.abstractmethod
    def _read_tuple_with_records(self) -> TupleWithRecords:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_tuple_with_records'
        return "<unknown>"

class VlensWriterBase(abc.ABC):
    """Abstract writer for the Vlens protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Vlens","sequence":[{"name":"intVector","type":{"vector":{"items":"int32"}}},{"name":"complexVector","type":{"vector":{"items":"complexfloat32"}}},{"name":"recordWithVlens","type":"TestModel.RecordWithVlens"},{"name":"vlenOfRecordWithVlens","type":{"vector":{"items":"TestModel.RecordWithVlens"}}}]},"types":[{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int_vector(self, value: list[yardl.Int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_int_vector(value)
        self._state = 2

    def write_complex_vector(self, value: list[yardl.ComplexFloat]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_complex_vector(value)
        self._state = 4

    def write_record_with_vlens(self, value: RecordWithVlens) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_record_with_vlens(value)
        self._state = 6

    def write_vlen_of_record_with_vlens(self, value: list[RecordWithVlens]) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_vlen_of_record_with_vlens(value)
        self._state = 8

    @abc.abstractmethod
    def _write_int_vector(self, value: list[yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_complex_vector(self, value: list[yardl.ComplexFloat]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_vlens(self, value: RecordWithVlens) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_vlen_of_record_with_vlens(self, value: list[RecordWithVlens]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int_vector'
        if state == 2:
            return 'write_complex_vector'
        if state == 4:
            return 'write_record_with_vlens'
        if state == 6:
            return 'write_vlen_of_record_with_vlens'
        return "<unknown>"

class VlensReaderBase(abc.ABC):
    """Abstract reader for the Vlens protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = VlensWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int_vector(self) -> list[yardl.Int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int_vector()
        self._state = 2
        return value

    def read_complex_vector(self) -> list[yardl.ComplexFloat]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_complex_vector()
        self._state = 4
        return value

    def read_record_with_vlens(self) -> RecordWithVlens:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_record_with_vlens()
        self._state = 6
        return value

    def read_vlen_of_record_with_vlens(self) -> list[RecordWithVlens]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_vlen_of_record_with_vlens()
        self._state = 8
        return value

    def copy_to(self, writer: VlensWriterBase) -> None:
        writer.write_int_vector(self.read_int_vector())
        writer.write_complex_vector(self.read_complex_vector())
        writer.write_record_with_vlens(self.read_record_with_vlens())
        writer.write_vlen_of_record_with_vlens(self.read_vlen_of_record_with_vlens())

    @abc.abstractmethod
    def _read_int_vector(self) -> list[yardl.Int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_complex_vector(self) -> list[yardl.ComplexFloat]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_vlens(self) -> RecordWithVlens:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_vlen_of_record_with_vlens(self) -> list[RecordWithVlens]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int_vector'
        if state == 2:
            return 'read_complex_vector'
        if state == 4:
            return 'read_record_with_vlens'
        if state == 6:
            return 'read_vlen_of_record_with_vlens'
        return "<unknown>"

class StringsWriterBase(abc.ABC):
    """Abstract writer for the Strings protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Strings","sequence":[{"name":"singleString","type":"string"},{"name":"recWithString","type":"TestModel.RecordWithStrings"}]},"types":[{"name":"RecordWithStrings","fields":[{"name":"a","type":"string"},{"name":"b","type":"string"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_single_string(self, value: str) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_single_string(value)
        self._state = 2

    def write_rec_with_string(self, value: RecordWithStrings) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_rec_with_string(value)
        self._state = 4

    @abc.abstractmethod
    def _write_single_string(self, value: str) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_rec_with_string(self, value: RecordWithStrings) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_single_string'
        if state == 2:
            return 'write_rec_with_string'
        return "<unknown>"

class StringsReaderBase(abc.ABC):
    """Abstract reader for the Strings protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = StringsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_single_string(self) -> str:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_single_string()
        self._state = 2
        return value

    def read_rec_with_string(self) -> RecordWithStrings:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_rec_with_string()
        self._state = 4
        return value

    def copy_to(self, writer: StringsWriterBase) -> None:
        writer.write_single_string(self.read_single_string())
        writer.write_rec_with_string(self.read_rec_with_string())

    @abc.abstractmethod
    def _read_single_string(self) -> str:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_rec_with_string(self) -> RecordWithStrings:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_single_string'
        if state == 2:
            return 'read_rec_with_string'
        return "<unknown>"

class OptionalVectorsWriterBase(abc.ABC):
    """Abstract writer for the OptionalVectors protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"OptionalVectors","sequence":[{"name":"recordWithOptionalVector","type":"TestModel.RecordWithOptionalVector"}]},"types":[{"name":"RecordWithOptionalVector","fields":[{"name":"optionalVector","type":[null,{"vector":{"items":"int32"}}]}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_record_with_optional_vector(self, value: RecordWithOptionalVector) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_record_with_optional_vector(value)
        self._state = 2

    @abc.abstractmethod
    def _write_record_with_optional_vector(self, value: RecordWithOptionalVector) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_record_with_optional_vector'
        return "<unknown>"

class OptionalVectorsReaderBase(abc.ABC):
    """Abstract reader for the OptionalVectors protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = OptionalVectorsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_record_with_optional_vector(self) -> RecordWithOptionalVector:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_record_with_optional_vector()
        self._state = 2
        return value

    def copy_to(self, writer: OptionalVectorsWriterBase) -> None:
        writer.write_record_with_optional_vector(self.read_record_with_optional_vector())

    @abc.abstractmethod
    def _read_record_with_optional_vector(self) -> RecordWithOptionalVector:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_record_with_optional_vector'
        return "<unknown>"

class FixedVectorsWriterBase(abc.ABC):
    """Abstract writer for the FixedVectors protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"FixedVectors","sequence":[{"name":"fixedIntVector","type":{"vector":{"items":"int32","length":5}}},{"name":"fixedSimpleRecordVector","type":{"vector":{"items":"TestModel.SimpleRecord","length":3}}},{"name":"fixedRecordWithVlensVector","type":{"vector":{"items":"TestModel.RecordWithVlens","length":2}}},{"name":"recordWithFixedVectors","type":"TestModel.RecordWithFixedVectors"}]},"types":[{"name":"RecordWithFixedVectors","fields":[{"name":"fixedIntVector","type":{"vector":{"items":"int32","length":5}}},{"name":"fixedSimpleRecordVector","type":{"vector":{"items":"TestModel.SimpleRecord","length":3}}},{"name":"fixedRecordWithVlensVector","type":{"vector":{"items":"TestModel.RecordWithVlens","length":2}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_fixed_int_vector(self, value: list[yardl.Int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_fixed_int_vector(value)
        self._state = 2

    def write_fixed_simple_record_vector(self, value: list[SimpleRecord]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_fixed_simple_record_vector(value)
        self._state = 4

    def write_fixed_record_with_vlens_vector(self, value: list[RecordWithVlens]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_fixed_record_with_vlens_vector(value)
        self._state = 6

    def write_record_with_fixed_vectors(self, value: RecordWithFixedVectors) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_record_with_fixed_vectors(value)
        self._state = 8

    @abc.abstractmethod
    def _write_fixed_int_vector(self, value: list[yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_simple_record_vector(self, value: list[SimpleRecord]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_record_with_vlens_vector(self, value: list[RecordWithVlens]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_fixed_vectors(self, value: RecordWithFixedVectors) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_fixed_int_vector'
        if state == 2:
            return 'write_fixed_simple_record_vector'
        if state == 4:
            return 'write_fixed_record_with_vlens_vector'
        if state == 6:
            return 'write_record_with_fixed_vectors'
        return "<unknown>"

class FixedVectorsReaderBase(abc.ABC):
    """Abstract reader for the FixedVectors protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = FixedVectorsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_fixed_int_vector(self) -> list[yardl.Int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_fixed_int_vector()
        self._state = 2
        return value

    def read_fixed_simple_record_vector(self) -> list[SimpleRecord]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_fixed_simple_record_vector()
        self._state = 4
        return value

    def read_fixed_record_with_vlens_vector(self) -> list[RecordWithVlens]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_fixed_record_with_vlens_vector()
        self._state = 6
        return value

    def read_record_with_fixed_vectors(self) -> RecordWithFixedVectors:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_record_with_fixed_vectors()
        self._state = 8
        return value

    def copy_to(self, writer: FixedVectorsWriterBase) -> None:
        writer.write_fixed_int_vector(self.read_fixed_int_vector())
        writer.write_fixed_simple_record_vector(self.read_fixed_simple_record_vector())
        writer.write_fixed_record_with_vlens_vector(self.read_fixed_record_with_vlens_vector())
        writer.write_record_with_fixed_vectors(self.read_record_with_fixed_vectors())

    @abc.abstractmethod
    def _read_fixed_int_vector(self) -> list[yardl.Int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_simple_record_vector(self) -> list[SimpleRecord]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_record_with_vlens_vector(self) -> list[RecordWithVlens]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_fixed_vectors(self) -> RecordWithFixedVectors:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_fixed_int_vector'
        if state == 2:
            return 'read_fixed_simple_record_vector'
        if state == 4:
            return 'read_fixed_record_with_vlens_vector'
        if state == 6:
            return 'read_record_with_fixed_vectors'
        return "<unknown>"

class StreamsWriterBase(abc.ABC):
    """Abstract writer for the Streams protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Streams","sequence":[{"name":"intData","type":{"stream":{"items":"int32"}}},{"name":"optionalIntData","type":{"stream":{"items":[null,"int32"]}}},{"name":"recordWithOptionalVectorData","type":{"stream":{"items":"TestModel.RecordWithOptionalVector"}}},{"name":"fixedVector","type":{"stream":{"items":{"vector":{"items":"int32","length":3}}}}}]},"types":[{"name":"RecordWithOptionalVector","fields":[{"name":"optionalVector","type":[null,{"vector":{"items":"int32"}}]}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 7:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int_data(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_int_data(value)
        self._state = 1

    def write_optional_int_data(self, value: collections.abc.Iterable[typing.Optional[yardl.Int32]]) -> None:
        """Ordinal 1"""

        if self._state == 1:
            self._end_stream()
            self._state = 2
        elif self._state & ~1 != 2:
            self._raise_unexpected_state(2)

        self._write_optional_int_data(value)
        self._state = 3

    def write_record_with_optional_vector_data(self, value: collections.abc.Iterable[RecordWithOptionalVector]) -> None:
        """Ordinal 2"""

        if self._state == 3:
            self._end_stream()
            self._state = 4
        elif self._state & ~1 != 4:
            self._raise_unexpected_state(4)

        self._write_record_with_optional_vector_data(value)
        self._state = 5

    def write_fixed_vector(self, value: collections.abc.Iterable[list[yardl.Int32]]) -> None:
        """Ordinal 3"""

        if self._state == 5:
            self._end_stream()
            self._state = 6
        elif self._state & ~1 != 6:
            self._raise_unexpected_state(6)

        self._write_fixed_vector(value)
        self._state = 7

    @abc.abstractmethod
    def _write_int_data(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_optional_int_data(self, value: collections.abc.Iterable[typing.Optional[yardl.Int32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_optional_vector_data(self, value: collections.abc.Iterable[RecordWithOptionalVector]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_vector(self, value: collections.abc.Iterable[list[yardl.Int32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int_data'
        if state == 2:
            return 'write_optional_int_data'
        if state == 4:
            return 'write_record_with_optional_vector_data'
        if state == 6:
            return 'write_fixed_vector'
        return "<unknown>"

class StreamsReaderBase(abc.ABC):
    """Abstract reader for the Streams protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = StreamsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int_data(self) -> collections.abc.Iterable[yardl.Int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int_data()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def read_optional_int_data(self) -> collections.abc.Iterable[typing.Optional[yardl.Int32]]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_optional_int_data()
        self._state = 3
        return self._wrap_iterable(value, 4)

    def read_record_with_optional_vector_data(self) -> collections.abc.Iterable[RecordWithOptionalVector]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_record_with_optional_vector_data()
        self._state = 5
        return self._wrap_iterable(value, 6)

    def read_fixed_vector(self) -> collections.abc.Iterable[list[yardl.Int32]]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_fixed_vector()
        self._state = 7
        return self._wrap_iterable(value, 8)

    def copy_to(self, writer: StreamsWriterBase) -> None:
        writer.write_int_data(self.read_int_data())
        writer.write_optional_int_data(self.read_optional_int_data())
        writer.write_record_with_optional_vector_data(self.read_record_with_optional_vector_data())
        writer.write_fixed_vector(self.read_fixed_vector())

    @abc.abstractmethod
    def _read_int_data(self) -> collections.abc.Iterable[yardl.Int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_optional_int_data(self) -> collections.abc.Iterable[typing.Optional[yardl.Int32]]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_optional_vector_data(self) -> collections.abc.Iterable[RecordWithOptionalVector]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_vector(self) -> collections.abc.Iterable[list[yardl.Int32]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int_data'
        if state == 2:
            return 'read_optional_int_data'
        if state == 4:
            return 'read_record_with_optional_vector_data'
        if state == 6:
            return 'read_fixed_vector'
        return "<unknown>"

class FixedArraysWriterBase(abc.ABC):
    """Abstract writer for the FixedArrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"FixedArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":[{"length":3},{"length":2}]}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":[{"length":2},{"length":2}]}}},{"name":"recordWithFixedArrays","type":"TestModel.RecordWithFixedArrays"},{"name":"namedArray","type":"TestModel.NamedFixedNDArray"}]},"types":[{"name":"NamedFixedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA","length":2},{"name":"dimB","length":4}]}}},{"name":"RecordWithFixedArrays","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":[{"length":3},{"length":2}]}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":[{"length":2},{"length":2}]}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 10:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_ints(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_ints(value)
        self._state = 2

    def write_fixed_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_fixed_simple_record_array(value)
        self._state = 4

    def write_fixed_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_fixed_record_with_vlens_array(value)
        self._state = 6

    def write_record_with_fixed_arrays(self, value: RecordWithFixedArrays) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_record_with_fixed_arrays(value)
        self._state = 8

    def write_named_array(self, value: NamedFixedNDArray) -> None:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        self._write_named_array(value)
        self._state = 10

    @abc.abstractmethod
    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_fixed_arrays(self, value: RecordWithFixedArrays) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_named_array(self, value: NamedFixedNDArray) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_ints'
        if state == 2:
            return 'write_fixed_simple_record_array'
        if state == 4:
            return 'write_fixed_record_with_vlens_array'
        if state == 6:
            return 'write_record_with_fixed_arrays'
        if state == 8:
            return 'write_named_array'
        return "<unknown>"

class FixedArraysReaderBase(abc.ABC):
    """Abstract reader for the FixedArrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = FixedArraysWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 10:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_ints(self) -> npt.NDArray[np.int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_ints()
        self._state = 2
        return value

    def read_fixed_simple_record_array(self) -> npt.NDArray[np.void]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_fixed_simple_record_array()
        self._state = 4
        return value

    def read_fixed_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_fixed_record_with_vlens_array()
        self._state = 6
        return value

    def read_record_with_fixed_arrays(self) -> RecordWithFixedArrays:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_record_with_fixed_arrays()
        self._state = 8
        return value

    def read_named_array(self) -> NamedFixedNDArray:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        value = self._read_named_array()
        self._state = 10
        return value

    def copy_to(self, writer: FixedArraysWriterBase) -> None:
        writer.write_ints(self.read_ints())
        writer.write_fixed_simple_record_array(self.read_fixed_simple_record_array())
        writer.write_fixed_record_with_vlens_array(self.read_fixed_record_with_vlens_array())
        writer.write_record_with_fixed_arrays(self.read_record_with_fixed_arrays())
        writer.write_named_array(self.read_named_array())

    @abc.abstractmethod
    def _read_ints(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_simple_record_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_fixed_arrays(self) -> RecordWithFixedArrays:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_named_array(self) -> NamedFixedNDArray:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_ints'
        if state == 2:
            return 'read_fixed_simple_record_array'
        if state == 4:
            return 'read_fixed_record_with_vlens_array'
        if state == 6:
            return 'read_record_with_fixed_arrays'
        if state == 8:
            return 'read_named_array'
        return "<unknown>"

class SubarraysWriterBase(abc.ABC):
    """Abstract writer for the Subarrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Subarrays","sequence":[{"name":"dynamicWithFixedIntSubarray","type":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}}}}},{"name":"dynamicWithFixedFloatSubarray","type":{"array":{"items":{"array":{"items":"float32","dimensions":[{"length":3}]}}}}},{"name":"knownDimCountWithFixedIntSubarray","type":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}},"dimensions":1}}},{"name":"knownDimCountWithFixedFloatSubarray","type":{"array":{"items":{"array":{"items":"float32","dimensions":[{"length":3}]}},"dimensions":1}}},{"name":"fixedWithFixedIntSubarray","type":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}},"dimensions":[{"length":2}]}}},{"name":"fixedWithFixedFloatSubarray","type":{"array":{"items":{"array":{"items":"float32","dimensions":[{"length":3}]}},"dimensions":[{"length":2}]}}},{"name":"nestedSubarray","type":{"array":{"items":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}},"dimensions":[{"length":2}]}}}}},{"name":"dynamicWithFixedVectorSubarray","type":{"array":{"items":{"vector":{"items":"int32","length":3}}}}},{"name":"genericSubarray","type":{"name":"TestModel.Image","typeArguments":[{"array":{"items":"int32","dimensions":[{"length":3}]}}]}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 18:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_dynamic_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_dynamic_with_fixed_int_subarray(value)
        self._state = 2

    def write_dynamic_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_dynamic_with_fixed_float_subarray(value)
        self._state = 4

    def write_known_dim_count_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_known_dim_count_with_fixed_int_subarray(value)
        self._state = 6

    def write_known_dim_count_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_known_dim_count_with_fixed_float_subarray(value)
        self._state = 8

    def write_fixed_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        self._write_fixed_with_fixed_int_subarray(value)
        self._state = 10

    def write_fixed_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        """Ordinal 5"""

        if self._state != 10:
            self._raise_unexpected_state(10)

        self._write_fixed_with_fixed_float_subarray(value)
        self._state = 12

    def write_nested_subarray(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 6"""

        if self._state != 12:
            self._raise_unexpected_state(12)

        self._write_nested_subarray(value)
        self._state = 14

    def write_dynamic_with_fixed_vector_subarray(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 7"""

        if self._state != 14:
            self._raise_unexpected_state(14)

        self._write_dynamic_with_fixed_vector_subarray(value)
        self._state = 16

    def write_generic_subarray(self, value: Image[np.int32]) -> None:
        """Ordinal 8"""

        if self._state != 16:
            self._raise_unexpected_state(16)

        self._write_generic_subarray(value)
        self._state = 18

    @abc.abstractmethod
    def _write_dynamic_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_dynamic_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_known_dim_count_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_known_dim_count_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_fixed_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_nested_subarray(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_dynamic_with_fixed_vector_subarray(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_generic_subarray(self, value: Image[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_dynamic_with_fixed_int_subarray'
        if state == 2:
            return 'write_dynamic_with_fixed_float_subarray'
        if state == 4:
            return 'write_known_dim_count_with_fixed_int_subarray'
        if state == 6:
            return 'write_known_dim_count_with_fixed_float_subarray'
        if state == 8:
            return 'write_fixed_with_fixed_int_subarray'
        if state == 10:
            return 'write_fixed_with_fixed_float_subarray'
        if state == 12:
            return 'write_nested_subarray'
        if state == 14:
            return 'write_dynamic_with_fixed_vector_subarray'
        if state == 16:
            return 'write_generic_subarray'
        return "<unknown>"

class SubarraysReaderBase(abc.ABC):
    """Abstract reader for the Subarrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = SubarraysWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 18:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_dynamic_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_dynamic_with_fixed_int_subarray()
        self._state = 2
        return value

    def read_dynamic_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_dynamic_with_fixed_float_subarray()
        self._state = 4
        return value

    def read_known_dim_count_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_known_dim_count_with_fixed_int_subarray()
        self._state = 6
        return value

    def read_known_dim_count_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_known_dim_count_with_fixed_float_subarray()
        self._state = 8
        return value

    def read_fixed_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        value = self._read_fixed_with_fixed_int_subarray()
        self._state = 10
        return value

    def read_fixed_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        """Ordinal 5"""

        if self._state != 10:
            self._raise_unexpected_state(10)

        value = self._read_fixed_with_fixed_float_subarray()
        self._state = 12
        return value

    def read_nested_subarray(self) -> npt.NDArray[np.int32]:
        """Ordinal 6"""

        if self._state != 12:
            self._raise_unexpected_state(12)

        value = self._read_nested_subarray()
        self._state = 14
        return value

    def read_dynamic_with_fixed_vector_subarray(self) -> npt.NDArray[np.int32]:
        """Ordinal 7"""

        if self._state != 14:
            self._raise_unexpected_state(14)

        value = self._read_dynamic_with_fixed_vector_subarray()
        self._state = 16
        return value

    def read_generic_subarray(self) -> Image[np.int32]:
        """Ordinal 8"""

        if self._state != 16:
            self._raise_unexpected_state(16)

        value = self._read_generic_subarray()
        self._state = 18
        return value

    def copy_to(self, writer: SubarraysWriterBase) -> None:
        writer.write_dynamic_with_fixed_int_subarray(self.read_dynamic_with_fixed_int_subarray())
        writer.write_dynamic_with_fixed_float_subarray(self.read_dynamic_with_fixed_float_subarray())
        writer.write_known_dim_count_with_fixed_int_subarray(self.read_known_dim_count_with_fixed_int_subarray())
        writer.write_known_dim_count_with_fixed_float_subarray(self.read_known_dim_count_with_fixed_float_subarray())
        writer.write_fixed_with_fixed_int_subarray(self.read_fixed_with_fixed_int_subarray())
        writer.write_fixed_with_fixed_float_subarray(self.read_fixed_with_fixed_float_subarray())
        writer.write_nested_subarray(self.read_nested_subarray())
        writer.write_dynamic_with_fixed_vector_subarray(self.read_dynamic_with_fixed_vector_subarray())
        writer.write_generic_subarray(self.read_generic_subarray())

    @abc.abstractmethod
    def _read_dynamic_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_dynamic_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_known_dim_count_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_known_dim_count_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_fixed_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_nested_subarray(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_dynamic_with_fixed_vector_subarray(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_generic_subarray(self) -> Image[np.int32]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_dynamic_with_fixed_int_subarray'
        if state == 2:
            return 'read_dynamic_with_fixed_float_subarray'
        if state == 4:
            return 'read_known_dim_count_with_fixed_int_subarray'
        if state == 6:
            return 'read_known_dim_count_with_fixed_float_subarray'
        if state == 8:
            return 'read_fixed_with_fixed_int_subarray'
        if state == 10:
            return 'read_fixed_with_fixed_float_subarray'
        if state == 12:
            return 'read_nested_subarray'
        if state == 14:
            return 'read_dynamic_with_fixed_vector_subarray'
        if state == 16:
            return 'read_generic_subarray'
        return "<unknown>"

class SubarraysInRecordsWriterBase(abc.ABC):
    """Abstract writer for the SubarraysInRecords protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"SubarraysInRecords","sequence":[{"name":"withFixedSubarrays","type":{"array":{"items":"TestModel.RecordWithFixedCollections"}}},{"name":"withVlenSubarrays","type":{"array":{"items":"TestModel.RecordWithVlenCollections"}}}]},"types":[{"name":"RecordWithFixedCollections","fields":[{"name":"fixedVector","type":{"vector":{"items":"int32","length":3}}},{"name":"fixedArray","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}}]},{"name":"RecordWithVlenCollections","fields":[{"name":"vector","type":{"vector":{"items":"int32"}}},{"name":"array","type":{"array":{"items":"int32","dimensions":2}}}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_with_fixed_subarrays(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_with_fixed_subarrays(value)
        self._state = 2

    def write_with_vlen_subarrays(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_with_vlen_subarrays(value)
        self._state = 4

    @abc.abstractmethod
    def _write_with_fixed_subarrays(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_with_vlen_subarrays(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_with_fixed_subarrays'
        if state == 2:
            return 'write_with_vlen_subarrays'
        return "<unknown>"

class SubarraysInRecordsReaderBase(abc.ABC):
    """Abstract reader for the SubarraysInRecords protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = SubarraysInRecordsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_with_fixed_subarrays(self) -> npt.NDArray[np.void]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_with_fixed_subarrays()
        self._state = 2
        return value

    def read_with_vlen_subarrays(self) -> npt.NDArray[np.void]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_with_vlen_subarrays()
        self._state = 4
        return value

    def copy_to(self, writer: SubarraysInRecordsWriterBase) -> None:
        writer.write_with_fixed_subarrays(self.read_with_fixed_subarrays())
        writer.write_with_vlen_subarrays(self.read_with_vlen_subarrays())

    @abc.abstractmethod
    def _read_with_fixed_subarrays(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_with_vlen_subarrays(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_with_fixed_subarrays'
        if state == 2:
            return 'read_with_vlen_subarrays'
        return "<unknown>"

class NDArraysWriterBase(abc.ABC):
    """Abstract writer for the NDArrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"NDArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":2}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":2}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":2}}},{"name":"recordWithNDArrays","type":"TestModel.RecordWithNDArrays"},{"name":"namedArray","type":"TestModel.NamedNDArray"}]},"types":[{"name":"NamedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA"},{"name":"dimB"}]}}},{"name":"RecordWithNDArrays","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":2}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":2}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":2}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 10:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_ints(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_ints(value)
        self._state = 2

    def write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_simple_record_array(value)
        self._state = 4

    def write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_record_with_vlens_array(value)
        self._state = 6

    def write_record_with_nd_arrays(self, value: RecordWithNDArrays) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_record_with_nd_arrays(value)
        self._state = 8

    def write_named_array(self, value: NamedNDArray) -> None:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        self._write_named_array(value)
        self._state = 10

    @abc.abstractmethod
    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_nd_arrays(self, value: RecordWithNDArrays) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_named_array(self, value: NamedNDArray) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_ints'
        if state == 2:
            return 'write_simple_record_array'
        if state == 4:
            return 'write_record_with_vlens_array'
        if state == 6:
            return 'write_record_with_nd_arrays'
        if state == 8:
            return 'write_named_array'
        return "<unknown>"

class NDArraysReaderBase(abc.ABC):
    """Abstract reader for the NDArrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = NDArraysWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 10:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_ints(self) -> npt.NDArray[np.int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_ints()
        self._state = 2
        return value

    def read_simple_record_array(self) -> npt.NDArray[np.void]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_simple_record_array()
        self._state = 4
        return value

    def read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_record_with_vlens_array()
        self._state = 6
        return value

    def read_record_with_nd_arrays(self) -> RecordWithNDArrays:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_record_with_nd_arrays()
        self._state = 8
        return value

    def read_named_array(self) -> NamedNDArray:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        value = self._read_named_array()
        self._state = 10
        return value

    def copy_to(self, writer: NDArraysWriterBase) -> None:
        writer.write_ints(self.read_ints())
        writer.write_simple_record_array(self.read_simple_record_array())
        writer.write_record_with_vlens_array(self.read_record_with_vlens_array())
        writer.write_record_with_nd_arrays(self.read_record_with_nd_arrays())
        writer.write_named_array(self.read_named_array())

    @abc.abstractmethod
    def _read_ints(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_simple_record_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_nd_arrays(self) -> RecordWithNDArrays:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_named_array(self) -> NamedNDArray:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_ints'
        if state == 2:
            return 'read_simple_record_array'
        if state == 4:
            return 'read_record_with_vlens_array'
        if state == 6:
            return 'read_record_with_nd_arrays'
        if state == 8:
            return 'read_named_array'
        return "<unknown>"

class NDArraysSingleDimensionWriterBase(abc.ABC):
    """Abstract writer for the NDArraysSingleDimension protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"NDArraysSingleDimension","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":1}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":1}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":1}}},{"name":"recordWithNDArrays","type":"TestModel.RecordWithNDArraysSingleDimension"}]},"types":[{"name":"RecordWithNDArraysSingleDimension","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":1}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":1}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":1}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_ints(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_ints(value)
        self._state = 2

    def write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_simple_record_array(value)
        self._state = 4

    def write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_record_with_vlens_array(value)
        self._state = 6

    def write_record_with_nd_arrays(self, value: RecordWithNDArraysSingleDimension) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_record_with_nd_arrays(value)
        self._state = 8

    @abc.abstractmethod
    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_nd_arrays(self, value: RecordWithNDArraysSingleDimension) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_ints'
        if state == 2:
            return 'write_simple_record_array'
        if state == 4:
            return 'write_record_with_vlens_array'
        if state == 6:
            return 'write_record_with_nd_arrays'
        return "<unknown>"

class NDArraysSingleDimensionReaderBase(abc.ABC):
    """Abstract reader for the NDArraysSingleDimension protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = NDArraysSingleDimensionWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_ints(self) -> npt.NDArray[np.int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_ints()
        self._state = 2
        return value

    def read_simple_record_array(self) -> npt.NDArray[np.void]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_simple_record_array()
        self._state = 4
        return value

    def read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_record_with_vlens_array()
        self._state = 6
        return value

    def read_record_with_nd_arrays(self) -> RecordWithNDArraysSingleDimension:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_record_with_nd_arrays()
        self._state = 8
        return value

    def copy_to(self, writer: NDArraysSingleDimensionWriterBase) -> None:
        writer.write_ints(self.read_ints())
        writer.write_simple_record_array(self.read_simple_record_array())
        writer.write_record_with_vlens_array(self.read_record_with_vlens_array())
        writer.write_record_with_nd_arrays(self.read_record_with_nd_arrays())

    @abc.abstractmethod
    def _read_ints(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_simple_record_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_nd_arrays(self) -> RecordWithNDArraysSingleDimension:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_ints'
        if state == 2:
            return 'read_simple_record_array'
        if state == 4:
            return 'read_record_with_vlens_array'
        if state == 6:
            return 'read_record_with_nd_arrays'
        return "<unknown>"

class DynamicNDArraysWriterBase(abc.ABC):
    """Abstract writer for the DynamicNDArrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"DynamicNDArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32"}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord"}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens"}}},{"name":"recordWithDynamicNDArrays","type":"TestModel.RecordWithDynamicNDArrays"}]},"types":[{"name":"RecordWithDynamicNDArrays","fields":[{"name":"ints","type":{"array":{"items":"int32"}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord"}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens"}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_ints(self, value: npt.NDArray[np.int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_ints(value)
        self._state = 2

    def write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_simple_record_array(value)
        self._state = 4

    def write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_record_with_vlens_array(value)
        self._state = 6

    def write_record_with_dynamic_nd_arrays(self, value: RecordWithDynamicNDArrays) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_record_with_dynamic_nd_arrays(value)
        self._state = 8

    @abc.abstractmethod
    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_dynamic_nd_arrays(self, value: RecordWithDynamicNDArrays) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_ints'
        if state == 2:
            return 'write_simple_record_array'
        if state == 4:
            return 'write_record_with_vlens_array'
        if state == 6:
            return 'write_record_with_dynamic_nd_arrays'
        return "<unknown>"

class DynamicNDArraysReaderBase(abc.ABC):
    """Abstract reader for the DynamicNDArrays protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = DynamicNDArraysWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_ints(self) -> npt.NDArray[np.int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_ints()
        self._state = 2
        return value

    def read_simple_record_array(self) -> npt.NDArray[np.void]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_simple_record_array()
        self._state = 4
        return value

    def read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_record_with_vlens_array()
        self._state = 6
        return value

    def read_record_with_dynamic_nd_arrays(self) -> RecordWithDynamicNDArrays:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_record_with_dynamic_nd_arrays()
        self._state = 8
        return value

    def copy_to(self, writer: DynamicNDArraysWriterBase) -> None:
        writer.write_ints(self.read_ints())
        writer.write_simple_record_array(self.read_simple_record_array())
        writer.write_record_with_vlens_array(self.read_record_with_vlens_array())
        writer.write_record_with_dynamic_nd_arrays(self.read_record_with_dynamic_nd_arrays())

    @abc.abstractmethod
    def _read_ints(self) -> npt.NDArray[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_simple_record_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_dynamic_nd_arrays(self) -> RecordWithDynamicNDArrays:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_ints'
        if state == 2:
            return 'read_simple_record_array'
        if state == 4:
            return 'read_record_with_vlens_array'
        if state == 6:
            return 'read_record_with_dynamic_nd_arrays'
        return "<unknown>"

class MapsWriterBase(abc.ABC):
    """Abstract writer for the Maps protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Maps","sequence":[{"name":"stringToInt","type":{"map":{"keys":"string","values":"int32"}}},{"name":"intToString","type":{"map":{"keys":"int32","values":"string"}}},{"name":"stringToUnion","type":{"map":{"keys":"string","values":[{"tag":"string","type":"string"},{"tag":"int32","type":"int32"}]}}},{"name":"aliasedGeneric","type":{"name":"TestModel.AliasedMap","typeArguments":["string","int32"]}}]},"types":[{"name":"AliasedMap","typeParameters":["K","V"],"type":{"map":{"keys":"K","values":"V"}}}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_string_to_int(self, value: dict[str, yardl.Int32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_string_to_int(value)
        self._state = 2

    def write_int_to_string(self, value: dict[yardl.Int32, str]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_int_to_string(value)
        self._state = 4

    def write_string_to_union(self, value: dict[str, StringOrInt32]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_string_to_union(value)
        self._state = 6

    def write_aliased_generic(self, value: AliasedMap[str, yardl.Int32]) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_aliased_generic(value)
        self._state = 8

    @abc.abstractmethod
    def _write_string_to_int(self, value: dict[str, yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_to_string(self, value: dict[yardl.Int32, str]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_string_to_union(self, value: dict[str, StringOrInt32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_generic(self, value: AliasedMap[str, yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_string_to_int'
        if state == 2:
            return 'write_int_to_string'
        if state == 4:
            return 'write_string_to_union'
        if state == 6:
            return 'write_aliased_generic'
        return "<unknown>"

class MapsReaderBase(abc.ABC):
    """Abstract reader for the Maps protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = MapsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_string_to_int(self) -> dict[str, yardl.Int32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_string_to_int()
        self._state = 2
        return value

    def read_int_to_string(self) -> dict[yardl.Int32, str]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_int_to_string()
        self._state = 4
        return value

    def read_string_to_union(self) -> dict[str, StringOrInt32]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_string_to_union()
        self._state = 6
        return value

    def read_aliased_generic(self) -> AliasedMap[str, yardl.Int32]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_aliased_generic()
        self._state = 8
        return value

    def copy_to(self, writer: MapsWriterBase) -> None:
        writer.write_string_to_int(self.read_string_to_int())
        writer.write_int_to_string(self.read_int_to_string())
        writer.write_string_to_union(self.read_string_to_union())
        writer.write_aliased_generic(self.read_aliased_generic())

    @abc.abstractmethod
    def _read_string_to_int(self) -> dict[str, yardl.Int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_to_string(self) -> dict[yardl.Int32, str]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_string_to_union(self) -> dict[str, StringOrInt32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_generic(self) -> AliasedMap[str, yardl.Int32]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_string_to_int'
        if state == 2:
            return 'read_int_to_string'
        if state == 4:
            return 'read_string_to_union'
        if state == 6:
            return 'read_aliased_generic'
        return "<unknown>"

class UnionsWriterBase(abc.ABC):
    """Abstract writer for the Unions protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Unions","sequence":[{"name":"intOrSimpleRecord","type":[{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"intOrRecordWithVlens","type":[{"tag":"int32","type":"int32"},{"tag":"RecordWithVlens","type":"TestModel.RecordWithVlens"}]},{"name":"monosotateOrIntOrSimpleRecord","type":[null,{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"recordWithUnions","type":"TestModel.RecordWithUnions"}]},"types":[{"name":"RecordWithUnions","fields":[{"name":"nullOrIntOrString","type":[null,{"tag":"int32","type":"int32"},{"tag":"string","type":"string"}]},{"name":"dateOrDatetime","type":[{"tag":"time","type":"time"},{"tag":"datetime","type":"datetime"}]}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int_or_simple_record(self, value: Int32OrSimpleRecord) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_int_or_simple_record(value)
        self._state = 2

    def write_int_or_record_with_vlens(self, value: Int32OrRecordWithVlens) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_int_or_record_with_vlens(value)
        self._state = 4

    def write_monosotate_or_int_or_simple_record(self, value: typing.Optional[Int32OrSimpleRecord]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_monosotate_or_int_or_simple_record(value)
        self._state = 6

    def write_record_with_unions(self, value: RecordWithUnions) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_record_with_unions(value)
        self._state = 8

    @abc.abstractmethod
    def _write_int_or_simple_record(self, value: Int32OrSimpleRecord) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_or_record_with_vlens(self, value: Int32OrRecordWithVlens) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_monosotate_or_int_or_simple_record(self, value: typing.Optional[Int32OrSimpleRecord]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_record_with_unions(self, value: RecordWithUnions) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int_or_simple_record'
        if state == 2:
            return 'write_int_or_record_with_vlens'
        if state == 4:
            return 'write_monosotate_or_int_or_simple_record'
        if state == 6:
            return 'write_record_with_unions'
        return "<unknown>"

class UnionsReaderBase(abc.ABC):
    """Abstract reader for the Unions protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = UnionsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 8:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int_or_simple_record(self) -> Int32OrSimpleRecord:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int_or_simple_record()
        self._state = 2
        return value

    def read_int_or_record_with_vlens(self) -> Int32OrRecordWithVlens:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_int_or_record_with_vlens()
        self._state = 4
        return value

    def read_monosotate_or_int_or_simple_record(self) -> typing.Optional[Int32OrSimpleRecord]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_monosotate_or_int_or_simple_record()
        self._state = 6
        return value

    def read_record_with_unions(self) -> RecordWithUnions:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_record_with_unions()
        self._state = 8
        return value

    def copy_to(self, writer: UnionsWriterBase) -> None:
        writer.write_int_or_simple_record(self.read_int_or_simple_record())
        writer.write_int_or_record_with_vlens(self.read_int_or_record_with_vlens())
        writer.write_monosotate_or_int_or_simple_record(self.read_monosotate_or_int_or_simple_record())
        writer.write_record_with_unions(self.read_record_with_unions())

    @abc.abstractmethod
    def _read_int_or_simple_record(self) -> Int32OrSimpleRecord:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_or_record_with_vlens(self) -> Int32OrRecordWithVlens:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_monosotate_or_int_or_simple_record(self) -> typing.Optional[Int32OrSimpleRecord]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_record_with_unions(self) -> RecordWithUnions:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int_or_simple_record'
        if state == 2:
            return 'read_int_or_record_with_vlens'
        if state == 4:
            return 'read_monosotate_or_int_or_simple_record'
        if state == 6:
            return 'read_record_with_unions'
        return "<unknown>"

class StreamsOfUnionsWriterBase(abc.ABC):
    """Abstract writer for the StreamsOfUnions protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"StreamsOfUnions","sequence":[{"name":"intOrSimpleRecord","type":{"stream":{"items":[{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]}}},{"name":"nullableIntOrSimpleRecord","type":{"stream":{"items":[null,{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]}}}]},"types":[{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 3:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int_or_simple_record(self, value: collections.abc.Iterable[Int32OrSimpleRecord]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_int_or_simple_record(value)
        self._state = 1

    def write_nullable_int_or_simple_record(self, value: collections.abc.Iterable[typing.Optional[Int32OrSimpleRecord]]) -> None:
        """Ordinal 1"""

        if self._state == 1:
            self._end_stream()
            self._state = 2
        elif self._state & ~1 != 2:
            self._raise_unexpected_state(2)

        self._write_nullable_int_or_simple_record(value)
        self._state = 3

    @abc.abstractmethod
    def _write_int_or_simple_record(self, value: collections.abc.Iterable[Int32OrSimpleRecord]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_nullable_int_or_simple_record(self, value: collections.abc.Iterable[typing.Optional[Int32OrSimpleRecord]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int_or_simple_record'
        if state == 2:
            return 'write_nullable_int_or_simple_record'
        return "<unknown>"

class StreamsOfUnionsReaderBase(abc.ABC):
    """Abstract reader for the StreamsOfUnions protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = StreamsOfUnionsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int_or_simple_record(self) -> collections.abc.Iterable[Int32OrSimpleRecord]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int_or_simple_record()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def read_nullable_int_or_simple_record(self) -> collections.abc.Iterable[typing.Optional[Int32OrSimpleRecord]]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_nullable_int_or_simple_record()
        self._state = 3
        return self._wrap_iterable(value, 4)

    def copy_to(self, writer: StreamsOfUnionsWriterBase) -> None:
        writer.write_int_or_simple_record(self.read_int_or_simple_record())
        writer.write_nullable_int_or_simple_record(self.read_nullable_int_or_simple_record())

    @abc.abstractmethod
    def _read_int_or_simple_record(self) -> collections.abc.Iterable[Int32OrSimpleRecord]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_nullable_int_or_simple_record(self) -> collections.abc.Iterable[typing.Optional[Int32OrSimpleRecord]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int_or_simple_record'
        if state == 2:
            return 'read_nullable_int_or_simple_record'
        return "<unknown>"

class EnumsWriterBase(abc.ABC):
    """Abstract writer for the Enums protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Enums","sequence":[{"name":"single","type":"TestModel.Fruits"},{"name":"vec","type":{"vector":{"items":"TestModel.Fruits"}}},{"name":"size","type":"TestModel.SizeBasedEnum"}]},"types":[{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"SizeBasedEnum","base":"size","values":[{"symbol":"a","value":0},{"symbol":"b","value":1},{"symbol":"c","value":2}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 6:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_single(self, value: Fruits) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_single(value)
        self._state = 2

    def write_vec(self, value: list[Fruits]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_vec(value)
        self._state = 4

    def write_size(self, value: SizeBasedEnum) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_size(value)
        self._state = 6

    @abc.abstractmethod
    def _write_single(self, value: Fruits) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_vec(self, value: list[Fruits]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_size(self, value: SizeBasedEnum) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_single'
        if state == 2:
            return 'write_vec'
        if state == 4:
            return 'write_size'
        return "<unknown>"

class EnumsReaderBase(abc.ABC):
    """Abstract reader for the Enums protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = EnumsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 6:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_single(self) -> Fruits:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_single()
        self._state = 2
        return value

    def read_vec(self) -> list[Fruits]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_vec()
        self._state = 4
        return value

    def read_size(self) -> SizeBasedEnum:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_size()
        self._state = 6
        return value

    def copy_to(self, writer: EnumsWriterBase) -> None:
        writer.write_single(self.read_single())
        writer.write_vec(self.read_vec())
        writer.write_size(self.read_size())

    @abc.abstractmethod
    def _read_single(self) -> Fruits:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_vec(self) -> list[Fruits]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_size(self) -> SizeBasedEnum:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_single'
        if state == 2:
            return 'read_vec'
        if state == 4:
            return 'read_size'
        return "<unknown>"

class FlagsWriterBase(abc.ABC):
    """Abstract writer for the Flags protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Flags","sequence":[{"name":"days","type":{"stream":{"items":"TestModel.DaysOfWeek"}}},{"name":"formats","type":{"stream":{"items":"TestModel.TextFormat"}}}]},"types":[{"name":"DaysOfWeek","values":[{"symbol":"monday","value":1},{"symbol":"tuesday","value":2},{"symbol":"wednesday","value":4},{"symbol":"thursday","value":8},{"symbol":"friday","value":16},{"symbol":"saturday","value":32},{"symbol":"sunday","value":64}]},{"name":"TextFormat","base":"uint64","values":[{"symbol":"regular","value":0},{"symbol":"bold","value":1},{"symbol":"italic","value":2},{"symbol":"underline","value":4},{"symbol":"strikethrough","value":8}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 3:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_days(self, value: collections.abc.Iterable[DaysOfWeek]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_days(value)
        self._state = 1

    def write_formats(self, value: collections.abc.Iterable[TextFormat]) -> None:
        """Ordinal 1"""

        if self._state == 1:
            self._end_stream()
            self._state = 2
        elif self._state & ~1 != 2:
            self._raise_unexpected_state(2)

        self._write_formats(value)
        self._state = 3

    @abc.abstractmethod
    def _write_days(self, value: collections.abc.Iterable[DaysOfWeek]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_formats(self, value: collections.abc.Iterable[TextFormat]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_days'
        if state == 2:
            return 'write_formats'
        return "<unknown>"

class FlagsReaderBase(abc.ABC):
    """Abstract reader for the Flags protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = FlagsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_days(self) -> collections.abc.Iterable[DaysOfWeek]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_days()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def read_formats(self) -> collections.abc.Iterable[TextFormat]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_formats()
        self._state = 3
        return self._wrap_iterable(value, 4)

    def copy_to(self, writer: FlagsWriterBase) -> None:
        writer.write_days(self.read_days())
        writer.write_formats(self.read_formats())

    @abc.abstractmethod
    def _read_days(self) -> collections.abc.Iterable[DaysOfWeek]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_formats(self) -> collections.abc.Iterable[TextFormat]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_days'
        if state == 2:
            return 'read_formats'
        return "<unknown>"

class StateTestWriterBase(abc.ABC):
    """Abstract writer for the StateTest protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"StateTest","sequence":[{"name":"anInt","type":"int32"},{"name":"aStream","type":{"stream":{"items":"int32"}}},{"name":"anotherInt","type":"int32"}]},"types":null}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 6:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_an_int(self, value: yardl.Int32) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_an_int(value)
        self._state = 2

    def write_a_stream(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        """Ordinal 1"""

        if self._state & ~1 != 2:
            self._raise_unexpected_state(2)

        self._write_a_stream(value)
        self._state = 3

    def write_another_int(self, value: yardl.Int32) -> None:
        """Ordinal 2"""

        if self._state == 3:
            self._end_stream()
            self._state = 4
        elif self._state != 4:
            self._raise_unexpected_state(4)

        self._write_another_int(value)
        self._state = 6

    @abc.abstractmethod
    def _write_an_int(self, value: yardl.Int32) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_a_stream(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_another_int(self, value: yardl.Int32) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_an_int'
        if state == 2:
            return 'write_a_stream'
        if state == 4:
            return 'write_another_int'
        return "<unknown>"

class StateTestReaderBase(abc.ABC):
    """Abstract reader for the StateTest protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = StateTestWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 6:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_an_int(self) -> yardl.Int32:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_an_int()
        self._state = 2
        return value

    def read_a_stream(self) -> collections.abc.Iterable[yardl.Int32]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_a_stream()
        self._state = 3
        return self._wrap_iterable(value, 4)

    def read_another_int(self) -> yardl.Int32:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_another_int()
        self._state = 6
        return value

    def copy_to(self, writer: StateTestWriterBase) -> None:
        writer.write_an_int(self.read_an_int())
        writer.write_a_stream(self.read_a_stream())
        writer.write_another_int(self.read_another_int())

    @abc.abstractmethod
    def _read_an_int(self) -> yardl.Int32:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_a_stream(self) -> collections.abc.Iterable[yardl.Int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_another_int(self) -> yardl.Int32:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_an_int'
        if state == 2:
            return 'read_a_stream'
        if state == 4:
            return 'read_another_int'
        return "<unknown>"

class SimpleGenericsWriterBase(abc.ABC):
    """Abstract writer for the SimpleGenerics protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"SimpleGenerics","sequence":[{"name":"floatImage","type":{"name":"TestModel.Image","typeArguments":["float32"]}},{"name":"intImage","type":{"name":"TestModel.Image","typeArguments":["int32"]}},{"name":"intImageAlternateSyntax","type":{"name":"TestModel.Image","typeArguments":["int32"]}},{"name":"stringImage","type":{"name":"TestModel.Image","typeArguments":["string"]}},{"name":"intFloatTuple","type":{"name":"TestModel.MyTuple","typeArguments":["int32","float32"]}},{"name":"floatFloatTuple","type":{"name":"TestModel.MyTuple","typeArguments":["float32","float32"]}},{"name":"intFloatTupleAlternateSyntax","type":{"name":"TestModel.MyTuple","typeArguments":["int32","float32"]}},{"name":"intStringTuple","type":{"name":"TestModel.MyTuple","typeArguments":["int32","string"]}},{"name":"streamOfTypeVariants","type":{"stream":{"items":[{"tag":"imageFloat","explicitTag":true,"type":{"name":"TestModel.Image","typeArguments":["float32"]}},{"tag":"imageDouble","explicitTag":true,"type":{"name":"TestModel.Image","typeArguments":["float64"]}}]}}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 17:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 18:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_float_image(self, value: Image[np.float32]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_float_image(value)
        self._state = 2

    def write_int_image(self, value: Image[np.int32]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_int_image(value)
        self._state = 4

    def write_int_image_alternate_syntax(self, value: Image[np.int32]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_int_image_alternate_syntax(value)
        self._state = 6

    def write_string_image(self, value: Image[np.object_]) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_string_image(value)
        self._state = 8

    def write_int_float_tuple(self, value: MyTuple[yardl.Int32, yardl.Float32]) -> None:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        self._write_int_float_tuple(value)
        self._state = 10

    def write_float_float_tuple(self, value: MyTuple[yardl.Float32, yardl.Float32]) -> None:
        """Ordinal 5"""

        if self._state != 10:
            self._raise_unexpected_state(10)

        self._write_float_float_tuple(value)
        self._state = 12

    def write_int_float_tuple_alternate_syntax(self, value: MyTuple[yardl.Int32, yardl.Float32]) -> None:
        """Ordinal 6"""

        if self._state != 12:
            self._raise_unexpected_state(12)

        self._write_int_float_tuple_alternate_syntax(value)
        self._state = 14

    def write_int_string_tuple(self, value: MyTuple[yardl.Int32, str]) -> None:
        """Ordinal 7"""

        if self._state != 14:
            self._raise_unexpected_state(14)

        self._write_int_string_tuple(value)
        self._state = 16

    def write_stream_of_type_variants(self, value: collections.abc.Iterable[ImageFloatOrImageDouble]) -> None:
        """Ordinal 8"""

        if self._state & ~1 != 16:
            self._raise_unexpected_state(16)

        self._write_stream_of_type_variants(value)
        self._state = 17

    @abc.abstractmethod
    def _write_float_image(self, value: Image[np.float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_image(self, value: Image[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_image_alternate_syntax(self, value: Image[np.int32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_string_image(self, value: Image[np.object_]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_float_tuple(self, value: MyTuple[yardl.Int32, yardl.Float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_float_float_tuple(self, value: MyTuple[yardl.Float32, yardl.Float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_float_tuple_alternate_syntax(self, value: MyTuple[yardl.Int32, yardl.Float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_int_string_tuple(self, value: MyTuple[yardl.Int32, str]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_stream_of_type_variants(self, value: collections.abc.Iterable[ImageFloatOrImageDouble]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_float_image'
        if state == 2:
            return 'write_int_image'
        if state == 4:
            return 'write_int_image_alternate_syntax'
        if state == 6:
            return 'write_string_image'
        if state == 8:
            return 'write_int_float_tuple'
        if state == 10:
            return 'write_float_float_tuple'
        if state == 12:
            return 'write_int_float_tuple_alternate_syntax'
        if state == 14:
            return 'write_int_string_tuple'
        if state == 16:
            return 'write_stream_of_type_variants'
        return "<unknown>"

class SimpleGenericsReaderBase(abc.ABC):
    """Abstract reader for the SimpleGenerics protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = SimpleGenericsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 18:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_float_image(self) -> Image[np.float32]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_float_image()
        self._state = 2
        return value

    def read_int_image(self) -> Image[np.int32]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_int_image()
        self._state = 4
        return value

    def read_int_image_alternate_syntax(self) -> Image[np.int32]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_int_image_alternate_syntax()
        self._state = 6
        return value

    def read_string_image(self) -> Image[np.object_]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_string_image()
        self._state = 8
        return value

    def read_int_float_tuple(self) -> MyTuple[yardl.Int32, yardl.Float32]:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        value = self._read_int_float_tuple()
        self._state = 10
        return value

    def read_float_float_tuple(self) -> MyTuple[yardl.Float32, yardl.Float32]:
        """Ordinal 5"""

        if self._state != 10:
            self._raise_unexpected_state(10)

        value = self._read_float_float_tuple()
        self._state = 12
        return value

    def read_int_float_tuple_alternate_syntax(self) -> MyTuple[yardl.Int32, yardl.Float32]:
        """Ordinal 6"""

        if self._state != 12:
            self._raise_unexpected_state(12)

        value = self._read_int_float_tuple_alternate_syntax()
        self._state = 14
        return value

    def read_int_string_tuple(self) -> MyTuple[yardl.Int32, str]:
        """Ordinal 7"""

        if self._state != 14:
            self._raise_unexpected_state(14)

        value = self._read_int_string_tuple()
        self._state = 16
        return value

    def read_stream_of_type_variants(self) -> collections.abc.Iterable[ImageFloatOrImageDouble]:
        """Ordinal 8"""

        if self._state != 16:
            self._raise_unexpected_state(16)

        value = self._read_stream_of_type_variants()
        self._state = 17
        return self._wrap_iterable(value, 18)

    def copy_to(self, writer: SimpleGenericsWriterBase) -> None:
        writer.write_float_image(self.read_float_image())
        writer.write_int_image(self.read_int_image())
        writer.write_int_image_alternate_syntax(self.read_int_image_alternate_syntax())
        writer.write_string_image(self.read_string_image())
        writer.write_int_float_tuple(self.read_int_float_tuple())
        writer.write_float_float_tuple(self.read_float_float_tuple())
        writer.write_int_float_tuple_alternate_syntax(self.read_int_float_tuple_alternate_syntax())
        writer.write_int_string_tuple(self.read_int_string_tuple())
        writer.write_stream_of_type_variants(self.read_stream_of_type_variants())

    @abc.abstractmethod
    def _read_float_image(self) -> Image[np.float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_image(self) -> Image[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_image_alternate_syntax(self) -> Image[np.int32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_string_image(self) -> Image[np.object_]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_float_tuple(self) -> MyTuple[yardl.Int32, yardl.Float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_float_float_tuple(self) -> MyTuple[yardl.Float32, yardl.Float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_float_tuple_alternate_syntax(self) -> MyTuple[yardl.Int32, yardl.Float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_int_string_tuple(self) -> MyTuple[yardl.Int32, str]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_stream_of_type_variants(self) -> collections.abc.Iterable[ImageFloatOrImageDouble]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_float_image'
        if state == 2:
            return 'read_int_image'
        if state == 4:
            return 'read_int_image_alternate_syntax'
        if state == 6:
            return 'read_string_image'
        if state == 8:
            return 'read_int_float_tuple'
        if state == 10:
            return 'read_float_float_tuple'
        if state == 12:
            return 'read_int_float_tuple_alternate_syntax'
        if state == 14:
            return 'read_int_string_tuple'
        if state == 16:
            return 'read_stream_of_type_variants'
        return "<unknown>"

class AdvancedGenericsWriterBase(abc.ABC):
    """Abstract writer for the AdvancedGenerics protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"AdvancedGenerics","sequence":[{"name":"floatImageImage","type":{"name":"TestModel.Image","typeArguments":[{"name":"TestModel.Image","typeArguments":["float32"]}]}},{"name":"genericRecord1","type":{"name":"TestModel.GenericRecord","typeArguments":["int32","string"]}},{"name":"tupleOfOptionals","type":{"name":"TestModel.MyTuple","typeArguments":[[null,"int32"],[null,"string"]]}},{"name":"tupleOfOptionalsAlternateSyntax","type":{"name":"TestModel.MyTuple","typeArguments":[[null,"int32"],[null,"string"]]}},{"name":"tupleOfVectors","type":{"name":"TestModel.MyTuple","typeArguments":[{"vector":{"items":"int32"}},{"vector":{"items":"float32"}}]}}]},"types":[{"name":"GenericRecord","typeParameters":["T1","T2"],"fields":[{"name":"scalar1","type":"T1"},{"name":"scalar2","type":"T2"},{"name":"vector1","type":{"vector":{"items":"T1"}}},{"name":"image2","type":{"name":"TestModel.Image","typeArguments":["T2"]}}]},{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 10:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_float_image_image(self, value: Image[np.object_]) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_float_image_image(value)
        self._state = 2

    def write_generic_record_1(self, value: GenericRecord[yardl.Int32, str, np.object_]) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_generic_record_1(value)
        self._state = 4

    def write_tuple_of_optionals(self, value: MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_tuple_of_optionals(value)
        self._state = 6

    def write_tuple_of_optionals_alternate_syntax(self, value: MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_tuple_of_optionals_alternate_syntax(value)
        self._state = 8

    def write_tuple_of_vectors(self, value: MyTuple[list[yardl.Int32], list[yardl.Float32]]) -> None:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        self._write_tuple_of_vectors(value)
        self._state = 10

    @abc.abstractmethod
    def _write_float_image_image(self, value: Image[np.object_]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_generic_record_1(self, value: GenericRecord[yardl.Int32, str, np.object_]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_tuple_of_optionals(self, value: MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_tuple_of_optionals_alternate_syntax(self, value: MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_tuple_of_vectors(self, value: MyTuple[list[yardl.Int32], list[yardl.Float32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_float_image_image'
        if state == 2:
            return 'write_generic_record_1'
        if state == 4:
            return 'write_tuple_of_optionals'
        if state == 6:
            return 'write_tuple_of_optionals_alternate_syntax'
        if state == 8:
            return 'write_tuple_of_vectors'
        return "<unknown>"

class AdvancedGenericsReaderBase(abc.ABC):
    """Abstract reader for the AdvancedGenerics protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = AdvancedGenericsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 10:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_float_image_image(self) -> Image[np.object_]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_float_image_image()
        self._state = 2
        return value

    def read_generic_record_1(self) -> GenericRecord[yardl.Int32, str, np.object_]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_generic_record_1()
        self._state = 4
        return value

    def read_tuple_of_optionals(self) -> MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_tuple_of_optionals()
        self._state = 6
        return value

    def read_tuple_of_optionals_alternate_syntax(self) -> MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_tuple_of_optionals_alternate_syntax()
        self._state = 8
        return value

    def read_tuple_of_vectors(self) -> MyTuple[list[yardl.Int32], list[yardl.Float32]]:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        value = self._read_tuple_of_vectors()
        self._state = 10
        return value

    def copy_to(self, writer: AdvancedGenericsWriterBase) -> None:
        writer.write_float_image_image(self.read_float_image_image())
        writer.write_generic_record_1(self.read_generic_record_1())
        writer.write_tuple_of_optionals(self.read_tuple_of_optionals())
        writer.write_tuple_of_optionals_alternate_syntax(self.read_tuple_of_optionals_alternate_syntax())
        writer.write_tuple_of_vectors(self.read_tuple_of_vectors())

    @abc.abstractmethod
    def _read_float_image_image(self) -> Image[np.object_]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_generic_record_1(self) -> GenericRecord[yardl.Int32, str, np.object_]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_tuple_of_optionals(self) -> MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_tuple_of_optionals_alternate_syntax(self) -> MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_tuple_of_vectors(self) -> MyTuple[list[yardl.Int32], list[yardl.Float32]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_float_image_image'
        if state == 2:
            return 'read_generic_record_1'
        if state == 4:
            return 'read_tuple_of_optionals'
        if state == 6:
            return 'read_tuple_of_optionals_alternate_syntax'
        if state == 8:
            return 'read_tuple_of_vectors'
        return "<unknown>"

class AliasesWriterBase(abc.ABC):
    """Abstract writer for the Aliases protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"Aliases","sequence":[{"name":"aliasedString","type":"TestModel.AliasedString"},{"name":"aliasedEnum","type":"TestModel.AliasedEnum"},{"name":"aliasedOpenGeneric","type":{"name":"TestModel.AliasedOpenGeneric","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"aliasedClosedGeneric","type":"TestModel.AliasedClosedGeneric"},{"name":"aliasedOptional","type":"TestModel.AliasedOptional"},{"name":"aliasedGenericOptional","type":{"name":"TestModel.AliasedGenericOptional","typeArguments":["float32"]}},{"name":"aliasedGenericUnion2","type":{"name":"TestModel.AliasedGenericUnion2","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"aliasedGenericVector","type":{"name":"TestModel.AliasedGenericVector","typeArguments":["float32"]}},{"name":"aliasedGenericFixedVector","type":{"name":"TestModel.AliasedGenericFixedVector","typeArguments":["float32"]}},{"name":"streamOfAliasedGenericUnion2","type":{"stream":{"items":{"name":"TestModel.AliasedGenericUnion2","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}}}}]},"types":[{"name":"AliasedClosedGeneric","type":{"name":"TestModel.MyTuple","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"AliasedEnum","type":"TestModel.Fruits"},{"name":"AliasedGenericFixedVector","typeParameters":["T"],"type":{"vector":{"items":"T","length":3}}},{"name":"AliasedGenericOptional","typeParameters":["T"],"type":[null,"T"]},{"name":"AliasedGenericUnion2","typeParameters":["T1","T2"],"type":[{"tag":"T1","type":"T1"},{"tag":"T2","type":"T2"}]},{"name":"AliasedGenericVector","typeParameters":["T"],"type":{"vector":{"items":"T"}}},{"name":"AliasedOpenGeneric","typeParameters":["T1","T2"],"type":{"name":"TestModel.MyTuple","typeArguments":["T1","T2"]}},{"name":"AliasedOptional","type":[null,"int32"]},{"name":"AliasedString","type":"string"},{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 19:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 20:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_aliased_string(self, value: AliasedString) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_aliased_string(value)
        self._state = 2

    def write_aliased_enum(self, value: AliasedEnum) -> None:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        self._write_aliased_enum(value)
        self._state = 4

    def write_aliased_open_generic(self, value: AliasedOpenGeneric[AliasedString, AliasedEnum]) -> None:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        self._write_aliased_open_generic(value)
        self._state = 6

    def write_aliased_closed_generic(self, value: AliasedClosedGeneric) -> None:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        self._write_aliased_closed_generic(value)
        self._state = 8

    def write_aliased_optional(self, value: typing.Optional[AliasedOptional]) -> None:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        self._write_aliased_optional(value)
        self._state = 10

    def write_aliased_generic_optional(self, value: typing.Optional[AliasedGenericOptional[yardl.Float32]]) -> None:
        """Ordinal 5"""

        if self._state != 10:
            self._raise_unexpected_state(10)

        self._write_aliased_generic_optional(value)
        self._state = 12

    def write_aliased_generic_union_2(self, value: AliasedGenericUnion2[AliasedString, AliasedEnum]) -> None:
        """Ordinal 6"""

        if self._state != 12:
            self._raise_unexpected_state(12)

        self._write_aliased_generic_union_2(value)
        self._state = 14

    def write_aliased_generic_vector(self, value: AliasedGenericVector[yardl.Float32]) -> None:
        """Ordinal 7"""

        if self._state != 14:
            self._raise_unexpected_state(14)

        self._write_aliased_generic_vector(value)
        self._state = 16

    def write_aliased_generic_fixed_vector(self, value: AliasedGenericFixedVector[yardl.Float32]) -> None:
        """Ordinal 8"""

        if self._state != 16:
            self._raise_unexpected_state(16)

        self._write_aliased_generic_fixed_vector(value)
        self._state = 18

    def write_stream_of_aliased_generic_union_2(self, value: collections.abc.Iterable[AliasedGenericUnion2[AliasedString, AliasedEnum]]) -> None:
        """Ordinal 9"""

        if self._state & ~1 != 18:
            self._raise_unexpected_state(18)

        self._write_stream_of_aliased_generic_union_2(value)
        self._state = 19

    @abc.abstractmethod
    def _write_aliased_string(self, value: AliasedString) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_enum(self, value: AliasedEnum) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_open_generic(self, value: AliasedOpenGeneric[AliasedString, AliasedEnum]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_closed_generic(self, value: AliasedClosedGeneric) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_optional(self, value: typing.Optional[AliasedOptional]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_generic_optional(self, value: typing.Optional[AliasedGenericOptional[yardl.Float32]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_generic_union_2(self, value: AliasedGenericUnion2[AliasedString, AliasedEnum]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_generic_vector(self, value: AliasedGenericVector[yardl.Float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_aliased_generic_fixed_vector(self, value: AliasedGenericFixedVector[yardl.Float32]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_stream_of_aliased_generic_union_2(self, value: collections.abc.Iterable[AliasedGenericUnion2[AliasedString, AliasedEnum]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_aliased_string'
        if state == 2:
            return 'write_aliased_enum'
        if state == 4:
            return 'write_aliased_open_generic'
        if state == 6:
            return 'write_aliased_closed_generic'
        if state == 8:
            return 'write_aliased_optional'
        if state == 10:
            return 'write_aliased_generic_optional'
        if state == 12:
            return 'write_aliased_generic_union_2'
        if state == 14:
            return 'write_aliased_generic_vector'
        if state == 16:
            return 'write_aliased_generic_fixed_vector'
        if state == 18:
            return 'write_stream_of_aliased_generic_union_2'
        return "<unknown>"

class AliasesReaderBase(abc.ABC):
    """Abstract reader for the Aliases protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = AliasesWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 20:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_aliased_string(self) -> AliasedString:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_aliased_string()
        self._state = 2
        return value

    def read_aliased_enum(self) -> AliasedEnum:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_aliased_enum()
        self._state = 4
        return value

    def read_aliased_open_generic(self) -> AliasedOpenGeneric[AliasedString, AliasedEnum]:
        """Ordinal 2"""

        if self._state != 4:
            self._raise_unexpected_state(4)

        value = self._read_aliased_open_generic()
        self._state = 6
        return value

    def read_aliased_closed_generic(self) -> AliasedClosedGeneric:
        """Ordinal 3"""

        if self._state != 6:
            self._raise_unexpected_state(6)

        value = self._read_aliased_closed_generic()
        self._state = 8
        return value

    def read_aliased_optional(self) -> typing.Optional[AliasedOptional]:
        """Ordinal 4"""

        if self._state != 8:
            self._raise_unexpected_state(8)

        value = self._read_aliased_optional()
        self._state = 10
        return value

    def read_aliased_generic_optional(self) -> typing.Optional[AliasedGenericOptional[yardl.Float32]]:
        """Ordinal 5"""

        if self._state != 10:
            self._raise_unexpected_state(10)

        value = self._read_aliased_generic_optional()
        self._state = 12
        return value

    def read_aliased_generic_union_2(self) -> AliasedGenericUnion2[AliasedString, AliasedEnum]:
        """Ordinal 6"""

        if self._state != 12:
            self._raise_unexpected_state(12)

        value = self._read_aliased_generic_union_2()
        self._state = 14
        return value

    def read_aliased_generic_vector(self) -> AliasedGenericVector[yardl.Float32]:
        """Ordinal 7"""

        if self._state != 14:
            self._raise_unexpected_state(14)

        value = self._read_aliased_generic_vector()
        self._state = 16
        return value

    def read_aliased_generic_fixed_vector(self) -> AliasedGenericFixedVector[yardl.Float32]:
        """Ordinal 8"""

        if self._state != 16:
            self._raise_unexpected_state(16)

        value = self._read_aliased_generic_fixed_vector()
        self._state = 18
        return value

    def read_stream_of_aliased_generic_union_2(self) -> collections.abc.Iterable[AliasedGenericUnion2[AliasedString, AliasedEnum]]:
        """Ordinal 9"""

        if self._state != 18:
            self._raise_unexpected_state(18)

        value = self._read_stream_of_aliased_generic_union_2()
        self._state = 19
        return self._wrap_iterable(value, 20)

    def copy_to(self, writer: AliasesWriterBase) -> None:
        writer.write_aliased_string(self.read_aliased_string())
        writer.write_aliased_enum(self.read_aliased_enum())
        writer.write_aliased_open_generic(self.read_aliased_open_generic())
        writer.write_aliased_closed_generic(self.read_aliased_closed_generic())
        writer.write_aliased_optional(self.read_aliased_optional())
        writer.write_aliased_generic_optional(self.read_aliased_generic_optional())
        writer.write_aliased_generic_union_2(self.read_aliased_generic_union_2())
        writer.write_aliased_generic_vector(self.read_aliased_generic_vector())
        writer.write_aliased_generic_fixed_vector(self.read_aliased_generic_fixed_vector())
        writer.write_stream_of_aliased_generic_union_2(self.read_stream_of_aliased_generic_union_2())

    @abc.abstractmethod
    def _read_aliased_string(self) -> AliasedString:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_enum(self) -> AliasedEnum:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_open_generic(self) -> AliasedOpenGeneric[AliasedString, AliasedEnum]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_closed_generic(self) -> AliasedClosedGeneric:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_optional(self) -> typing.Optional[AliasedOptional]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_generic_optional(self) -> typing.Optional[AliasedGenericOptional[yardl.Float32]]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_generic_union_2(self) -> AliasedGenericUnion2[AliasedString, AliasedEnum]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_generic_vector(self) -> AliasedGenericVector[yardl.Float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_aliased_generic_fixed_vector(self) -> AliasedGenericFixedVector[yardl.Float32]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_stream_of_aliased_generic_union_2(self) -> collections.abc.Iterable[AliasedGenericUnion2[AliasedString, AliasedEnum]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_aliased_string'
        if state == 2:
            return 'read_aliased_enum'
        if state == 4:
            return 'read_aliased_open_generic'
        if state == 6:
            return 'read_aliased_closed_generic'
        if state == 8:
            return 'read_aliased_optional'
        if state == 10:
            return 'read_aliased_generic_optional'
        if state == 12:
            return 'read_aliased_generic_union_2'
        if state == 14:
            return 'read_aliased_generic_vector'
        if state == 16:
            return 'read_aliased_generic_fixed_vector'
        if state == 18:
            return 'read_stream_of_aliased_generic_union_2'
        return "<unknown>"

class StreamsOfAliasedUnionsWriterBase(abc.ABC):
    """Abstract writer for the StreamsOfAliasedUnions protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"StreamsOfAliasedUnions","sequence":[{"name":"intOrSimpleRecord","type":{"stream":{"items":"TestModel.AliasedIntOrSimpleRecord"}}},{"name":"nullableIntOrSimpleRecord","type":{"stream":{"items":"TestModel.AliasedNullableIntSimpleRecord"}}}]},"types":[{"name":"AliasedIntOrSimpleRecord","type":[{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"AliasedNullableIntSimpleRecord","type":[null,{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        if exc is None and self._state == 3:
            try:
                self._end_stream()
                return
            finally:
                self.close()
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int_or_simple_record(self, value: collections.abc.Iterable[AliasedIntOrSimpleRecord]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_int_or_simple_record(value)
        self._state = 1

    def write_nullable_int_or_simple_record(self, value: collections.abc.Iterable[typing.Optional[AliasedNullableIntSimpleRecord]]) -> None:
        """Ordinal 1"""

        if self._state == 1:
            self._end_stream()
            self._state = 2
        elif self._state & ~1 != 2:
            self._raise_unexpected_state(2)

        self._write_nullable_int_or_simple_record(value)
        self._state = 3

    @abc.abstractmethod
    def _write_int_or_simple_record(self, value: collections.abc.Iterable[AliasedIntOrSimpleRecord]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_nullable_int_or_simple_record(self, value: collections.abc.Iterable[typing.Optional[AliasedNullableIntSimpleRecord]]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int_or_simple_record'
        if state == 2:
            return 'write_nullable_int_or_simple_record'
        return "<unknown>"

class StreamsOfAliasedUnionsReaderBase(abc.ABC):
    """Abstract reader for the StreamsOfAliasedUnions protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = StreamsOfAliasedUnionsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int_or_simple_record(self) -> collections.abc.Iterable[AliasedIntOrSimpleRecord]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int_or_simple_record()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def read_nullable_int_or_simple_record(self) -> collections.abc.Iterable[typing.Optional[AliasedNullableIntSimpleRecord]]:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_nullable_int_or_simple_record()
        self._state = 3
        return self._wrap_iterable(value, 4)

    def copy_to(self, writer: StreamsOfAliasedUnionsWriterBase) -> None:
        writer.write_int_or_simple_record(self.read_int_or_simple_record())
        writer.write_nullable_int_or_simple_record(self.read_nullable_int_or_simple_record())

    @abc.abstractmethod
    def _read_int_or_simple_record(self) -> collections.abc.Iterable[AliasedIntOrSimpleRecord]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_nullable_int_or_simple_record(self) -> collections.abc.Iterable[typing.Optional[AliasedNullableIntSimpleRecord]]:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int_or_simple_record'
        if state == 2:
            return 'read_nullable_int_or_simple_record'
        return "<unknown>"

class ProtocolWithComputedFieldsWriterBase(abc.ABC):
    """Abstract writer for the ProtocolWithComputedFields protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"ProtocolWithComputedFields","sequence":[{"name":"recordWithComputedFields","type":"TestModel.RecordWithComputedFields"}]},"types":[{"name":"GenericRecordWithComputedFields","typeParameters":["T0","T1"],"fields":[{"name":"f1","type":[{"tag":"T0","type":"T0"},{"tag":"T1","type":"T1"}]}]},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]},{"name":"NamedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA"},{"name":"dimB"}]}}},{"name":"RecordWithComputedFields","fields":[{"name":"arrayField","type":{"array":{"items":"int32","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"arrayFieldMapDimensions","type":{"array":{"items":"int32","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"dynamicArrayField","type":{"array":{"items":"int32"}}},{"name":"fixedArrayField","type":{"array":{"items":"int32","dimensions":[{"name":"x","length":3},{"name":"y","length":4}]}}},{"name":"intField","type":"int32"},{"name":"stringField","type":"string"},{"name":"tupleField","type":{"name":"TestModel.MyTuple","typeArguments":["int32","int32"]}},{"name":"vectorField","type":{"vector":{"items":"int32"}}},{"name":"vectorOfVectorsField","type":{"vector":{"items":{"vector":{"items":"int32"}}}}},{"name":"fixedVectorField","type":{"vector":{"items":"int32","length":3}}},{"name":"optionalNamedArray","type":[null,"TestModel.NamedNDArray"]},{"name":"intFloatUnion","type":[{"tag":"int32","type":"int32"},{"tag":"float32","type":"float32"}]},{"name":"nullableIntFloatUnion","type":[null,{"tag":"int32","type":"int32"},{"tag":"float32","type":"float32"}]},{"name":"unionWithNestedGenericUnion","type":[{"tag":"int","explicitTag":true,"type":"int32"},{"tag":"genericRecordWithComputedFields","explicitTag":true,"type":{"name":"TestModel.GenericRecordWithComputedFields","typeArguments":["string","float32"]}}]},{"name":"mapField","type":{"map":{"keys":"string","values":"string"}}}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_record_with_computed_fields(self, value: RecordWithComputedFields) -> None:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        self._write_record_with_computed_fields(value)
        self._state = 2

    @abc.abstractmethod
    def _write_record_with_computed_fields(self, value: RecordWithComputedFields) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_record_with_computed_fields'
        return "<unknown>"

class ProtocolWithComputedFieldsReaderBase(abc.ABC):
    """Abstract reader for the ProtocolWithComputedFields protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = ProtocolWithComputedFieldsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 2:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_record_with_computed_fields(self) -> RecordWithComputedFields:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_record_with_computed_fields()
        self._state = 2
        return value

    def copy_to(self, writer: ProtocolWithComputedFieldsWriterBase) -> None:
        writer.write_record_with_computed_fields(self.read_record_with_computed_fields())

    @abc.abstractmethod
    def _read_record_with_computed_fields(self) -> RecordWithComputedFields:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_record_with_computed_fields'
        return "<unknown>"

class ProtocolWithKeywordStepsWriterBase(abc.ABC):
    """Abstract writer for the ProtocolWithKeywordSteps protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = r"""{"protocol":{"name":"ProtocolWithKeywordSteps","sequence":[{"name":"int","type":{"stream":{"items":"TestModel.RecordWithKeywordFields"}}},{"name":"float","type":"TestModel.EnumWithKeywordSymbols"}]},"types":[{"name":"ArrayWithKeywordDimensionNames","type":{"array":{"items":"int32","dimensions":[{"name":"while"},{"name":"do"}]}}},{"name":"EnumWithKeywordSymbols","values":[{"symbol":"try","value":2},{"symbol":"catch","value":1}]},{"name":"RecordWithKeywordFields","fields":[{"name":"int","type":"string"},{"name":"sizeof","type":"TestModel.ArrayWithKeywordDimensionNames"},{"name":"if","type":"TestModel.EnumWithKeywordSymbols"}]}]}"""

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            expected_method = self._state_to_method_name((self._state + 1) & ~1)
            raise ProtocolError(f"Protocol writer closed before all steps were called. Expected to call to '{expected_method}'.")

    def write_int(self, value: collections.abc.Iterable[RecordWithKeywordFields]) -> None:
        """Ordinal 0"""

        if self._state & ~1 != 0:
            self._raise_unexpected_state(0)

        self._write_int(value)
        self._state = 1

    def write_float(self, value: EnumWithKeywordSymbols) -> None:
        """Ordinal 1"""

        if self._state == 1:
            self._end_stream()
            self._state = 2
        elif self._state != 2:
            self._raise_unexpected_state(2)

        self._write_float(value)
        self._state = 4

    @abc.abstractmethod
    def _write_int(self, value: collections.abc.Iterable[RecordWithKeywordFields]) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _write_float(self, value: EnumWithKeywordSymbols) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self) -> None:
        pass

    @abc.abstractmethod
    def _end_stream(self) -> None:
        pass

    def _raise_unexpected_state(self, actual: int) -> None:
        expected_method = self._state_to_method_name(self._state)
        actual_method = self._state_to_method_name(actual)
        raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")

    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'write_int'
        if state == 2:
            return 'write_float'
        return "<unknown>"

class ProtocolWithKeywordStepsReaderBase(abc.ABC):
    """Abstract reader for the ProtocolWithKeywordSteps protocol."""


    def __init__(self) -> None:
        self._state = 0

    schema = ProtocolWithKeywordStepsWriterBase.schema

    def __enter__(self):
        return self

    def __exit__(self, exc_type: typing.Optional[type[BaseException]], exc: typing.Optional[BaseException], traceback: object) -> None:
        self.close()
        if exc is None and self._state != 4:
            if self._state % 2 == 1:
                previous_method = self._state_to_method_name(self._state - 1)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. The iterable returned by '{previous_method}' was not fully consumed.")
            else:
                expected_method = self._state_to_method_name(self._state)
                raise ProtocolError(f"Protocol reader closed before all data was consumed. Expected call to '{expected_method}'.")
            	

    @abc.abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read_int(self) -> collections.abc.Iterable[RecordWithKeywordFields]:
        """Ordinal 0"""

        if self._state != 0:
            self._raise_unexpected_state(0)

        value = self._read_int()
        self._state = 1
        return self._wrap_iterable(value, 2)

    def read_float(self) -> EnumWithKeywordSymbols:
        """Ordinal 1"""

        if self._state != 2:
            self._raise_unexpected_state(2)

        value = self._read_float()
        self._state = 4
        return value

    def copy_to(self, writer: ProtocolWithKeywordStepsWriterBase) -> None:
        writer.write_int(self.read_int())
        writer.write_float(self.read_float())

    @abc.abstractmethod
    def _read_int(self) -> collections.abc.Iterable[RecordWithKeywordFields]:
        raise NotImplementedError()

    @abc.abstractmethod
    def _read_float(self) -> EnumWithKeywordSymbols:
        raise NotImplementedError()

    T = typing.TypeVar('T')
    def _wrap_iterable(self, iterable: collections.abc.Iterable[T], final_state: int) -> collections.abc.Iterable[T]:
        yield from iterable
        self._state = final_state

    def _raise_unexpected_state(self, actual: int) -> None:
        actual_method = self._state_to_method_name(actual)
        if self._state % 2 == 1:
            previous_method = self._state_to_method_name(self._state - 1)
            raise ProtocolError(f"Received call to '{actual_method}' but the iterable returned by '{previous_method}' was not fully consumed.")
        else:
            expected_method = self._state_to_method_name(self._state)
            raise ProtocolError(f"Expected to call to '{expected_method}' but received call to '{actual_method}'.")
        	
    def _state_to_method_name(self, state: int) -> str:
        if state == 0:
            return 'read_int'
        if state == 2:
            return 'read_float'
        return "<unknown>"

