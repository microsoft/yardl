// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include <array>
#include <complex>
#include <optional>
#include <unordered_map>
#include <variant>
#include <vector>

#include "yardl/yardl.h"

namespace evo_test {
using AliasedLongToString = int64_t;

struct UnchangedRecord {
  std::string name{};
  int32_t age{};
  std::unordered_map<std::string, double> meta{};

  bool operator==(const UnchangedRecord& other) const {
    return name == other.name &&
      age == other.age &&
      meta == other.meta;
  }

  bool operator!=(const UnchangedRecord& other) const {
    return !(*this == other);
  }
};

struct RecordWithChanges {
  float deprecated_float{};
  int32_t int_to_long{};
  std::vector<int32_t> deprecated_vector{};
  float float_to_double{};
  yardl::FixedNDArray<uint8_t, 7> deprecated_array{};
  std::optional<int64_t> optional_long_to_string{};
  std::unordered_map<std::string, std::vector<int32_t>> deprecated_map{};
  evo_test::UnchangedRecord unchanged_record{};

  bool operator==(const RecordWithChanges& other) const {
    return deprecated_float == other.deprecated_float &&
      int_to_long == other.int_to_long &&
      deprecated_vector == other.deprecated_vector &&
      float_to_double == other.float_to_double &&
      deprecated_array == other.deprecated_array &&
      optional_long_to_string == other.optional_long_to_string &&
      deprecated_map == other.deprecated_map &&
      unchanged_record == other.unchanged_record;
  }

  bool operator!=(const RecordWithChanges& other) const {
    return !(*this == other);
  }
};

using AliasedRecordWithChanges = evo_test::RecordWithChanges;

struct RenamedRecord {
  int32_t i{};
  std::string s{};

  bool operator==(const RenamedRecord& other) const {
    return i == other.i &&
      s == other.s;
  }

  bool operator!=(const RenamedRecord& other) const {
    return !(*this == other);
  }
};

using StreamItem = evo_test::RecordWithChanges;

struct RC {
  std::string subject{};

  bool operator==(const RC& other) const {
    return subject == other.subject;
  }

  bool operator!=(const RC& other) const {
    return !(*this == other);
  }
};

using RB = evo_test::RC;

using RA = evo_test::RB;

using RLink = evo_test::RA;

struct UnusedButChangedRecord {
  std::string name{};
  int32_t age{};

  bool operator==(const UnusedButChangedRecord& other) const {
    return name == other.name &&
      age == other.age;
  }

  bool operator!=(const UnusedButChangedRecord& other) const {
    return !(*this == other);
  }
};

template <typename T1, typename T2>
struct GenericRecord {
  std::optional<bool> removed{};
  T1 field_1{};
  T2 field_2{};

  bool operator==(const GenericRecord& other) const {
    return removed == other.removed &&
      field_1 == other.field_1 &&
      field_2 == other.field_2;
  }

  bool operator!=(const GenericRecord& other) const {
    return !(*this == other);
  }
};

template <typename T1, typename T2>
using GenericUnion = std::variant<T1, T2>;

template <typename T>
struct GenericParentRecord {
  evo_test::GenericRecord<T, std::string> record{};
  evo_test::GenericRecord<evo_test::GenericUnion<T, float>, std::string> record_of_union{};
  evo_test::GenericUnion<evo_test::GenericRecord<int32_t, std::string>, float> union_of_record{};

  bool operator==(const GenericParentRecord& other) const {
    return record == other.record &&
      record_of_union == other.record_of_union &&
      union_of_record == other.union_of_record;
  }

  bool operator!=(const GenericParentRecord& other) const {
    return !(*this == other);
  }
};

template <typename T>
using AliasedHalfClosedGenericUnion = evo_test::GenericUnion<T, float>;

using AliasedClosedGenericUnion = evo_test::AliasedHalfClosedGenericUnion<evo_test::GenericRecord<int32_t, std::string>>;

template <typename T>
using AliasedHalfClosedGenericRecord = evo_test::GenericRecord<T, std::string>;

using AliasedClosedGenericRecord = evo_test::AliasedHalfClosedGenericRecord<int32_t>;

template <typename T2>
struct UnchangedGeneric {
  T2 field{};

  bool operator==(const UnchangedGeneric& other) const {
    return field == other.field;
  }

  bool operator!=(const UnchangedGeneric& other) const {
    return !(*this == other);
  }
};

template <typename Y, typename Z>
struct ChangedGeneric {
  Y y{};
  evo_test::UnchangedGeneric<Z> z{};

  bool operator==(const ChangedGeneric& other) const {
    return y == other.y &&
      z == other.z;
  }

  bool operator!=(const ChangedGeneric& other) const {
    return !(*this == other);
  }
};

enum class GrowingEnum : uint16_t {
  kA = 0,
  kB = 1,
  kC = 2,
};

} // namespace evo_test

