# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedClass=false
# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import collections.abc
import io
import typing

import numpy as np
import numpy.typing as npt

from .types import *

from .protocols import *
from . import _ndjson
from . import yardl_types as yardl

class BinaryTreeConverter(_ndjson.JsonConverter[BinaryTree, np.void]):
    def __init__(self) -> None:
        self._value_converter = _ndjson.int32_converter
        self._left_converter = BinaryTreeConverter()
        self._right_converter = BinaryTreeConverter()
        super().__init__(np.dtype([
            ("value", self._value_converter.overall_dtype()),
            ("left", self._left_converter.overall_dtype()),
            ("right", self._right_converter.overall_dtype()),
        ]))

    def to_json(self, value: BinaryTree) -> object:
        if not isinstance(value, BinaryTree): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'BinaryTree' instance")
        json_object = {}

        json_object["value"] = self._value_converter.to_json(value.value)
        json_object["left"] = self._left_converter.to_json(value.left)
        json_object["right"] = self._right_converter.to_json(value.right)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["value"] = self._value_converter.numpy_to_json(value["value"])
        json_object["left"] = self._left_converter.numpy_to_json(value["left"])
        json_object["right"] = self._right_converter.numpy_to_json(value["right"])
        return json_object

    def from_json(self, json_object: object) -> BinaryTree:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return BinaryTree(
            value=self._value_converter.from_json(json_object["value"],),
            left=self._left_converter.from_json(json_object["left"],),
            right=self._right_converter.from_json(json_object["right"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._value_converter.from_json_to_numpy(json_object["value"]),
            self._left_converter.from_json_to_numpy(json_object["left"]),
            self._right_converter.from_json_to_numpy(json_object["right"]),
        ) # type:ignore 


class LinkedListConverter(typing.Generic[T, T_NP], _ndjson.JsonConverter[LinkedList[T], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP]) -> None:
        self._value_converter = t_converter
        self._value_supports_none = self._value_converter.supports_none()
        self._next_converter = LinkedListConverter(t_converter)
        super().__init__(np.dtype([
            ("value", self._value_converter.overall_dtype()),
            ("next", self._next_converter.overall_dtype()),
        ]))

    def to_json(self, value: LinkedList[T]) -> object:
        if not isinstance(value, LinkedList): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'LinkedList[T]' instance")
        json_object = {}

        if not self._value_supports_none or value.value is not None:
            json_object["value"] = self._value_converter.to_json(value.value)
        json_object["next"] = self._next_converter.to_json(value.next)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if not self._value_supports_none or value["value"] is not None:
            json_object["value"] = self._value_converter.numpy_to_json(value["value"])
        json_object["next"] = self._next_converter.numpy_to_json(value["next"])
        return json_object

    def from_json(self, json_object: object) -> LinkedList[T]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return LinkedList[T](
            value=self._value_converter.from_json(json_object.get("value") if self._value_supports_none else json_object["value"]),
            next=self._next_converter.from_json(json_object["next"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._value_converter.from_json_to_numpy(json_object.get("value") if self._value_supports_none else json_object["value"]),
            self._next_converter.from_json_to_numpy(json_object["next"]),
        ) # type:ignore 


class FileConverter(_ndjson.JsonConverter[File, np.void]):
    def __init__(self) -> None:
        self._name_converter = _ndjson.string_converter
        self._data_converter = _ndjson.VectorConverter(_ndjson.uint8_converter)
        super().__init__(np.dtype([
            ("name", self._name_converter.overall_dtype()),
            ("data", self._data_converter.overall_dtype()),
        ]))

    def to_json(self, value: File) -> object:
        if not isinstance(value, File): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'File' instance")
        json_object = {}

        json_object["name"] = self._name_converter.to_json(value.name)
        json_object["data"] = self._data_converter.to_json(value.data)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["name"] = self._name_converter.numpy_to_json(value["name"])
        json_object["data"] = self._data_converter.numpy_to_json(value["data"])
        return json_object

    def from_json(self, json_object: object) -> File:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return File(
            name=self._name_converter.from_json(json_object["name"],),
            data=self._data_converter.from_json(json_object["data"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._name_converter.from_json_to_numpy(json_object["name"]),
            self._data_converter.from_json_to_numpy(json_object["data"]),
        ) # type:ignore 


class DirectoryConverter(_ndjson.JsonConverter[Directory, np.void]):
    def __init__(self) -> None:
        self._name_converter = _ndjson.string_converter
        self._entries_converter = _ndjson.VectorConverter(_ndjson.UnionConverter(DirectoryEntry, [(DirectoryEntry.File, FileConverter(), [dict]), (DirectoryEntry.Directory, DirectoryConverter(), [dict])], False))
        super().__init__(np.dtype([
            ("name", self._name_converter.overall_dtype()),
            ("entries", self._entries_converter.overall_dtype()),
        ]))

    def to_json(self, value: Directory) -> object:
        if not isinstance(value, Directory): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'Directory' instance")
        json_object = {}

        json_object["name"] = self._name_converter.to_json(value.name)
        json_object["entries"] = self._entries_converter.to_json(value.entries)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["name"] = self._name_converter.numpy_to_json(value["name"])
        json_object["entries"] = self._entries_converter.numpy_to_json(value["entries"])
        return json_object

    def from_json(self, json_object: object) -> Directory:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return Directory(
            name=self._name_converter.from_json(json_object["name"],),
            entries=self._entries_converter.from_json(json_object["entries"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._name_converter.from_json_to_numpy(json_object["name"]),
            self._entries_converter.from_json_to_numpy(json_object["entries"]),
        ) # type:ignore 


class NDJsonMyProtocolWriter(_ndjson.NDJsonProtocolWriter, MyProtocolWriterBase):
    """NDJson writer for the MyProtocol protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        MyProtocolWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, MyProtocolWriterBase.schema)

    def _write_tree(self, value: BinaryTree) -> None:
        converter = BinaryTreeConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"tree": json_value})

    def _write_ptree(self, value: BinaryTree__) -> None:
        converter = BinaryTreeConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"ptree": json_value})

    def _write_list(self, value: typing.Optional[LinkedList[str]]) -> None:
        converter = _ndjson.OptionalConverter(LinkedListConverter(_ndjson.string_converter))
        json_value = converter.to_json(value)
        self._write_json_line({"list": json_value})

    def _write_cwd(self, value: collections.abc.Iterable[DirectoryEntry]) -> None:
        converter = _ndjson.UnionConverter(DirectoryEntry, [(DirectoryEntry.File, FileConverter(), [dict]), (DirectoryEntry.Directory, DirectoryConverter(), [dict])], False)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"cwd": json_item})


class NDJsonMyProtocolReader(_ndjson.NDJsonProtocolReader, MyProtocolReaderBase):
    """NDJson writer for the MyProtocol protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        MyProtocolReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, MyProtocolReaderBase.schema)

    def _read_tree(self) -> BinaryTree:
        json_object = self._read_json_line("tree", True)
        converter = BinaryTreeConverter()
        return converter.from_json(json_object)

    def _read_ptree(self) -> BinaryTree__:
        json_object = self._read_json_line("ptree", True)
        converter = BinaryTreeConverter()
        return converter.from_json(json_object)

    def _read_list(self) -> typing.Optional[LinkedList[str]]:
        json_object = self._read_json_line("list", True)
        converter = _ndjson.OptionalConverter(LinkedListConverter(_ndjson.string_converter))
        return converter.from_json(json_object)

    def _read_cwd(self) -> collections.abc.Iterable[DirectoryEntry]:
        converter = _ndjson.UnionConverter(DirectoryEntry, [(DirectoryEntry.File, FileConverter(), [dict]), (DirectoryEntry.Directory, DirectoryConverter(), [dict])], False)
        while (json_object := self._read_json_line("cwd", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

