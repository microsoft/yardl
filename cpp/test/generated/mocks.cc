// This file was generated by the "yardl" tool. DO NOT EDIT.

#include <functional>
#include <queue>

#include <gtest/gtest.h>

#include "../yardl_testing.h"
#include "binary/protocols.h"
#include "hdf5/protocols.h"
#include "types.h"

namespace test_model {
namespace {
class MockBenchmarkFloat256x256Writer : public BenchmarkFloat256x256WriterBase {
  public:
  void WriteFloat256x256Impl (yardl::FixedNDArray<float, 256, 256> const& value) override {
    if (WriteFloat256x256Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloat256x256Impl");
    }
    if (WriteFloat256x256Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloat256x256Impl");
    }
    WriteFloat256x256Impl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<float, 256, 256>> WriteFloat256x256Impl_expected_values_;

  void ExpectWriteFloat256x256Impl (yardl::FixedNDArray<float, 256, 256> const& value) {
    WriteFloat256x256Impl_expected_values_.push(value);
  }

  void EndFloat256x256Impl () override {
    if (--EndFloat256x256Impl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFloat256x256Impl");
    }
  }

  int EndFloat256x256Impl_expected_call_count_ = 0;

  void ExpectEndFloat256x256Impl () {
    EndFloat256x256Impl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteFloat256x256Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloat256x256Impl was not received");
    }
    if (EndFloat256x256Impl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFloat256x256Impl was not received");
    }
  }
};

class TestBenchmarkFloat256x256WriterBase : public BenchmarkFloat256x256WriterBase {
  public:
  TestBenchmarkFloat256x256WriterBase(std::unique_ptr<test_model::BenchmarkFloat256x256WriterBase> writer, std::function<std::unique_ptr<BenchmarkFloat256x256ReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkFloat256x256WriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkFloat256x256WriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloat256x256Impl(yardl::FixedNDArray<float, 256, 256> const& value) override {
    writer_->WriteFloat256x256(value);
    mock_writer_.ExpectWriteFloat256x256Impl(value);
  }

  void WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) override {
    writer_->WriteFloat256x256(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFloat256x256Impl(v);
    }
  }

  void EndFloat256x256Impl() override {
    writer_->EndFloat256x256();
    mock_writer_.ExpectEndFloat256x256Impl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkFloat256x256ReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkFloat256x256WriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkFloat256x256ReaderBase>()> create_reader_;
  MockBenchmarkFloat256x256Writer mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkFloatVlenWriter : public BenchmarkFloatVlenWriterBase {
  public:
  void WriteFloatArrayImpl (yardl::NDArray<float, 2> const& value) override {
    if (WriteFloatArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatArrayImpl");
    }
    if (WriteFloatArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatArrayImpl");
    }
    WriteFloatArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<float, 2>> WriteFloatArrayImpl_expected_values_;

  void ExpectWriteFloatArrayImpl (yardl::NDArray<float, 2> const& value) {
    WriteFloatArrayImpl_expected_values_.push(value);
  }

  void EndFloatArrayImpl () override {
    if (--EndFloatArrayImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFloatArrayImpl");
    }
  }

  int EndFloatArrayImpl_expected_call_count_ = 0;

  void ExpectEndFloatArrayImpl () {
    EndFloatArrayImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteFloatArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatArrayImpl was not received");
    }
    if (EndFloatArrayImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFloatArrayImpl was not received");
    }
  }
};

class TestBenchmarkFloatVlenWriterBase : public BenchmarkFloatVlenWriterBase {
  public:
  TestBenchmarkFloatVlenWriterBase(std::unique_ptr<test_model::BenchmarkFloatVlenWriterBase> writer, std::function<std::unique_ptr<BenchmarkFloatVlenReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkFloatVlenWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkFloatVlenWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloatArrayImpl(yardl::NDArray<float, 2> const& value) override {
    writer_->WriteFloatArray(value);
    mock_writer_.ExpectWriteFloatArrayImpl(value);
  }

  void WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& values) override {
    writer_->WriteFloatArray(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFloatArrayImpl(v);
    }
  }

  void EndFloatArrayImpl() override {
    writer_->EndFloatArray();
    mock_writer_.ExpectEndFloatArrayImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkFloatVlenReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkFloatVlenWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkFloatVlenReaderBase>()> create_reader_;
  MockBenchmarkFloatVlenWriter mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkSmallRecordWriter : public BenchmarkSmallRecordWriterBase {
  public:
  void WriteSmallRecordImpl (test_model::SmallBenchmarkRecord const& value) override {
    if (WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSmallRecordImpl");
    }
    if (WriteSmallRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSmallRecordImpl");
    }
    WriteSmallRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::SmallBenchmarkRecord> WriteSmallRecordImpl_expected_values_;

  void ExpectWriteSmallRecordImpl (test_model::SmallBenchmarkRecord const& value) {
    WriteSmallRecordImpl_expected_values_.push(value);
  }

  void EndSmallRecordImpl () override {
    if (--EndSmallRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndSmallRecordImpl");
    }
  }

  int EndSmallRecordImpl_expected_call_count_ = 0;

  void ExpectEndSmallRecordImpl () {
    EndSmallRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSmallRecordImpl was not received");
    }
    if (EndSmallRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndSmallRecordImpl was not received");
    }
  }
};

class TestBenchmarkSmallRecordWriterBase : public BenchmarkSmallRecordWriterBase {
  public:
  TestBenchmarkSmallRecordWriterBase(std::unique_ptr<test_model::BenchmarkSmallRecordWriterBase> writer, std::function<std::unique_ptr<BenchmarkSmallRecordReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkSmallRecordWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkSmallRecordWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSmallRecordImpl(test_model::SmallBenchmarkRecord const& value) override {
    writer_->WriteSmallRecord(value);
    mock_writer_.ExpectWriteSmallRecordImpl(value);
  }

  void WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& values) override {
    writer_->WriteSmallRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteSmallRecordImpl(v);
    }
  }

  void EndSmallRecordImpl() override {
    writer_->EndSmallRecord();
    mock_writer_.ExpectEndSmallRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkSmallRecordReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkSmallRecordWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkSmallRecordReaderBase>()> create_reader_;
  MockBenchmarkSmallRecordWriter mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkSmallRecordWithOptionalsWriter : public BenchmarkSmallRecordWithOptionalsWriterBase {
  public:
  void WriteSmallRecordImpl (test_model::SimpleEncodingCounters const& value) override {
    if (WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSmallRecordImpl");
    }
    if (WriteSmallRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSmallRecordImpl");
    }
    WriteSmallRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::SimpleEncodingCounters> WriteSmallRecordImpl_expected_values_;

  void ExpectWriteSmallRecordImpl (test_model::SimpleEncodingCounters const& value) {
    WriteSmallRecordImpl_expected_values_.push(value);
  }

  void EndSmallRecordImpl () override {
    if (--EndSmallRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndSmallRecordImpl");
    }
  }

  int EndSmallRecordImpl_expected_call_count_ = 0;

  void ExpectEndSmallRecordImpl () {
    EndSmallRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSmallRecordImpl was not received");
    }
    if (EndSmallRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndSmallRecordImpl was not received");
    }
  }
};

class TestBenchmarkSmallRecordWithOptionalsWriterBase : public BenchmarkSmallRecordWithOptionalsWriterBase {
  public:
  TestBenchmarkSmallRecordWithOptionalsWriterBase(std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsWriterBase> writer, std::function<std::unique_ptr<BenchmarkSmallRecordWithOptionalsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkSmallRecordWithOptionalsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkSmallRecordWithOptionalsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSmallRecordImpl(test_model::SimpleEncodingCounters const& value) override {
    writer_->WriteSmallRecord(value);
    mock_writer_.ExpectWriteSmallRecordImpl(value);
  }

  void WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& values) override {
    writer_->WriteSmallRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteSmallRecordImpl(v);
    }
  }

  void EndSmallRecordImpl() override {
    writer_->EndSmallRecord();
    mock_writer_.ExpectEndSmallRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkSmallRecordWithOptionalsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsReaderBase>()> create_reader_;
  MockBenchmarkSmallRecordWithOptionalsWriter mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkSimpleMrdWriter : public BenchmarkSimpleMrdWriterBase {
  public:
  void WriteDataImpl (std::variant<test_model::SimpleAcquisition, test_model::Image<float>> const& value) override {
    if (WriteDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDataImpl");
    }
    if (WriteDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDataImpl");
    }
    WriteDataImpl_expected_values_.pop();
  }

  std::queue<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>> WriteDataImpl_expected_values_;

  void ExpectWriteDataImpl (std::variant<test_model::SimpleAcquisition, test_model::Image<float>> const& value) {
    WriteDataImpl_expected_values_.push(value);
  }

  void EndDataImpl () override {
    if (--EndDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndDataImpl");
    }
  }

  int EndDataImpl_expected_call_count_ = 0;

  void ExpectEndDataImpl () {
    EndDataImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDataImpl was not received");
    }
    if (EndDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndDataImpl was not received");
    }
  }
};

class TestBenchmarkSimpleMrdWriterBase : public BenchmarkSimpleMrdWriterBase {
  public:
  TestBenchmarkSimpleMrdWriterBase(std::unique_ptr<test_model::BenchmarkSimpleMrdWriterBase> writer, std::function<std::unique_ptr<BenchmarkSimpleMrdReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkSimpleMrdWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkSimpleMrdWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteDataImpl(std::variant<test_model::SimpleAcquisition, test_model::Image<float>> const& value) override {
    writer_->WriteData(value);
    mock_writer_.ExpectWriteDataImpl(value);
  }

  void WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>> const& values) override {
    writer_->WriteData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteDataImpl(v);
    }
  }

  void EndDataImpl() override {
    writer_->EndData();
    mock_writer_.ExpectEndDataImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkSimpleMrdReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkSimpleMrdWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkSimpleMrdReaderBase>()> create_reader_;
  MockBenchmarkSimpleMrdWriter mock_writer_;
  bool close_called_ = false;
};

class MockScalarsWriter : public ScalarsWriterBase {
  public:
  void WriteInt32Impl (int32_t const& value) override {
    if (WriteInt32Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteInt32Impl");
    }
    if (WriteInt32Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteInt32Impl");
    }
    WriteInt32Impl_expected_values_.pop();
  }

  std::queue<int32_t> WriteInt32Impl_expected_values_;

  void ExpectWriteInt32Impl (int32_t const& value) {
    WriteInt32Impl_expected_values_.push(value);
  }

  void WriteRecordImpl (test_model::RecordWithPrimitives const& value) override {
    if (WriteRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordImpl");
    }
    if (WriteRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordImpl");
    }
    WriteRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithPrimitives> WriteRecordImpl_expected_values_;

  void ExpectWriteRecordImpl (test_model::RecordWithPrimitives const& value) {
    WriteRecordImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteInt32Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteInt32Impl was not received");
    }
    if (!WriteRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordImpl was not received");
    }
  }
};

class TestScalarsWriterBase : public ScalarsWriterBase {
  public:
  TestScalarsWriterBase(std::unique_ptr<test_model::ScalarsWriterBase> writer, std::function<std::unique_ptr<ScalarsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestScalarsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestScalarsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteInt32Impl(int32_t const& value) override {
    writer_->WriteInt32(value);
    mock_writer_.ExpectWriteInt32Impl(value);
  }

  void WriteRecordImpl(test_model::RecordWithPrimitives const& value) override {
    writer_->WriteRecord(value);
    mock_writer_.ExpectWriteRecordImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ScalarsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ScalarsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ScalarsReaderBase>()> create_reader_;
  MockScalarsWriter mock_writer_;
  bool close_called_ = false;
};

class MockScalarOptionalsWriter : public ScalarOptionalsWriterBase {
  public:
  void WriteOptionalIntImpl (std::optional<int32_t> const& value) override {
    if (WriteOptionalIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalIntImpl");
    }
    if (WriteOptionalIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalIntImpl");
    }
    WriteOptionalIntImpl_expected_values_.pop();
  }

  std::queue<std::optional<int32_t>> WriteOptionalIntImpl_expected_values_;

  void ExpectWriteOptionalIntImpl (std::optional<int32_t> const& value) {
    WriteOptionalIntImpl_expected_values_.push(value);
  }

  void WriteOptionalRecordImpl (std::optional<test_model::SimpleRecord> const& value) override {
    if (WriteOptionalRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalRecordImpl");
    }
    if (WriteOptionalRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalRecordImpl");
    }
    WriteOptionalRecordImpl_expected_values_.pop();
  }

  std::queue<std::optional<test_model::SimpleRecord>> WriteOptionalRecordImpl_expected_values_;

  void ExpectWriteOptionalRecordImpl (std::optional<test_model::SimpleRecord> const& value) {
    WriteOptionalRecordImpl_expected_values_.push(value);
  }

  void WriteRecordWithOptionalFieldsImpl (test_model::RecordWithOptionalFields const& value) override {
    if (WriteRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithOptionalFieldsImpl");
    }
    if (WriteRecordWithOptionalFieldsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithOptionalFieldsImpl");
    }
    WriteRecordWithOptionalFieldsImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithOptionalFields> WriteRecordWithOptionalFieldsImpl_expected_values_;

  void ExpectWriteRecordWithOptionalFieldsImpl (test_model::RecordWithOptionalFields const& value) {
    WriteRecordWithOptionalFieldsImpl_expected_values_.push(value);
  }

  void WriteOptionalRecordWithOptionalFieldsImpl (std::optional<test_model::RecordWithOptionalFields> const& value) override {
    if (WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalRecordWithOptionalFieldsImpl");
    }
    if (WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalRecordWithOptionalFieldsImpl");
    }
    WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.pop();
  }

  std::queue<std::optional<test_model::RecordWithOptionalFields>> WriteOptionalRecordWithOptionalFieldsImpl_expected_values_;

  void ExpectWriteOptionalRecordWithOptionalFieldsImpl (std::optional<test_model::RecordWithOptionalFields> const& value) {
    WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteOptionalIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalIntImpl was not received");
    }
    if (!WriteOptionalRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalRecordImpl was not received");
    }
    if (!WriteRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithOptionalFieldsImpl was not received");
    }
    if (!WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalRecordWithOptionalFieldsImpl was not received");
    }
  }
};

class TestScalarOptionalsWriterBase : public ScalarOptionalsWriterBase {
  public:
  TestScalarOptionalsWriterBase(std::unique_ptr<test_model::ScalarOptionalsWriterBase> writer, std::function<std::unique_ptr<ScalarOptionalsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestScalarOptionalsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestScalarOptionalsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteOptionalIntImpl(std::optional<int32_t> const& value) override {
    writer_->WriteOptionalInt(value);
    mock_writer_.ExpectWriteOptionalIntImpl(value);
  }

  void WriteOptionalRecordImpl(std::optional<test_model::SimpleRecord> const& value) override {
    writer_->WriteOptionalRecord(value);
    mock_writer_.ExpectWriteOptionalRecordImpl(value);
  }

  void WriteRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields const& value) override {
    writer_->WriteRecordWithOptionalFields(value);
    mock_writer_.ExpectWriteRecordWithOptionalFieldsImpl(value);
  }

  void WriteOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields> const& value) override {
    writer_->WriteOptionalRecordWithOptionalFields(value);
    mock_writer_.ExpectWriteOptionalRecordWithOptionalFieldsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ScalarOptionalsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ScalarOptionalsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ScalarOptionalsReaderBase>()> create_reader_;
  MockScalarOptionalsWriter mock_writer_;
  bool close_called_ = false;
};

class MockNestedRecordsWriter : public NestedRecordsWriterBase {
  public:
  void WriteTupleWithRecordsImpl (test_model::TupleWithRecords const& value) override {
    if (WriteTupleWithRecordsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleWithRecordsImpl");
    }
    if (WriteTupleWithRecordsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleWithRecordsImpl");
    }
    WriteTupleWithRecordsImpl_expected_values_.pop();
  }

  std::queue<test_model::TupleWithRecords> WriteTupleWithRecordsImpl_expected_values_;

  void ExpectWriteTupleWithRecordsImpl (test_model::TupleWithRecords const& value) {
    WriteTupleWithRecordsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteTupleWithRecordsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleWithRecordsImpl was not received");
    }
  }
};

class TestNestedRecordsWriterBase : public NestedRecordsWriterBase {
  public:
  TestNestedRecordsWriterBase(std::unique_ptr<test_model::NestedRecordsWriterBase> writer, std::function<std::unique_ptr<NestedRecordsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestNestedRecordsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestNestedRecordsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteTupleWithRecordsImpl(test_model::TupleWithRecords const& value) override {
    writer_->WriteTupleWithRecords(value);
    mock_writer_.ExpectWriteTupleWithRecordsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<NestedRecordsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::NestedRecordsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::NestedRecordsReaderBase>()> create_reader_;
  MockNestedRecordsWriter mock_writer_;
  bool close_called_ = false;
};

class MockVlensWriter : public VlensWriterBase {
  public:
  void WriteIntVectorImpl (std::vector<int32_t> const& value) override {
    if (WriteIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntVectorImpl");
    }
    if (WriteIntVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntVectorImpl");
    }
    WriteIntVectorImpl_expected_values_.pop();
  }

  std::queue<std::vector<int32_t>> WriteIntVectorImpl_expected_values_;

  void ExpectWriteIntVectorImpl (std::vector<int32_t> const& value) {
    WriteIntVectorImpl_expected_values_.push(value);
  }

  void WriteComplexVectorImpl (std::vector<std::complex<float>> const& value) override {
    if (WriteComplexVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteComplexVectorImpl");
    }
    if (WriteComplexVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteComplexVectorImpl");
    }
    WriteComplexVectorImpl_expected_values_.pop();
  }

  std::queue<std::vector<std::complex<float>>> WriteComplexVectorImpl_expected_values_;

  void ExpectWriteComplexVectorImpl (std::vector<std::complex<float>> const& value) {
    WriteComplexVectorImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensImpl (test_model::RecordWithVlens const& value) override {
    if (WriteRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensImpl");
    }
    if (WriteRecordWithVlensImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensImpl");
    }
    WriteRecordWithVlensImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithVlens> WriteRecordWithVlensImpl_expected_values_;

  void ExpectWriteRecordWithVlensImpl (test_model::RecordWithVlens const& value) {
    WriteRecordWithVlensImpl_expected_values_.push(value);
  }

  void WriteVlenOfRecordWithVlensImpl (std::vector<test_model::RecordWithVlens> const& value) override {
    if (WriteVlenOfRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteVlenOfRecordWithVlensImpl");
    }
    if (WriteVlenOfRecordWithVlensImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteVlenOfRecordWithVlensImpl");
    }
    WriteVlenOfRecordWithVlensImpl_expected_values_.pop();
  }

  std::queue<std::vector<test_model::RecordWithVlens>> WriteVlenOfRecordWithVlensImpl_expected_values_;

  void ExpectWriteVlenOfRecordWithVlensImpl (std::vector<test_model::RecordWithVlens> const& value) {
    WriteVlenOfRecordWithVlensImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntVectorImpl was not received");
    }
    if (!WriteComplexVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteComplexVectorImpl was not received");
    }
    if (!WriteRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensImpl was not received");
    }
    if (!WriteVlenOfRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteVlenOfRecordWithVlensImpl was not received");
    }
  }
};

class TestVlensWriterBase : public VlensWriterBase {
  public:
  TestVlensWriterBase(std::unique_ptr<test_model::VlensWriterBase> writer, std::function<std::unique_ptr<VlensReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestVlensWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestVlensWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntVectorImpl(std::vector<int32_t> const& value) override {
    writer_->WriteIntVector(value);
    mock_writer_.ExpectWriteIntVectorImpl(value);
  }

  void WriteComplexVectorImpl(std::vector<std::complex<float>> const& value) override {
    writer_->WriteComplexVector(value);
    mock_writer_.ExpectWriteComplexVectorImpl(value);
  }

  void WriteRecordWithVlensImpl(test_model::RecordWithVlens const& value) override {
    writer_->WriteRecordWithVlens(value);
    mock_writer_.ExpectWriteRecordWithVlensImpl(value);
  }

  void WriteVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens> const& value) override {
    writer_->WriteVlenOfRecordWithVlens(value);
    mock_writer_.ExpectWriteVlenOfRecordWithVlensImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<VlensReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::VlensWriterBase> writer_;
  std::function<std::unique_ptr<test_model::VlensReaderBase>()> create_reader_;
  MockVlensWriter mock_writer_;
  bool close_called_ = false;
};

class MockStringsWriter : public StringsWriterBase {
  public:
  void WriteSingleStringImpl (std::string const& value) override {
    if (WriteSingleStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSingleStringImpl");
    }
    if (WriteSingleStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSingleStringImpl");
    }
    WriteSingleStringImpl_expected_values_.pop();
  }

  std::queue<std::string> WriteSingleStringImpl_expected_values_;

  void ExpectWriteSingleStringImpl (std::string const& value) {
    WriteSingleStringImpl_expected_values_.push(value);
  }

  void WriteRecWithStringImpl (test_model::RecordWithStrings const& value) override {
    if (WriteRecWithStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecWithStringImpl");
    }
    if (WriteRecWithStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecWithStringImpl");
    }
    WriteRecWithStringImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithStrings> WriteRecWithStringImpl_expected_values_;

  void ExpectWriteRecWithStringImpl (test_model::RecordWithStrings const& value) {
    WriteRecWithStringImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteSingleStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSingleStringImpl was not received");
    }
    if (!WriteRecWithStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecWithStringImpl was not received");
    }
  }
};

class TestStringsWriterBase : public StringsWriterBase {
  public:
  TestStringsWriterBase(std::unique_ptr<test_model::StringsWriterBase> writer, std::function<std::unique_ptr<StringsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStringsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStringsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSingleStringImpl(std::string const& value) override {
    writer_->WriteSingleString(value);
    mock_writer_.ExpectWriteSingleStringImpl(value);
  }

  void WriteRecWithStringImpl(test_model::RecordWithStrings const& value) override {
    writer_->WriteRecWithString(value);
    mock_writer_.ExpectWriteRecWithStringImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StringsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StringsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StringsReaderBase>()> create_reader_;
  MockStringsWriter mock_writer_;
  bool close_called_ = false;
};

class MockOptionalVectorsWriter : public OptionalVectorsWriterBase {
  public:
  void WriteRecordWithOptionalVectorImpl (test_model::RecordWithOptionalVector const& value) override {
    if (WriteRecordWithOptionalVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithOptionalVectorImpl");
    }
    if (WriteRecordWithOptionalVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithOptionalVectorImpl");
    }
    WriteRecordWithOptionalVectorImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithOptionalVector> WriteRecordWithOptionalVectorImpl_expected_values_;

  void ExpectWriteRecordWithOptionalVectorImpl (test_model::RecordWithOptionalVector const& value) {
    WriteRecordWithOptionalVectorImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteRecordWithOptionalVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithOptionalVectorImpl was not received");
    }
  }
};

class TestOptionalVectorsWriterBase : public OptionalVectorsWriterBase {
  public:
  TestOptionalVectorsWriterBase(std::unique_ptr<test_model::OptionalVectorsWriterBase> writer, std::function<std::unique_ptr<OptionalVectorsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestOptionalVectorsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestOptionalVectorsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector const& value) override {
    writer_->WriteRecordWithOptionalVector(value);
    mock_writer_.ExpectWriteRecordWithOptionalVectorImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<OptionalVectorsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::OptionalVectorsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::OptionalVectorsReaderBase>()> create_reader_;
  MockOptionalVectorsWriter mock_writer_;
  bool close_called_ = false;
};

class MockFixedVectorsWriter : public FixedVectorsWriterBase {
  public:
  void WriteFixedIntVectorImpl (std::array<int32_t, 5> const& value) override {
    if (WriteFixedIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedIntVectorImpl");
    }
    if (WriteFixedIntVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedIntVectorImpl");
    }
    WriteFixedIntVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<int32_t, 5>> WriteFixedIntVectorImpl_expected_values_;

  void ExpectWriteFixedIntVectorImpl (std::array<int32_t, 5> const& value) {
    WriteFixedIntVectorImpl_expected_values_.push(value);
  }

  void WriteFixedSimpleRecordVectorImpl (std::array<test_model::SimpleRecord, 3> const& value) override {
    if (WriteFixedSimpleRecordVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedSimpleRecordVectorImpl");
    }
    if (WriteFixedSimpleRecordVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedSimpleRecordVectorImpl");
    }
    WriteFixedSimpleRecordVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<test_model::SimpleRecord, 3>> WriteFixedSimpleRecordVectorImpl_expected_values_;

  void ExpectWriteFixedSimpleRecordVectorImpl (std::array<test_model::SimpleRecord, 3> const& value) {
    WriteFixedSimpleRecordVectorImpl_expected_values_.push(value);
  }

  void WriteFixedRecordWithVlensVectorImpl (std::array<test_model::RecordWithVlens, 2> const& value) override {
    if (WriteFixedRecordWithVlensVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedRecordWithVlensVectorImpl");
    }
    if (WriteFixedRecordWithVlensVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedRecordWithVlensVectorImpl");
    }
    WriteFixedRecordWithVlensVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<test_model::RecordWithVlens, 2>> WriteFixedRecordWithVlensVectorImpl_expected_values_;

  void ExpectWriteFixedRecordWithVlensVectorImpl (std::array<test_model::RecordWithVlens, 2> const& value) {
    WriteFixedRecordWithVlensVectorImpl_expected_values_.push(value);
  }

  void WriteRecordWithFixedVectorsImpl (test_model::RecordWithFixedVectors const& value) override {
    if (WriteRecordWithFixedVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithFixedVectorsImpl");
    }
    if (WriteRecordWithFixedVectorsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithFixedVectorsImpl");
    }
    WriteRecordWithFixedVectorsImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithFixedVectors> WriteRecordWithFixedVectorsImpl_expected_values_;

  void ExpectWriteRecordWithFixedVectorsImpl (test_model::RecordWithFixedVectors const& value) {
    WriteRecordWithFixedVectorsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteFixedIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedIntVectorImpl was not received");
    }
    if (!WriteFixedSimpleRecordVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedSimpleRecordVectorImpl was not received");
    }
    if (!WriteFixedRecordWithVlensVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedRecordWithVlensVectorImpl was not received");
    }
    if (!WriteRecordWithFixedVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithFixedVectorsImpl was not received");
    }
  }
};

class TestFixedVectorsWriterBase : public FixedVectorsWriterBase {
  public:
  TestFixedVectorsWriterBase(std::unique_ptr<test_model::FixedVectorsWriterBase> writer, std::function<std::unique_ptr<FixedVectorsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestFixedVectorsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestFixedVectorsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFixedIntVectorImpl(std::array<int32_t, 5> const& value) override {
    writer_->WriteFixedIntVector(value);
    mock_writer_.ExpectWriteFixedIntVectorImpl(value);
  }

  void WriteFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3> const& value) override {
    writer_->WriteFixedSimpleRecordVector(value);
    mock_writer_.ExpectWriteFixedSimpleRecordVectorImpl(value);
  }

  void WriteFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2> const& value) override {
    writer_->WriteFixedRecordWithVlensVector(value);
    mock_writer_.ExpectWriteFixedRecordWithVlensVectorImpl(value);
  }

  void WriteRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors const& value) override {
    writer_->WriteRecordWithFixedVectors(value);
    mock_writer_.ExpectWriteRecordWithFixedVectorsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<FixedVectorsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::FixedVectorsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::FixedVectorsReaderBase>()> create_reader_;
  MockFixedVectorsWriter mock_writer_;
  bool close_called_ = false;
};

class MockStreamsWriter : public StreamsWriterBase {
  public:
  void WriteIntDataImpl (int32_t const& value) override {
    if (WriteIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntDataImpl");
    }
    if (WriteIntDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntDataImpl");
    }
    WriteIntDataImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteIntDataImpl_expected_values_;

  void ExpectWriteIntDataImpl (int32_t const& value) {
    WriteIntDataImpl_expected_values_.push(value);
  }

  void EndIntDataImpl () override {
    if (--EndIntDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntDataImpl");
    }
  }

  int EndIntDataImpl_expected_call_count_ = 0;

  void ExpectEndIntDataImpl () {
    EndIntDataImpl_expected_call_count_++;
  }

  void WriteOptionalIntDataImpl (std::optional<int32_t> const& value) override {
    if (WriteOptionalIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalIntDataImpl");
    }
    if (WriteOptionalIntDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalIntDataImpl");
    }
    WriteOptionalIntDataImpl_expected_values_.pop();
  }

  std::queue<std::optional<int32_t>> WriteOptionalIntDataImpl_expected_values_;

  void ExpectWriteOptionalIntDataImpl (std::optional<int32_t> const& value) {
    WriteOptionalIntDataImpl_expected_values_.push(value);
  }

  void EndOptionalIntDataImpl () override {
    if (--EndOptionalIntDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndOptionalIntDataImpl");
    }
  }

  int EndOptionalIntDataImpl_expected_call_count_ = 0;

  void ExpectEndOptionalIntDataImpl () {
    EndOptionalIntDataImpl_expected_call_count_++;
  }

  void WriteRecordWithOptionalVectorDataImpl (test_model::RecordWithOptionalVector const& value) override {
    if (WriteRecordWithOptionalVectorDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithOptionalVectorDataImpl");
    }
    if (WriteRecordWithOptionalVectorDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithOptionalVectorDataImpl");
    }
    WriteRecordWithOptionalVectorDataImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithOptionalVector> WriteRecordWithOptionalVectorDataImpl_expected_values_;

  void ExpectWriteRecordWithOptionalVectorDataImpl (test_model::RecordWithOptionalVector const& value) {
    WriteRecordWithOptionalVectorDataImpl_expected_values_.push(value);
  }

  void EndRecordWithOptionalVectorDataImpl () override {
    if (--EndRecordWithOptionalVectorDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndRecordWithOptionalVectorDataImpl");
    }
  }

  int EndRecordWithOptionalVectorDataImpl_expected_call_count_ = 0;

  void ExpectEndRecordWithOptionalVectorDataImpl () {
    EndRecordWithOptionalVectorDataImpl_expected_call_count_++;
  }

  void WriteFixedVectorImpl (std::array<int32_t, 3> const& value) override {
    if (WriteFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedVectorImpl");
    }
    if (WriteFixedVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedVectorImpl");
    }
    WriteFixedVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<int32_t, 3>> WriteFixedVectorImpl_expected_values_;

  void ExpectWriteFixedVectorImpl (std::array<int32_t, 3> const& value) {
    WriteFixedVectorImpl_expected_values_.push(value);
  }

  void EndFixedVectorImpl () override {
    if (--EndFixedVectorImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFixedVectorImpl");
    }
  }

  int EndFixedVectorImpl_expected_call_count_ = 0;

  void ExpectEndFixedVectorImpl () {
    EndFixedVectorImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntDataImpl was not received");
    }
    if (EndIntDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntDataImpl was not received");
    }
    if (!WriteOptionalIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalIntDataImpl was not received");
    }
    if (EndOptionalIntDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndOptionalIntDataImpl was not received");
    }
    if (!WriteRecordWithOptionalVectorDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithOptionalVectorDataImpl was not received");
    }
    if (EndRecordWithOptionalVectorDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndRecordWithOptionalVectorDataImpl was not received");
    }
    if (!WriteFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedVectorImpl was not received");
    }
    if (EndFixedVectorImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFixedVectorImpl was not received");
    }
  }
};

class TestStreamsWriterBase : public StreamsWriterBase {
  public:
  TestStreamsWriterBase(std::unique_ptr<test_model::StreamsWriterBase> writer, std::function<std::unique_ptr<StreamsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStreamsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStreamsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntDataImpl(int32_t const& value) override {
    writer_->WriteIntData(value);
    mock_writer_.ExpectWriteIntDataImpl(value);
  }

  void WriteIntDataImpl(std::vector<int32_t> const& values) override {
    writer_->WriteIntData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntDataImpl(v);
    }
  }

  void EndIntDataImpl() override {
    writer_->EndIntData();
    mock_writer_.ExpectEndIntDataImpl();
  }

  void WriteOptionalIntDataImpl(std::optional<int32_t> const& value) override {
    writer_->WriteOptionalIntData(value);
    mock_writer_.ExpectWriteOptionalIntDataImpl(value);
  }

  void WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& values) override {
    writer_->WriteOptionalIntData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteOptionalIntDataImpl(v);
    }
  }

  void EndOptionalIntDataImpl() override {
    writer_->EndOptionalIntData();
    mock_writer_.ExpectEndOptionalIntDataImpl();
  }

  void WriteRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector const& value) override {
    writer_->WriteRecordWithOptionalVectorData(value);
    mock_writer_.ExpectWriteRecordWithOptionalVectorDataImpl(value);
  }

  void WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& values) override {
    writer_->WriteRecordWithOptionalVectorData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteRecordWithOptionalVectorDataImpl(v);
    }
  }

  void EndRecordWithOptionalVectorDataImpl() override {
    writer_->EndRecordWithOptionalVectorData();
    mock_writer_.ExpectEndRecordWithOptionalVectorDataImpl();
  }

  void WriteFixedVectorImpl(std::array<int32_t, 3> const& value) override {
    writer_->WriteFixedVector(value);
    mock_writer_.ExpectWriteFixedVectorImpl(value);
  }

  void WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& values) override {
    writer_->WriteFixedVector(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFixedVectorImpl(v);
    }
  }

  void EndFixedVectorImpl() override {
    writer_->EndFixedVector();
    mock_writer_.ExpectEndFixedVectorImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StreamsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1, 4, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StreamsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StreamsReaderBase>()> create_reader_;
  MockStreamsWriter mock_writer_;
  bool close_called_ = false;
};

class MockFixedArraysWriter : public FixedArraysWriterBase {
  public:
  void WriteIntsImpl (yardl::FixedNDArray<int32_t, 2, 3> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<int32_t, 2, 3>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::FixedNDArray<int32_t, 2, 3> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteFixedSimpleRecordArrayImpl (yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) override {
    if (WriteFixedSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedSimpleRecordArrayImpl");
    }
    if (WriteFixedSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedSimpleRecordArrayImpl");
    }
    WriteFixedSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>> WriteFixedSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteFixedSimpleRecordArrayImpl (yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) {
    WriteFixedSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteFixedRecordWithVlensArrayImpl (yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) override {
    if (WriteFixedRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedRecordWithVlensArrayImpl");
    }
    if (WriteFixedRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedRecordWithVlensArrayImpl");
    }
    WriteFixedRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>> WriteFixedRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteFixedRecordWithVlensArrayImpl (yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) {
    WriteFixedRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithFixedArraysImpl (test_model::RecordWithFixedArrays const& value) override {
    if (WriteRecordWithFixedArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithFixedArraysImpl");
    }
    if (WriteRecordWithFixedArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithFixedArraysImpl");
    }
    WriteRecordWithFixedArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithFixedArrays> WriteRecordWithFixedArraysImpl_expected_values_;

  void ExpectWriteRecordWithFixedArraysImpl (test_model::RecordWithFixedArrays const& value) {
    WriteRecordWithFixedArraysImpl_expected_values_.push(value);
  }

  void WriteNamedArrayImpl (test_model::NamedFixedNDArray const& value) override {
    if (WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNamedArrayImpl");
    }
    if (WriteNamedArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNamedArrayImpl");
    }
    WriteNamedArrayImpl_expected_values_.pop();
  }

  std::queue<test_model::NamedFixedNDArray> WriteNamedArrayImpl_expected_values_;

  void ExpectWriteNamedArrayImpl (test_model::NamedFixedNDArray const& value) {
    WriteNamedArrayImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteFixedSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedSimpleRecordArrayImpl was not received");
    }
    if (!WriteFixedRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithFixedArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithFixedArraysImpl was not received");
    }
    if (!WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNamedArrayImpl was not received");
    }
  }
};

class TestFixedArraysWriterBase : public FixedArraysWriterBase {
  public:
  TestFixedArraysWriterBase(std::unique_ptr<test_model::FixedArraysWriterBase> writer, std::function<std::unique_ptr<FixedArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestFixedArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestFixedArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::FixedNDArray<int32_t, 2, 3> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) override {
    writer_->WriteFixedSimpleRecordArray(value);
    mock_writer_.ExpectWriteFixedSimpleRecordArrayImpl(value);
  }

  void WriteFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) override {
    writer_->WriteFixedRecordWithVlensArray(value);
    mock_writer_.ExpectWriteFixedRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays const& value) override {
    writer_->WriteRecordWithFixedArrays(value);
    mock_writer_.ExpectWriteRecordWithFixedArraysImpl(value);
  }

  void WriteNamedArrayImpl(test_model::NamedFixedNDArray const& value) override {
    writer_->WriteNamedArray(value);
    mock_writer_.ExpectWriteNamedArrayImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<FixedArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::FixedArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::FixedArraysReaderBase>()> create_reader_;
  MockFixedArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockNDArraysWriter : public NDArraysWriterBase {
  public:
  void WriteIntsImpl (yardl::NDArray<int32_t, 2> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<int32_t, 2>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::NDArray<int32_t, 2> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 2> const& value) override {
    if (WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSimpleRecordArrayImpl");
    }
    if (WriteSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSimpleRecordArrayImpl");
    }
    WriteSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::SimpleRecord, 2>> WriteSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 2> const& value) {
    WriteSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 2> const& value) override {
    if (WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensArrayImpl");
    }
    if (WriteRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensArrayImpl");
    }
    WriteRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::RecordWithVlens, 2>> WriteRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 2> const& value) {
    WriteRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithNDArraysImpl (test_model::RecordWithNDArrays const& value) override {
    if (WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithNDArraysImpl");
    }
    if (WriteRecordWithNDArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithNDArraysImpl");
    }
    WriteRecordWithNDArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithNDArrays> WriteRecordWithNDArraysImpl_expected_values_;

  void ExpectWriteRecordWithNDArraysImpl (test_model::RecordWithNDArrays const& value) {
    WriteRecordWithNDArraysImpl_expected_values_.push(value);
  }

  void WriteNamedArrayImpl (test_model::NamedNDArray const& value) override {
    if (WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNamedArrayImpl");
    }
    if (WriteNamedArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNamedArrayImpl");
    }
    WriteNamedArrayImpl_expected_values_.pop();
  }

  std::queue<test_model::NamedNDArray> WriteNamedArrayImpl_expected_values_;

  void ExpectWriteNamedArrayImpl (test_model::NamedNDArray const& value) {
    WriteNamedArrayImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSimpleRecordArrayImpl was not received");
    }
    if (!WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithNDArraysImpl was not received");
    }
    if (!WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNamedArrayImpl was not received");
    }
  }
};

class TestNDArraysWriterBase : public NDArraysWriterBase {
  public:
  TestNDArraysWriterBase(std::unique_ptr<test_model::NDArraysWriterBase> writer, std::function<std::unique_ptr<NDArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestNDArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestNDArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::NDArray<int32_t, 2> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2> const& value) override {
    writer_->WriteSimpleRecordArray(value);
    mock_writer_.ExpectWriteSimpleRecordArrayImpl(value);
  }

  void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) override {
    writer_->WriteRecordWithVlensArray(value);
    mock_writer_.ExpectWriteRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArrays const& value) override {
    writer_->WriteRecordWithNDArrays(value);
    mock_writer_.ExpectWriteRecordWithNDArraysImpl(value);
  }

  void WriteNamedArrayImpl(test_model::NamedNDArray const& value) override {
    writer_->WriteNamedArray(value);
    mock_writer_.ExpectWriteNamedArrayImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<NDArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::NDArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::NDArraysReaderBase>()> create_reader_;
  MockNDArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockNDArraysSingleDimensionWriter : public NDArraysSingleDimensionWriterBase {
  public:
  void WriteIntsImpl (yardl::NDArray<int32_t, 1> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<int32_t, 1>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::NDArray<int32_t, 1> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 1> const& value) override {
    if (WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSimpleRecordArrayImpl");
    }
    if (WriteSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSimpleRecordArrayImpl");
    }
    WriteSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::SimpleRecord, 1>> WriteSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 1> const& value) {
    WriteSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 1> const& value) override {
    if (WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensArrayImpl");
    }
    if (WriteRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensArrayImpl");
    }
    WriteRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::RecordWithVlens, 1>> WriteRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 1> const& value) {
    WriteRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithNDArraysImpl (test_model::RecordWithNDArraysSingleDimension const& value) override {
    if (WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithNDArraysImpl");
    }
    if (WriteRecordWithNDArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithNDArraysImpl");
    }
    WriteRecordWithNDArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithNDArraysSingleDimension> WriteRecordWithNDArraysImpl_expected_values_;

  void ExpectWriteRecordWithNDArraysImpl (test_model::RecordWithNDArraysSingleDimension const& value) {
    WriteRecordWithNDArraysImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSimpleRecordArrayImpl was not received");
    }
    if (!WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithNDArraysImpl was not received");
    }
  }
};

class TestNDArraysSingleDimensionWriterBase : public NDArraysSingleDimensionWriterBase {
  public:
  TestNDArraysSingleDimensionWriterBase(std::unique_ptr<test_model::NDArraysSingleDimensionWriterBase> writer, std::function<std::unique_ptr<NDArraysSingleDimensionReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestNDArraysSingleDimensionWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestNDArraysSingleDimensionWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::NDArray<int32_t, 1> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1> const& value) override {
    writer_->WriteSimpleRecordArray(value);
    mock_writer_.ExpectWriteSimpleRecordArrayImpl(value);
  }

  void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) override {
    writer_->WriteRecordWithVlensArray(value);
    mock_writer_.ExpectWriteRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension const& value) override {
    writer_->WriteRecordWithNDArrays(value);
    mock_writer_.ExpectWriteRecordWithNDArraysImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<NDArraysSingleDimensionReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::NDArraysSingleDimensionWriterBase> writer_;
  std::function<std::unique_ptr<test_model::NDArraysSingleDimensionReaderBase>()> create_reader_;
  MockNDArraysSingleDimensionWriter mock_writer_;
  bool close_called_ = false;
};

class MockDynamicNDArraysWriter : public DynamicNDArraysWriterBase {
  public:
  void WriteIntsImpl (yardl::DynamicNDArray<int32_t> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<int32_t>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::DynamicNDArray<int32_t> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteSimpleRecordArrayImpl (yardl::DynamicNDArray<test_model::SimpleRecord> const& value) override {
    if (WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSimpleRecordArrayImpl");
    }
    if (WriteSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSimpleRecordArrayImpl");
    }
    WriteSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<test_model::SimpleRecord>> WriteSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteSimpleRecordArrayImpl (yardl::DynamicNDArray<test_model::SimpleRecord> const& value) {
    WriteSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensArrayImpl (yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) override {
    if (WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensArrayImpl");
    }
    if (WriteRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensArrayImpl");
    }
    WriteRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<test_model::RecordWithVlens>> WriteRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteRecordWithVlensArrayImpl (yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) {
    WriteRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithDynamicNDArraysImpl (test_model::RecordWithDynamicNDArrays const& value) override {
    if (WriteRecordWithDynamicNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithDynamicNDArraysImpl");
    }
    if (WriteRecordWithDynamicNDArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithDynamicNDArraysImpl");
    }
    WriteRecordWithDynamicNDArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithDynamicNDArrays> WriteRecordWithDynamicNDArraysImpl_expected_values_;

  void ExpectWriteRecordWithDynamicNDArraysImpl (test_model::RecordWithDynamicNDArrays const& value) {
    WriteRecordWithDynamicNDArraysImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSimpleRecordArrayImpl was not received");
    }
    if (!WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithDynamicNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithDynamicNDArraysImpl was not received");
    }
  }
};

class TestDynamicNDArraysWriterBase : public DynamicNDArraysWriterBase {
  public:
  TestDynamicNDArraysWriterBase(std::unique_ptr<test_model::DynamicNDArraysWriterBase> writer, std::function<std::unique_ptr<DynamicNDArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestDynamicNDArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestDynamicNDArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::DynamicNDArray<int32_t> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) override {
    writer_->WriteSimpleRecordArray(value);
    mock_writer_.ExpectWriteSimpleRecordArrayImpl(value);
  }

  void WriteRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) override {
    writer_->WriteRecordWithVlensArray(value);
    mock_writer_.ExpectWriteRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays const& value) override {
    writer_->WriteRecordWithDynamicNDArrays(value);
    mock_writer_.ExpectWriteRecordWithDynamicNDArraysImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<DynamicNDArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::DynamicNDArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::DynamicNDArraysReaderBase>()> create_reader_;
  MockDynamicNDArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockUnionsWriter : public UnionsWriterBase {
  public:
  void WriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrSimpleRecordImpl");
    }
    if (WriteIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrSimpleRecordImpl");
    }
    WriteIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<int32_t, test_model::SimpleRecord>> WriteIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) {
    WriteIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void WriteIntOrRecordWithVlensImpl (std::variant<int32_t, test_model::RecordWithVlens> const& value) override {
    if (WriteIntOrRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrRecordWithVlensImpl");
    }
    if (WriteIntOrRecordWithVlensImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrRecordWithVlensImpl");
    }
    WriteIntOrRecordWithVlensImpl_expected_values_.pop();
  }

  std::queue<std::variant<int32_t, test_model::RecordWithVlens>> WriteIntOrRecordWithVlensImpl_expected_values_;

  void ExpectWriteIntOrRecordWithVlensImpl (std::variant<int32_t, test_model::RecordWithVlens> const& value) {
    WriteIntOrRecordWithVlensImpl_expected_values_.push(value);
  }

  void WriteMonosotateOrIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteMonosotateOrIntOrSimpleRecordImpl");
    }
    if (WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteMonosotateOrIntOrSimpleRecordImpl");
    }
    WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteMonosotateOrIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
    WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrSimpleRecordImpl was not received");
    }
    if (!WriteIntOrRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrRecordWithVlensImpl was not received");
    }
    if (!WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteMonosotateOrIntOrSimpleRecordImpl was not received");
    }
  }
};

class TestUnionsWriterBase : public UnionsWriterBase {
  public:
  TestUnionsWriterBase(std::unique_ptr<test_model::UnionsWriterBase> writer, std::function<std::unique_ptr<UnionsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestUnionsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestUnionsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteIntOrSimpleRecordImpl(value);
  }

  void WriteIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens> const& value) override {
    writer_->WriteIntOrRecordWithVlens(value);
    mock_writer_.ExpectWriteIntOrRecordWithVlensImpl(value);
  }

  void WriteMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteMonosotateOrIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteMonosotateOrIntOrSimpleRecordImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<UnionsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::UnionsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::UnionsReaderBase>()> create_reader_;
  MockUnionsWriter mock_writer_;
  bool close_called_ = false;
};

class MockStreamsOfUnionsWriter : public StreamsOfUnionsWriterBase {
  public:
  void WriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrSimpleRecordImpl");
    }
    if (WriteIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrSimpleRecordImpl");
    }
    WriteIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<int32_t, test_model::SimpleRecord>> WriteIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) {
    WriteIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndIntOrSimpleRecordImpl () override {
    if (--EndIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntOrSimpleRecordImpl");
    }
  }

  int EndIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndIntOrSimpleRecordImpl () {
    EndIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void WriteNullableIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNullableIntOrSimpleRecordImpl");
    }
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNullableIntOrSimpleRecordImpl");
    }
    WriteNullableIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> WriteNullableIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteNullableIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
    WriteNullableIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndNullableIntOrSimpleRecordImpl () override {
    if (--EndNullableIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndNullableIntOrSimpleRecordImpl");
    }
  }

  int EndNullableIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndNullableIntOrSimpleRecordImpl () {
    EndNullableIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrSimpleRecordImpl was not received");
    }
    if (EndIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntOrSimpleRecordImpl was not received");
    }
    if (!WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNullableIntOrSimpleRecordImpl was not received");
    }
    if (EndNullableIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndNullableIntOrSimpleRecordImpl was not received");
    }
  }
};

class TestStreamsOfUnionsWriterBase : public StreamsOfUnionsWriterBase {
  public:
  TestStreamsOfUnionsWriterBase(std::unique_ptr<test_model::StreamsOfUnionsWriterBase> writer, std::function<std::unique_ptr<StreamsOfUnionsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStreamsOfUnionsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStreamsOfUnionsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteIntOrSimpleRecordImpl(value);
  }

  void WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) override {
    writer_->WriteIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntOrSimpleRecordImpl(v);
    }
  }

  void EndIntOrSimpleRecordImpl() override {
    writer_->EndIntOrSimpleRecord();
    mock_writer_.ExpectEndIntOrSimpleRecordImpl();
  }

  void WriteNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteNullableIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(value);
  }

  void WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) override {
    writer_->WriteNullableIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(v);
    }
  }

  void EndNullableIntOrSimpleRecordImpl() override {
    writer_->EndNullableIntOrSimpleRecord();
    mock_writer_.ExpectEndNullableIntOrSimpleRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StreamsOfUnionsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StreamsOfUnionsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StreamsOfUnionsReaderBase>()> create_reader_;
  MockStreamsOfUnionsWriter mock_writer_;
  bool close_called_ = false;
};

class MockEnumsWriter : public EnumsWriterBase {
  public:
  void WriteSingleImpl (test_model::Fruits const& value) override {
    if (WriteSingleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSingleImpl");
    }
    if (WriteSingleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSingleImpl");
    }
    WriteSingleImpl_expected_values_.pop();
  }

  std::queue<test_model::Fruits> WriteSingleImpl_expected_values_;

  void ExpectWriteSingleImpl (test_model::Fruits const& value) {
    WriteSingleImpl_expected_values_.push(value);
  }

  void WriteVecImpl (std::vector<test_model::Fruits> const& value) override {
    if (WriteVecImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteVecImpl");
    }
    if (WriteVecImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteVecImpl");
    }
    WriteVecImpl_expected_values_.pop();
  }

  std::queue<std::vector<test_model::Fruits>> WriteVecImpl_expected_values_;

  void ExpectWriteVecImpl (std::vector<test_model::Fruits> const& value) {
    WriteVecImpl_expected_values_.push(value);
  }

  void WriteSizeImpl (test_model::SizeBasedEnum const& value) override {
    if (WriteSizeImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSizeImpl");
    }
    if (WriteSizeImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSizeImpl");
    }
    WriteSizeImpl_expected_values_.pop();
  }

  std::queue<test_model::SizeBasedEnum> WriteSizeImpl_expected_values_;

  void ExpectWriteSizeImpl (test_model::SizeBasedEnum const& value) {
    WriteSizeImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteSingleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSingleImpl was not received");
    }
    if (!WriteVecImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteVecImpl was not received");
    }
    if (!WriteSizeImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSizeImpl was not received");
    }
  }
};

class TestEnumsWriterBase : public EnumsWriterBase {
  public:
  TestEnumsWriterBase(std::unique_ptr<test_model::EnumsWriterBase> writer, std::function<std::unique_ptr<EnumsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestEnumsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestEnumsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSingleImpl(test_model::Fruits const& value) override {
    writer_->WriteSingle(value);
    mock_writer_.ExpectWriteSingleImpl(value);
  }

  void WriteVecImpl(std::vector<test_model::Fruits> const& value) override {
    writer_->WriteVec(value);
    mock_writer_.ExpectWriteVecImpl(value);
  }

  void WriteSizeImpl(test_model::SizeBasedEnum const& value) override {
    writer_->WriteSize(value);
    mock_writer_.ExpectWriteSizeImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<EnumsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::EnumsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::EnumsReaderBase>()> create_reader_;
  MockEnumsWriter mock_writer_;
  bool close_called_ = false;
};

class MockStateTestWriter : public StateTestWriterBase {
  public:
  void WriteAnIntImpl (int32_t const& value) override {
    if (WriteAnIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAnIntImpl");
    }
    if (WriteAnIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAnIntImpl");
    }
    WriteAnIntImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteAnIntImpl_expected_values_;

  void ExpectWriteAnIntImpl (int32_t const& value) {
    WriteAnIntImpl_expected_values_.push(value);
  }

  void WriteAStreamImpl (int32_t const& value) override {
    if (WriteAStreamImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAStreamImpl");
    }
    if (WriteAStreamImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAStreamImpl");
    }
    WriteAStreamImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteAStreamImpl_expected_values_;

  void ExpectWriteAStreamImpl (int32_t const& value) {
    WriteAStreamImpl_expected_values_.push(value);
  }

  void EndAStreamImpl () override {
    if (--EndAStreamImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndAStreamImpl");
    }
  }

  int EndAStreamImpl_expected_call_count_ = 0;

  void ExpectEndAStreamImpl () {
    EndAStreamImpl_expected_call_count_++;
  }

  void WriteAnotherIntImpl (int32_t const& value) override {
    if (WriteAnotherIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAnotherIntImpl");
    }
    if (WriteAnotherIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAnotherIntImpl");
    }
    WriteAnotherIntImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteAnotherIntImpl_expected_values_;

  void ExpectWriteAnotherIntImpl (int32_t const& value) {
    WriteAnotherIntImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteAnIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAnIntImpl was not received");
    }
    if (!WriteAStreamImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAStreamImpl was not received");
    }
    if (EndAStreamImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndAStreamImpl was not received");
    }
    if (!WriteAnotherIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAnotherIntImpl was not received");
    }
  }
};

class TestStateTestWriterBase : public StateTestWriterBase {
  public:
  TestStateTestWriterBase(std::unique_ptr<test_model::StateTestWriterBase> writer, std::function<std::unique_ptr<StateTestReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStateTestWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStateTestWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteAnIntImpl(int32_t const& value) override {
    writer_->WriteAnInt(value);
    mock_writer_.ExpectWriteAnIntImpl(value);
  }

  void WriteAStreamImpl(int32_t const& value) override {
    writer_->WriteAStream(value);
    mock_writer_.ExpectWriteAStreamImpl(value);
  }

  void WriteAStreamImpl(std::vector<int32_t> const& values) override {
    writer_->WriteAStream(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteAStreamImpl(v);
    }
  }

  void EndAStreamImpl() override {
    writer_->EndAStream();
    mock_writer_.ExpectEndAStreamImpl();
  }

  void WriteAnotherIntImpl(int32_t const& value) override {
    writer_->WriteAnotherInt(value);
    mock_writer_.ExpectWriteAnotherIntImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StateTestReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StateTestWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StateTestReaderBase>()> create_reader_;
  MockStateTestWriter mock_writer_;
  bool close_called_ = false;
};

class MockSimpleGenericsWriter : public SimpleGenericsWriterBase {
  public:
  void WriteFloatImageImpl (test_model::Image<float> const& value) override {
    if (WriteFloatImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatImageImpl");
    }
    if (WriteFloatImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatImageImpl");
    }
    WriteFloatImageImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<float>> WriteFloatImageImpl_expected_values_;

  void ExpectWriteFloatImageImpl (test_model::Image<float> const& value) {
    WriteFloatImageImpl_expected_values_.push(value);
  }

  void WriteIntImageImpl (test_model::Image<int32_t> const& value) override {
    if (WriteIntImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImageImpl");
    }
    if (WriteIntImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImageImpl");
    }
    WriteIntImageImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<int32_t>> WriteIntImageImpl_expected_values_;

  void ExpectWriteIntImageImpl (test_model::Image<int32_t> const& value) {
    WriteIntImageImpl_expected_values_.push(value);
  }

  void WriteIntImageAlternateSyntaxImpl (test_model::Image<int32_t> const& value) override {
    if (WriteIntImageAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImageAlternateSyntaxImpl");
    }
    if (WriteIntImageAlternateSyntaxImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImageAlternateSyntaxImpl");
    }
    WriteIntImageAlternateSyntaxImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<int32_t>> WriteIntImageAlternateSyntaxImpl_expected_values_;

  void ExpectWriteIntImageAlternateSyntaxImpl (test_model::Image<int32_t> const& value) {
    WriteIntImageAlternateSyntaxImpl_expected_values_.push(value);
  }

  void WriteStringImageImpl (test_model::Image<std::string> const& value) override {
    if (WriteStringImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStringImageImpl");
    }
    if (WriteStringImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStringImageImpl");
    }
    WriteStringImageImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<std::string>> WriteStringImageImpl_expected_values_;

  void ExpectWriteStringImageImpl (test_model::Image<std::string> const& value) {
    WriteStringImageImpl_expected_values_.push(value);
  }

  void WriteIntFloatTupleImpl (test_model::MyTuple<int32_t, float> const& value) override {
    if (WriteIntFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntFloatTupleImpl");
    }
    if (WriteIntFloatTupleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntFloatTupleImpl");
    }
    WriteIntFloatTupleImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<int32_t, float>> WriteIntFloatTupleImpl_expected_values_;

  void ExpectWriteIntFloatTupleImpl (test_model::MyTuple<int32_t, float> const& value) {
    WriteIntFloatTupleImpl_expected_values_.push(value);
  }

  void WriteFloatFloatTupleImpl (test_model::MyTuple<float, float> const& value) override {
    if (WriteFloatFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatFloatTupleImpl");
    }
    if (WriteFloatFloatTupleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatFloatTupleImpl");
    }
    WriteFloatFloatTupleImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<float, float>> WriteFloatFloatTupleImpl_expected_values_;

  void ExpectWriteFloatFloatTupleImpl (test_model::MyTuple<float, float> const& value) {
    WriteFloatFloatTupleImpl_expected_values_.push(value);
  }

  void WriteIntFloatTupleAlternateSyntaxImpl (test_model::MyTuple<int32_t, float> const& value) override {
    if (WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntFloatTupleAlternateSyntaxImpl");
    }
    if (WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntFloatTupleAlternateSyntaxImpl");
    }
    WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<int32_t, float>> WriteIntFloatTupleAlternateSyntaxImpl_expected_values_;

  void ExpectWriteIntFloatTupleAlternateSyntaxImpl (test_model::MyTuple<int32_t, float> const& value) {
    WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.push(value);
  }

  void WriteIntStringTupleImpl (test_model::MyTuple<int32_t, std::string> const& value) override {
    if (WriteIntStringTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntStringTupleImpl");
    }
    if (WriteIntStringTupleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntStringTupleImpl");
    }
    WriteIntStringTupleImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<int32_t, std::string>> WriteIntStringTupleImpl_expected_values_;

  void ExpectWriteIntStringTupleImpl (test_model::MyTuple<int32_t, std::string> const& value) {
    WriteIntStringTupleImpl_expected_values_.push(value);
  }

  void WriteStreamOfTypeVariantsImpl (std::variant<test_model::Image<float>, test_model::Image<double>> const& value) override {
    if (WriteStreamOfTypeVariantsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStreamOfTypeVariantsImpl");
    }
    if (WriteStreamOfTypeVariantsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStreamOfTypeVariantsImpl");
    }
    WriteStreamOfTypeVariantsImpl_expected_values_.pop();
  }

  std::queue<std::variant<test_model::Image<float>, test_model::Image<double>>> WriteStreamOfTypeVariantsImpl_expected_values_;

  void ExpectWriteStreamOfTypeVariantsImpl (std::variant<test_model::Image<float>, test_model::Image<double>> const& value) {
    WriteStreamOfTypeVariantsImpl_expected_values_.push(value);
  }

  void EndStreamOfTypeVariantsImpl () override {
    if (--EndStreamOfTypeVariantsImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndStreamOfTypeVariantsImpl");
    }
  }

  int EndStreamOfTypeVariantsImpl_expected_call_count_ = 0;

  void ExpectEndStreamOfTypeVariantsImpl () {
    EndStreamOfTypeVariantsImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteFloatImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatImageImpl was not received");
    }
    if (!WriteIntImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImageImpl was not received");
    }
    if (!WriteIntImageAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImageAlternateSyntaxImpl was not received");
    }
    if (!WriteStringImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStringImageImpl was not received");
    }
    if (!WriteIntFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntFloatTupleImpl was not received");
    }
    if (!WriteFloatFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatFloatTupleImpl was not received");
    }
    if (!WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntFloatTupleAlternateSyntaxImpl was not received");
    }
    if (!WriteIntStringTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntStringTupleImpl was not received");
    }
    if (!WriteStreamOfTypeVariantsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStreamOfTypeVariantsImpl was not received");
    }
    if (EndStreamOfTypeVariantsImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndStreamOfTypeVariantsImpl was not received");
    }
  }
};

class TestSimpleGenericsWriterBase : public SimpleGenericsWriterBase {
  public:
  TestSimpleGenericsWriterBase(std::unique_ptr<test_model::SimpleGenericsWriterBase> writer, std::function<std::unique_ptr<SimpleGenericsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestSimpleGenericsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestSimpleGenericsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloatImageImpl(test_model::Image<float> const& value) override {
    writer_->WriteFloatImage(value);
    mock_writer_.ExpectWriteFloatImageImpl(value);
  }

  void WriteIntImageImpl(test_model::Image<int32_t> const& value) override {
    writer_->WriteIntImage(value);
    mock_writer_.ExpectWriteIntImageImpl(value);
  }

  void WriteIntImageAlternateSyntaxImpl(test_model::Image<int32_t> const& value) override {
    writer_->WriteIntImageAlternateSyntax(value);
    mock_writer_.ExpectWriteIntImageAlternateSyntaxImpl(value);
  }

  void WriteStringImageImpl(test_model::Image<std::string> const& value) override {
    writer_->WriteStringImage(value);
    mock_writer_.ExpectWriteStringImageImpl(value);
  }

  void WriteIntFloatTupleImpl(test_model::MyTuple<int32_t, float> const& value) override {
    writer_->WriteIntFloatTuple(value);
    mock_writer_.ExpectWriteIntFloatTupleImpl(value);
  }

  void WriteFloatFloatTupleImpl(test_model::MyTuple<float, float> const& value) override {
    writer_->WriteFloatFloatTuple(value);
    mock_writer_.ExpectWriteFloatFloatTupleImpl(value);
  }

  void WriteIntFloatTupleAlternateSyntaxImpl(test_model::MyTuple<int32_t, float> const& value) override {
    writer_->WriteIntFloatTupleAlternateSyntax(value);
    mock_writer_.ExpectWriteIntFloatTupleAlternateSyntaxImpl(value);
  }

  void WriteIntStringTupleImpl(test_model::MyTuple<int32_t, std::string> const& value) override {
    writer_->WriteIntStringTuple(value);
    mock_writer_.ExpectWriteIntStringTupleImpl(value);
  }

  void WriteStreamOfTypeVariantsImpl(std::variant<test_model::Image<float>, test_model::Image<double>> const& value) override {
    writer_->WriteStreamOfTypeVariants(value);
    mock_writer_.ExpectWriteStreamOfTypeVariantsImpl(value);
  }

  void WriteStreamOfTypeVariantsImpl(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>> const& values) override {
    writer_->WriteStreamOfTypeVariants(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteStreamOfTypeVariantsImpl(v);
    }
  }

  void EndStreamOfTypeVariantsImpl() override {
    writer_->EndStreamOfTypeVariants();
    mock_writer_.ExpectEndStreamOfTypeVariantsImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<SimpleGenericsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 10);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::SimpleGenericsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::SimpleGenericsReaderBase>()> create_reader_;
  MockSimpleGenericsWriter mock_writer_;
  bool close_called_ = false;
};

class MockAdvancedGenericsWriter : public AdvancedGenericsWriterBase {
  public:
  void WriteIntImageImageImpl (test_model::Image<test_model::Image<float>> const& value) override {
    if (WriteIntImageImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImageImageImpl");
    }
    if (WriteIntImageImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImageImageImpl");
    }
    WriteIntImageImageImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<test_model::Image<float>>> WriteIntImageImageImpl_expected_values_;

  void ExpectWriteIntImageImageImpl (test_model::Image<test_model::Image<float>> const& value) {
    WriteIntImageImageImpl_expected_values_.push(value);
  }

  void WriteGenericRecord1Impl (test_model::GenericRecord<int32_t, std::string> const& value) override {
    if (WriteGenericRecord1Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteGenericRecord1Impl");
    }
    if (WriteGenericRecord1Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteGenericRecord1Impl");
    }
    WriteGenericRecord1Impl_expected_values_.pop();
  }

  std::queue<test_model::GenericRecord<int32_t, std::string>> WriteGenericRecord1Impl_expected_values_;

  void ExpectWriteGenericRecord1Impl (test_model::GenericRecord<int32_t, std::string> const& value) {
    WriteGenericRecord1Impl_expected_values_.push(value);
  }

  void WriteTupleOfOptionalsImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    if (WriteTupleOfOptionalsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleOfOptionalsImpl");
    }
    if (WriteTupleOfOptionalsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleOfOptionalsImpl");
    }
    WriteTupleOfOptionalsImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>> WriteTupleOfOptionalsImpl_expected_values_;

  void ExpectWriteTupleOfOptionalsImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
    WriteTupleOfOptionalsImpl_expected_values_.push(value);
  }

  void WriteTupleOfOptionalsAlternateSyntaxImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    if (WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleOfOptionalsAlternateSyntaxImpl");
    }
    if (WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleOfOptionalsAlternateSyntaxImpl");
    }
    WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>> WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_;

  void ExpectWriteTupleOfOptionalsAlternateSyntaxImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
    WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.push(value);
  }

  void WriteTupleOfVectorsImpl (test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) override {
    if (WriteTupleOfVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleOfVectorsImpl");
    }
    if (WriteTupleOfVectorsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleOfVectorsImpl");
    }
    WriteTupleOfVectorsImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<std::vector<int32_t>, std::vector<float>>> WriteTupleOfVectorsImpl_expected_values_;

  void ExpectWriteTupleOfVectorsImpl (test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) {
    WriteTupleOfVectorsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntImageImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImageImageImpl was not received");
    }
    if (!WriteGenericRecord1Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteGenericRecord1Impl was not received");
    }
    if (!WriteTupleOfOptionalsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleOfOptionalsImpl was not received");
    }
    if (!WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleOfOptionalsAlternateSyntaxImpl was not received");
    }
    if (!WriteTupleOfVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleOfVectorsImpl was not received");
    }
  }
};

class TestAdvancedGenericsWriterBase : public AdvancedGenericsWriterBase {
  public:
  TestAdvancedGenericsWriterBase(std::unique_ptr<test_model::AdvancedGenericsWriterBase> writer, std::function<std::unique_ptr<AdvancedGenericsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestAdvancedGenericsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestAdvancedGenericsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntImageImageImpl(test_model::Image<test_model::Image<float>> const& value) override {
    writer_->WriteIntImageImage(value);
    mock_writer_.ExpectWriteIntImageImageImpl(value);
  }

  void WriteGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string> const& value) override {
    writer_->WriteGenericRecord1(value);
    mock_writer_.ExpectWriteGenericRecord1Impl(value);
  }

  void WriteTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    writer_->WriteTupleOfOptionals(value);
    mock_writer_.ExpectWriteTupleOfOptionalsImpl(value);
  }

  void WriteTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    writer_->WriteTupleOfOptionalsAlternateSyntax(value);
    mock_writer_.ExpectWriteTupleOfOptionalsAlternateSyntaxImpl(value);
  }

  void WriteTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) override {
    writer_->WriteTupleOfVectors(value);
    mock_writer_.ExpectWriteTupleOfVectorsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<AdvancedGenericsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::AdvancedGenericsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::AdvancedGenericsReaderBase>()> create_reader_;
  MockAdvancedGenericsWriter mock_writer_;
  bool close_called_ = false;
};

class MockAliasesWriter : public AliasesWriterBase {
  public:
  void WriteAliasedStringImpl (test_model::AliasedString const& value) override {
    if (WriteAliasedStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedStringImpl");
    }
    if (WriteAliasedStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedStringImpl");
    }
    WriteAliasedStringImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedString> WriteAliasedStringImpl_expected_values_;

  void ExpectWriteAliasedStringImpl (test_model::AliasedString const& value) {
    WriteAliasedStringImpl_expected_values_.push(value);
  }

  void WriteAliasedEnumImpl (test_model::AliasedEnum const& value) override {
    if (WriteAliasedEnumImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedEnumImpl");
    }
    if (WriteAliasedEnumImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedEnumImpl");
    }
    WriteAliasedEnumImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedEnum> WriteAliasedEnumImpl_expected_values_;

  void ExpectWriteAliasedEnumImpl (test_model::AliasedEnum const& value) {
    WriteAliasedEnumImpl_expected_values_.push(value);
  }

  void WriteAliasedOpenGenericImpl (test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    if (WriteAliasedOpenGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedOpenGenericImpl");
    }
    if (WriteAliasedOpenGenericImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedOpenGenericImpl");
    }
    WriteAliasedOpenGenericImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>> WriteAliasedOpenGenericImpl_expected_values_;

  void ExpectWriteAliasedOpenGenericImpl (test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    WriteAliasedOpenGenericImpl_expected_values_.push(value);
  }

  void WriteAliasedClosedGenericImpl (test_model::AliasedClosedGeneric const& value) override {
    if (WriteAliasedClosedGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedClosedGenericImpl");
    }
    if (WriteAliasedClosedGenericImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedClosedGenericImpl");
    }
    WriteAliasedClosedGenericImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedClosedGeneric> WriteAliasedClosedGenericImpl_expected_values_;

  void ExpectWriteAliasedClosedGenericImpl (test_model::AliasedClosedGeneric const& value) {
    WriteAliasedClosedGenericImpl_expected_values_.push(value);
  }

  void WriteAliasedOptionalImpl (test_model::AliasedOptional const& value) override {
    if (WriteAliasedOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedOptionalImpl");
    }
    if (WriteAliasedOptionalImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedOptionalImpl");
    }
    WriteAliasedOptionalImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedOptional> WriteAliasedOptionalImpl_expected_values_;

  void ExpectWriteAliasedOptionalImpl (test_model::AliasedOptional const& value) {
    WriteAliasedOptionalImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericOptionalImpl (test_model::AliasedGenericOptional<float> const& value) override {
    if (WriteAliasedGenericOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericOptionalImpl");
    }
    if (WriteAliasedGenericOptionalImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericOptionalImpl");
    }
    WriteAliasedGenericOptionalImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericOptional<float>> WriteAliasedGenericOptionalImpl_expected_values_;

  void ExpectWriteAliasedGenericOptionalImpl (test_model::AliasedGenericOptional<float> const& value) {
    WriteAliasedGenericOptionalImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    if (WriteAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericUnion2Impl");
    }
    if (WriteAliasedGenericUnion2Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericUnion2Impl");
    }
    WriteAliasedGenericUnion2Impl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> WriteAliasedGenericUnion2Impl_expected_values_;

  void ExpectWriteAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    WriteAliasedGenericUnion2Impl_expected_values_.push(value);
  }

  void WriteAliasedGenericVectorImpl (test_model::AliasedGenericVector<float> const& value) override {
    if (WriteAliasedGenericVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericVectorImpl");
    }
    if (WriteAliasedGenericVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericVectorImpl");
    }
    WriteAliasedGenericVectorImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericVector<float>> WriteAliasedGenericVectorImpl_expected_values_;

  void ExpectWriteAliasedGenericVectorImpl (test_model::AliasedGenericVector<float> const& value) {
    WriteAliasedGenericVectorImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericFixedVectorImpl (test_model::AliasedGenericFixedVector<float> const& value) override {
    if (WriteAliasedGenericFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericFixedVectorImpl");
    }
    if (WriteAliasedGenericFixedVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericFixedVectorImpl");
    }
    WriteAliasedGenericFixedVectorImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericFixedVector<float>> WriteAliasedGenericFixedVectorImpl_expected_values_;

  void ExpectWriteAliasedGenericFixedVectorImpl (test_model::AliasedGenericFixedVector<float> const& value) {
    WriteAliasedGenericFixedVectorImpl_expected_values_.push(value);
  }

  void WriteStreamOfAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    if (WriteStreamOfAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStreamOfAliasedGenericUnion2Impl");
    }
    if (WriteStreamOfAliasedGenericUnion2Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStreamOfAliasedGenericUnion2Impl");
    }
    WriteStreamOfAliasedGenericUnion2Impl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> WriteStreamOfAliasedGenericUnion2Impl_expected_values_;

  void ExpectWriteStreamOfAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    WriteStreamOfAliasedGenericUnion2Impl_expected_values_.push(value);
  }

  void EndStreamOfAliasedGenericUnion2Impl () override {
    if (--EndStreamOfAliasedGenericUnion2Impl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndStreamOfAliasedGenericUnion2Impl");
    }
  }

  int EndStreamOfAliasedGenericUnion2Impl_expected_call_count_ = 0;

  void ExpectEndStreamOfAliasedGenericUnion2Impl () {
    EndStreamOfAliasedGenericUnion2Impl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteAliasedStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedStringImpl was not received");
    }
    if (!WriteAliasedEnumImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedEnumImpl was not received");
    }
    if (!WriteAliasedOpenGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedOpenGenericImpl was not received");
    }
    if (!WriteAliasedClosedGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedClosedGenericImpl was not received");
    }
    if (!WriteAliasedOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedOptionalImpl was not received");
    }
    if (!WriteAliasedGenericOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericOptionalImpl was not received");
    }
    if (!WriteAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericUnion2Impl was not received");
    }
    if (!WriteAliasedGenericVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericVectorImpl was not received");
    }
    if (!WriteAliasedGenericFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericFixedVectorImpl was not received");
    }
    if (!WriteStreamOfAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStreamOfAliasedGenericUnion2Impl was not received");
    }
    if (EndStreamOfAliasedGenericUnion2Impl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndStreamOfAliasedGenericUnion2Impl was not received");
    }
  }
};

class TestAliasesWriterBase : public AliasesWriterBase {
  public:
  TestAliasesWriterBase(std::unique_ptr<test_model::AliasesWriterBase> writer, std::function<std::unique_ptr<AliasesReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestAliasesWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestAliasesWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteAliasedStringImpl(test_model::AliasedString const& value) override {
    writer_->WriteAliasedString(value);
    mock_writer_.ExpectWriteAliasedStringImpl(value);
  }

  void WriteAliasedEnumImpl(test_model::AliasedEnum const& value) override {
    writer_->WriteAliasedEnum(value);
    mock_writer_.ExpectWriteAliasedEnumImpl(value);
  }

  void WriteAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    writer_->WriteAliasedOpenGeneric(value);
    mock_writer_.ExpectWriteAliasedOpenGenericImpl(value);
  }

  void WriteAliasedClosedGenericImpl(test_model::AliasedClosedGeneric const& value) override {
    writer_->WriteAliasedClosedGeneric(value);
    mock_writer_.ExpectWriteAliasedClosedGenericImpl(value);
  }

  void WriteAliasedOptionalImpl(test_model::AliasedOptional const& value) override {
    writer_->WriteAliasedOptional(value);
    mock_writer_.ExpectWriteAliasedOptionalImpl(value);
  }

  void WriteAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float> const& value) override {
    writer_->WriteAliasedGenericOptional(value);
    mock_writer_.ExpectWriteAliasedGenericOptionalImpl(value);
  }

  void WriteAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    writer_->WriteAliasedGenericUnion2(value);
    mock_writer_.ExpectWriteAliasedGenericUnion2Impl(value);
  }

  void WriteAliasedGenericVectorImpl(test_model::AliasedGenericVector<float> const& value) override {
    writer_->WriteAliasedGenericVector(value);
    mock_writer_.ExpectWriteAliasedGenericVectorImpl(value);
  }

  void WriteAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float> const& value) override {
    writer_->WriteAliasedGenericFixedVector(value);
    mock_writer_.ExpectWriteAliasedGenericFixedVectorImpl(value);
  }

  void WriteStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    writer_->WriteStreamOfAliasedGenericUnion2(value);
    mock_writer_.ExpectWriteStreamOfAliasedGenericUnion2Impl(value);
  }

  void WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) override {
    writer_->WriteStreamOfAliasedGenericUnion2(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteStreamOfAliasedGenericUnion2Impl(v);
    }
  }

  void EndStreamOfAliasedGenericUnion2Impl() override {
    writer_->EndStreamOfAliasedGenericUnion2();
    mock_writer_.ExpectEndStreamOfAliasedGenericUnion2Impl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<AliasesReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::AliasesWriterBase> writer_;
  std::function<std::unique_ptr<test_model::AliasesReaderBase>()> create_reader_;
  MockAliasesWriter mock_writer_;
  bool close_called_ = false;
};

class MockStreamsOfAliasedUnionsWriter : public StreamsOfAliasedUnionsWriterBase {
  public:
  void WriteIntOrSimpleRecordImpl (test_model::AliasedIntOrSimpleRecord const& value) override {
    if (WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrSimpleRecordImpl");
    }
    if (WriteIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrSimpleRecordImpl");
    }
    WriteIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedIntOrSimpleRecord> WriteIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteIntOrSimpleRecordImpl (test_model::AliasedIntOrSimpleRecord const& value) {
    WriteIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndIntOrSimpleRecordImpl () override {
    if (--EndIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntOrSimpleRecordImpl");
    }
  }

  int EndIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndIntOrSimpleRecordImpl () {
    EndIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void WriteNullableIntOrSimpleRecordImpl (test_model::AliasedNullableIntSimpleRecord const& value) override {
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNullableIntOrSimpleRecordImpl");
    }
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNullableIntOrSimpleRecordImpl");
    }
    WriteNullableIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedNullableIntSimpleRecord> WriteNullableIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteNullableIntOrSimpleRecordImpl (test_model::AliasedNullableIntSimpleRecord const& value) {
    WriteNullableIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndNullableIntOrSimpleRecordImpl () override {
    if (--EndNullableIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndNullableIntOrSimpleRecordImpl");
    }
  }

  int EndNullableIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndNullableIntOrSimpleRecordImpl () {
    EndNullableIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrSimpleRecordImpl was not received");
    }
    if (EndIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntOrSimpleRecordImpl was not received");
    }
    if (!WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNullableIntOrSimpleRecordImpl was not received");
    }
    if (EndNullableIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndNullableIntOrSimpleRecordImpl was not received");
    }
  }
};

class TestStreamsOfAliasedUnionsWriterBase : public StreamsOfAliasedUnionsWriterBase {
  public:
  TestStreamsOfAliasedUnionsWriterBase(std::unique_ptr<test_model::StreamsOfAliasedUnionsWriterBase> writer, std::function<std::unique_ptr<StreamsOfAliasedUnionsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStreamsOfAliasedUnionsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStreamsOfAliasedUnionsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord const& value) override {
    writer_->WriteIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteIntOrSimpleRecordImpl(value);
  }

  void WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) override {
    writer_->WriteIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntOrSimpleRecordImpl(v);
    }
  }

  void EndIntOrSimpleRecordImpl() override {
    writer_->EndIntOrSimpleRecord();
    mock_writer_.ExpectEndIntOrSimpleRecordImpl();
  }

  void WriteNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord const& value) override {
    writer_->WriteNullableIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(value);
  }

  void WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) override {
    writer_->WriteNullableIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(v);
    }
  }

  void EndNullableIntOrSimpleRecordImpl() override {
    writer_->EndNullableIntOrSimpleRecord();
    mock_writer_.ExpectEndNullableIntOrSimpleRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StreamsOfAliasedUnionsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StreamsOfAliasedUnionsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StreamsOfAliasedUnionsReaderBase>()> create_reader_;
  MockStreamsOfAliasedUnionsWriter mock_writer_;
  bool close_called_ = false;
};

class MockProtocolWithComputedFieldsWriter : public ProtocolWithComputedFieldsWriterBase {
  public:
  void WriteRecordWithComputedFieldsImpl (test_model::RecordWithComputedFields const& value) override {
    if (WriteRecordWithComputedFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithComputedFieldsImpl");
    }
    if (WriteRecordWithComputedFieldsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithComputedFieldsImpl");
    }
    WriteRecordWithComputedFieldsImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithComputedFields> WriteRecordWithComputedFieldsImpl_expected_values_;

  void ExpectWriteRecordWithComputedFieldsImpl (test_model::RecordWithComputedFields const& value) {
    WriteRecordWithComputedFieldsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteRecordWithComputedFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithComputedFieldsImpl was not received");
    }
  }
};

class TestProtocolWithComputedFieldsWriterBase : public ProtocolWithComputedFieldsWriterBase {
  public:
  TestProtocolWithComputedFieldsWriterBase(std::unique_ptr<test_model::ProtocolWithComputedFieldsWriterBase> writer, std::function<std::unique_ptr<ProtocolWithComputedFieldsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestProtocolWithComputedFieldsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestProtocolWithComputedFieldsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields const& value) override {
    writer_->WriteRecordWithComputedFields(value);
    mock_writer_.ExpectWriteRecordWithComputedFieldsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ProtocolWithComputedFieldsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ProtocolWithComputedFieldsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ProtocolWithComputedFieldsReaderBase>()> create_reader_;
  MockProtocolWithComputedFieldsWriter mock_writer_;
  bool close_called_ = false;
};

class MockProtocolWithKeywordStepsWriter : public ProtocolWithKeywordStepsWriterBase {
  public:
  void WriteIntImpl (test_model::RecordWithKeywordFields const& value) override {
    if (WriteIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImpl");
    }
    if (WriteIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImpl");
    }
    WriteIntImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithKeywordFields> WriteIntImpl_expected_values_;

  void ExpectWriteIntImpl (test_model::RecordWithKeywordFields const& value) {
    WriteIntImpl_expected_values_.push(value);
  }

  void EndIntImpl () override {
    if (--EndIntImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntImpl");
    }
  }

  int EndIntImpl_expected_call_count_ = 0;

  void ExpectEndIntImpl () {
    EndIntImpl_expected_call_count_++;
  }

  void WriteFloatImpl (test_model::EnumWithKeywordSymbols const& value) override {
    if (WriteFloatImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatImpl");
    }
    if (WriteFloatImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatImpl");
    }
    WriteFloatImpl_expected_values_.pop();
  }

  std::queue<test_model::EnumWithKeywordSymbols> WriteFloatImpl_expected_values_;

  void ExpectWriteFloatImpl (test_model::EnumWithKeywordSymbols const& value) {
    WriteFloatImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImpl was not received");
    }
    if (EndIntImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntImpl was not received");
    }
    if (!WriteFloatImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatImpl was not received");
    }
  }
};

class TestProtocolWithKeywordStepsWriterBase : public ProtocolWithKeywordStepsWriterBase {
  public:
  TestProtocolWithKeywordStepsWriterBase(std::unique_ptr<test_model::ProtocolWithKeywordStepsWriterBase> writer, std::function<std::unique_ptr<ProtocolWithKeywordStepsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestProtocolWithKeywordStepsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestProtocolWithKeywordStepsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntImpl(test_model::RecordWithKeywordFields const& value) override {
    writer_->WriteInt(value);
    mock_writer_.ExpectWriteIntImpl(value);
  }

  void WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& values) override {
    writer_->WriteInt(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntImpl(v);
    }
  }

  void EndIntImpl() override {
    writer_->EndInt();
    mock_writer_.ExpectEndIntImpl();
  }

  void WriteFloatImpl(test_model::EnumWithKeywordSymbols const& value) override {
    writer_->WriteFloat(value);
    mock_writer_.ExpectWriteFloatImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ProtocolWithKeywordStepsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ProtocolWithKeywordStepsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ProtocolWithKeywordStepsReaderBase>()> create_reader_;
  MockProtocolWithKeywordStepsWriter mock_writer_;
  bool close_called_ = false;
};
} // namespace
} // namespace test_model

namespace yardl::testing {
template<>
std::unique_ptr<test_model::BenchmarkFloat256x256WriterBase> CreateValidatingWriter<test_model::BenchmarkFloat256x256WriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestBenchmarkFloat256x256WriterBase>(std::make_unique<test_model::hdf5::BenchmarkFloat256x256Writer>(filename), [filename](){ return std::make_unique<test_model::hdf5::BenchmarkFloat256x256Reader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestBenchmarkFloat256x256WriterBase>(std::make_unique<test_model::binary::BenchmarkFloat256x256Writer>(filename), [filename](){return std::make_unique<test_model::binary::BenchmarkFloat256x256Reader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::BenchmarkFloatVlenWriterBase> CreateValidatingWriter<test_model::BenchmarkFloatVlenWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestBenchmarkFloatVlenWriterBase>(std::make_unique<test_model::hdf5::BenchmarkFloatVlenWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::BenchmarkFloatVlenReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestBenchmarkFloatVlenWriterBase>(std::make_unique<test_model::binary::BenchmarkFloatVlenWriter>(filename), [filename](){return std::make_unique<test_model::binary::BenchmarkFloatVlenReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::BenchmarkSmallRecordWriterBase> CreateValidatingWriter<test_model::BenchmarkSmallRecordWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestBenchmarkSmallRecordWriterBase>(std::make_unique<test_model::hdf5::BenchmarkSmallRecordWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::BenchmarkSmallRecordReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestBenchmarkSmallRecordWriterBase>(std::make_unique<test_model::binary::BenchmarkSmallRecordWriter>(filename), [filename](){return std::make_unique<test_model::binary::BenchmarkSmallRecordReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsWriterBase> CreateValidatingWriter<test_model::BenchmarkSmallRecordWithOptionalsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestBenchmarkSmallRecordWithOptionalsWriterBase>(std::make_unique<test_model::hdf5::BenchmarkSmallRecordWithOptionalsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::BenchmarkSmallRecordWithOptionalsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestBenchmarkSmallRecordWithOptionalsWriterBase>(std::make_unique<test_model::binary::BenchmarkSmallRecordWithOptionalsWriter>(filename), [filename](){return std::make_unique<test_model::binary::BenchmarkSmallRecordWithOptionalsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::BenchmarkSimpleMrdWriterBase> CreateValidatingWriter<test_model::BenchmarkSimpleMrdWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestBenchmarkSimpleMrdWriterBase>(std::make_unique<test_model::hdf5::BenchmarkSimpleMrdWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::BenchmarkSimpleMrdReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestBenchmarkSimpleMrdWriterBase>(std::make_unique<test_model::binary::BenchmarkSimpleMrdWriter>(filename), [filename](){return std::make_unique<test_model::binary::BenchmarkSimpleMrdReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::ScalarsWriterBase> CreateValidatingWriter<test_model::ScalarsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestScalarsWriterBase>(std::make_unique<test_model::hdf5::ScalarsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::ScalarsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestScalarsWriterBase>(std::make_unique<test_model::binary::ScalarsWriter>(filename), [filename](){return std::make_unique<test_model::binary::ScalarsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::ScalarOptionalsWriterBase> CreateValidatingWriter<test_model::ScalarOptionalsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestScalarOptionalsWriterBase>(std::make_unique<test_model::hdf5::ScalarOptionalsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::ScalarOptionalsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestScalarOptionalsWriterBase>(std::make_unique<test_model::binary::ScalarOptionalsWriter>(filename), [filename](){return std::make_unique<test_model::binary::ScalarOptionalsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::NestedRecordsWriterBase> CreateValidatingWriter<test_model::NestedRecordsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestNestedRecordsWriterBase>(std::make_unique<test_model::hdf5::NestedRecordsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::NestedRecordsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestNestedRecordsWriterBase>(std::make_unique<test_model::binary::NestedRecordsWriter>(filename), [filename](){return std::make_unique<test_model::binary::NestedRecordsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::VlensWriterBase> CreateValidatingWriter<test_model::VlensWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestVlensWriterBase>(std::make_unique<test_model::hdf5::VlensWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::VlensReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestVlensWriterBase>(std::make_unique<test_model::binary::VlensWriter>(filename), [filename](){return std::make_unique<test_model::binary::VlensReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::StringsWriterBase> CreateValidatingWriter<test_model::StringsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestStringsWriterBase>(std::make_unique<test_model::hdf5::StringsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::StringsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestStringsWriterBase>(std::make_unique<test_model::binary::StringsWriter>(filename), [filename](){return std::make_unique<test_model::binary::StringsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::OptionalVectorsWriterBase> CreateValidatingWriter<test_model::OptionalVectorsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestOptionalVectorsWriterBase>(std::make_unique<test_model::hdf5::OptionalVectorsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::OptionalVectorsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestOptionalVectorsWriterBase>(std::make_unique<test_model::binary::OptionalVectorsWriter>(filename), [filename](){return std::make_unique<test_model::binary::OptionalVectorsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::FixedVectorsWriterBase> CreateValidatingWriter<test_model::FixedVectorsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestFixedVectorsWriterBase>(std::make_unique<test_model::hdf5::FixedVectorsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::FixedVectorsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestFixedVectorsWriterBase>(std::make_unique<test_model::binary::FixedVectorsWriter>(filename), [filename](){return std::make_unique<test_model::binary::FixedVectorsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::StreamsWriterBase> CreateValidatingWriter<test_model::StreamsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestStreamsWriterBase>(std::make_unique<test_model::hdf5::StreamsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::StreamsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestStreamsWriterBase>(std::make_unique<test_model::binary::StreamsWriter>(filename), [filename](){return std::make_unique<test_model::binary::StreamsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::FixedArraysWriterBase> CreateValidatingWriter<test_model::FixedArraysWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestFixedArraysWriterBase>(std::make_unique<test_model::hdf5::FixedArraysWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::FixedArraysReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestFixedArraysWriterBase>(std::make_unique<test_model::binary::FixedArraysWriter>(filename), [filename](){return std::make_unique<test_model::binary::FixedArraysReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::NDArraysWriterBase> CreateValidatingWriter<test_model::NDArraysWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestNDArraysWriterBase>(std::make_unique<test_model::hdf5::NDArraysWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::NDArraysReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestNDArraysWriterBase>(std::make_unique<test_model::binary::NDArraysWriter>(filename), [filename](){return std::make_unique<test_model::binary::NDArraysReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::NDArraysSingleDimensionWriterBase> CreateValidatingWriter<test_model::NDArraysSingleDimensionWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestNDArraysSingleDimensionWriterBase>(std::make_unique<test_model::hdf5::NDArraysSingleDimensionWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::NDArraysSingleDimensionReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestNDArraysSingleDimensionWriterBase>(std::make_unique<test_model::binary::NDArraysSingleDimensionWriter>(filename), [filename](){return std::make_unique<test_model::binary::NDArraysSingleDimensionReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::DynamicNDArraysWriterBase> CreateValidatingWriter<test_model::DynamicNDArraysWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestDynamicNDArraysWriterBase>(std::make_unique<test_model::hdf5::DynamicNDArraysWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::DynamicNDArraysReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestDynamicNDArraysWriterBase>(std::make_unique<test_model::binary::DynamicNDArraysWriter>(filename), [filename](){return std::make_unique<test_model::binary::DynamicNDArraysReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::UnionsWriterBase> CreateValidatingWriter<test_model::UnionsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestUnionsWriterBase>(std::make_unique<test_model::hdf5::UnionsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::UnionsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestUnionsWriterBase>(std::make_unique<test_model::binary::UnionsWriter>(filename), [filename](){return std::make_unique<test_model::binary::UnionsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::StreamsOfUnionsWriterBase> CreateValidatingWriter<test_model::StreamsOfUnionsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestStreamsOfUnionsWriterBase>(std::make_unique<test_model::hdf5::StreamsOfUnionsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::StreamsOfUnionsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestStreamsOfUnionsWriterBase>(std::make_unique<test_model::binary::StreamsOfUnionsWriter>(filename), [filename](){return std::make_unique<test_model::binary::StreamsOfUnionsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::EnumsWriterBase> CreateValidatingWriter<test_model::EnumsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestEnumsWriterBase>(std::make_unique<test_model::hdf5::EnumsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::EnumsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestEnumsWriterBase>(std::make_unique<test_model::binary::EnumsWriter>(filename), [filename](){return std::make_unique<test_model::binary::EnumsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::StateTestWriterBase> CreateValidatingWriter<test_model::StateTestWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestStateTestWriterBase>(std::make_unique<test_model::hdf5::StateTestWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::StateTestReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestStateTestWriterBase>(std::make_unique<test_model::binary::StateTestWriter>(filename), [filename](){return std::make_unique<test_model::binary::StateTestReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::SimpleGenericsWriterBase> CreateValidatingWriter<test_model::SimpleGenericsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestSimpleGenericsWriterBase>(std::make_unique<test_model::hdf5::SimpleGenericsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::SimpleGenericsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestSimpleGenericsWriterBase>(std::make_unique<test_model::binary::SimpleGenericsWriter>(filename), [filename](){return std::make_unique<test_model::binary::SimpleGenericsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::AdvancedGenericsWriterBase> CreateValidatingWriter<test_model::AdvancedGenericsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestAdvancedGenericsWriterBase>(std::make_unique<test_model::hdf5::AdvancedGenericsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::AdvancedGenericsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestAdvancedGenericsWriterBase>(std::make_unique<test_model::binary::AdvancedGenericsWriter>(filename), [filename](){return std::make_unique<test_model::binary::AdvancedGenericsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::AliasesWriterBase> CreateValidatingWriter<test_model::AliasesWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestAliasesWriterBase>(std::make_unique<test_model::hdf5::AliasesWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::AliasesReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestAliasesWriterBase>(std::make_unique<test_model::binary::AliasesWriter>(filename), [filename](){return std::make_unique<test_model::binary::AliasesReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::StreamsOfAliasedUnionsWriterBase> CreateValidatingWriter<test_model::StreamsOfAliasedUnionsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestStreamsOfAliasedUnionsWriterBase>(std::make_unique<test_model::hdf5::StreamsOfAliasedUnionsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::StreamsOfAliasedUnionsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestStreamsOfAliasedUnionsWriterBase>(std::make_unique<test_model::binary::StreamsOfAliasedUnionsWriter>(filename), [filename](){return std::make_unique<test_model::binary::StreamsOfAliasedUnionsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::ProtocolWithComputedFieldsWriterBase> CreateValidatingWriter<test_model::ProtocolWithComputedFieldsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestProtocolWithComputedFieldsWriterBase>(std::make_unique<test_model::hdf5::ProtocolWithComputedFieldsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::ProtocolWithComputedFieldsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestProtocolWithComputedFieldsWriterBase>(std::make_unique<test_model::binary::ProtocolWithComputedFieldsWriter>(filename), [filename](){return std::make_unique<test_model::binary::ProtocolWithComputedFieldsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

template<>
std::unique_ptr<test_model::ProtocolWithKeywordStepsWriterBase> CreateValidatingWriter<test_model::ProtocolWithKeywordStepsWriterBase>(Format format, std::string const& filename) {
  switch (format) {
  case Format::kHdf5:
    return std::make_unique<test_model::TestProtocolWithKeywordStepsWriterBase>(std::make_unique<test_model::hdf5::ProtocolWithKeywordStepsWriter>(filename), [filename](){ return std::make_unique<test_model::hdf5::ProtocolWithKeywordStepsReader>(filename);});
  case Format::kBinary:
    return std::make_unique<test_model::TestProtocolWithKeywordStepsWriterBase>(std::make_unique<test_model::binary::ProtocolWithKeywordStepsWriter>(filename), [filename](){return std::make_unique<test_model::binary::ProtocolWithKeywordStepsReader>(filename);});
  default:
    throw std::runtime_error("Unknown format");
  }
}

}
