// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "../yardl/detail/ndjson/serializers.h"
#include "protocols.h"

namespace sketch {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, sketch::BinaryTree const& value);
void from_json(ordered_json const& j, sketch::BinaryTree& value);

template <typename T>
void to_json(ordered_json& j, sketch::LinkedList<T> const& value);
template <typename T>
void from_json(ordered_json const& j, sketch::LinkedList<T>& value);

void to_json(ordered_json& j, sketch::File const& value);
void from_json(ordered_json const& j, sketch::File& value);

void to_json(ordered_json& j, sketch::Directory const& value);
void from_json(ordered_json const& j, sketch::Directory& value);

} // namespace sketch

NLOHMANN_JSON_NAMESPACE_BEGIN

template <>
struct adl_serializer<std::variant<sketch::File, std::unique_ptr<sketch::Directory>>> {
  static void to_json(ordered_json& j, std::variant<sketch::File, std::unique_ptr<sketch::Directory>> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"File", std::get<sketch::File>(value)} };
        break;
      case 1:
        j = ordered_json{ {"Directory", std::get<std::unique_ptr<sketch::Directory>>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<sketch::File, std::unique_ptr<sketch::Directory>>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "File") {
      value = it.value().get<sketch::File>();
      return;
    }
    if (tag == "Directory") {
      value = it.value().get<std::unique_ptr<sketch::Directory>>();
      return;
    }
  }
};

NLOHMANN_JSON_NAMESPACE_END

namespace sketch {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, sketch::BinaryTree const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.value)) {
    j.push_back({"value", value.value});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.left)) {
    j.push_back({"left", value.left});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.right)) {
    j.push_back({"right", value.right});
  }
}

void from_json(ordered_json const& j, sketch::BinaryTree& value) {
  if (auto it = j.find("value"); it != j.end()) {
    it->get_to(value.value);
  }
  if (auto it = j.find("left"); it != j.end()) {
    it->get_to(value.left);
  }
  if (auto it = j.find("right"); it != j.end()) {
    it->get_to(value.right);
  }
}

template <typename T>
void to_json(ordered_json& j, sketch::LinkedList<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.value)) {
    j.push_back({"value", value.value});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.next)) {
    j.push_back({"next", value.next});
  }
}

template <typename T>
void from_json(ordered_json const& j, sketch::LinkedList<T>& value) {
  if (auto it = j.find("value"); it != j.end()) {
    it->get_to(value.value);
  }
  if (auto it = j.find("next"); it != j.end()) {
    it->get_to(value.next);
  }
}

void to_json(ordered_json& j, sketch::File const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
}

void from_json(ordered_json const& j, sketch::File& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
}

void to_json(ordered_json& j, sketch::Directory const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.entries)) {
    j.push_back({"entries", value.entries});
  }
}

void from_json(ordered_json const& j, sketch::Directory& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("entries"); it != j.end()) {
    it->get_to(value.entries);
  }
}

} // namespace sketch

namespace sketch::ndjson {
void MyProtocolWriter::WriteTreeImpl(sketch::BinaryTree const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "tree", json_value);}

void MyProtocolWriter::WritePtreeImpl(std::unique_ptr<sketch::BinaryTree> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "ptree", json_value);}

void MyProtocolWriter::WriteListImpl(std::optional<sketch::LinkedList<std::string>> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "list", json_value);}

void MyProtocolWriter::WriteCwdImpl(sketch::DirectoryEntry const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "cwd", json_value);}

void MyProtocolWriter::Flush() {
  stream_.flush();
}

void MyProtocolWriter::CloseImpl() {
  stream_.flush();
}

void MyProtocolReader::ReadTreeImpl(sketch::BinaryTree& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "tree", true, unused_step_, value);
}

void MyProtocolReader::ReadPtreeImpl(std::unique_ptr<sketch::BinaryTree>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "ptree", true, unused_step_, value);
}

void MyProtocolReader::ReadListImpl(std::optional<sketch::LinkedList<std::string>>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "list", true, unused_step_, value);
}

bool MyProtocolReader::ReadCwdImpl(sketch::DirectoryEntry& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "cwd", false, unused_step_, value);
}

void MyProtocolReader::CloseImpl() {
  VerifyFinished();
}

} // namespace sketch::ndjson

