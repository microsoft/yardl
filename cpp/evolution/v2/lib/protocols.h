// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include "types.h"

namespace evo_test {
enum class Version {
  v0,
  v1,
  Latest
};
// Abstract writer for the MyProtocol protocol.
class MyProtocolWriterBase {
  public:
  // Ordinal 0.
  void WriteHeader(evo_test::Header const& value);

  // Ordinal 1.
  void WriteId(std::string const& value);

  // Ordinal 2.
  // Call this method for each element of the `samples` stream, then call `EndSamples() when done.`
  void WriteSamples(evo_test::Sample const& value);

  // Ordinal 2.
  // Call this method to write many values to the `samples` stream, then call `EndSamples()` when done.
  void WriteSamples(std::vector<evo_test::Sample> const& values);

  // Marks the end of the `samples` stream.
  void EndSamples();

  // Ordinal 3.
  void WriteMaybe(std::optional<std::string> const& value);

  // Ordinal 4.
  void WriteFooter(std::optional<evo_test::Footer> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~MyProtocolWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteHeaderImpl(evo_test::Header const& value) = 0;
  virtual void WriteIdImpl(std::string const& value) = 0;
  virtual void WriteSamplesImpl(evo_test::Sample const& value) = 0;
  virtual void WriteSamplesImpl(std::vector<evo_test::Sample> const& value);
  virtual void EndSamplesImpl() = 0;
  virtual void WriteMaybeImpl(std::optional<std::string> const& value) = 0;
  virtual void WriteFooterImpl(std::optional<evo_test::Footer> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class MyProtocolReaderBase;
};

// Abstract reader for the MyProtocol protocol.
class MyProtocolReaderBase {
  public:
  // Ordinal 0.
  void ReadHeader(evo_test::Header& value);

  // Ordinal 1.
  void ReadId(std::string& value);

  // Ordinal 2.
  [[nodiscard]] bool ReadSamples(evo_test::Sample& value);

  // Ordinal 2.
  [[nodiscard]] bool ReadSamples(std::vector<evo_test::Sample>& values);

  // Ordinal 3.
  void ReadMaybe(std::optional<std::string>& value);

  // Ordinal 4.
  void ReadFooter(std::optional<evo_test::Footer>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(MyProtocolWriterBase& writer, size_t samples_buffer_size = 1);

  virtual ~MyProtocolReaderBase() = default;

  protected:
  virtual void ReadHeaderImpl(evo_test::Header& value) = 0;
  virtual void ReadIdImpl(std::string& value) = 0;
  virtual bool ReadSamplesImpl(evo_test::Sample& value) = 0;
  virtual bool ReadSamplesImpl(std::vector<evo_test::Sample>& values);
  virtual void ReadMaybeImpl(std::optional<std::string>& value) = 0;
  virtual void ReadFooterImpl(std::optional<evo_test::Footer>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the NewProtocol protocol.
class NewProtocolWriterBase {
  public:
  // Ordinal 0.
  void WriteCalibration(std::vector<double> const& value);

  // Ordinal 1.
  // Call this method for each element of the `data` stream, then call `EndData() when done.`
  void WriteData(evo_test::NewRecord const& value);

  // Ordinal 1.
  // Call this method to write many values to the `data` stream, then call `EndData()` when done.
  void WriteData(std::vector<evo_test::NewRecord> const& values);

  // Marks the end of the `data` stream.
  void EndData();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~NewProtocolWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteCalibrationImpl(std::vector<double> const& value) = 0;
  virtual void WriteDataImpl(evo_test::NewRecord const& value) = 0;
  virtual void WriteDataImpl(std::vector<evo_test::NewRecord> const& value);
  virtual void EndDataImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class NewProtocolReaderBase;
};

// Abstract reader for the NewProtocol protocol.
class NewProtocolReaderBase {
  public:
  // Ordinal 0.
  void ReadCalibration(std::vector<double>& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadData(evo_test::NewRecord& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadData(std::vector<evo_test::NewRecord>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(NewProtocolWriterBase& writer, size_t data_buffer_size = 1);

  virtual ~NewProtocolReaderBase() = default;

  protected:
  virtual void ReadCalibrationImpl(std::vector<double>& value) = 0;
  virtual bool ReadDataImpl(evo_test::NewRecord& value) = 0;
  virtual bool ReadDataImpl(std::vector<evo_test::NewRecord>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  private:
  uint8_t state_ = 0;
};
} // namespace evo_test
