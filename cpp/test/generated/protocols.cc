// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#ifdef _MSC_VER
#define unlikely(x) x
#else
#define unlikely(x) __builtin_expect((x), 0)
#endif

namespace test_model {
namespace {
void BenchmarkFloat256x256WriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloat256x256() or EndFloat256x256()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndFloat256x256()" : "WriteFloat256x256()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkFloat256x256ReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloat256x256()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkFloat256x256WriterBase::schema_ = R"({"protocol":{"name":"BenchmarkFloat256x256","sequence":[{"name":"float256x256","type":{"stream":{"items":{"array":{"items":"float32","dimensions":[{"length":256},{"length":256}]}}}}}]},"types":null})";

std::vector<std::string> BenchmarkFloat256x256WriterBase::previous_schemas_ = {
};

std::string BenchmarkFloat256x256WriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return BenchmarkFloat256x256WriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol BenchmarkFloat256x256.");
  }

}
void BenchmarkFloat256x256WriterBase::WriteFloat256x256(yardl::FixedNDArray<float, 256, 256> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloat256x256WriterBaseInvalidState(0, false, state_);
  }

  WriteFloat256x256Impl(value);
}

void BenchmarkFloat256x256WriterBase::WriteFloat256x256(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloat256x256WriterBaseInvalidState(0, false, state_);
  }

  WriteFloat256x256Impl(values);
}

void BenchmarkFloat256x256WriterBase::EndFloat256x256() {
  if (unlikely(state_ != 0)) {
    BenchmarkFloat256x256WriterBaseInvalidState(0, true, state_);
  }

  EndFloat256x256Impl();
  state_ = 1;
}

// fallback implementation
void BenchmarkFloat256x256WriterBase::WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) {
  for (auto const& v : values) {
    WriteFloat256x256Impl(v);
  }
}

void BenchmarkFloat256x256WriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkFloat256x256WriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkFloat256x256ReaderBase::schema_ = BenchmarkFloat256x256WriterBase::schema_;

std::vector<std::string> BenchmarkFloat256x256ReaderBase::previous_schemas_ = BenchmarkFloat256x256WriterBase::previous_schemas_;

Version BenchmarkFloat256x256ReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == BenchmarkFloat256x256WriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol BenchmarkFloat256x256.");
}
bool BenchmarkFloat256x256ReaderBase::ReadFloat256x256(yardl::FixedNDArray<float, 256, 256>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkFloat256x256ReaderBaseInvalidState(0, state_);
  }

  bool result = ReadFloat256x256Impl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkFloat256x256ReaderBase::ReadFloat256x256(std::vector<yardl::FixedNDArray<float, 256, 256>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkFloat256x256ReaderBaseInvalidState(0, state_);
  }

  if (!ReadFloat256x256Impl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool BenchmarkFloat256x256ReaderBase::ReadFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFloat256x256Impl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkFloat256x256ReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      BenchmarkFloat256x256ReaderBaseInvalidState(2, state_);
    }
  }

  CloseImpl();
}
void BenchmarkFloat256x256ReaderBase::CopyTo(BenchmarkFloat256x256WriterBase& writer, size_t float256x256_buffer_size) {
  if (float256x256_buffer_size > 1) {
    std::vector<yardl::FixedNDArray<float, 256, 256>> values;
    values.reserve(float256x256_buffer_size);
    while(ReadFloat256x256(values)) {
      writer.WriteFloat256x256(values);
    }
    writer.EndFloat256x256();
  } else {
    yardl::FixedNDArray<float, 256, 256> value;
    while(ReadFloat256x256(value)) {
      writer.WriteFloat256x256(value);
    }
    writer.EndFloat256x256();
  }
}

namespace {
void BenchmarkInt256x256WriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInt256x256() or EndInt256x256()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndInt256x256()" : "WriteInt256x256()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkInt256x256ReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInt256x256()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkInt256x256WriterBase::schema_ = R"({"protocol":{"name":"BenchmarkInt256x256","sequence":[{"name":"int256x256","type":{"stream":{"items":{"array":{"items":"int32","dimensions":[{"length":256},{"length":256}]}}}}}]},"types":null})";

std::vector<std::string> BenchmarkInt256x256WriterBase::previous_schemas_ = {
};

std::string BenchmarkInt256x256WriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return BenchmarkInt256x256WriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol BenchmarkInt256x256.");
  }

}
void BenchmarkInt256x256WriterBase::WriteInt256x256(yardl::FixedNDArray<int32_t, 256, 256> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkInt256x256WriterBaseInvalidState(0, false, state_);
  }

  WriteInt256x256Impl(value);
}

void BenchmarkInt256x256WriterBase::WriteInt256x256(std::vector<yardl::FixedNDArray<int32_t, 256, 256>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkInt256x256WriterBaseInvalidState(0, false, state_);
  }

  WriteInt256x256Impl(values);
}

void BenchmarkInt256x256WriterBase::EndInt256x256() {
  if (unlikely(state_ != 0)) {
    BenchmarkInt256x256WriterBaseInvalidState(0, true, state_);
  }

  EndInt256x256Impl();
  state_ = 1;
}

// fallback implementation
void BenchmarkInt256x256WriterBase::WriteInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>> const& values) {
  for (auto const& v : values) {
    WriteInt256x256Impl(v);
  }
}

void BenchmarkInt256x256WriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkInt256x256WriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkInt256x256ReaderBase::schema_ = BenchmarkInt256x256WriterBase::schema_;

std::vector<std::string> BenchmarkInt256x256ReaderBase::previous_schemas_ = BenchmarkInt256x256WriterBase::previous_schemas_;

Version BenchmarkInt256x256ReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == BenchmarkInt256x256WriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol BenchmarkInt256x256.");
}
bool BenchmarkInt256x256ReaderBase::ReadInt256x256(yardl::FixedNDArray<int32_t, 256, 256>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkInt256x256ReaderBaseInvalidState(0, state_);
  }

  bool result = ReadInt256x256Impl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkInt256x256ReaderBase::ReadInt256x256(std::vector<yardl::FixedNDArray<int32_t, 256, 256>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkInt256x256ReaderBaseInvalidState(0, state_);
  }

  if (!ReadInt256x256Impl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool BenchmarkInt256x256ReaderBase::ReadInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadInt256x256Impl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkInt256x256ReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      BenchmarkInt256x256ReaderBaseInvalidState(2, state_);
    }
  }

  CloseImpl();
}
void BenchmarkInt256x256ReaderBase::CopyTo(BenchmarkInt256x256WriterBase& writer, size_t int256x256_buffer_size) {
  if (int256x256_buffer_size > 1) {
    std::vector<yardl::FixedNDArray<int32_t, 256, 256>> values;
    values.reserve(int256x256_buffer_size);
    while(ReadInt256x256(values)) {
      writer.WriteInt256x256(values);
    }
    writer.EndInt256x256();
  } else {
    yardl::FixedNDArray<int32_t, 256, 256> value;
    while(ReadInt256x256(value)) {
      writer.WriteInt256x256(value);
    }
    writer.EndInt256x256();
  }
}

namespace {
void BenchmarkFloatVlenWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloatArray() or EndFloatArray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndFloatArray()" : "WriteFloatArray()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkFloatVlenReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloatArray()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkFloatVlenWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkFloatVlen","sequence":[{"name":"floatArray","type":{"stream":{"items":{"array":{"items":"float32","dimensions":2}}}}}]},"types":null})";

std::vector<std::string> BenchmarkFloatVlenWriterBase::previous_schemas_ = {
};

std::string BenchmarkFloatVlenWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return BenchmarkFloatVlenWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol BenchmarkFloatVlen.");
  }

}
void BenchmarkFloatVlenWriterBase::WriteFloatArray(yardl::NDArray<float, 2> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloatVlenWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatArrayImpl(value);
}

void BenchmarkFloatVlenWriterBase::WriteFloatArray(std::vector<yardl::NDArray<float, 2>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloatVlenWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatArrayImpl(values);
}

void BenchmarkFloatVlenWriterBase::EndFloatArray() {
  if (unlikely(state_ != 0)) {
    BenchmarkFloatVlenWriterBaseInvalidState(0, true, state_);
  }

  EndFloatArrayImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkFloatVlenWriterBase::WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& values) {
  for (auto const& v : values) {
    WriteFloatArrayImpl(v);
  }
}

void BenchmarkFloatVlenWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkFloatVlenWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkFloatVlenReaderBase::schema_ = BenchmarkFloatVlenWriterBase::schema_;

std::vector<std::string> BenchmarkFloatVlenReaderBase::previous_schemas_ = BenchmarkFloatVlenWriterBase::previous_schemas_;

Version BenchmarkFloatVlenReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == BenchmarkFloatVlenWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol BenchmarkFloatVlen.");
}
bool BenchmarkFloatVlenReaderBase::ReadFloatArray(yardl::NDArray<float, 2>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkFloatVlenReaderBaseInvalidState(0, state_);
  }

  bool result = ReadFloatArrayImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkFloatVlenReaderBase::ReadFloatArray(std::vector<yardl::NDArray<float, 2>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkFloatVlenReaderBaseInvalidState(0, state_);
  }

  if (!ReadFloatArrayImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool BenchmarkFloatVlenReaderBase::ReadFloatArrayImpl(std::vector<yardl::NDArray<float, 2>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFloatArrayImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkFloatVlenReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      BenchmarkFloatVlenReaderBaseInvalidState(2, state_);
    }
  }

  CloseImpl();
}
void BenchmarkFloatVlenReaderBase::CopyTo(BenchmarkFloatVlenWriterBase& writer, size_t float_array_buffer_size) {
  if (float_array_buffer_size > 1) {
    std::vector<yardl::NDArray<float, 2>> values;
    values.reserve(float_array_buffer_size);
    while(ReadFloatArray(values)) {
      writer.WriteFloatArray(values);
    }
    writer.EndFloatArray();
  } else {
    yardl::NDArray<float, 2> value;
    while(ReadFloatArray(value)) {
      writer.WriteFloatArray(value);
    }
    writer.EndFloatArray();
  }
}

namespace {
void BenchmarkSmallRecordWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSmallRecord() or EndSmallRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndSmallRecord()" : "WriteSmallRecord()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkSmallRecordReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSmallRecord()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkSmallRecordWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkSmallRecord","sequence":[{"name":"smallRecord","type":{"stream":{"items":"TestModel.SmallBenchmarkRecord"}}}]},"types":[{"name":"SmallBenchmarkRecord","fields":[{"name":"a","type":"float64"},{"name":"b","type":"float32"},{"name":"c","type":"float32"}]}]})";

std::vector<std::string> BenchmarkSmallRecordWriterBase::previous_schemas_ = {
};

std::string BenchmarkSmallRecordWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return BenchmarkSmallRecordWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol BenchmarkSmallRecord.");
  }

}
void BenchmarkSmallRecordWriterBase::WriteSmallRecord(test_model::SmallBenchmarkRecord const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(value);
}

void BenchmarkSmallRecordWriterBase::WriteSmallRecord(std::vector<test_model::SmallBenchmarkRecord> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(values);
}

void BenchmarkSmallRecordWriterBase::EndSmallRecord() {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWriterBaseInvalidState(0, true, state_);
  }

  EndSmallRecordImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkSmallRecordWriterBase::WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& values) {
  for (auto const& v : values) {
    WriteSmallRecordImpl(v);
  }
}

void BenchmarkSmallRecordWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkSmallRecordWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkSmallRecordReaderBase::schema_ = BenchmarkSmallRecordWriterBase::schema_;

std::vector<std::string> BenchmarkSmallRecordReaderBase::previous_schemas_ = BenchmarkSmallRecordWriterBase::previous_schemas_;

Version BenchmarkSmallRecordReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == BenchmarkSmallRecordWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol BenchmarkSmallRecord.");
}
bool BenchmarkSmallRecordReaderBase::ReadSmallRecord(test_model::SmallBenchmarkRecord& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkSmallRecordReaderBaseInvalidState(0, state_);
  }

  bool result = ReadSmallRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkSmallRecordReaderBase::ReadSmallRecord(std::vector<test_model::SmallBenchmarkRecord>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkSmallRecordReaderBaseInvalidState(0, state_);
  }

  if (!ReadSmallRecordImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool BenchmarkSmallRecordReaderBase::ReadSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadSmallRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkSmallRecordReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      BenchmarkSmallRecordReaderBaseInvalidState(2, state_);
    }
  }

  CloseImpl();
}
void BenchmarkSmallRecordReaderBase::CopyTo(BenchmarkSmallRecordWriterBase& writer, size_t small_record_buffer_size) {
  if (small_record_buffer_size > 1) {
    std::vector<test_model::SmallBenchmarkRecord> values;
    values.reserve(small_record_buffer_size);
    while(ReadSmallRecord(values)) {
      writer.WriteSmallRecord(values);
    }
    writer.EndSmallRecord();
  } else {
    test_model::SmallBenchmarkRecord value;
    while(ReadSmallRecord(value)) {
      writer.WriteSmallRecord(value);
    }
    writer.EndSmallRecord();
  }
}

namespace {
void BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSmallRecord() or EndSmallRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndSmallRecord()" : "WriteSmallRecord()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSmallRecord()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkSmallRecordWithOptionalsWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkSmallRecordWithOptionals","sequence":[{"name":"smallRecord","type":{"stream":{"items":"TestModel.SimpleEncodingCounters"}}}]},"types":[{"name":"SimpleEncodingCounters","fields":[{"name":"e1","type":[null,"uint32"]},{"name":"e2","type":[null,"uint32"]},{"name":"slice","type":[null,"uint32"]},{"name":"repetition","type":[null,"uint32"]}]}]})";

std::vector<std::string> BenchmarkSmallRecordWithOptionalsWriterBase::previous_schemas_ = {
};

std::string BenchmarkSmallRecordWithOptionalsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return BenchmarkSmallRecordWithOptionalsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol BenchmarkSmallRecordWithOptionals.");
  }

}
void BenchmarkSmallRecordWithOptionalsWriterBase::WriteSmallRecord(test_model::SimpleEncodingCounters const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(value);
}

void BenchmarkSmallRecordWithOptionalsWriterBase::WriteSmallRecord(std::vector<test_model::SimpleEncodingCounters> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(values);
}

void BenchmarkSmallRecordWithOptionalsWriterBase::EndSmallRecord() {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(0, true, state_);
  }

  EndSmallRecordImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkSmallRecordWithOptionalsWriterBase::WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& values) {
  for (auto const& v : values) {
    WriteSmallRecordImpl(v);
  }
}

void BenchmarkSmallRecordWithOptionalsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkSmallRecordWithOptionalsReaderBase::schema_ = BenchmarkSmallRecordWithOptionalsWriterBase::schema_;

std::vector<std::string> BenchmarkSmallRecordWithOptionalsReaderBase::previous_schemas_ = BenchmarkSmallRecordWithOptionalsWriterBase::previous_schemas_;

Version BenchmarkSmallRecordWithOptionalsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == BenchmarkSmallRecordWithOptionalsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol BenchmarkSmallRecordWithOptionals.");
}
bool BenchmarkSmallRecordWithOptionalsReaderBase::ReadSmallRecord(test_model::SimpleEncodingCounters& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadSmallRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkSmallRecordWithOptionalsReaderBase::ReadSmallRecord(std::vector<test_model::SimpleEncodingCounters>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(0, state_);
  }

  if (!ReadSmallRecordImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool BenchmarkSmallRecordWithOptionalsReaderBase::ReadSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadSmallRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkSmallRecordWithOptionalsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(2, state_);
    }
  }

  CloseImpl();
}
void BenchmarkSmallRecordWithOptionalsReaderBase::CopyTo(BenchmarkSmallRecordWithOptionalsWriterBase& writer, size_t small_record_buffer_size) {
  if (small_record_buffer_size > 1) {
    std::vector<test_model::SimpleEncodingCounters> values;
    values.reserve(small_record_buffer_size);
    while(ReadSmallRecord(values)) {
      writer.WriteSmallRecord(values);
    }
    writer.EndSmallRecord();
  } else {
    test_model::SimpleEncodingCounters value;
    while(ReadSmallRecord(value)) {
      writer.WriteSmallRecord(value);
    }
    writer.EndSmallRecord();
  }
}

namespace {
void BenchmarkSimpleMrdWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteData() or EndData()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndData()" : "WriteData()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkSimpleMrdReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadData()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkSimpleMrdWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkSimpleMrd","sequence":[{"name":"data","type":{"stream":{"items":[{"tag":"acquisition","explicitTag":true,"type":"TestModel.SimpleAcquisition"},{"tag":"image","explicitTag":true,"type":{"name":"Image.Image","typeArguments":["float32"]}}]}}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"SimpleAcquisition","fields":[{"name":"flags","type":"uint64"},{"name":"idx","type":"TestModel.SimpleEncodingCounters"},{"name":"data","type":{"array":{"items":"complexfloat32","dimensions":2}}},{"name":"trajectory","type":{"array":{"items":"float32","dimensions":2}}}]},{"name":"SimpleEncodingCounters","fields":[{"name":"e1","type":[null,"uint32"]},{"name":"e2","type":[null,"uint32"]},{"name":"slice","type":[null,"uint32"]},{"name":"repetition","type":[null,"uint32"]}]}]})";

std::vector<std::string> BenchmarkSimpleMrdWriterBase::previous_schemas_ = {
};

std::string BenchmarkSimpleMrdWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return BenchmarkSimpleMrdWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol BenchmarkSimpleMrd.");
  }

}
void BenchmarkSimpleMrdWriterBase::WriteData(std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(0, false, state_);
  }

  WriteDataImpl(value);
}

void BenchmarkSimpleMrdWriterBase::WriteData(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(0, false, state_);
  }

  WriteDataImpl(values);
}

void BenchmarkSimpleMrdWriterBase::EndData() {
  if (unlikely(state_ != 0)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(0, true, state_);
  }

  EndDataImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkSimpleMrdWriterBase::WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> const& values) {
  for (auto const& v : values) {
    WriteDataImpl(v);
  }
}

void BenchmarkSimpleMrdWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkSimpleMrdReaderBase::schema_ = BenchmarkSimpleMrdWriterBase::schema_;

std::vector<std::string> BenchmarkSimpleMrdReaderBase::previous_schemas_ = BenchmarkSimpleMrdWriterBase::previous_schemas_;

Version BenchmarkSimpleMrdReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == BenchmarkSimpleMrdWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol BenchmarkSimpleMrd.");
}
bool BenchmarkSimpleMrdReaderBase::ReadData(std::variant<test_model::SimpleAcquisition, image::Image<float>>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkSimpleMrdReaderBaseInvalidState(0, state_);
  }

  bool result = ReadDataImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkSimpleMrdReaderBase::ReadData(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkSimpleMrdReaderBaseInvalidState(0, state_);
  }

  if (!ReadDataImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool BenchmarkSimpleMrdReaderBase::ReadDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkSimpleMrdReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      BenchmarkSimpleMrdReaderBaseInvalidState(2, state_);
    }
  }

  CloseImpl();
}
void BenchmarkSimpleMrdReaderBase::CopyTo(BenchmarkSimpleMrdWriterBase& writer, size_t data_buffer_size) {
  if (data_buffer_size > 1) {
    std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> values;
    values.reserve(data_buffer_size);
    while(ReadData(values)) {
      writer.WriteData(values);
    }
    writer.EndData();
  } else {
    std::variant<test_model::SimpleAcquisition, image::Image<float>> value;
    while(ReadData(value)) {
      writer.WriteData(value);
    }
    writer.EndData();
  }
}

namespace {
void ScalarsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInt32()"; break;
  case 1: expected_method = "WriteRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInt32()"; break;
  case 1: attempted_method = "WriteRecord()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ScalarsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInt32()";
    case 1: return "ReadRecord()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ScalarsWriterBase::schema_ = R"({"protocol":{"name":"Scalars","sequence":[{"name":"int32","type":"int32"},{"name":"record","type":"TestModel.RecordWithPrimitives"}]},"types":[{"name":"RecordWithPrimitives","fields":[{"name":"boolField","type":"bool"},{"name":"int8Field","type":"int8"},{"name":"uint8Field","type":"uint8"},{"name":"int16Field","type":"int16"},{"name":"uint16Field","type":"uint16"},{"name":"int32Field","type":"int32"},{"name":"uint32Field","type":"uint32"},{"name":"int64Field","type":"int64"},{"name":"uint64Field","type":"uint64"},{"name":"sizeField","type":"size"},{"name":"float32Field","type":"float32"},{"name":"float64Field","type":"float64"},{"name":"complexfloat32Field","type":"complexfloat32"},{"name":"complexfloat64Field","type":"complexfloat64"},{"name":"dateField","type":"date"},{"name":"timeField","type":"time"},{"name":"datetimeField","type":"datetime"}]}]})";

std::vector<std::string> ScalarsWriterBase::previous_schemas_ = {
};

std::string ScalarsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return ScalarsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Scalars.");
  }

}
void ScalarsWriterBase::WriteInt32(int32_t const& value) {
  if (unlikely(state_ != 0)) {
    ScalarsWriterBaseInvalidState(0, false, state_);
  }

  WriteInt32Impl(value);
  state_ = 1;
}

void ScalarsWriterBase::WriteRecord(test_model::RecordWithPrimitives const& value) {
  if (unlikely(state_ != 1)) {
    ScalarsWriterBaseInvalidState(1, false, state_);
  }

  WriteRecordImpl(value);
  state_ = 2;
}

void ScalarsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    ScalarsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string ScalarsReaderBase::schema_ = ScalarsWriterBase::schema_;

std::vector<std::string> ScalarsReaderBase::previous_schemas_ = ScalarsWriterBase::previous_schemas_;

Version ScalarsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == ScalarsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Scalars.");
}
void ScalarsReaderBase::ReadInt32(int32_t& value) {
  if (unlikely(state_ != 0)) {
    ScalarsReaderBaseInvalidState(0, state_);
  }

  ReadInt32Impl(value);
  state_ = 2;
}

void ScalarsReaderBase::ReadRecord(test_model::RecordWithPrimitives& value) {
  if (unlikely(state_ != 2)) {
    ScalarsReaderBaseInvalidState(2, state_);
  }

  ReadRecordImpl(value);
  state_ = 4;
}

void ScalarsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    ScalarsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void ScalarsReaderBase::CopyTo(ScalarsWriterBase& writer) {
  {
    int32_t value;
    ReadInt32(value);
    writer.WriteInt32(value);
  }
  {
    test_model::RecordWithPrimitives value;
    ReadRecord(value);
    writer.WriteRecord(value);
  }
}

namespace {
void ScalarOptionalsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteOptionalInt()"; break;
  case 1: expected_method = "WriteOptionalRecord()"; break;
  case 2: expected_method = "WriteRecordWithOptionalFields()"; break;
  case 3: expected_method = "WriteOptionalRecordWithOptionalFields()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteOptionalInt()"; break;
  case 1: attempted_method = "WriteOptionalRecord()"; break;
  case 2: attempted_method = "WriteRecordWithOptionalFields()"; break;
  case 3: attempted_method = "WriteOptionalRecordWithOptionalFields()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ScalarOptionalsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadOptionalInt()";
    case 1: return "ReadOptionalRecord()";
    case 2: return "ReadRecordWithOptionalFields()";
    case 3: return "ReadOptionalRecordWithOptionalFields()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ScalarOptionalsWriterBase::schema_ = R"({"protocol":{"name":"ScalarOptionals","sequence":[{"name":"optionalInt","type":[null,"int32"]},{"name":"optionalRecord","type":[null,"TestModel.SimpleRecord"]},{"name":"recordWithOptionalFields","type":"TestModel.RecordWithOptionalFields"},{"name":"optionalRecordWithOptionalFields","type":[null,"TestModel.RecordWithOptionalFields"]}]},"types":[{"name":"RecordWithOptionalFields","fields":[{"name":"optionalInt","type":[null,"int32"]},{"name":"optionalIntAlternateSyntax","type":[null,"int32"]},{"name":"optionalTime","type":[null,"time"]}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> ScalarOptionalsWriterBase::previous_schemas_ = {
};

std::string ScalarOptionalsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return ScalarOptionalsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol ScalarOptionals.");
  }

}
void ScalarOptionalsWriterBase::WriteOptionalInt(std::optional<int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    ScalarOptionalsWriterBaseInvalidState(0, false, state_);
  }

  WriteOptionalIntImpl(value);
  state_ = 1;
}

void ScalarOptionalsWriterBase::WriteOptionalRecord(std::optional<test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 1)) {
    ScalarOptionalsWriterBaseInvalidState(1, false, state_);
  }

  WriteOptionalRecordImpl(value);
  state_ = 2;
}

void ScalarOptionalsWriterBase::WriteRecordWithOptionalFields(test_model::RecordWithOptionalFields const& value) {
  if (unlikely(state_ != 2)) {
    ScalarOptionalsWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithOptionalFieldsImpl(value);
  state_ = 3;
}

void ScalarOptionalsWriterBase::WriteOptionalRecordWithOptionalFields(std::optional<test_model::RecordWithOptionalFields> const& value) {
  if (unlikely(state_ != 3)) {
    ScalarOptionalsWriterBaseInvalidState(3, false, state_);
  }

  WriteOptionalRecordWithOptionalFieldsImpl(value);
  state_ = 4;
}

void ScalarOptionalsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    ScalarOptionalsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string ScalarOptionalsReaderBase::schema_ = ScalarOptionalsWriterBase::schema_;

std::vector<std::string> ScalarOptionalsReaderBase::previous_schemas_ = ScalarOptionalsWriterBase::previous_schemas_;

Version ScalarOptionalsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == ScalarOptionalsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol ScalarOptionals.");
}
void ScalarOptionalsReaderBase::ReadOptionalInt(std::optional<int32_t>& value) {
  if (unlikely(state_ != 0)) {
    ScalarOptionalsReaderBaseInvalidState(0, state_);
  }

  ReadOptionalIntImpl(value);
  state_ = 2;
}

void ScalarOptionalsReaderBase::ReadOptionalRecord(std::optional<test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 2)) {
    ScalarOptionalsReaderBaseInvalidState(2, state_);
  }

  ReadOptionalRecordImpl(value);
  state_ = 4;
}

void ScalarOptionalsReaderBase::ReadRecordWithOptionalFields(test_model::RecordWithOptionalFields& value) {
  if (unlikely(state_ != 4)) {
    ScalarOptionalsReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithOptionalFieldsImpl(value);
  state_ = 6;
}

void ScalarOptionalsReaderBase::ReadOptionalRecordWithOptionalFields(std::optional<test_model::RecordWithOptionalFields>& value) {
  if (unlikely(state_ != 6)) {
    ScalarOptionalsReaderBaseInvalidState(6, state_);
  }

  ReadOptionalRecordWithOptionalFieldsImpl(value);
  state_ = 8;
}

void ScalarOptionalsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    ScalarOptionalsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void ScalarOptionalsReaderBase::CopyTo(ScalarOptionalsWriterBase& writer) {
  {
    std::optional<int32_t> value;
    ReadOptionalInt(value);
    writer.WriteOptionalInt(value);
  }
  {
    std::optional<test_model::SimpleRecord> value;
    ReadOptionalRecord(value);
    writer.WriteOptionalRecord(value);
  }
  {
    test_model::RecordWithOptionalFields value;
    ReadRecordWithOptionalFields(value);
    writer.WriteRecordWithOptionalFields(value);
  }
  {
    std::optional<test_model::RecordWithOptionalFields> value;
    ReadOptionalRecordWithOptionalFields(value);
    writer.WriteOptionalRecordWithOptionalFields(value);
  }
}

namespace {
void NestedRecordsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteTupleWithRecords()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteTupleWithRecords()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void NestedRecordsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadTupleWithRecords()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string NestedRecordsWriterBase::schema_ = R"({"protocol":{"name":"NestedRecords","sequence":[{"name":"tupleWithRecords","type":"TestModel.TupleWithRecords"}]},"types":[{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]},{"name":"TupleWithRecords","fields":[{"name":"a","type":"TestModel.SimpleRecord"},{"name":"b","type":"TestModel.SimpleRecord"}]}]})";

std::vector<std::string> NestedRecordsWriterBase::previous_schemas_ = {
};

std::string NestedRecordsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return NestedRecordsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol NestedRecords.");
  }

}
void NestedRecordsWriterBase::WriteTupleWithRecords(test_model::TupleWithRecords const& value) {
  if (unlikely(state_ != 0)) {
    NestedRecordsWriterBaseInvalidState(0, false, state_);
  }

  WriteTupleWithRecordsImpl(value);
  state_ = 1;
}

void NestedRecordsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    NestedRecordsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string NestedRecordsReaderBase::schema_ = NestedRecordsWriterBase::schema_;

std::vector<std::string> NestedRecordsReaderBase::previous_schemas_ = NestedRecordsWriterBase::previous_schemas_;

Version NestedRecordsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == NestedRecordsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol NestedRecords.");
}
void NestedRecordsReaderBase::ReadTupleWithRecords(test_model::TupleWithRecords& value) {
  if (unlikely(state_ != 0)) {
    NestedRecordsReaderBaseInvalidState(0, state_);
  }

  ReadTupleWithRecordsImpl(value);
  state_ = 2;
}

void NestedRecordsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    NestedRecordsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void NestedRecordsReaderBase::CopyTo(NestedRecordsWriterBase& writer) {
  {
    test_model::TupleWithRecords value;
    ReadTupleWithRecords(value);
    writer.WriteTupleWithRecords(value);
  }
}

namespace {
void VlensWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntVector()"; break;
  case 1: expected_method = "WriteComplexVector()"; break;
  case 2: expected_method = "WriteRecordWithVlens()"; break;
  case 3: expected_method = "WriteVlenOfRecordWithVlens()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteIntVector()"; break;
  case 1: attempted_method = "WriteComplexVector()"; break;
  case 2: attempted_method = "WriteRecordWithVlens()"; break;
  case 3: attempted_method = "WriteVlenOfRecordWithVlens()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void VlensReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntVector()";
    case 1: return "ReadComplexVector()";
    case 2: return "ReadRecordWithVlens()";
    case 3: return "ReadVlenOfRecordWithVlens()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string VlensWriterBase::schema_ = R"({"protocol":{"name":"Vlens","sequence":[{"name":"intVector","type":{"vector":{"items":"int32"}}},{"name":"complexVector","type":{"vector":{"items":"complexfloat32"}}},{"name":"recordWithVlens","type":"TestModel.RecordWithVlens"},{"name":"vlenOfRecordWithVlens","type":{"vector":{"items":"TestModel.RecordWithVlens"}}}]},"types":[{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> VlensWriterBase::previous_schemas_ = {
};

std::string VlensWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return VlensWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Vlens.");
  }

}
void VlensWriterBase::WriteIntVector(std::vector<int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    VlensWriterBaseInvalidState(0, false, state_);
  }

  WriteIntVectorImpl(value);
  state_ = 1;
}

void VlensWriterBase::WriteComplexVector(std::vector<std::complex<float>> const& value) {
  if (unlikely(state_ != 1)) {
    VlensWriterBaseInvalidState(1, false, state_);
  }

  WriteComplexVectorImpl(value);
  state_ = 2;
}

void VlensWriterBase::WriteRecordWithVlens(test_model::RecordWithVlens const& value) {
  if (unlikely(state_ != 2)) {
    VlensWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensImpl(value);
  state_ = 3;
}

void VlensWriterBase::WriteVlenOfRecordWithVlens(std::vector<test_model::RecordWithVlens> const& value) {
  if (unlikely(state_ != 3)) {
    VlensWriterBaseInvalidState(3, false, state_);
  }

  WriteVlenOfRecordWithVlensImpl(value);
  state_ = 4;
}

void VlensWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    VlensWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string VlensReaderBase::schema_ = VlensWriterBase::schema_;

std::vector<std::string> VlensReaderBase::previous_schemas_ = VlensWriterBase::previous_schemas_;

Version VlensReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == VlensWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Vlens.");
}
void VlensReaderBase::ReadIntVector(std::vector<int32_t>& value) {
  if (unlikely(state_ != 0)) {
    VlensReaderBaseInvalidState(0, state_);
  }

  ReadIntVectorImpl(value);
  state_ = 2;
}

void VlensReaderBase::ReadComplexVector(std::vector<std::complex<float>>& value) {
  if (unlikely(state_ != 2)) {
    VlensReaderBaseInvalidState(2, state_);
  }

  ReadComplexVectorImpl(value);
  state_ = 4;
}

void VlensReaderBase::ReadRecordWithVlens(test_model::RecordWithVlens& value) {
  if (unlikely(state_ != 4)) {
    VlensReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensImpl(value);
  state_ = 6;
}

void VlensReaderBase::ReadVlenOfRecordWithVlens(std::vector<test_model::RecordWithVlens>& value) {
  if (unlikely(state_ != 6)) {
    VlensReaderBaseInvalidState(6, state_);
  }

  ReadVlenOfRecordWithVlensImpl(value);
  state_ = 8;
}

void VlensReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    VlensReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void VlensReaderBase::CopyTo(VlensWriterBase& writer) {
  {
    std::vector<int32_t> value;
    ReadIntVector(value);
    writer.WriteIntVector(value);
  }
  {
    std::vector<std::complex<float>> value;
    ReadComplexVector(value);
    writer.WriteComplexVector(value);
  }
  {
    test_model::RecordWithVlens value;
    ReadRecordWithVlens(value);
    writer.WriteRecordWithVlens(value);
  }
  {
    std::vector<test_model::RecordWithVlens> value;
    ReadVlenOfRecordWithVlens(value);
    writer.WriteVlenOfRecordWithVlens(value);
  }
}

namespace {
void StringsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSingleString()"; break;
  case 1: expected_method = "WriteRecWithString()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteSingleString()"; break;
  case 1: attempted_method = "WriteRecWithString()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StringsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSingleString()";
    case 1: return "ReadRecWithString()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StringsWriterBase::schema_ = R"({"protocol":{"name":"Strings","sequence":[{"name":"singleString","type":"string"},{"name":"recWithString","type":"TestModel.RecordWithStrings"}]},"types":[{"name":"RecordWithStrings","fields":[{"name":"a","type":"string"},{"name":"b","type":"string"}]}]})";

std::vector<std::string> StringsWriterBase::previous_schemas_ = {
};

std::string StringsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return StringsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Strings.");
  }

}
void StringsWriterBase::WriteSingleString(std::string const& value) {
  if (unlikely(state_ != 0)) {
    StringsWriterBaseInvalidState(0, false, state_);
  }

  WriteSingleStringImpl(value);
  state_ = 1;
}

void StringsWriterBase::WriteRecWithString(test_model::RecordWithStrings const& value) {
  if (unlikely(state_ != 1)) {
    StringsWriterBaseInvalidState(1, false, state_);
  }

  WriteRecWithStringImpl(value);
  state_ = 2;
}

void StringsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    StringsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string StringsReaderBase::schema_ = StringsWriterBase::schema_;

std::vector<std::string> StringsReaderBase::previous_schemas_ = StringsWriterBase::previous_schemas_;

Version StringsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == StringsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Strings.");
}
void StringsReaderBase::ReadSingleString(std::string& value) {
  if (unlikely(state_ != 0)) {
    StringsReaderBaseInvalidState(0, state_);
  }

  ReadSingleStringImpl(value);
  state_ = 2;
}

void StringsReaderBase::ReadRecWithString(test_model::RecordWithStrings& value) {
  if (unlikely(state_ != 2)) {
    StringsReaderBaseInvalidState(2, state_);
  }

  ReadRecWithStringImpl(value);
  state_ = 4;
}

void StringsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    StringsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void StringsReaderBase::CopyTo(StringsWriterBase& writer) {
  {
    std::string value;
    ReadSingleString(value);
    writer.WriteSingleString(value);
  }
  {
    test_model::RecordWithStrings value;
    ReadRecWithString(value);
    writer.WriteRecWithString(value);
  }
}

namespace {
void OptionalVectorsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteRecordWithOptionalVector()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteRecordWithOptionalVector()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void OptionalVectorsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadRecordWithOptionalVector()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string OptionalVectorsWriterBase::schema_ = R"({"protocol":{"name":"OptionalVectors","sequence":[{"name":"recordWithOptionalVector","type":"TestModel.RecordWithOptionalVector"}]},"types":[{"name":"RecordWithOptionalVector","fields":[{"name":"optionalVector","type":[null,{"vector":{"items":"int32"}}]}]}]})";

std::vector<std::string> OptionalVectorsWriterBase::previous_schemas_ = {
};

std::string OptionalVectorsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return OptionalVectorsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol OptionalVectors.");
  }

}
void OptionalVectorsWriterBase::WriteRecordWithOptionalVector(test_model::RecordWithOptionalVector const& value) {
  if (unlikely(state_ != 0)) {
    OptionalVectorsWriterBaseInvalidState(0, false, state_);
  }

  WriteRecordWithOptionalVectorImpl(value);
  state_ = 1;
}

void OptionalVectorsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    OptionalVectorsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string OptionalVectorsReaderBase::schema_ = OptionalVectorsWriterBase::schema_;

std::vector<std::string> OptionalVectorsReaderBase::previous_schemas_ = OptionalVectorsWriterBase::previous_schemas_;

Version OptionalVectorsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == OptionalVectorsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol OptionalVectors.");
}
void OptionalVectorsReaderBase::ReadRecordWithOptionalVector(test_model::RecordWithOptionalVector& value) {
  if (unlikely(state_ != 0)) {
    OptionalVectorsReaderBaseInvalidState(0, state_);
  }

  ReadRecordWithOptionalVectorImpl(value);
  state_ = 2;
}

void OptionalVectorsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    OptionalVectorsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void OptionalVectorsReaderBase::CopyTo(OptionalVectorsWriterBase& writer) {
  {
    test_model::RecordWithOptionalVector value;
    ReadRecordWithOptionalVector(value);
    writer.WriteRecordWithOptionalVector(value);
  }
}

namespace {
void FixedVectorsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFixedIntVector()"; break;
  case 1: expected_method = "WriteFixedSimpleRecordVector()"; break;
  case 2: expected_method = "WriteFixedRecordWithVlensVector()"; break;
  case 3: expected_method = "WriteRecordWithFixedVectors()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteFixedIntVector()"; break;
  case 1: attempted_method = "WriteFixedSimpleRecordVector()"; break;
  case 2: attempted_method = "WriteFixedRecordWithVlensVector()"; break;
  case 3: attempted_method = "WriteRecordWithFixedVectors()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void FixedVectorsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFixedIntVector()";
    case 1: return "ReadFixedSimpleRecordVector()";
    case 2: return "ReadFixedRecordWithVlensVector()";
    case 3: return "ReadRecordWithFixedVectors()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string FixedVectorsWriterBase::schema_ = R"({"protocol":{"name":"FixedVectors","sequence":[{"name":"fixedIntVector","type":{"vector":{"items":"int32","length":5}}},{"name":"fixedSimpleRecordVector","type":{"vector":{"items":"TestModel.SimpleRecord","length":3}}},{"name":"fixedRecordWithVlensVector","type":{"vector":{"items":"TestModel.RecordWithVlens","length":2}}},{"name":"recordWithFixedVectors","type":"TestModel.RecordWithFixedVectors"}]},"types":[{"name":"RecordWithFixedVectors","fields":[{"name":"fixedIntVector","type":{"vector":{"items":"int32","length":5}}},{"name":"fixedSimpleRecordVector","type":{"vector":{"items":"TestModel.SimpleRecord","length":3}}},{"name":"fixedRecordWithVlensVector","type":{"vector":{"items":"TestModel.RecordWithVlens","length":2}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> FixedVectorsWriterBase::previous_schemas_ = {
};

std::string FixedVectorsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return FixedVectorsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol FixedVectors.");
  }

}
void FixedVectorsWriterBase::WriteFixedIntVector(std::array<int32_t, 5> const& value) {
  if (unlikely(state_ != 0)) {
    FixedVectorsWriterBaseInvalidState(0, false, state_);
  }

  WriteFixedIntVectorImpl(value);
  state_ = 1;
}

void FixedVectorsWriterBase::WriteFixedSimpleRecordVector(std::array<test_model::SimpleRecord, 3> const& value) {
  if (unlikely(state_ != 1)) {
    FixedVectorsWriterBaseInvalidState(1, false, state_);
  }

  WriteFixedSimpleRecordVectorImpl(value);
  state_ = 2;
}

void FixedVectorsWriterBase::WriteFixedRecordWithVlensVector(std::array<test_model::RecordWithVlens, 2> const& value) {
  if (unlikely(state_ != 2)) {
    FixedVectorsWriterBaseInvalidState(2, false, state_);
  }

  WriteFixedRecordWithVlensVectorImpl(value);
  state_ = 3;
}

void FixedVectorsWriterBase::WriteRecordWithFixedVectors(test_model::RecordWithFixedVectors const& value) {
  if (unlikely(state_ != 3)) {
    FixedVectorsWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithFixedVectorsImpl(value);
  state_ = 4;
}

void FixedVectorsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    FixedVectorsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string FixedVectorsReaderBase::schema_ = FixedVectorsWriterBase::schema_;

std::vector<std::string> FixedVectorsReaderBase::previous_schemas_ = FixedVectorsWriterBase::previous_schemas_;

Version FixedVectorsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == FixedVectorsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol FixedVectors.");
}
void FixedVectorsReaderBase::ReadFixedIntVector(std::array<int32_t, 5>& value) {
  if (unlikely(state_ != 0)) {
    FixedVectorsReaderBaseInvalidState(0, state_);
  }

  ReadFixedIntVectorImpl(value);
  state_ = 2;
}

void FixedVectorsReaderBase::ReadFixedSimpleRecordVector(std::array<test_model::SimpleRecord, 3>& value) {
  if (unlikely(state_ != 2)) {
    FixedVectorsReaderBaseInvalidState(2, state_);
  }

  ReadFixedSimpleRecordVectorImpl(value);
  state_ = 4;
}

void FixedVectorsReaderBase::ReadFixedRecordWithVlensVector(std::array<test_model::RecordWithVlens, 2>& value) {
  if (unlikely(state_ != 4)) {
    FixedVectorsReaderBaseInvalidState(4, state_);
  }

  ReadFixedRecordWithVlensVectorImpl(value);
  state_ = 6;
}

void FixedVectorsReaderBase::ReadRecordWithFixedVectors(test_model::RecordWithFixedVectors& value) {
  if (unlikely(state_ != 6)) {
    FixedVectorsReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithFixedVectorsImpl(value);
  state_ = 8;
}

void FixedVectorsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    FixedVectorsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void FixedVectorsReaderBase::CopyTo(FixedVectorsWriterBase& writer) {
  {
    std::array<int32_t, 5> value;
    ReadFixedIntVector(value);
    writer.WriteFixedIntVector(value);
  }
  {
    std::array<test_model::SimpleRecord, 3> value;
    ReadFixedSimpleRecordVector(value);
    writer.WriteFixedSimpleRecordVector(value);
  }
  {
    std::array<test_model::RecordWithVlens, 2> value;
    ReadFixedRecordWithVlensVector(value);
    writer.WriteFixedRecordWithVlensVector(value);
  }
  {
    test_model::RecordWithFixedVectors value;
    ReadRecordWithFixedVectors(value);
    writer.WriteRecordWithFixedVectors(value);
  }
}

namespace {
void StreamsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntData() or EndIntData()"; break;
  case 1: expected_method = "WriteOptionalIntData() or EndOptionalIntData()"; break;
  case 2: expected_method = "WriteRecordWithOptionalVectorData() or EndRecordWithOptionalVectorData()"; break;
  case 3: expected_method = "WriteFixedVector() or EndFixedVector()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndIntData()" : "WriteIntData()"; break;
  case 1: attempted_method = end ? "EndOptionalIntData()" : "WriteOptionalIntData()"; break;
  case 2: attempted_method = end ? "EndRecordWithOptionalVectorData()" : "WriteRecordWithOptionalVectorData()"; break;
  case 3: attempted_method = end ? "EndFixedVector()" : "WriteFixedVector()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StreamsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntData()";
    case 1: return "ReadOptionalIntData()";
    case 2: return "ReadRecordWithOptionalVectorData()";
    case 3: return "ReadFixedVector()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StreamsWriterBase::schema_ = R"({"protocol":{"name":"Streams","sequence":[{"name":"intData","type":{"stream":{"items":"int32"}}},{"name":"optionalIntData","type":{"stream":{"items":[null,"int32"]}}},{"name":"recordWithOptionalVectorData","type":{"stream":{"items":"TestModel.RecordWithOptionalVector"}}},{"name":"fixedVector","type":{"stream":{"items":{"vector":{"items":"int32","length":3}}}}}]},"types":[{"name":"RecordWithOptionalVector","fields":[{"name":"optionalVector","type":[null,{"vector":{"items":"int32"}}]}]}]})";

std::vector<std::string> StreamsWriterBase::previous_schemas_ = {
};

std::string StreamsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return StreamsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Streams.");
  }

}
void StreamsWriterBase::WriteIntData(int32_t const& value) {
  if (unlikely(state_ != 0)) {
    StreamsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntDataImpl(value);
}

void StreamsWriterBase::WriteIntData(std::vector<int32_t> const& values) {
  if (unlikely(state_ != 0)) {
    StreamsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntDataImpl(values);
}

void StreamsWriterBase::EndIntData() {
  if (unlikely(state_ != 0)) {
    StreamsWriterBaseInvalidState(0, true, state_);
  }

  EndIntDataImpl();
  state_ = 1;
}

// fallback implementation
void StreamsWriterBase::WriteIntDataImpl(std::vector<int32_t> const& values) {
  for (auto const& v : values) {
    WriteIntDataImpl(v);
  }
}

void StreamsWriterBase::WriteOptionalIntData(std::optional<int32_t> const& value) {
  if (unlikely(state_ != 1)) {
    StreamsWriterBaseInvalidState(1, false, state_);
  }

  WriteOptionalIntDataImpl(value);
}

void StreamsWriterBase::WriteOptionalIntData(std::vector<std::optional<int32_t>> const& values) {
  if (unlikely(state_ != 1)) {
    StreamsWriterBaseInvalidState(1, false, state_);
  }

  WriteOptionalIntDataImpl(values);
}

void StreamsWriterBase::EndOptionalIntData() {
  if (unlikely(state_ != 1)) {
    StreamsWriterBaseInvalidState(1, true, state_);
  }

  EndOptionalIntDataImpl();
  state_ = 2;
}

// fallback implementation
void StreamsWriterBase::WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& values) {
  for (auto const& v : values) {
    WriteOptionalIntDataImpl(v);
  }
}

void StreamsWriterBase::WriteRecordWithOptionalVectorData(test_model::RecordWithOptionalVector const& value) {
  if (unlikely(state_ != 2)) {
    StreamsWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithOptionalVectorDataImpl(value);
}

void StreamsWriterBase::WriteRecordWithOptionalVectorData(std::vector<test_model::RecordWithOptionalVector> const& values) {
  if (unlikely(state_ != 2)) {
    StreamsWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithOptionalVectorDataImpl(values);
}

void StreamsWriterBase::EndRecordWithOptionalVectorData() {
  if (unlikely(state_ != 2)) {
    StreamsWriterBaseInvalidState(2, true, state_);
  }

  EndRecordWithOptionalVectorDataImpl();
  state_ = 3;
}

// fallback implementation
void StreamsWriterBase::WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& values) {
  for (auto const& v : values) {
    WriteRecordWithOptionalVectorDataImpl(v);
  }
}

void StreamsWriterBase::WriteFixedVector(std::array<int32_t, 3> const& value) {
  if (unlikely(state_ != 3)) {
    StreamsWriterBaseInvalidState(3, false, state_);
  }

  WriteFixedVectorImpl(value);
}

void StreamsWriterBase::WriteFixedVector(std::vector<std::array<int32_t, 3>> const& values) {
  if (unlikely(state_ != 3)) {
    StreamsWriterBaseInvalidState(3, false, state_);
  }

  WriteFixedVectorImpl(values);
}

void StreamsWriterBase::EndFixedVector() {
  if (unlikely(state_ != 3)) {
    StreamsWriterBaseInvalidState(3, true, state_);
  }

  EndFixedVectorImpl();
  state_ = 4;
}

// fallback implementation
void StreamsWriterBase::WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& values) {
  for (auto const& v : values) {
    WriteFixedVectorImpl(v);
  }
}

void StreamsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    StreamsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string StreamsReaderBase::schema_ = StreamsWriterBase::schema_;

std::vector<std::string> StreamsReaderBase::previous_schemas_ = StreamsWriterBase::previous_schemas_;

Version StreamsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == StreamsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Streams.");
}
bool StreamsReaderBase::ReadIntData(int32_t& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    StreamsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntDataImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool StreamsReaderBase::ReadIntData(std::vector<int32_t>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    StreamsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntDataImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadIntDataImpl(std::vector<int32_t>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsReaderBase::ReadOptionalIntData(std::optional<int32_t>& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadOptionalIntDataImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StreamsReaderBase::ReadOptionalIntData(std::vector<std::optional<int32_t>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadOptionalIntDataImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadOptionalIntDataImpl(std::vector<std::optional<int32_t>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadOptionalIntDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsReaderBase::ReadRecordWithOptionalVectorData(test_model::RecordWithOptionalVector& value) {
  if (unlikely(state_ != 4)) {
    if (state_ == 5) {
      state_ = 6;
      return false;
    }
    if (state_ == 3) {
      state_ = 4;
    } else {
      StreamsReaderBaseInvalidState(4, state_);
    }
  }

  bool result = ReadRecordWithOptionalVectorDataImpl(value);
  if (!result) {
    state_ = 6;
  }
  return result;
}

bool StreamsReaderBase::ReadRecordWithOptionalVectorData(std::vector<test_model::RecordWithOptionalVector>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 4)) {
    if (state_ == 5) {
      state_ = 6;
      values.clear();
      return false;
    }
    if (state_ == 3) {
      state_ = 4;
    } else {
      StreamsReaderBaseInvalidState(4, state_);
    }
  }

  if (!ReadRecordWithOptionalVectorDataImpl(values)) {
    state_ = 5;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadRecordWithOptionalVectorDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsReaderBase::ReadFixedVector(std::array<int32_t, 3>& value) {
  if (unlikely(state_ != 6)) {
    if (state_ == 7) {
      state_ = 8;
      return false;
    }
    if (state_ == 5) {
      state_ = 6;
    } else {
      StreamsReaderBaseInvalidState(6, state_);
    }
  }

  bool result = ReadFixedVectorImpl(value);
  if (!result) {
    state_ = 8;
  }
  return result;
}

bool StreamsReaderBase::ReadFixedVector(std::vector<std::array<int32_t, 3>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 6)) {
    if (state_ == 7) {
      state_ = 8;
      values.clear();
      return false;
    }
    if (state_ == 5) {
      state_ = 6;
    } else {
      StreamsReaderBaseInvalidState(6, state_);
    }
  }

  if (!ReadFixedVectorImpl(values)) {
    state_ = 7;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadFixedVectorImpl(std::vector<std::array<int32_t, 3>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFixedVectorImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StreamsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    if (state_ == 7) {
      state_ = 8;
    } else {
      StreamsReaderBaseInvalidState(8, state_);
    }
  }

  CloseImpl();
}
void StreamsReaderBase::CopyTo(StreamsWriterBase& writer, size_t int_data_buffer_size, size_t optional_int_data_buffer_size, size_t record_with_optional_vector_data_buffer_size, size_t fixed_vector_buffer_size) {
  if (int_data_buffer_size > 1) {
    std::vector<int32_t> values;
    values.reserve(int_data_buffer_size);
    while(ReadIntData(values)) {
      writer.WriteIntData(values);
    }
    writer.EndIntData();
  } else {
    int32_t value;
    while(ReadIntData(value)) {
      writer.WriteIntData(value);
    }
    writer.EndIntData();
  }
  if (optional_int_data_buffer_size > 1) {
    std::vector<std::optional<int32_t>> values;
    values.reserve(optional_int_data_buffer_size);
    while(ReadOptionalIntData(values)) {
      writer.WriteOptionalIntData(values);
    }
    writer.EndOptionalIntData();
  } else {
    std::optional<int32_t> value;
    while(ReadOptionalIntData(value)) {
      writer.WriteOptionalIntData(value);
    }
    writer.EndOptionalIntData();
  }
  if (record_with_optional_vector_data_buffer_size > 1) {
    std::vector<test_model::RecordWithOptionalVector> values;
    values.reserve(record_with_optional_vector_data_buffer_size);
    while(ReadRecordWithOptionalVectorData(values)) {
      writer.WriteRecordWithOptionalVectorData(values);
    }
    writer.EndRecordWithOptionalVectorData();
  } else {
    test_model::RecordWithOptionalVector value;
    while(ReadRecordWithOptionalVectorData(value)) {
      writer.WriteRecordWithOptionalVectorData(value);
    }
    writer.EndRecordWithOptionalVectorData();
  }
  if (fixed_vector_buffer_size > 1) {
    std::vector<std::array<int32_t, 3>> values;
    values.reserve(fixed_vector_buffer_size);
    while(ReadFixedVector(values)) {
      writer.WriteFixedVector(values);
    }
    writer.EndFixedVector();
  } else {
    std::array<int32_t, 3> value;
    while(ReadFixedVector(value)) {
      writer.WriteFixedVector(value);
    }
    writer.EndFixedVector();
  }
}

namespace {
void FixedArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteFixedSimpleRecordArray()"; break;
  case 2: expected_method = "WriteFixedRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithFixedArrays()"; break;
  case 4: expected_method = "WriteNamedArray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteFixedSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteFixedRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithFixedArrays()"; break;
  case 4: attempted_method = "WriteNamedArray()"; break;
  case 5: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void FixedArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadFixedSimpleRecordArray()";
    case 2: return "ReadFixedRecordWithVlensArray()";
    case 3: return "ReadRecordWithFixedArrays()";
    case 4: return "ReadNamedArray()";
    case 5: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string FixedArraysWriterBase::schema_ = R"({"protocol":{"name":"FixedArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":[{"length":3},{"length":2}]}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":[{"length":2},{"length":2}]}}},{"name":"recordWithFixedArrays","type":"TestModel.RecordWithFixedArrays"},{"name":"namedArray","type":"TestModel.NamedFixedNDArray"}]},"types":[{"name":"NamedFixedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA","length":2},{"name":"dimB","length":4}]}}},{"name":"RecordWithFixedArrays","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":[{"length":3},{"length":2}]}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":[{"length":2},{"length":2}]}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> FixedArraysWriterBase::previous_schemas_ = {
};

std::string FixedArraysWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return FixedArraysWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol FixedArrays.");
  }

}
void FixedArraysWriterBase::WriteInts(yardl::FixedNDArray<int32_t, 2, 3> const& value) {
  if (unlikely(state_ != 0)) {
    FixedArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void FixedArraysWriterBase::WriteFixedSimpleRecordArray(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) {
  if (unlikely(state_ != 1)) {
    FixedArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteFixedSimpleRecordArrayImpl(value);
  state_ = 2;
}

void FixedArraysWriterBase::WriteFixedRecordWithVlensArray(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) {
  if (unlikely(state_ != 2)) {
    FixedArraysWriterBaseInvalidState(2, false, state_);
  }

  WriteFixedRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void FixedArraysWriterBase::WriteRecordWithFixedArrays(test_model::RecordWithFixedArrays const& value) {
  if (unlikely(state_ != 3)) {
    FixedArraysWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithFixedArraysImpl(value);
  state_ = 4;
}

void FixedArraysWriterBase::WriteNamedArray(test_model::NamedFixedNDArray const& value) {
  if (unlikely(state_ != 4)) {
    FixedArraysWriterBaseInvalidState(4, false, state_);
  }

  WriteNamedArrayImpl(value);
  state_ = 5;
}

void FixedArraysWriterBase::Close() {
  if (unlikely(state_ != 5)) {
    FixedArraysWriterBaseInvalidState(5, false, state_);
  }

  CloseImpl();
}

std::string FixedArraysReaderBase::schema_ = FixedArraysWriterBase::schema_;

std::vector<std::string> FixedArraysReaderBase::previous_schemas_ = FixedArraysWriterBase::previous_schemas_;

Version FixedArraysReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == FixedArraysWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol FixedArrays.");
}
void FixedArraysReaderBase::ReadInts(yardl::FixedNDArray<int32_t, 2, 3>& value) {
  if (unlikely(state_ != 0)) {
    FixedArraysReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void FixedArraysReaderBase::ReadFixedSimpleRecordArray(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value) {
  if (unlikely(state_ != 2)) {
    FixedArraysReaderBaseInvalidState(2, state_);
  }

  ReadFixedSimpleRecordArrayImpl(value);
  state_ = 4;
}

void FixedArraysReaderBase::ReadFixedRecordWithVlensArray(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value) {
  if (unlikely(state_ != 4)) {
    FixedArraysReaderBaseInvalidState(4, state_);
  }

  ReadFixedRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void FixedArraysReaderBase::ReadRecordWithFixedArrays(test_model::RecordWithFixedArrays& value) {
  if (unlikely(state_ != 6)) {
    FixedArraysReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithFixedArraysImpl(value);
  state_ = 8;
}

void FixedArraysReaderBase::ReadNamedArray(test_model::NamedFixedNDArray& value) {
  if (unlikely(state_ != 8)) {
    FixedArraysReaderBaseInvalidState(8, state_);
  }

  ReadNamedArrayImpl(value);
  state_ = 10;
}

void FixedArraysReaderBase::Close() {
  if (unlikely(state_ != 10)) {
    FixedArraysReaderBaseInvalidState(10, state_);
  }

  CloseImpl();
}
void FixedArraysReaderBase::CopyTo(FixedArraysWriterBase& writer) {
  {
    yardl::FixedNDArray<int32_t, 2, 3> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> value;
    ReadFixedSimpleRecordArray(value);
    writer.WriteFixedSimpleRecordArray(value);
  }
  {
    yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> value;
    ReadFixedRecordWithVlensArray(value);
    writer.WriteFixedRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithFixedArrays value;
    ReadRecordWithFixedArrays(value);
    writer.WriteRecordWithFixedArrays(value);
  }
  {
    test_model::NamedFixedNDArray value;
    ReadNamedArray(value);
    writer.WriteNamedArray(value);
  }
}

namespace {
void SubarraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteDynamicWithFixedIntSubarray()"; break;
  case 1: expected_method = "WriteDynamicWithFixedFloatSubarray()"; break;
  case 2: expected_method = "WriteKnownDimCountWithFixedIntSubarray()"; break;
  case 3: expected_method = "WriteKnownDimCountWithFixedFloatSubarray()"; break;
  case 4: expected_method = "WriteFixedWithFixedIntSubarray()"; break;
  case 5: expected_method = "WriteFixedWithFixedFloatSubarray()"; break;
  case 6: expected_method = "WriteNestedSubarray()"; break;
  case 7: expected_method = "WriteDynamicWithFixedVectorSubarray()"; break;
  case 8: expected_method = "WriteGenericSubarray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteDynamicWithFixedIntSubarray()"; break;
  case 1: attempted_method = "WriteDynamicWithFixedFloatSubarray()"; break;
  case 2: attempted_method = "WriteKnownDimCountWithFixedIntSubarray()"; break;
  case 3: attempted_method = "WriteKnownDimCountWithFixedFloatSubarray()"; break;
  case 4: attempted_method = "WriteFixedWithFixedIntSubarray()"; break;
  case 5: attempted_method = "WriteFixedWithFixedFloatSubarray()"; break;
  case 6: attempted_method = "WriteNestedSubarray()"; break;
  case 7: attempted_method = "WriteDynamicWithFixedVectorSubarray()"; break;
  case 8: attempted_method = "WriteGenericSubarray()"; break;
  case 9: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void SubarraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadDynamicWithFixedIntSubarray()";
    case 1: return "ReadDynamicWithFixedFloatSubarray()";
    case 2: return "ReadKnownDimCountWithFixedIntSubarray()";
    case 3: return "ReadKnownDimCountWithFixedFloatSubarray()";
    case 4: return "ReadFixedWithFixedIntSubarray()";
    case 5: return "ReadFixedWithFixedFloatSubarray()";
    case 6: return "ReadNestedSubarray()";
    case 7: return "ReadDynamicWithFixedVectorSubarray()";
    case 8: return "ReadGenericSubarray()";
    case 9: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string SubarraysWriterBase::schema_ = R"({"protocol":{"name":"Subarrays","sequence":[{"name":"dynamicWithFixedIntSubarray","type":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}}}}},{"name":"dynamicWithFixedFloatSubarray","type":{"array":{"items":{"array":{"items":"float32","dimensions":[{"length":3}]}}}}},{"name":"knownDimCountWithFixedIntSubarray","type":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}},"dimensions":1}}},{"name":"knownDimCountWithFixedFloatSubarray","type":{"array":{"items":{"array":{"items":"float32","dimensions":[{"length":3}]}},"dimensions":1}}},{"name":"fixedWithFixedIntSubarray","type":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}},"dimensions":[{"length":2}]}}},{"name":"fixedWithFixedFloatSubarray","type":{"array":{"items":{"array":{"items":"float32","dimensions":[{"length":3}]}},"dimensions":[{"length":2}]}}},{"name":"nestedSubarray","type":{"array":{"items":{"array":{"items":{"array":{"items":"int32","dimensions":[{"length":3}]}},"dimensions":[{"length":2}]}}}}},{"name":"dynamicWithFixedVectorSubarray","type":{"array":{"items":{"vector":{"items":"int32","length":3}}}}},{"name":"genericSubarray","type":{"name":"TestModel.Image","typeArguments":[{"array":{"items":"int32","dimensions":[{"length":3}]}}]}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"Image","typeParameters":["T"],"type":{"name":"Image.Image","typeArguments":["T"]}}]})";

std::vector<std::string> SubarraysWriterBase::previous_schemas_ = {
};

std::string SubarraysWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return SubarraysWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Subarrays.");
  }

}
void SubarraysWriterBase::WriteDynamicWithFixedIntSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) {
  if (unlikely(state_ != 0)) {
    SubarraysWriterBaseInvalidState(0, false, state_);
  }

  WriteDynamicWithFixedIntSubarrayImpl(value);
  state_ = 1;
}

void SubarraysWriterBase::WriteDynamicWithFixedFloatSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) {
  if (unlikely(state_ != 1)) {
    SubarraysWriterBaseInvalidState(1, false, state_);
  }

  WriteDynamicWithFixedFloatSubarrayImpl(value);
  state_ = 2;
}

void SubarraysWriterBase::WriteKnownDimCountWithFixedIntSubarray(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) {
  if (unlikely(state_ != 2)) {
    SubarraysWriterBaseInvalidState(2, false, state_);
  }

  WriteKnownDimCountWithFixedIntSubarrayImpl(value);
  state_ = 3;
}

void SubarraysWriterBase::WriteKnownDimCountWithFixedFloatSubarray(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) {
  if (unlikely(state_ != 3)) {
    SubarraysWriterBaseInvalidState(3, false, state_);
  }

  WriteKnownDimCountWithFixedFloatSubarrayImpl(value);
  state_ = 4;
}

void SubarraysWriterBase::WriteFixedWithFixedIntSubarray(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) {
  if (unlikely(state_ != 4)) {
    SubarraysWriterBaseInvalidState(4, false, state_);
  }

  WriteFixedWithFixedIntSubarrayImpl(value);
  state_ = 5;
}

void SubarraysWriterBase::WriteFixedWithFixedFloatSubarray(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) {
  if (unlikely(state_ != 5)) {
    SubarraysWriterBaseInvalidState(5, false, state_);
  }

  WriteFixedWithFixedFloatSubarrayImpl(value);
  state_ = 6;
}

void SubarraysWriterBase::WriteNestedSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) {
  if (unlikely(state_ != 6)) {
    SubarraysWriterBaseInvalidState(6, false, state_);
  }

  WriteNestedSubarrayImpl(value);
  state_ = 7;
}

void SubarraysWriterBase::WriteDynamicWithFixedVectorSubarray(yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) {
  if (unlikely(state_ != 7)) {
    SubarraysWriterBaseInvalidState(7, false, state_);
  }

  WriteDynamicWithFixedVectorSubarrayImpl(value);
  state_ = 8;
}

void SubarraysWriterBase::WriteGenericSubarray(test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) {
  if (unlikely(state_ != 8)) {
    SubarraysWriterBaseInvalidState(8, false, state_);
  }

  WriteGenericSubarrayImpl(value);
  state_ = 9;
}

void SubarraysWriterBase::Close() {
  if (unlikely(state_ != 9)) {
    SubarraysWriterBaseInvalidState(9, false, state_);
  }

  CloseImpl();
}

std::string SubarraysReaderBase::schema_ = SubarraysWriterBase::schema_;

std::vector<std::string> SubarraysReaderBase::previous_schemas_ = SubarraysWriterBase::previous_schemas_;

Version SubarraysReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == SubarraysWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Subarrays.");
}
void SubarraysReaderBase::ReadDynamicWithFixedIntSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>>& value) {
  if (unlikely(state_ != 0)) {
    SubarraysReaderBaseInvalidState(0, state_);
  }

  ReadDynamicWithFixedIntSubarrayImpl(value);
  state_ = 2;
}

void SubarraysReaderBase::ReadDynamicWithFixedFloatSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>>& value) {
  if (unlikely(state_ != 2)) {
    SubarraysReaderBaseInvalidState(2, state_);
  }

  ReadDynamicWithFixedFloatSubarrayImpl(value);
  state_ = 4;
}

void SubarraysReaderBase::ReadKnownDimCountWithFixedIntSubarray(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1>& value) {
  if (unlikely(state_ != 4)) {
    SubarraysReaderBaseInvalidState(4, state_);
  }

  ReadKnownDimCountWithFixedIntSubarrayImpl(value);
  state_ = 6;
}

void SubarraysReaderBase::ReadKnownDimCountWithFixedFloatSubarray(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1>& value) {
  if (unlikely(state_ != 6)) {
    SubarraysReaderBaseInvalidState(6, state_);
  }

  ReadKnownDimCountWithFixedFloatSubarrayImpl(value);
  state_ = 8;
}

void SubarraysReaderBase::ReadFixedWithFixedIntSubarray(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>& value) {
  if (unlikely(state_ != 8)) {
    SubarraysReaderBaseInvalidState(8, state_);
  }

  ReadFixedWithFixedIntSubarrayImpl(value);
  state_ = 10;
}

void SubarraysReaderBase::ReadFixedWithFixedFloatSubarray(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2>& value) {
  if (unlikely(state_ != 10)) {
    SubarraysReaderBaseInvalidState(10, state_);
  }

  ReadFixedWithFixedFloatSubarrayImpl(value);
  state_ = 12;
}

void SubarraysReaderBase::ReadNestedSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>>& value) {
  if (unlikely(state_ != 12)) {
    SubarraysReaderBaseInvalidState(12, state_);
  }

  ReadNestedSubarrayImpl(value);
  state_ = 14;
}

void SubarraysReaderBase::ReadDynamicWithFixedVectorSubarray(yardl::DynamicNDArray<std::array<int32_t, 3>>& value) {
  if (unlikely(state_ != 14)) {
    SubarraysReaderBaseInvalidState(14, state_);
  }

  ReadDynamicWithFixedVectorSubarrayImpl(value);
  state_ = 16;
}

void SubarraysReaderBase::ReadGenericSubarray(test_model::Image<yardl::FixedNDArray<int32_t, 3>>& value) {
  if (unlikely(state_ != 16)) {
    SubarraysReaderBaseInvalidState(16, state_);
  }

  ReadGenericSubarrayImpl(value);
  state_ = 18;
}

void SubarraysReaderBase::Close() {
  if (unlikely(state_ != 18)) {
    SubarraysReaderBaseInvalidState(18, state_);
  }

  CloseImpl();
}
void SubarraysReaderBase::CopyTo(SubarraysWriterBase& writer) {
  {
    yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> value;
    ReadDynamicWithFixedIntSubarray(value);
    writer.WriteDynamicWithFixedIntSubarray(value);
  }
  {
    yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> value;
    ReadDynamicWithFixedFloatSubarray(value);
    writer.WriteDynamicWithFixedFloatSubarray(value);
  }
  {
    yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> value;
    ReadKnownDimCountWithFixedIntSubarray(value);
    writer.WriteKnownDimCountWithFixedIntSubarray(value);
  }
  {
    yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> value;
    ReadKnownDimCountWithFixedFloatSubarray(value);
    writer.WriteKnownDimCountWithFixedFloatSubarray(value);
  }
  {
    yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> value;
    ReadFixedWithFixedIntSubarray(value);
    writer.WriteFixedWithFixedIntSubarray(value);
  }
  {
    yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> value;
    ReadFixedWithFixedFloatSubarray(value);
    writer.WriteFixedWithFixedFloatSubarray(value);
  }
  {
    yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> value;
    ReadNestedSubarray(value);
    writer.WriteNestedSubarray(value);
  }
  {
    yardl::DynamicNDArray<std::array<int32_t, 3>> value;
    ReadDynamicWithFixedVectorSubarray(value);
    writer.WriteDynamicWithFixedVectorSubarray(value);
  }
  {
    test_model::Image<yardl::FixedNDArray<int32_t, 3>> value;
    ReadGenericSubarray(value);
    writer.WriteGenericSubarray(value);
  }
}

namespace {
void SubarraysInRecordsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteWithFixedSubarrays()"; break;
  case 1: expected_method = "WriteWithVlenSubarrays()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteWithFixedSubarrays()"; break;
  case 1: attempted_method = "WriteWithVlenSubarrays()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void SubarraysInRecordsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadWithFixedSubarrays()";
    case 1: return "ReadWithVlenSubarrays()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string SubarraysInRecordsWriterBase::schema_ = R"({"protocol":{"name":"SubarraysInRecords","sequence":[{"name":"withFixedSubarrays","type":{"array":{"items":"TestModel.RecordWithFixedCollections"}}},{"name":"withVlenSubarrays","type":{"array":{"items":"TestModel.RecordWithVlenCollections"}}}]},"types":[{"name":"RecordWithFixedCollections","fields":[{"name":"fixedVector","type":{"vector":{"items":"int32","length":3}}},{"name":"fixedArray","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}}]},{"name":"RecordWithVlenCollections","fields":[{"name":"vector","type":{"vector":{"items":"int32"}}},{"name":"array","type":{"array":{"items":"int32","dimensions":2}}}]}]})";

std::vector<std::string> SubarraysInRecordsWriterBase::previous_schemas_ = {
};

std::string SubarraysInRecordsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return SubarraysInRecordsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol SubarraysInRecords.");
  }

}
void SubarraysInRecordsWriterBase::WriteWithFixedSubarrays(yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) {
  if (unlikely(state_ != 0)) {
    SubarraysInRecordsWriterBaseInvalidState(0, false, state_);
  }

  WriteWithFixedSubarraysImpl(value);
  state_ = 1;
}

void SubarraysInRecordsWriterBase::WriteWithVlenSubarrays(yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) {
  if (unlikely(state_ != 1)) {
    SubarraysInRecordsWriterBaseInvalidState(1, false, state_);
  }

  WriteWithVlenSubarraysImpl(value);
  state_ = 2;
}

void SubarraysInRecordsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    SubarraysInRecordsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string SubarraysInRecordsReaderBase::schema_ = SubarraysInRecordsWriterBase::schema_;

std::vector<std::string> SubarraysInRecordsReaderBase::previous_schemas_ = SubarraysInRecordsWriterBase::previous_schemas_;

Version SubarraysInRecordsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == SubarraysInRecordsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol SubarraysInRecords.");
}
void SubarraysInRecordsReaderBase::ReadWithFixedSubarrays(yardl::DynamicNDArray<test_model::RecordWithFixedCollections>& value) {
  if (unlikely(state_ != 0)) {
    SubarraysInRecordsReaderBaseInvalidState(0, state_);
  }

  ReadWithFixedSubarraysImpl(value);
  state_ = 2;
}

void SubarraysInRecordsReaderBase::ReadWithVlenSubarrays(yardl::DynamicNDArray<test_model::RecordWithVlenCollections>& value) {
  if (unlikely(state_ != 2)) {
    SubarraysInRecordsReaderBaseInvalidState(2, state_);
  }

  ReadWithVlenSubarraysImpl(value);
  state_ = 4;
}

void SubarraysInRecordsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    SubarraysInRecordsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void SubarraysInRecordsReaderBase::CopyTo(SubarraysInRecordsWriterBase& writer) {
  {
    yardl::DynamicNDArray<test_model::RecordWithFixedCollections> value;
    ReadWithFixedSubarrays(value);
    writer.WriteWithFixedSubarrays(value);
  }
  {
    yardl::DynamicNDArray<test_model::RecordWithVlenCollections> value;
    ReadWithVlenSubarrays(value);
    writer.WriteWithVlenSubarrays(value);
  }
}

namespace {
void NDArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteSimpleRecordArray()"; break;
  case 2: expected_method = "WriteRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithNDArrays()"; break;
  case 4: expected_method = "WriteNamedArray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithNDArrays()"; break;
  case 4: attempted_method = "WriteNamedArray()"; break;
  case 5: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void NDArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadSimpleRecordArray()";
    case 2: return "ReadRecordWithVlensArray()";
    case 3: return "ReadRecordWithNDArrays()";
    case 4: return "ReadNamedArray()";
    case 5: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string NDArraysWriterBase::schema_ = R"({"protocol":{"name":"NDArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":2}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":2}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":2}}},{"name":"recordWithNDArrays","type":"TestModel.RecordWithNDArrays"},{"name":"namedArray","type":"TestModel.NamedNDArray"}]},"types":[{"name":"NamedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA"},{"name":"dimB"}]}}},{"name":"RecordWithNDArrays","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":2}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":2}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":2}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> NDArraysWriterBase::previous_schemas_ = {
};

std::string NDArraysWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return NDArraysWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol NDArrays.");
  }

}
void NDArraysWriterBase::WriteInts(yardl::NDArray<int32_t, 2> const& value) {
  if (unlikely(state_ != 0)) {
    NDArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void NDArraysWriterBase::WriteSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 2> const& value) {
  if (unlikely(state_ != 1)) {
    NDArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteSimpleRecordArrayImpl(value);
  state_ = 2;
}

void NDArraysWriterBase::WriteRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) {
  if (unlikely(state_ != 2)) {
    NDArraysWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void NDArraysWriterBase::WriteRecordWithNDArrays(test_model::RecordWithNDArrays const& value) {
  if (unlikely(state_ != 3)) {
    NDArraysWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithNDArraysImpl(value);
  state_ = 4;
}

void NDArraysWriterBase::WriteNamedArray(test_model::NamedNDArray const& value) {
  if (unlikely(state_ != 4)) {
    NDArraysWriterBaseInvalidState(4, false, state_);
  }

  WriteNamedArrayImpl(value);
  state_ = 5;
}

void NDArraysWriterBase::Close() {
  if (unlikely(state_ != 5)) {
    NDArraysWriterBaseInvalidState(5, false, state_);
  }

  CloseImpl();
}

std::string NDArraysReaderBase::schema_ = NDArraysWriterBase::schema_;

std::vector<std::string> NDArraysReaderBase::previous_schemas_ = NDArraysWriterBase::previous_schemas_;

Version NDArraysReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == NDArraysWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol NDArrays.");
}
void NDArraysReaderBase::ReadInts(yardl::NDArray<int32_t, 2>& value) {
  if (unlikely(state_ != 0)) {
    NDArraysReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void NDArraysReaderBase::ReadSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 2>& value) {
  if (unlikely(state_ != 2)) {
    NDArraysReaderBaseInvalidState(2, state_);
  }

  ReadSimpleRecordArrayImpl(value);
  state_ = 4;
}

void NDArraysReaderBase::ReadRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 2>& value) {
  if (unlikely(state_ != 4)) {
    NDArraysReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void NDArraysReaderBase::ReadRecordWithNDArrays(test_model::RecordWithNDArrays& value) {
  if (unlikely(state_ != 6)) {
    NDArraysReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithNDArraysImpl(value);
  state_ = 8;
}

void NDArraysReaderBase::ReadNamedArray(test_model::NamedNDArray& value) {
  if (unlikely(state_ != 8)) {
    NDArraysReaderBaseInvalidState(8, state_);
  }

  ReadNamedArrayImpl(value);
  state_ = 10;
}

void NDArraysReaderBase::Close() {
  if (unlikely(state_ != 10)) {
    NDArraysReaderBaseInvalidState(10, state_);
  }

  CloseImpl();
}
void NDArraysReaderBase::CopyTo(NDArraysWriterBase& writer) {
  {
    yardl::NDArray<int32_t, 2> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::NDArray<test_model::SimpleRecord, 2> value;
    ReadSimpleRecordArray(value);
    writer.WriteSimpleRecordArray(value);
  }
  {
    yardl::NDArray<test_model::RecordWithVlens, 2> value;
    ReadRecordWithVlensArray(value);
    writer.WriteRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithNDArrays value;
    ReadRecordWithNDArrays(value);
    writer.WriteRecordWithNDArrays(value);
  }
  {
    test_model::NamedNDArray value;
    ReadNamedArray(value);
    writer.WriteNamedArray(value);
  }
}

namespace {
void NDArraysSingleDimensionWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteSimpleRecordArray()"; break;
  case 2: expected_method = "WriteRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithNDArrays()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithNDArrays()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void NDArraysSingleDimensionReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadSimpleRecordArray()";
    case 2: return "ReadRecordWithVlensArray()";
    case 3: return "ReadRecordWithNDArrays()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string NDArraysSingleDimensionWriterBase::schema_ = R"({"protocol":{"name":"NDArraysSingleDimension","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":1}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":1}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":1}}},{"name":"recordWithNDArrays","type":"TestModel.RecordWithNDArraysSingleDimension"}]},"types":[{"name":"RecordWithNDArraysSingleDimension","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":1}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":1}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":1}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> NDArraysSingleDimensionWriterBase::previous_schemas_ = {
};

std::string NDArraysSingleDimensionWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return NDArraysSingleDimensionWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol NDArraysSingleDimension.");
  }

}
void NDArraysSingleDimensionWriterBase::WriteInts(yardl::NDArray<int32_t, 1> const& value) {
  if (unlikely(state_ != 0)) {
    NDArraysSingleDimensionWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void NDArraysSingleDimensionWriterBase::WriteSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 1> const& value) {
  if (unlikely(state_ != 1)) {
    NDArraysSingleDimensionWriterBaseInvalidState(1, false, state_);
  }

  WriteSimpleRecordArrayImpl(value);
  state_ = 2;
}

void NDArraysSingleDimensionWriterBase::WriteRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) {
  if (unlikely(state_ != 2)) {
    NDArraysSingleDimensionWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void NDArraysSingleDimensionWriterBase::WriteRecordWithNDArrays(test_model::RecordWithNDArraysSingleDimension const& value) {
  if (unlikely(state_ != 3)) {
    NDArraysSingleDimensionWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithNDArraysImpl(value);
  state_ = 4;
}

void NDArraysSingleDimensionWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    NDArraysSingleDimensionWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string NDArraysSingleDimensionReaderBase::schema_ = NDArraysSingleDimensionWriterBase::schema_;

std::vector<std::string> NDArraysSingleDimensionReaderBase::previous_schemas_ = NDArraysSingleDimensionWriterBase::previous_schemas_;

Version NDArraysSingleDimensionReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == NDArraysSingleDimensionWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol NDArraysSingleDimension.");
}
void NDArraysSingleDimensionReaderBase::ReadInts(yardl::NDArray<int32_t, 1>& value) {
  if (unlikely(state_ != 0)) {
    NDArraysSingleDimensionReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void NDArraysSingleDimensionReaderBase::ReadSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 1>& value) {
  if (unlikely(state_ != 2)) {
    NDArraysSingleDimensionReaderBaseInvalidState(2, state_);
  }

  ReadSimpleRecordArrayImpl(value);
  state_ = 4;
}

void NDArraysSingleDimensionReaderBase::ReadRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 1>& value) {
  if (unlikely(state_ != 4)) {
    NDArraysSingleDimensionReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void NDArraysSingleDimensionReaderBase::ReadRecordWithNDArrays(test_model::RecordWithNDArraysSingleDimension& value) {
  if (unlikely(state_ != 6)) {
    NDArraysSingleDimensionReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithNDArraysImpl(value);
  state_ = 8;
}

void NDArraysSingleDimensionReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    NDArraysSingleDimensionReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void NDArraysSingleDimensionReaderBase::CopyTo(NDArraysSingleDimensionWriterBase& writer) {
  {
    yardl::NDArray<int32_t, 1> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::NDArray<test_model::SimpleRecord, 1> value;
    ReadSimpleRecordArray(value);
    writer.WriteSimpleRecordArray(value);
  }
  {
    yardl::NDArray<test_model::RecordWithVlens, 1> value;
    ReadRecordWithVlensArray(value);
    writer.WriteRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithNDArraysSingleDimension value;
    ReadRecordWithNDArrays(value);
    writer.WriteRecordWithNDArrays(value);
  }
}

namespace {
void DynamicNDArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteSimpleRecordArray()"; break;
  case 2: expected_method = "WriteRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithDynamicNDArrays()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithDynamicNDArrays()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void DynamicNDArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadSimpleRecordArray()";
    case 2: return "ReadRecordWithVlensArray()";
    case 3: return "ReadRecordWithDynamicNDArrays()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string DynamicNDArraysWriterBase::schema_ = R"({"protocol":{"name":"DynamicNDArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32"}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord"}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens"}}},{"name":"recordWithDynamicNDArrays","type":"TestModel.RecordWithDynamicNDArrays"}]},"types":[{"name":"IntArray","type":{"array":{"items":"int32"}}},{"name":"RecordWithDynamicNDArrays","fields":[{"name":"ints","type":"TestModel.IntArray"},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord"}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens"}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> DynamicNDArraysWriterBase::previous_schemas_ = {
};

std::string DynamicNDArraysWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return DynamicNDArraysWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol DynamicNDArrays.");
  }

}
void DynamicNDArraysWriterBase::WriteInts(yardl::DynamicNDArray<int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    DynamicNDArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void DynamicNDArraysWriterBase::WriteSimpleRecordArray(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 1)) {
    DynamicNDArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteSimpleRecordArrayImpl(value);
  state_ = 2;
}

void DynamicNDArraysWriterBase::WriteRecordWithVlensArray(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) {
  if (unlikely(state_ != 2)) {
    DynamicNDArraysWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void DynamicNDArraysWriterBase::WriteRecordWithDynamicNDArrays(test_model::RecordWithDynamicNDArrays const& value) {
  if (unlikely(state_ != 3)) {
    DynamicNDArraysWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithDynamicNDArraysImpl(value);
  state_ = 4;
}

void DynamicNDArraysWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    DynamicNDArraysWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string DynamicNDArraysReaderBase::schema_ = DynamicNDArraysWriterBase::schema_;

std::vector<std::string> DynamicNDArraysReaderBase::previous_schemas_ = DynamicNDArraysWriterBase::previous_schemas_;

Version DynamicNDArraysReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == DynamicNDArraysWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol DynamicNDArrays.");
}
void DynamicNDArraysReaderBase::ReadInts(yardl::DynamicNDArray<int32_t>& value) {
  if (unlikely(state_ != 0)) {
    DynamicNDArraysReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void DynamicNDArraysReaderBase::ReadSimpleRecordArray(yardl::DynamicNDArray<test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 2)) {
    DynamicNDArraysReaderBaseInvalidState(2, state_);
  }

  ReadSimpleRecordArrayImpl(value);
  state_ = 4;
}

void DynamicNDArraysReaderBase::ReadRecordWithVlensArray(yardl::DynamicNDArray<test_model::RecordWithVlens>& value) {
  if (unlikely(state_ != 4)) {
    DynamicNDArraysReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void DynamicNDArraysReaderBase::ReadRecordWithDynamicNDArrays(test_model::RecordWithDynamicNDArrays& value) {
  if (unlikely(state_ != 6)) {
    DynamicNDArraysReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithDynamicNDArraysImpl(value);
  state_ = 8;
}

void DynamicNDArraysReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    DynamicNDArraysReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void DynamicNDArraysReaderBase::CopyTo(DynamicNDArraysWriterBase& writer) {
  {
    yardl::DynamicNDArray<int32_t> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::DynamicNDArray<test_model::SimpleRecord> value;
    ReadSimpleRecordArray(value);
    writer.WriteSimpleRecordArray(value);
  }
  {
    yardl::DynamicNDArray<test_model::RecordWithVlens> value;
    ReadRecordWithVlensArray(value);
    writer.WriteRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithDynamicNDArrays value;
    ReadRecordWithDynamicNDArrays(value);
    writer.WriteRecordWithDynamicNDArrays(value);
  }
}

namespace {
void MultiDArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteImages() or EndImages()"; break;
  case 1: expected_method = "WriteFrames() or EndFrames()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndImages()" : "WriteImages()"; break;
  case 1: attempted_method = end ? "EndFrames()" : "WriteFrames()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void MultiDArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadImages()";
    case 1: return "ReadFrames()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string MultiDArraysWriterBase::schema_ = R"({"protocol":{"name":"MultiDArrays","sequence":[{"name":"images","type":{"stream":{"items":{"array":{"items":"float32","dimensions":[{"name":"ch"},{"name":"z"},{"name":"y"},{"name":"x"}]}}}}},{"name":"frames","type":{"stream":{"items":{"array":{"items":"float32","dimensions":[{"name":"ch","length":1},{"name":"z","length":1},{"name":"y","length":64},{"name":"x","length":32}]}}}}}]},"types":null})";

std::vector<std::string> MultiDArraysWriterBase::previous_schemas_ = {
};

std::string MultiDArraysWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return MultiDArraysWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol MultiDArrays.");
  }

}
void MultiDArraysWriterBase::WriteImages(yardl::NDArray<float, 4> const& value) {
  if (unlikely(state_ != 0)) {
    MultiDArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteImagesImpl(value);
}

void MultiDArraysWriterBase::WriteImages(std::vector<yardl::NDArray<float, 4>> const& values) {
  if (unlikely(state_ != 0)) {
    MultiDArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteImagesImpl(values);
}

void MultiDArraysWriterBase::EndImages() {
  if (unlikely(state_ != 0)) {
    MultiDArraysWriterBaseInvalidState(0, true, state_);
  }

  EndImagesImpl();
  state_ = 1;
}

// fallback implementation
void MultiDArraysWriterBase::WriteImagesImpl(std::vector<yardl::NDArray<float, 4>> const& values) {
  for (auto const& v : values) {
    WriteImagesImpl(v);
  }
}

void MultiDArraysWriterBase::WriteFrames(yardl::FixedNDArray<float, 1, 1, 64, 32> const& value) {
  if (unlikely(state_ != 1)) {
    MultiDArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteFramesImpl(value);
}

void MultiDArraysWriterBase::WriteFrames(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> const& values) {
  if (unlikely(state_ != 1)) {
    MultiDArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteFramesImpl(values);
}

void MultiDArraysWriterBase::EndFrames() {
  if (unlikely(state_ != 1)) {
    MultiDArraysWriterBaseInvalidState(1, true, state_);
  }

  EndFramesImpl();
  state_ = 2;
}

// fallback implementation
void MultiDArraysWriterBase::WriteFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> const& values) {
  for (auto const& v : values) {
    WriteFramesImpl(v);
  }
}

void MultiDArraysWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    MultiDArraysWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string MultiDArraysReaderBase::schema_ = MultiDArraysWriterBase::schema_;

std::vector<std::string> MultiDArraysReaderBase::previous_schemas_ = MultiDArraysWriterBase::previous_schemas_;

Version MultiDArraysReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == MultiDArraysWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol MultiDArrays.");
}
bool MultiDArraysReaderBase::ReadImages(yardl::NDArray<float, 4>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    MultiDArraysReaderBaseInvalidState(0, state_);
  }

  bool result = ReadImagesImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool MultiDArraysReaderBase::ReadImages(std::vector<yardl::NDArray<float, 4>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    MultiDArraysReaderBaseInvalidState(0, state_);
  }

  if (!ReadImagesImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool MultiDArraysReaderBase::ReadImagesImpl(std::vector<yardl::NDArray<float, 4>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadImagesImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool MultiDArraysReaderBase::ReadFrames(yardl::FixedNDArray<float, 1, 1, 64, 32>& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      MultiDArraysReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadFramesImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool MultiDArraysReaderBase::ReadFrames(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      MultiDArraysReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadFramesImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool MultiDArraysReaderBase::ReadFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFramesImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void MultiDArraysReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      MultiDArraysReaderBaseInvalidState(4, state_);
    }
  }

  CloseImpl();
}
void MultiDArraysReaderBase::CopyTo(MultiDArraysWriterBase& writer, size_t images_buffer_size, size_t frames_buffer_size) {
  if (images_buffer_size > 1) {
    std::vector<yardl::NDArray<float, 4>> values;
    values.reserve(images_buffer_size);
    while(ReadImages(values)) {
      writer.WriteImages(values);
    }
    writer.EndImages();
  } else {
    yardl::NDArray<float, 4> value;
    while(ReadImages(value)) {
      writer.WriteImages(value);
    }
    writer.EndImages();
  }
  if (frames_buffer_size > 1) {
    std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> values;
    values.reserve(frames_buffer_size);
    while(ReadFrames(values)) {
      writer.WriteFrames(values);
    }
    writer.EndFrames();
  } else {
    yardl::FixedNDArray<float, 1, 1, 64, 32> value;
    while(ReadFrames(value)) {
      writer.WriteFrames(value);
    }
    writer.EndFrames();
  }
}

namespace {
void MapsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteStringToInt()"; break;
  case 1: expected_method = "WriteIntToString()"; break;
  case 2: expected_method = "WriteStringToUnion()"; break;
  case 3: expected_method = "WriteAliasedGeneric()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteStringToInt()"; break;
  case 1: attempted_method = "WriteIntToString()"; break;
  case 2: attempted_method = "WriteStringToUnion()"; break;
  case 3: attempted_method = "WriteAliasedGeneric()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void MapsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadStringToInt()";
    case 1: return "ReadIntToString()";
    case 2: return "ReadStringToUnion()";
    case 3: return "ReadAliasedGeneric()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string MapsWriterBase::schema_ = R"({"protocol":{"name":"Maps","sequence":[{"name":"stringToInt","type":{"map":{"keys":"string","values":"int32"}}},{"name":"intToString","type":{"map":{"keys":"int32","values":"string"}}},{"name":"stringToUnion","type":{"map":{"keys":"string","values":[{"tag":"string","type":"string"},{"tag":"int32","type":"int32"}]}}},{"name":"aliasedGeneric","type":{"name":"BasicTypes.AliasedMap","typeArguments":["string","int32"]}}]},"types":[{"name":"AliasedMap","typeParameters":["K","V"],"type":{"map":{"keys":"K","values":"V"}}}]})";

std::vector<std::string> MapsWriterBase::previous_schemas_ = {
};

std::string MapsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return MapsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Maps.");
  }

}
void MapsWriterBase::WriteStringToInt(std::unordered_map<std::string, int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    MapsWriterBaseInvalidState(0, false, state_);
  }

  WriteStringToIntImpl(value);
  state_ = 1;
}

void MapsWriterBase::WriteIntToString(std::unordered_map<int32_t, std::string> const& value) {
  if (unlikely(state_ != 1)) {
    MapsWriterBaseInvalidState(1, false, state_);
  }

  WriteIntToStringImpl(value);
  state_ = 2;
}

void MapsWriterBase::WriteStringToUnion(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) {
  if (unlikely(state_ != 2)) {
    MapsWriterBaseInvalidState(2, false, state_);
  }

  WriteStringToUnionImpl(value);
  state_ = 3;
}

void MapsWriterBase::WriteAliasedGeneric(basic_types::AliasedMap<std::string, int32_t> const& value) {
  if (unlikely(state_ != 3)) {
    MapsWriterBaseInvalidState(3, false, state_);
  }

  WriteAliasedGenericImpl(value);
  state_ = 4;
}

void MapsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    MapsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string MapsReaderBase::schema_ = MapsWriterBase::schema_;

std::vector<std::string> MapsReaderBase::previous_schemas_ = MapsWriterBase::previous_schemas_;

Version MapsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == MapsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Maps.");
}
void MapsReaderBase::ReadStringToInt(std::unordered_map<std::string, int32_t>& value) {
  if (unlikely(state_ != 0)) {
    MapsReaderBaseInvalidState(0, state_);
  }

  ReadStringToIntImpl(value);
  state_ = 2;
}

void MapsReaderBase::ReadIntToString(std::unordered_map<int32_t, std::string>& value) {
  if (unlikely(state_ != 2)) {
    MapsReaderBaseInvalidState(2, state_);
  }

  ReadIntToStringImpl(value);
  state_ = 4;
}

void MapsReaderBase::ReadStringToUnion(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value) {
  if (unlikely(state_ != 4)) {
    MapsReaderBaseInvalidState(4, state_);
  }

  ReadStringToUnionImpl(value);
  state_ = 6;
}

void MapsReaderBase::ReadAliasedGeneric(basic_types::AliasedMap<std::string, int32_t>& value) {
  if (unlikely(state_ != 6)) {
    MapsReaderBaseInvalidState(6, state_);
  }

  ReadAliasedGenericImpl(value);
  state_ = 8;
}

void MapsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    MapsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void MapsReaderBase::CopyTo(MapsWriterBase& writer) {
  {
    std::unordered_map<std::string, int32_t> value;
    ReadStringToInt(value);
    writer.WriteStringToInt(value);
  }
  {
    std::unordered_map<int32_t, std::string> value;
    ReadIntToString(value);
    writer.WriteIntToString(value);
  }
  {
    std::unordered_map<std::string, std::variant<std::string, int32_t>> value;
    ReadStringToUnion(value);
    writer.WriteStringToUnion(value);
  }
  {
    basic_types::AliasedMap<std::string, int32_t> value;
    ReadAliasedGeneric(value);
    writer.WriteAliasedGeneric(value);
  }
}

namespace {
void UnionsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntOrSimpleRecord()"; break;
  case 1: expected_method = "WriteIntOrRecordWithVlens()"; break;
  case 2: expected_method = "WriteMonosotateOrIntOrSimpleRecord()"; break;
  case 3: expected_method = "WriteRecordWithUnions()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteIntOrSimpleRecord()"; break;
  case 1: attempted_method = "WriteIntOrRecordWithVlens()"; break;
  case 2: attempted_method = "WriteMonosotateOrIntOrSimpleRecord()"; break;
  case 3: attempted_method = "WriteRecordWithUnions()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void UnionsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntOrSimpleRecord()";
    case 1: return "ReadIntOrRecordWithVlens()";
    case 2: return "ReadMonosotateOrIntOrSimpleRecord()";
    case 3: return "ReadRecordWithUnions()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string UnionsWriterBase::schema_ = R"({"protocol":{"name":"Unions","sequence":[{"name":"intOrSimpleRecord","type":[{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"intOrRecordWithVlens","type":[{"tag":"int32","type":"int32"},{"tag":"RecordWithVlens","type":"TestModel.RecordWithVlens"}]},{"name":"monosotateOrIntOrSimpleRecord","type":[null,{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"recordWithUnions","type":"BasicTypes.RecordWithUnions"}]},"types":[{"name":"DaysOfWeek","values":[{"symbol":"monday","value":1},{"symbol":"tuesday","value":2},{"symbol":"wednesday","value":4},{"symbol":"thursday","value":8},{"symbol":"friday","value":16},{"symbol":"saturday","value":32},{"symbol":"sunday","value":64}]},{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"GenericNullableUnion2","typeParameters":["T1","T2"],"type":[null,{"tag":"T1","type":"T1"},{"tag":"T2","type":"T2"}]},{"name":"RecordWithUnions","fields":[{"name":"nullOrIntOrString","type":[null,{"tag":"int32","type":"int32"},{"tag":"string","type":"string"}]},{"name":"dateOrDatetime","type":[{"tag":"time","type":"time"},{"tag":"datetime","type":"datetime"}]},{"name":"nullOrFruitsOrDaysOfWeek","type":{"name":"BasicTypes.GenericNullableUnion2","typeArguments":["BasicTypes.Fruits","BasicTypes.DaysOfWeek"]}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> UnionsWriterBase::previous_schemas_ = {
};

std::string UnionsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return UnionsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Unions.");
  }

}
void UnionsWriterBase::WriteIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 0)) {
    UnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(value);
  state_ = 1;
}

void UnionsWriterBase::WriteIntOrRecordWithVlens(std::variant<int32_t, test_model::RecordWithVlens> const& value) {
  if (unlikely(state_ != 1)) {
    UnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteIntOrRecordWithVlensImpl(value);
  state_ = 2;
}

void UnionsWriterBase::WriteMonosotateOrIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 2)) {
    UnionsWriterBaseInvalidState(2, false, state_);
  }

  WriteMonosotateOrIntOrSimpleRecordImpl(value);
  state_ = 3;
}

void UnionsWriterBase::WriteRecordWithUnions(basic_types::RecordWithUnions const& value) {
  if (unlikely(state_ != 3)) {
    UnionsWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithUnionsImpl(value);
  state_ = 4;
}

void UnionsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    UnionsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string UnionsReaderBase::schema_ = UnionsWriterBase::schema_;

std::vector<std::string> UnionsReaderBase::previous_schemas_ = UnionsWriterBase::previous_schemas_;

Version UnionsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == UnionsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Unions.");
}
void UnionsReaderBase::ReadIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 0)) {
    UnionsReaderBaseInvalidState(0, state_);
  }

  ReadIntOrSimpleRecordImpl(value);
  state_ = 2;
}

void UnionsReaderBase::ReadIntOrRecordWithVlens(std::variant<int32_t, test_model::RecordWithVlens>& value) {
  if (unlikely(state_ != 2)) {
    UnionsReaderBaseInvalidState(2, state_);
  }

  ReadIntOrRecordWithVlensImpl(value);
  state_ = 4;
}

void UnionsReaderBase::ReadMonosotateOrIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 4)) {
    UnionsReaderBaseInvalidState(4, state_);
  }

  ReadMonosotateOrIntOrSimpleRecordImpl(value);
  state_ = 6;
}

void UnionsReaderBase::ReadRecordWithUnions(basic_types::RecordWithUnions& value) {
  if (unlikely(state_ != 6)) {
    UnionsReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithUnionsImpl(value);
  state_ = 8;
}

void UnionsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    UnionsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void UnionsReaderBase::CopyTo(UnionsWriterBase& writer) {
  {
    std::variant<int32_t, test_model::SimpleRecord> value;
    ReadIntOrSimpleRecord(value);
    writer.WriteIntOrSimpleRecord(value);
  }
  {
    std::variant<int32_t, test_model::RecordWithVlens> value;
    ReadIntOrRecordWithVlens(value);
    writer.WriteIntOrRecordWithVlens(value);
  }
  {
    std::variant<std::monostate, int32_t, test_model::SimpleRecord> value;
    ReadMonosotateOrIntOrSimpleRecord(value);
    writer.WriteMonosotateOrIntOrSimpleRecord(value);
  }
  {
    basic_types::RecordWithUnions value;
    ReadRecordWithUnions(value);
    writer.WriteRecordWithUnions(value);
  }
}

namespace {
void StreamsOfUnionsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntOrSimpleRecord() or EndIntOrSimpleRecord()"; break;
  case 1: expected_method = "WriteNullableIntOrSimpleRecord() or EndNullableIntOrSimpleRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndIntOrSimpleRecord()" : "WriteIntOrSimpleRecord()"; break;
  case 1: attempted_method = end ? "EndNullableIntOrSimpleRecord()" : "WriteNullableIntOrSimpleRecord()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StreamsOfUnionsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntOrSimpleRecord()";
    case 1: return "ReadNullableIntOrSimpleRecord()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StreamsOfUnionsWriterBase::schema_ = R"({"protocol":{"name":"StreamsOfUnions","sequence":[{"name":"intOrSimpleRecord","type":{"stream":{"items":[{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]}}},{"name":"nullableIntOrSimpleRecord","type":{"stream":{"items":[null,{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]}}}]},"types":[{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> StreamsOfUnionsWriterBase::previous_schemas_ = {
};

std::string StreamsOfUnionsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return StreamsOfUnionsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol StreamsOfUnions.");
  }

}
void StreamsOfUnionsWriterBase::WriteIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 0)) {
    StreamsOfUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(value);
}

void StreamsOfUnionsWriterBase::WriteIntOrSimpleRecord(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) {
  if (unlikely(state_ != 0)) {
    StreamsOfUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(values);
}

void StreamsOfUnionsWriterBase::EndIntOrSimpleRecord() {
  if (unlikely(state_ != 0)) {
    StreamsOfUnionsWriterBaseInvalidState(0, true, state_);
  }

  EndIntOrSimpleRecordImpl();
  state_ = 1;
}

// fallback implementation
void StreamsOfUnionsWriterBase::WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) {
  for (auto const& v : values) {
    WriteIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfUnionsWriterBase::WriteNullableIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 1)) {
    StreamsOfUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(value);
}

void StreamsOfUnionsWriterBase::WriteNullableIntOrSimpleRecord(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) {
  if (unlikely(state_ != 1)) {
    StreamsOfUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(values);
}

void StreamsOfUnionsWriterBase::EndNullableIntOrSimpleRecord() {
  if (unlikely(state_ != 1)) {
    StreamsOfUnionsWriterBaseInvalidState(1, true, state_);
  }

  EndNullableIntOrSimpleRecordImpl();
  state_ = 2;
}

// fallback implementation
void StreamsOfUnionsWriterBase::WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) {
  for (auto const& v : values) {
    WriteNullableIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfUnionsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    StreamsOfUnionsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string StreamsOfUnionsReaderBase::schema_ = StreamsOfUnionsWriterBase::schema_;

std::vector<std::string> StreamsOfUnionsReaderBase::previous_schemas_ = StreamsOfUnionsWriterBase::previous_schemas_;

Version StreamsOfUnionsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == StreamsOfUnionsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol StreamsOfUnions.");
}
bool StreamsOfUnionsReaderBase::ReadIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    StreamsOfUnionsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool StreamsOfUnionsReaderBase::ReadIntOrSimpleRecord(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    StreamsOfUnionsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntOrSimpleRecordImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsOfUnionsReaderBase::ReadIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsOfUnionsReaderBase::ReadNullableIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfUnionsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadNullableIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StreamsOfUnionsReaderBase::ReadNullableIntOrSimpleRecord(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfUnionsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadNullableIntOrSimpleRecordImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsOfUnionsReaderBase::ReadNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadNullableIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StreamsOfUnionsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      StreamsOfUnionsReaderBaseInvalidState(4, state_);
    }
  }

  CloseImpl();
}
void StreamsOfUnionsReaderBase::CopyTo(StreamsOfUnionsWriterBase& writer, size_t int_or_simple_record_buffer_size, size_t nullable_int_or_simple_record_buffer_size) {
  if (int_or_simple_record_buffer_size > 1) {
    std::vector<std::variant<int32_t, test_model::SimpleRecord>> values;
    values.reserve(int_or_simple_record_buffer_size);
    while(ReadIntOrSimpleRecord(values)) {
      writer.WriteIntOrSimpleRecord(values);
    }
    writer.EndIntOrSimpleRecord();
  } else {
    std::variant<int32_t, test_model::SimpleRecord> value;
    while(ReadIntOrSimpleRecord(value)) {
      writer.WriteIntOrSimpleRecord(value);
    }
    writer.EndIntOrSimpleRecord();
  }
  if (nullable_int_or_simple_record_buffer_size > 1) {
    std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> values;
    values.reserve(nullable_int_or_simple_record_buffer_size);
    while(ReadNullableIntOrSimpleRecord(values)) {
      writer.WriteNullableIntOrSimpleRecord(values);
    }
    writer.EndNullableIntOrSimpleRecord();
  } else {
    std::variant<std::monostate, int32_t, test_model::SimpleRecord> value;
    while(ReadNullableIntOrSimpleRecord(value)) {
      writer.WriteNullableIntOrSimpleRecord(value);
    }
    writer.EndNullableIntOrSimpleRecord();
  }
}

namespace {
void EnumsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSingle()"; break;
  case 1: expected_method = "WriteVec()"; break;
  case 2: expected_method = "WriteSize()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteSingle()"; break;
  case 1: attempted_method = "WriteVec()"; break;
  case 2: attempted_method = "WriteSize()"; break;
  case 3: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void EnumsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSingle()";
    case 1: return "ReadVec()";
    case 2: return "ReadSize()";
    case 3: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string EnumsWriterBase::schema_ = R"({"protocol":{"name":"Enums","sequence":[{"name":"single","type":"TestModel.Fruits"},{"name":"vec","type":{"vector":{"items":"TestModel.Fruits"}}},{"name":"size","type":"TestModel.SizeBasedEnum"}]},"types":[{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"Fruits","type":"BasicTypes.Fruits"},{"name":"SizeBasedEnum","base":"size","values":[{"symbol":"a","value":0},{"symbol":"b","value":1},{"symbol":"c","value":2}]}]})";

std::vector<std::string> EnumsWriterBase::previous_schemas_ = {
};

std::string EnumsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return EnumsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Enums.");
  }

}
void EnumsWriterBase::WriteSingle(test_model::Fruits const& value) {
  if (unlikely(state_ != 0)) {
    EnumsWriterBaseInvalidState(0, false, state_);
  }

  WriteSingleImpl(value);
  state_ = 1;
}

void EnumsWriterBase::WriteVec(std::vector<test_model::Fruits> const& value) {
  if (unlikely(state_ != 1)) {
    EnumsWriterBaseInvalidState(1, false, state_);
  }

  WriteVecImpl(value);
  state_ = 2;
}

void EnumsWriterBase::WriteSize(test_model::SizeBasedEnum const& value) {
  if (unlikely(state_ != 2)) {
    EnumsWriterBaseInvalidState(2, false, state_);
  }

  WriteSizeImpl(value);
  state_ = 3;
}

void EnumsWriterBase::Close() {
  if (unlikely(state_ != 3)) {
    EnumsWriterBaseInvalidState(3, false, state_);
  }

  CloseImpl();
}

std::string EnumsReaderBase::schema_ = EnumsWriterBase::schema_;

std::vector<std::string> EnumsReaderBase::previous_schemas_ = EnumsWriterBase::previous_schemas_;

Version EnumsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == EnumsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Enums.");
}
void EnumsReaderBase::ReadSingle(test_model::Fruits& value) {
  if (unlikely(state_ != 0)) {
    EnumsReaderBaseInvalidState(0, state_);
  }

  ReadSingleImpl(value);
  state_ = 2;
}

void EnumsReaderBase::ReadVec(std::vector<test_model::Fruits>& value) {
  if (unlikely(state_ != 2)) {
    EnumsReaderBaseInvalidState(2, state_);
  }

  ReadVecImpl(value);
  state_ = 4;
}

void EnumsReaderBase::ReadSize(test_model::SizeBasedEnum& value) {
  if (unlikely(state_ != 4)) {
    EnumsReaderBaseInvalidState(4, state_);
  }

  ReadSizeImpl(value);
  state_ = 6;
}

void EnumsReaderBase::Close() {
  if (unlikely(state_ != 6)) {
    EnumsReaderBaseInvalidState(6, state_);
  }

  CloseImpl();
}
void EnumsReaderBase::CopyTo(EnumsWriterBase& writer) {
  {
    test_model::Fruits value;
    ReadSingle(value);
    writer.WriteSingle(value);
  }
  {
    std::vector<test_model::Fruits> value;
    ReadVec(value);
    writer.WriteVec(value);
  }
  {
    test_model::SizeBasedEnum value;
    ReadSize(value);
    writer.WriteSize(value);
  }
}

namespace {
void FlagsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteDays() or EndDays()"; break;
  case 1: expected_method = "WriteFormats() or EndFormats()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndDays()" : "WriteDays()"; break;
  case 1: attempted_method = end ? "EndFormats()" : "WriteFormats()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void FlagsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadDays()";
    case 1: return "ReadFormats()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string FlagsWriterBase::schema_ = R"({"protocol":{"name":"Flags","sequence":[{"name":"days","type":{"stream":{"items":"TestModel.DaysOfWeek"}}},{"name":"formats","type":{"stream":{"items":"TestModel.TextFormat"}}}]},"types":[{"name":"DaysOfWeek","values":[{"symbol":"monday","value":1},{"symbol":"tuesday","value":2},{"symbol":"wednesday","value":4},{"symbol":"thursday","value":8},{"symbol":"friday","value":16},{"symbol":"saturday","value":32},{"symbol":"sunday","value":64}]},{"name":"TextFormat","base":"uint64","values":[{"symbol":"regular","value":0},{"symbol":"bold","value":1},{"symbol":"italic","value":2},{"symbol":"underline","value":4},{"symbol":"strikethrough","value":8}]},{"name":"DaysOfWeek","type":"BasicTypes.DaysOfWeek"},{"name":"TextFormat","type":"BasicTypes.TextFormat"}]})";

std::vector<std::string> FlagsWriterBase::previous_schemas_ = {
};

std::string FlagsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return FlagsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Flags.");
  }

}
void FlagsWriterBase::WriteDays(test_model::DaysOfWeek const& value) {
  if (unlikely(state_ != 0)) {
    FlagsWriterBaseInvalidState(0, false, state_);
  }

  WriteDaysImpl(value);
}

void FlagsWriterBase::WriteDays(std::vector<test_model::DaysOfWeek> const& values) {
  if (unlikely(state_ != 0)) {
    FlagsWriterBaseInvalidState(0, false, state_);
  }

  WriteDaysImpl(values);
}

void FlagsWriterBase::EndDays() {
  if (unlikely(state_ != 0)) {
    FlagsWriterBaseInvalidState(0, true, state_);
  }

  EndDaysImpl();
  state_ = 1;
}

// fallback implementation
void FlagsWriterBase::WriteDaysImpl(std::vector<test_model::DaysOfWeek> const& values) {
  for (auto const& v : values) {
    WriteDaysImpl(v);
  }
}

void FlagsWriterBase::WriteFormats(test_model::TextFormat const& value) {
  if (unlikely(state_ != 1)) {
    FlagsWriterBaseInvalidState(1, false, state_);
  }

  WriteFormatsImpl(value);
}

void FlagsWriterBase::WriteFormats(std::vector<test_model::TextFormat> const& values) {
  if (unlikely(state_ != 1)) {
    FlagsWriterBaseInvalidState(1, false, state_);
  }

  WriteFormatsImpl(values);
}

void FlagsWriterBase::EndFormats() {
  if (unlikely(state_ != 1)) {
    FlagsWriterBaseInvalidState(1, true, state_);
  }

  EndFormatsImpl();
  state_ = 2;
}

// fallback implementation
void FlagsWriterBase::WriteFormatsImpl(std::vector<test_model::TextFormat> const& values) {
  for (auto const& v : values) {
    WriteFormatsImpl(v);
  }
}

void FlagsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    FlagsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string FlagsReaderBase::schema_ = FlagsWriterBase::schema_;

std::vector<std::string> FlagsReaderBase::previous_schemas_ = FlagsWriterBase::previous_schemas_;

Version FlagsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == FlagsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Flags.");
}
bool FlagsReaderBase::ReadDays(test_model::DaysOfWeek& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    FlagsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadDaysImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool FlagsReaderBase::ReadDays(std::vector<test_model::DaysOfWeek>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    FlagsReaderBaseInvalidState(0, state_);
  }

  if (!ReadDaysImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool FlagsReaderBase::ReadDaysImpl(std::vector<test_model::DaysOfWeek>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadDaysImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool FlagsReaderBase::ReadFormats(test_model::TextFormat& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      FlagsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadFormatsImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool FlagsReaderBase::ReadFormats(std::vector<test_model::TextFormat>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      FlagsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadFormatsImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool FlagsReaderBase::ReadFormatsImpl(std::vector<test_model::TextFormat>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFormatsImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void FlagsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      FlagsReaderBaseInvalidState(4, state_);
    }
  }

  CloseImpl();
}
void FlagsReaderBase::CopyTo(FlagsWriterBase& writer, size_t days_buffer_size, size_t formats_buffer_size) {
  if (days_buffer_size > 1) {
    std::vector<test_model::DaysOfWeek> values;
    values.reserve(days_buffer_size);
    while(ReadDays(values)) {
      writer.WriteDays(values);
    }
    writer.EndDays();
  } else {
    test_model::DaysOfWeek value;
    while(ReadDays(value)) {
      writer.WriteDays(value);
    }
    writer.EndDays();
  }
  if (formats_buffer_size > 1) {
    std::vector<test_model::TextFormat> values;
    values.reserve(formats_buffer_size);
    while(ReadFormats(values)) {
      writer.WriteFormats(values);
    }
    writer.EndFormats();
  } else {
    test_model::TextFormat value;
    while(ReadFormats(value)) {
      writer.WriteFormats(value);
    }
    writer.EndFormats();
  }
}

namespace {
void StateTestWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteAnInt()"; break;
  case 1: expected_method = "WriteAStream() or EndAStream()"; break;
  case 2: expected_method = "WriteAnotherInt()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteAnInt()"; break;
  case 1: attempted_method = end ? "EndAStream()" : "WriteAStream()"; break;
  case 2: attempted_method = "WriteAnotherInt()"; break;
  case 3: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StateTestReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadAnInt()";
    case 1: return "ReadAStream()";
    case 2: return "ReadAnotherInt()";
    case 3: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StateTestWriterBase::schema_ = R"({"protocol":{"name":"StateTest","sequence":[{"name":"anInt","type":"int32"},{"name":"aStream","type":{"stream":{"items":"int32"}}},{"name":"anotherInt","type":"int32"}]},"types":null})";

std::vector<std::string> StateTestWriterBase::previous_schemas_ = {
};

std::string StateTestWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return StateTestWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol StateTest.");
  }

}
void StateTestWriterBase::WriteAnInt(int32_t const& value) {
  if (unlikely(state_ != 0)) {
    StateTestWriterBaseInvalidState(0, false, state_);
  }

  WriteAnIntImpl(value);
  state_ = 1;
}

void StateTestWriterBase::WriteAStream(int32_t const& value) {
  if (unlikely(state_ != 1)) {
    StateTestWriterBaseInvalidState(1, false, state_);
  }

  WriteAStreamImpl(value);
}

void StateTestWriterBase::WriteAStream(std::vector<int32_t> const& values) {
  if (unlikely(state_ != 1)) {
    StateTestWriterBaseInvalidState(1, false, state_);
  }

  WriteAStreamImpl(values);
}

void StateTestWriterBase::EndAStream() {
  if (unlikely(state_ != 1)) {
    StateTestWriterBaseInvalidState(1, true, state_);
  }

  EndAStreamImpl();
  state_ = 2;
}

// fallback implementation
void StateTestWriterBase::WriteAStreamImpl(std::vector<int32_t> const& values) {
  for (auto const& v : values) {
    WriteAStreamImpl(v);
  }
}

void StateTestWriterBase::WriteAnotherInt(int32_t const& value) {
  if (unlikely(state_ != 2)) {
    StateTestWriterBaseInvalidState(2, false, state_);
  }

  WriteAnotherIntImpl(value);
  state_ = 3;
}

void StateTestWriterBase::Close() {
  if (unlikely(state_ != 3)) {
    StateTestWriterBaseInvalidState(3, false, state_);
  }

  CloseImpl();
}

std::string StateTestReaderBase::schema_ = StateTestWriterBase::schema_;

std::vector<std::string> StateTestReaderBase::previous_schemas_ = StateTestWriterBase::previous_schemas_;

Version StateTestReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == StateTestWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol StateTest.");
}
void StateTestReaderBase::ReadAnInt(int32_t& value) {
  if (unlikely(state_ != 0)) {
    StateTestReaderBaseInvalidState(0, state_);
  }

  ReadAnIntImpl(value);
  state_ = 2;
}

bool StateTestReaderBase::ReadAStream(int32_t& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    StateTestReaderBaseInvalidState(2, state_);
  }

  bool result = ReadAStreamImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StateTestReaderBase::ReadAStream(std::vector<int32_t>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    StateTestReaderBaseInvalidState(2, state_);
  }

  if (!ReadAStreamImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StateTestReaderBase::ReadAStreamImpl(std::vector<int32_t>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadAStreamImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StateTestReaderBase::ReadAnotherInt(int32_t& value) {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      StateTestReaderBaseInvalidState(4, state_);
    }
  }

  ReadAnotherIntImpl(value);
  state_ = 6;
}

void StateTestReaderBase::Close() {
  if (unlikely(state_ != 6)) {
    StateTestReaderBaseInvalidState(6, state_);
  }

  CloseImpl();
}
void StateTestReaderBase::CopyTo(StateTestWriterBase& writer, size_t a_stream_buffer_size) {
  {
    int32_t value;
    ReadAnInt(value);
    writer.WriteAnInt(value);
  }
  if (a_stream_buffer_size > 1) {
    std::vector<int32_t> values;
    values.reserve(a_stream_buffer_size);
    while(ReadAStream(values)) {
      writer.WriteAStream(values);
    }
    writer.EndAStream();
  } else {
    int32_t value;
    while(ReadAStream(value)) {
      writer.WriteAStream(value);
    }
    writer.EndAStream();
  }
  {
    int32_t value;
    ReadAnotherInt(value);
    writer.WriteAnotherInt(value);
  }
}

namespace {
void SimpleGenericsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloatImage()"; break;
  case 1: expected_method = "WriteIntImage()"; break;
  case 2: expected_method = "WriteIntImageAlternateSyntax()"; break;
  case 3: expected_method = "WriteStringImage()"; break;
  case 4: expected_method = "WriteIntFloatTuple()"; break;
  case 5: expected_method = "WriteFloatFloatTuple()"; break;
  case 6: expected_method = "WriteIntFloatTupleAlternateSyntax()"; break;
  case 7: expected_method = "WriteIntStringTuple()"; break;
  case 8: expected_method = "WriteStreamOfTypeVariants() or EndStreamOfTypeVariants()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteFloatImage()"; break;
  case 1: attempted_method = "WriteIntImage()"; break;
  case 2: attempted_method = "WriteIntImageAlternateSyntax()"; break;
  case 3: attempted_method = "WriteStringImage()"; break;
  case 4: attempted_method = "WriteIntFloatTuple()"; break;
  case 5: attempted_method = "WriteFloatFloatTuple()"; break;
  case 6: attempted_method = "WriteIntFloatTupleAlternateSyntax()"; break;
  case 7: attempted_method = "WriteIntStringTuple()"; break;
  case 8: attempted_method = end ? "EndStreamOfTypeVariants()" : "WriteStreamOfTypeVariants()"; break;
  case 9: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void SimpleGenericsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloatImage()";
    case 1: return "ReadIntImage()";
    case 2: return "ReadIntImageAlternateSyntax()";
    case 3: return "ReadStringImage()";
    case 4: return "ReadIntFloatTuple()";
    case 5: return "ReadFloatFloatTuple()";
    case 6: return "ReadIntFloatTupleAlternateSyntax()";
    case 7: return "ReadIntStringTuple()";
    case 8: return "ReadStreamOfTypeVariants()";
    case 9: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string SimpleGenericsWriterBase::schema_ = R"({"protocol":{"name":"SimpleGenerics","sequence":[{"name":"floatImage","type":"Image.FloatImage"},{"name":"intImage","type":"Image.IntImage"},{"name":"intImageAlternateSyntax","type":{"name":"TestModel.Image","typeArguments":["int32"]}},{"name":"stringImage","type":{"name":"TestModel.Image","typeArguments":["string"]}},{"name":"intFloatTuple","type":{"name":"Tuples.Tuple","typeArguments":["int32","float32"]}},{"name":"floatFloatTuple","type":{"name":"Tuples.Tuple","typeArguments":["float32","float32"]}},{"name":"intFloatTupleAlternateSyntax","type":{"name":"Tuples.Tuple","typeArguments":["int32","float32"]}},{"name":"intStringTuple","type":{"name":"Tuples.Tuple","typeArguments":["int32","string"]}},{"name":"streamOfTypeVariants","type":{"stream":{"items":[{"tag":"imageFloat","explicitTag":true,"type":"Image.FloatImage"},{"tag":"imageDouble","explicitTag":true,"type":{"name":"TestModel.Image","typeArguments":["float64"]}}]}}}]},"types":[{"name":"FloatImage","type":{"name":"Image.Image","typeArguments":["float32"]}},{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"IntImage","type":{"name":"Image.Image","typeArguments":["int32"]}},{"name":"Image","typeParameters":["T"],"type":{"name":"Image.Image","typeArguments":["T"]}},{"name":"Tuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

std::vector<std::string> SimpleGenericsWriterBase::previous_schemas_ = {
};

std::string SimpleGenericsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return SimpleGenericsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol SimpleGenerics.");
  }

}
void SimpleGenericsWriterBase::WriteFloatImage(image::FloatImage const& value) {
  if (unlikely(state_ != 0)) {
    SimpleGenericsWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatImageImpl(value);
  state_ = 1;
}

void SimpleGenericsWriterBase::WriteIntImage(image::IntImage const& value) {
  if (unlikely(state_ != 1)) {
    SimpleGenericsWriterBaseInvalidState(1, false, state_);
  }

  WriteIntImageImpl(value);
  state_ = 2;
}

void SimpleGenericsWriterBase::WriteIntImageAlternateSyntax(test_model::Image<int32_t> const& value) {
  if (unlikely(state_ != 2)) {
    SimpleGenericsWriterBaseInvalidState(2, false, state_);
  }

  WriteIntImageAlternateSyntaxImpl(value);
  state_ = 3;
}

void SimpleGenericsWriterBase::WriteStringImage(test_model::Image<std::string> const& value) {
  if (unlikely(state_ != 3)) {
    SimpleGenericsWriterBaseInvalidState(3, false, state_);
  }

  WriteStringImageImpl(value);
  state_ = 4;
}

void SimpleGenericsWriterBase::WriteIntFloatTuple(tuples::Tuple<int32_t, float> const& value) {
  if (unlikely(state_ != 4)) {
    SimpleGenericsWriterBaseInvalidState(4, false, state_);
  }

  WriteIntFloatTupleImpl(value);
  state_ = 5;
}

void SimpleGenericsWriterBase::WriteFloatFloatTuple(tuples::Tuple<float, float> const& value) {
  if (unlikely(state_ != 5)) {
    SimpleGenericsWriterBaseInvalidState(5, false, state_);
  }

  WriteFloatFloatTupleImpl(value);
  state_ = 6;
}

void SimpleGenericsWriterBase::WriteIntFloatTupleAlternateSyntax(tuples::Tuple<int32_t, float> const& value) {
  if (unlikely(state_ != 6)) {
    SimpleGenericsWriterBaseInvalidState(6, false, state_);
  }

  WriteIntFloatTupleAlternateSyntaxImpl(value);
  state_ = 7;
}

void SimpleGenericsWriterBase::WriteIntStringTuple(tuples::Tuple<int32_t, std::string> const& value) {
  if (unlikely(state_ != 7)) {
    SimpleGenericsWriterBaseInvalidState(7, false, state_);
  }

  WriteIntStringTupleImpl(value);
  state_ = 8;
}

void SimpleGenericsWriterBase::WriteStreamOfTypeVariants(std::variant<image::FloatImage, test_model::Image<double>> const& value) {
  if (unlikely(state_ != 8)) {
    SimpleGenericsWriterBaseInvalidState(8, false, state_);
  }

  WriteStreamOfTypeVariantsImpl(value);
}

void SimpleGenericsWriterBase::WriteStreamOfTypeVariants(std::vector<std::variant<image::FloatImage, test_model::Image<double>>> const& values) {
  if (unlikely(state_ != 8)) {
    SimpleGenericsWriterBaseInvalidState(8, false, state_);
  }

  WriteStreamOfTypeVariantsImpl(values);
}

void SimpleGenericsWriterBase::EndStreamOfTypeVariants() {
  if (unlikely(state_ != 8)) {
    SimpleGenericsWriterBaseInvalidState(8, true, state_);
  }

  EndStreamOfTypeVariantsImpl();
  state_ = 9;
}

// fallback implementation
void SimpleGenericsWriterBase::WriteStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>> const& values) {
  for (auto const& v : values) {
    WriteStreamOfTypeVariantsImpl(v);
  }
}

void SimpleGenericsWriterBase::Close() {
  if (unlikely(state_ != 9)) {
    SimpleGenericsWriterBaseInvalidState(9, false, state_);
  }

  CloseImpl();
}

std::string SimpleGenericsReaderBase::schema_ = SimpleGenericsWriterBase::schema_;

std::vector<std::string> SimpleGenericsReaderBase::previous_schemas_ = SimpleGenericsWriterBase::previous_schemas_;

Version SimpleGenericsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == SimpleGenericsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol SimpleGenerics.");
}
void SimpleGenericsReaderBase::ReadFloatImage(image::FloatImage& value) {
  if (unlikely(state_ != 0)) {
    SimpleGenericsReaderBaseInvalidState(0, state_);
  }

  ReadFloatImageImpl(value);
  state_ = 2;
}

void SimpleGenericsReaderBase::ReadIntImage(image::IntImage& value) {
  if (unlikely(state_ != 2)) {
    SimpleGenericsReaderBaseInvalidState(2, state_);
  }

  ReadIntImageImpl(value);
  state_ = 4;
}

void SimpleGenericsReaderBase::ReadIntImageAlternateSyntax(test_model::Image<int32_t>& value) {
  if (unlikely(state_ != 4)) {
    SimpleGenericsReaderBaseInvalidState(4, state_);
  }

  ReadIntImageAlternateSyntaxImpl(value);
  state_ = 6;
}

void SimpleGenericsReaderBase::ReadStringImage(test_model::Image<std::string>& value) {
  if (unlikely(state_ != 6)) {
    SimpleGenericsReaderBaseInvalidState(6, state_);
  }

  ReadStringImageImpl(value);
  state_ = 8;
}

void SimpleGenericsReaderBase::ReadIntFloatTuple(tuples::Tuple<int32_t, float>& value) {
  if (unlikely(state_ != 8)) {
    SimpleGenericsReaderBaseInvalidState(8, state_);
  }

  ReadIntFloatTupleImpl(value);
  state_ = 10;
}

void SimpleGenericsReaderBase::ReadFloatFloatTuple(tuples::Tuple<float, float>& value) {
  if (unlikely(state_ != 10)) {
    SimpleGenericsReaderBaseInvalidState(10, state_);
  }

  ReadFloatFloatTupleImpl(value);
  state_ = 12;
}

void SimpleGenericsReaderBase::ReadIntFloatTupleAlternateSyntax(tuples::Tuple<int32_t, float>& value) {
  if (unlikely(state_ != 12)) {
    SimpleGenericsReaderBaseInvalidState(12, state_);
  }

  ReadIntFloatTupleAlternateSyntaxImpl(value);
  state_ = 14;
}

void SimpleGenericsReaderBase::ReadIntStringTuple(tuples::Tuple<int32_t, std::string>& value) {
  if (unlikely(state_ != 14)) {
    SimpleGenericsReaderBaseInvalidState(14, state_);
  }

  ReadIntStringTupleImpl(value);
  state_ = 16;
}

bool SimpleGenericsReaderBase::ReadStreamOfTypeVariants(std::variant<image::FloatImage, test_model::Image<double>>& value) {
  if (unlikely(state_ != 16)) {
    if (state_ == 17) {
      state_ = 18;
      return false;
    }
    SimpleGenericsReaderBaseInvalidState(16, state_);
  }

  bool result = ReadStreamOfTypeVariantsImpl(value);
  if (!result) {
    state_ = 18;
  }
  return result;
}

bool SimpleGenericsReaderBase::ReadStreamOfTypeVariants(std::vector<std::variant<image::FloatImage, test_model::Image<double>>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 16)) {
    if (state_ == 17) {
      state_ = 18;
      values.clear();
      return false;
    }
    SimpleGenericsReaderBaseInvalidState(16, state_);
  }

  if (!ReadStreamOfTypeVariantsImpl(values)) {
    state_ = 17;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool SimpleGenericsReaderBase::ReadStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadStreamOfTypeVariantsImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void SimpleGenericsReaderBase::Close() {
  if (unlikely(state_ != 18)) {
    if (state_ == 17) {
      state_ = 18;
    } else {
      SimpleGenericsReaderBaseInvalidState(18, state_);
    }
  }

  CloseImpl();
}
void SimpleGenericsReaderBase::CopyTo(SimpleGenericsWriterBase& writer, size_t stream_of_type_variants_buffer_size) {
  {
    image::FloatImage value;
    ReadFloatImage(value);
    writer.WriteFloatImage(value);
  }
  {
    image::IntImage value;
    ReadIntImage(value);
    writer.WriteIntImage(value);
  }
  {
    test_model::Image<int32_t> value;
    ReadIntImageAlternateSyntax(value);
    writer.WriteIntImageAlternateSyntax(value);
  }
  {
    test_model::Image<std::string> value;
    ReadStringImage(value);
    writer.WriteStringImage(value);
  }
  {
    tuples::Tuple<int32_t, float> value;
    ReadIntFloatTuple(value);
    writer.WriteIntFloatTuple(value);
  }
  {
    tuples::Tuple<float, float> value;
    ReadFloatFloatTuple(value);
    writer.WriteFloatFloatTuple(value);
  }
  {
    tuples::Tuple<int32_t, float> value;
    ReadIntFloatTupleAlternateSyntax(value);
    writer.WriteIntFloatTupleAlternateSyntax(value);
  }
  {
    tuples::Tuple<int32_t, std::string> value;
    ReadIntStringTuple(value);
    writer.WriteIntStringTuple(value);
  }
  if (stream_of_type_variants_buffer_size > 1) {
    std::vector<std::variant<image::FloatImage, test_model::Image<double>>> values;
    values.reserve(stream_of_type_variants_buffer_size);
    while(ReadStreamOfTypeVariants(values)) {
      writer.WriteStreamOfTypeVariants(values);
    }
    writer.EndStreamOfTypeVariants();
  } else {
    std::variant<image::FloatImage, test_model::Image<double>> value;
    while(ReadStreamOfTypeVariants(value)) {
      writer.WriteStreamOfTypeVariants(value);
    }
    writer.EndStreamOfTypeVariants();
  }
}

namespace {
void AdvancedGenericsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloatImageImage()"; break;
  case 1: expected_method = "WriteGenericRecord1()"; break;
  case 2: expected_method = "WriteTupleOfOptionals()"; break;
  case 3: expected_method = "WriteTupleOfOptionalsAlternateSyntax()"; break;
  case 4: expected_method = "WriteTupleOfVectors()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteFloatImageImage()"; break;
  case 1: attempted_method = "WriteGenericRecord1()"; break;
  case 2: attempted_method = "WriteTupleOfOptionals()"; break;
  case 3: attempted_method = "WriteTupleOfOptionalsAlternateSyntax()"; break;
  case 4: attempted_method = "WriteTupleOfVectors()"; break;
  case 5: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void AdvancedGenericsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloatImageImage()";
    case 1: return "ReadGenericRecord1()";
    case 2: return "ReadTupleOfOptionals()";
    case 3: return "ReadTupleOfOptionalsAlternateSyntax()";
    case 4: return "ReadTupleOfVectors()";
    case 5: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string AdvancedGenericsWriterBase::schema_ = R"({"protocol":{"name":"AdvancedGenerics","sequence":[{"name":"floatImageImage","type":{"name":"TestModel.Image","typeArguments":[{"name":"TestModel.Image","typeArguments":["float32"]}]}},{"name":"genericRecord1","type":{"name":"TestModel.GenericRecord","typeArguments":["int32","string"]}},{"name":"tupleOfOptionals","type":{"name":"TestModel.MyTuple","typeArguments":[[null,"int32"],[null,"string"]]}},{"name":"tupleOfOptionalsAlternateSyntax","type":{"name":"TestModel.MyTuple","typeArguments":[[null,"int32"],[null,"string"]]}},{"name":"tupleOfVectors","type":{"name":"TestModel.MyTuple","typeArguments":[{"vector":{"items":"int32"}},{"vector":{"items":"float32"}}]}}]},"types":[{"name":"MyTuple","typeParameters":["T1","T2"],"type":{"name":"Tuples.Tuple","typeArguments":["T1","T2"]}},{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"GenericRecord","typeParameters":["T1","T2"],"fields":[{"name":"scalar1","type":"T1"},{"name":"scalar2","type":"T2"},{"name":"vector1","type":{"vector":{"items":"T1"}}},{"name":"image2","type":{"name":"TestModel.Image","typeArguments":["T2"]}}]},{"name":"Image","typeParameters":["T"],"type":{"name":"Image.Image","typeArguments":["T"]}},{"name":"MyTuple","typeParameters":["T1","T2"],"type":{"name":"BasicTypes.MyTuple","typeArguments":["T1","T2"]}},{"name":"Tuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

std::vector<std::string> AdvancedGenericsWriterBase::previous_schemas_ = {
};

std::string AdvancedGenericsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return AdvancedGenericsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol AdvancedGenerics.");
  }

}
void AdvancedGenericsWriterBase::WriteFloatImageImage(test_model::Image<test_model::Image<float>> const& value) {
  if (unlikely(state_ != 0)) {
    AdvancedGenericsWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatImageImageImpl(value);
  state_ = 1;
}

void AdvancedGenericsWriterBase::WriteGenericRecord1(test_model::GenericRecord<int32_t, std::string> const& value) {
  if (unlikely(state_ != 1)) {
    AdvancedGenericsWriterBaseInvalidState(1, false, state_);
  }

  WriteGenericRecord1Impl(value);
  state_ = 2;
}

void AdvancedGenericsWriterBase::WriteTupleOfOptionals(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  if (unlikely(state_ != 2)) {
    AdvancedGenericsWriterBaseInvalidState(2, false, state_);
  }

  WriteTupleOfOptionalsImpl(value);
  state_ = 3;
}

void AdvancedGenericsWriterBase::WriteTupleOfOptionalsAlternateSyntax(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  if (unlikely(state_ != 3)) {
    AdvancedGenericsWriterBaseInvalidState(3, false, state_);
  }

  WriteTupleOfOptionalsAlternateSyntaxImpl(value);
  state_ = 4;
}

void AdvancedGenericsWriterBase::WriteTupleOfVectors(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) {
  if (unlikely(state_ != 4)) {
    AdvancedGenericsWriterBaseInvalidState(4, false, state_);
  }

  WriteTupleOfVectorsImpl(value);
  state_ = 5;
}

void AdvancedGenericsWriterBase::Close() {
  if (unlikely(state_ != 5)) {
    AdvancedGenericsWriterBaseInvalidState(5, false, state_);
  }

  CloseImpl();
}

std::string AdvancedGenericsReaderBase::schema_ = AdvancedGenericsWriterBase::schema_;

std::vector<std::string> AdvancedGenericsReaderBase::previous_schemas_ = AdvancedGenericsWriterBase::previous_schemas_;

Version AdvancedGenericsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == AdvancedGenericsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol AdvancedGenerics.");
}
void AdvancedGenericsReaderBase::ReadFloatImageImage(test_model::Image<test_model::Image<float>>& value) {
  if (unlikely(state_ != 0)) {
    AdvancedGenericsReaderBaseInvalidState(0, state_);
  }

  ReadFloatImageImageImpl(value);
  state_ = 2;
}

void AdvancedGenericsReaderBase::ReadGenericRecord1(test_model::GenericRecord<int32_t, std::string>& value) {
  if (unlikely(state_ != 2)) {
    AdvancedGenericsReaderBaseInvalidState(2, state_);
  }

  ReadGenericRecord1Impl(value);
  state_ = 4;
}

void AdvancedGenericsReaderBase::ReadTupleOfOptionals(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  if (unlikely(state_ != 4)) {
    AdvancedGenericsReaderBaseInvalidState(4, state_);
  }

  ReadTupleOfOptionalsImpl(value);
  state_ = 6;
}

void AdvancedGenericsReaderBase::ReadTupleOfOptionalsAlternateSyntax(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  if (unlikely(state_ != 6)) {
    AdvancedGenericsReaderBaseInvalidState(6, state_);
  }

  ReadTupleOfOptionalsAlternateSyntaxImpl(value);
  state_ = 8;
}

void AdvancedGenericsReaderBase::ReadTupleOfVectors(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value) {
  if (unlikely(state_ != 8)) {
    AdvancedGenericsReaderBaseInvalidState(8, state_);
  }

  ReadTupleOfVectorsImpl(value);
  state_ = 10;
}

void AdvancedGenericsReaderBase::Close() {
  if (unlikely(state_ != 10)) {
    AdvancedGenericsReaderBaseInvalidState(10, state_);
  }

  CloseImpl();
}
void AdvancedGenericsReaderBase::CopyTo(AdvancedGenericsWriterBase& writer) {
  {
    test_model::Image<test_model::Image<float>> value;
    ReadFloatImageImage(value);
    writer.WriteFloatImageImage(value);
  }
  {
    test_model::GenericRecord<int32_t, std::string> value;
    ReadGenericRecord1(value);
    writer.WriteGenericRecord1(value);
  }
  {
    test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> value;
    ReadTupleOfOptionals(value);
    writer.WriteTupleOfOptionals(value);
  }
  {
    test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> value;
    ReadTupleOfOptionalsAlternateSyntax(value);
    writer.WriteTupleOfOptionalsAlternateSyntax(value);
  }
  {
    test_model::MyTuple<std::vector<int32_t>, std::vector<float>> value;
    ReadTupleOfVectors(value);
    writer.WriteTupleOfVectors(value);
  }
}

namespace {
void AliasesWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteAliasedString()"; break;
  case 1: expected_method = "WriteAliasedEnum()"; break;
  case 2: expected_method = "WriteAliasedOpenGeneric()"; break;
  case 3: expected_method = "WriteAliasedClosedGeneric()"; break;
  case 4: expected_method = "WriteAliasedOptional()"; break;
  case 5: expected_method = "WriteAliasedGenericOptional()"; break;
  case 6: expected_method = "WriteAliasedGenericUnion2()"; break;
  case 7: expected_method = "WriteAliasedGenericVector()"; break;
  case 8: expected_method = "WriteAliasedGenericFixedVector()"; break;
  case 9: expected_method = "WriteStreamOfAliasedGenericUnion2() or EndStreamOfAliasedGenericUnion2()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteAliasedString()"; break;
  case 1: attempted_method = "WriteAliasedEnum()"; break;
  case 2: attempted_method = "WriteAliasedOpenGeneric()"; break;
  case 3: attempted_method = "WriteAliasedClosedGeneric()"; break;
  case 4: attempted_method = "WriteAliasedOptional()"; break;
  case 5: attempted_method = "WriteAliasedGenericOptional()"; break;
  case 6: attempted_method = "WriteAliasedGenericUnion2()"; break;
  case 7: attempted_method = "WriteAliasedGenericVector()"; break;
  case 8: attempted_method = "WriteAliasedGenericFixedVector()"; break;
  case 9: attempted_method = end ? "EndStreamOfAliasedGenericUnion2()" : "WriteStreamOfAliasedGenericUnion2()"; break;
  case 10: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void AliasesReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadAliasedString()";
    case 1: return "ReadAliasedEnum()";
    case 2: return "ReadAliasedOpenGeneric()";
    case 3: return "ReadAliasedClosedGeneric()";
    case 4: return "ReadAliasedOptional()";
    case 5: return "ReadAliasedGenericOptional()";
    case 6: return "ReadAliasedGenericUnion2()";
    case 7: return "ReadAliasedGenericVector()";
    case 8: return "ReadAliasedGenericFixedVector()";
    case 9: return "ReadStreamOfAliasedGenericUnion2()";
    case 10: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string AliasesWriterBase::schema_ = R"({"protocol":{"name":"Aliases","sequence":[{"name":"aliasedString","type":"TestModel.AliasedString"},{"name":"aliasedEnum","type":"TestModel.AliasedEnum"},{"name":"aliasedOpenGeneric","type":{"name":"TestModel.AliasedOpenGeneric","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"aliasedClosedGeneric","type":"TestModel.AliasedClosedGeneric"},{"name":"aliasedOptional","type":"TestModel.AliasedOptional"},{"name":"aliasedGenericOptional","type":{"name":"TestModel.AliasedGenericOptional","typeArguments":["float32"]}},{"name":"aliasedGenericUnion2","type":{"name":"TestModel.AliasedGenericUnion2","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"aliasedGenericVector","type":{"name":"TestModel.AliasedGenericVector","typeArguments":["float32"]}},{"name":"aliasedGenericFixedVector","type":{"name":"TestModel.AliasedGenericFixedVector","typeArguments":["float32"]}},{"name":"streamOfAliasedGenericUnion2","type":{"stream":{"items":{"name":"TestModel.AliasedGenericUnion2","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}}}}]},"types":[{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"GenericUnion2","typeParameters":["T1","T2"],"type":[{"tag":"T1","type":"T1"},{"tag":"T2","type":"T2"}]},{"name":"GenericVector","typeParameters":["T"],"type":{"vector":{"items":"T"}}},{"name":"MyTuple","typeParameters":["T1","T2"],"type":{"name":"Tuples.Tuple","typeArguments":["T1","T2"]}},{"name":"AliasedClosedGeneric","type":{"name":"TestModel.AliasedTuple","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"AliasedEnum","type":"TestModel.Fruits"},{"name":"AliasedGenericFixedVector","typeParameters":["T"],"type":{"vector":{"items":"T","length":3}}},{"name":"AliasedGenericOptional","typeParameters":["T"],"type":[null,"T"]},{"name":"AliasedGenericUnion2","typeParameters":["T1","T2"],"type":{"name":"BasicTypes.GenericUnion2","typeArguments":["T1","T2"]}},{"name":"AliasedGenericVector","typeParameters":["T"],"type":{"name":"BasicTypes.GenericVector","typeArguments":["T"]}},{"name":"AliasedOpenGeneric","typeParameters":["T1","T2"],"type":{"name":"TestModel.AliasedTuple","typeArguments":["T1","T2"]}},{"name":"AliasedOptional","type":[null,"int32"]},{"name":"AliasedString","type":"string"},{"name":"AliasedTuple","typeParameters":["T1","T2"],"type":{"name":"TestModel.MyTuple","typeArguments":["T1","T2"]}},{"name":"Fruits","type":"BasicTypes.Fruits"},{"name":"MyTuple","typeParameters":["T1","T2"],"type":{"name":"BasicTypes.MyTuple","typeArguments":["T1","T2"]}},{"name":"Tuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

std::vector<std::string> AliasesWriterBase::previous_schemas_ = {
};

std::string AliasesWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return AliasesWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol Aliases.");
  }

}
void AliasesWriterBase::WriteAliasedString(test_model::AliasedString const& value) {
  if (unlikely(state_ != 0)) {
    AliasesWriterBaseInvalidState(0, false, state_);
  }

  WriteAliasedStringImpl(value);
  state_ = 1;
}

void AliasesWriterBase::WriteAliasedEnum(test_model::AliasedEnum const& value) {
  if (unlikely(state_ != 1)) {
    AliasesWriterBaseInvalidState(1, false, state_);
  }

  WriteAliasedEnumImpl(value);
  state_ = 2;
}

void AliasesWriterBase::WriteAliasedOpenGeneric(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  if (unlikely(state_ != 2)) {
    AliasesWriterBaseInvalidState(2, false, state_);
  }

  WriteAliasedOpenGenericImpl(value);
  state_ = 3;
}

void AliasesWriterBase::WriteAliasedClosedGeneric(test_model::AliasedClosedGeneric const& value) {
  if (unlikely(state_ != 3)) {
    AliasesWriterBaseInvalidState(3, false, state_);
  }

  WriteAliasedClosedGenericImpl(value);
  state_ = 4;
}

void AliasesWriterBase::WriteAliasedOptional(test_model::AliasedOptional const& value) {
  if (unlikely(state_ != 4)) {
    AliasesWriterBaseInvalidState(4, false, state_);
  }

  WriteAliasedOptionalImpl(value);
  state_ = 5;
}

void AliasesWriterBase::WriteAliasedGenericOptional(test_model::AliasedGenericOptional<float> const& value) {
  if (unlikely(state_ != 5)) {
    AliasesWriterBaseInvalidState(5, false, state_);
  }

  WriteAliasedGenericOptionalImpl(value);
  state_ = 6;
}

void AliasesWriterBase::WriteAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  if (unlikely(state_ != 6)) {
    AliasesWriterBaseInvalidState(6, false, state_);
  }

  WriteAliasedGenericUnion2Impl(value);
  state_ = 7;
}

void AliasesWriterBase::WriteAliasedGenericVector(test_model::AliasedGenericVector<float> const& value) {
  if (unlikely(state_ != 7)) {
    AliasesWriterBaseInvalidState(7, false, state_);
  }

  WriteAliasedGenericVectorImpl(value);
  state_ = 8;
}

void AliasesWriterBase::WriteAliasedGenericFixedVector(test_model::AliasedGenericFixedVector<float> const& value) {
  if (unlikely(state_ != 8)) {
    AliasesWriterBaseInvalidState(8, false, state_);
  }

  WriteAliasedGenericFixedVectorImpl(value);
  state_ = 9;
}

void AliasesWriterBase::WriteStreamOfAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  if (unlikely(state_ != 9)) {
    AliasesWriterBaseInvalidState(9, false, state_);
  }

  WriteStreamOfAliasedGenericUnion2Impl(value);
}

void AliasesWriterBase::WriteStreamOfAliasedGenericUnion2(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) {
  if (unlikely(state_ != 9)) {
    AliasesWriterBaseInvalidState(9, false, state_);
  }

  WriteStreamOfAliasedGenericUnion2Impl(values);
}

void AliasesWriterBase::EndStreamOfAliasedGenericUnion2() {
  if (unlikely(state_ != 9)) {
    AliasesWriterBaseInvalidState(9, true, state_);
  }

  EndStreamOfAliasedGenericUnion2Impl();
  state_ = 10;
}

// fallback implementation
void AliasesWriterBase::WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) {
  for (auto const& v : values) {
    WriteStreamOfAliasedGenericUnion2Impl(v);
  }
}

void AliasesWriterBase::Close() {
  if (unlikely(state_ != 10)) {
    AliasesWriterBaseInvalidState(10, false, state_);
  }

  CloseImpl();
}

std::string AliasesReaderBase::schema_ = AliasesWriterBase::schema_;

std::vector<std::string> AliasesReaderBase::previous_schemas_ = AliasesWriterBase::previous_schemas_;

Version AliasesReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == AliasesWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol Aliases.");
}
void AliasesReaderBase::ReadAliasedString(test_model::AliasedString& value) {
  if (unlikely(state_ != 0)) {
    AliasesReaderBaseInvalidState(0, state_);
  }

  ReadAliasedStringImpl(value);
  state_ = 2;
}

void AliasesReaderBase::ReadAliasedEnum(test_model::AliasedEnum& value) {
  if (unlikely(state_ != 2)) {
    AliasesReaderBaseInvalidState(2, state_);
  }

  ReadAliasedEnumImpl(value);
  state_ = 4;
}

void AliasesReaderBase::ReadAliasedOpenGeneric(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value) {
  if (unlikely(state_ != 4)) {
    AliasesReaderBaseInvalidState(4, state_);
  }

  ReadAliasedOpenGenericImpl(value);
  state_ = 6;
}

void AliasesReaderBase::ReadAliasedClosedGeneric(test_model::AliasedClosedGeneric& value) {
  if (unlikely(state_ != 6)) {
    AliasesReaderBaseInvalidState(6, state_);
  }

  ReadAliasedClosedGenericImpl(value);
  state_ = 8;
}

void AliasesReaderBase::ReadAliasedOptional(test_model::AliasedOptional& value) {
  if (unlikely(state_ != 8)) {
    AliasesReaderBaseInvalidState(8, state_);
  }

  ReadAliasedOptionalImpl(value);
  state_ = 10;
}

void AliasesReaderBase::ReadAliasedGenericOptional(test_model::AliasedGenericOptional<float>& value) {
  if (unlikely(state_ != 10)) {
    AliasesReaderBaseInvalidState(10, state_);
  }

  ReadAliasedGenericOptionalImpl(value);
  state_ = 12;
}

void AliasesReaderBase::ReadAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  if (unlikely(state_ != 12)) {
    AliasesReaderBaseInvalidState(12, state_);
  }

  ReadAliasedGenericUnion2Impl(value);
  state_ = 14;
}

void AliasesReaderBase::ReadAliasedGenericVector(test_model::AliasedGenericVector<float>& value) {
  if (unlikely(state_ != 14)) {
    AliasesReaderBaseInvalidState(14, state_);
  }

  ReadAliasedGenericVectorImpl(value);
  state_ = 16;
}

void AliasesReaderBase::ReadAliasedGenericFixedVector(test_model::AliasedGenericFixedVector<float>& value) {
  if (unlikely(state_ != 16)) {
    AliasesReaderBaseInvalidState(16, state_);
  }

  ReadAliasedGenericFixedVectorImpl(value);
  state_ = 18;
}

bool AliasesReaderBase::ReadStreamOfAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  if (unlikely(state_ != 18)) {
    if (state_ == 19) {
      state_ = 20;
      return false;
    }
    AliasesReaderBaseInvalidState(18, state_);
  }

  bool result = ReadStreamOfAliasedGenericUnion2Impl(value);
  if (!result) {
    state_ = 20;
  }
  return result;
}

bool AliasesReaderBase::ReadStreamOfAliasedGenericUnion2(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 18)) {
    if (state_ == 19) {
      state_ = 20;
      values.clear();
      return false;
    }
    AliasesReaderBaseInvalidState(18, state_);
  }

  if (!ReadStreamOfAliasedGenericUnion2Impl(values)) {
    state_ = 19;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool AliasesReaderBase::ReadStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadStreamOfAliasedGenericUnion2Impl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void AliasesReaderBase::Close() {
  if (unlikely(state_ != 20)) {
    if (state_ == 19) {
      state_ = 20;
    } else {
      AliasesReaderBaseInvalidState(20, state_);
    }
  }

  CloseImpl();
}
void AliasesReaderBase::CopyTo(AliasesWriterBase& writer, size_t stream_of_aliased_generic_union_2_buffer_size) {
  {
    test_model::AliasedString value;
    ReadAliasedString(value);
    writer.WriteAliasedString(value);
  }
  {
    test_model::AliasedEnum value;
    ReadAliasedEnum(value);
    writer.WriteAliasedEnum(value);
  }
  {
    test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> value;
    ReadAliasedOpenGeneric(value);
    writer.WriteAliasedOpenGeneric(value);
  }
  {
    test_model::AliasedClosedGeneric value;
    ReadAliasedClosedGeneric(value);
    writer.WriteAliasedClosedGeneric(value);
  }
  {
    test_model::AliasedOptional value;
    ReadAliasedOptional(value);
    writer.WriteAliasedOptional(value);
  }
  {
    test_model::AliasedGenericOptional<float> value;
    ReadAliasedGenericOptional(value);
    writer.WriteAliasedGenericOptional(value);
  }
  {
    test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> value;
    ReadAliasedGenericUnion2(value);
    writer.WriteAliasedGenericUnion2(value);
  }
  {
    test_model::AliasedGenericVector<float> value;
    ReadAliasedGenericVector(value);
    writer.WriteAliasedGenericVector(value);
  }
  {
    test_model::AliasedGenericFixedVector<float> value;
    ReadAliasedGenericFixedVector(value);
    writer.WriteAliasedGenericFixedVector(value);
  }
  if (stream_of_aliased_generic_union_2_buffer_size > 1) {
    std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> values;
    values.reserve(stream_of_aliased_generic_union_2_buffer_size);
    while(ReadStreamOfAliasedGenericUnion2(values)) {
      writer.WriteStreamOfAliasedGenericUnion2(values);
    }
    writer.EndStreamOfAliasedGenericUnion2();
  } else {
    test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> value;
    while(ReadStreamOfAliasedGenericUnion2(value)) {
      writer.WriteStreamOfAliasedGenericUnion2(value);
    }
    writer.EndStreamOfAliasedGenericUnion2();
  }
}

namespace {
void StreamsOfAliasedUnionsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntOrSimpleRecord() or EndIntOrSimpleRecord()"; break;
  case 1: expected_method = "WriteNullableIntOrSimpleRecord() or EndNullableIntOrSimpleRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndIntOrSimpleRecord()" : "WriteIntOrSimpleRecord()"; break;
  case 1: attempted_method = end ? "EndNullableIntOrSimpleRecord()" : "WriteNullableIntOrSimpleRecord()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StreamsOfAliasedUnionsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntOrSimpleRecord()";
    case 1: return "ReadNullableIntOrSimpleRecord()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StreamsOfAliasedUnionsWriterBase::schema_ = R"({"protocol":{"name":"StreamsOfAliasedUnions","sequence":[{"name":"intOrSimpleRecord","type":{"stream":{"items":"TestModel.AliasedIntOrSimpleRecord"}}},{"name":"nullableIntOrSimpleRecord","type":{"stream":{"items":"TestModel.AliasedNullableIntSimpleRecord"}}}]},"types":[{"name":"AliasedIntOrSimpleRecord","type":[{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"AliasedNullableIntSimpleRecord","type":[null,{"tag":"int32","type":"int32"},{"tag":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

std::vector<std::string> StreamsOfAliasedUnionsWriterBase::previous_schemas_ = {
};

std::string StreamsOfAliasedUnionsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return StreamsOfAliasedUnionsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol StreamsOfAliasedUnions.");
  }

}
void StreamsOfAliasedUnionsWriterBase::WriteIntOrSimpleRecord(test_model::AliasedIntOrSimpleRecord const& value) {
  if (unlikely(state_ != 0)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(value);
}

void StreamsOfAliasedUnionsWriterBase::WriteIntOrSimpleRecord(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) {
  if (unlikely(state_ != 0)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(values);
}

void StreamsOfAliasedUnionsWriterBase::EndIntOrSimpleRecord() {
  if (unlikely(state_ != 0)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(0, true, state_);
  }

  EndIntOrSimpleRecordImpl();
  state_ = 1;
}

// fallback implementation
void StreamsOfAliasedUnionsWriterBase::WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) {
  for (auto const& v : values) {
    WriteIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfAliasedUnionsWriterBase::WriteNullableIntOrSimpleRecord(test_model::AliasedNullableIntSimpleRecord const& value) {
  if (unlikely(state_ != 1)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(value);
}

void StreamsOfAliasedUnionsWriterBase::WriteNullableIntOrSimpleRecord(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) {
  if (unlikely(state_ != 1)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(values);
}

void StreamsOfAliasedUnionsWriterBase::EndNullableIntOrSimpleRecord() {
  if (unlikely(state_ != 1)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(1, true, state_);
  }

  EndNullableIntOrSimpleRecordImpl();
  state_ = 2;
}

// fallback implementation
void StreamsOfAliasedUnionsWriterBase::WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) {
  for (auto const& v : values) {
    WriteNullableIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfAliasedUnionsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string StreamsOfAliasedUnionsReaderBase::schema_ = StreamsOfAliasedUnionsWriterBase::schema_;

std::vector<std::string> StreamsOfAliasedUnionsReaderBase::previous_schemas_ = StreamsOfAliasedUnionsWriterBase::previous_schemas_;

Version StreamsOfAliasedUnionsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == StreamsOfAliasedUnionsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol StreamsOfAliasedUnions.");
}
bool StreamsOfAliasedUnionsReaderBase::ReadIntOrSimpleRecord(test_model::AliasedIntOrSimpleRecord& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    StreamsOfAliasedUnionsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool StreamsOfAliasedUnionsReaderBase::ReadIntOrSimpleRecord(std::vector<test_model::AliasedIntOrSimpleRecord>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    StreamsOfAliasedUnionsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntOrSimpleRecordImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsOfAliasedUnionsReaderBase::ReadIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsOfAliasedUnionsReaderBase::ReadNullableIntOrSimpleRecord(test_model::AliasedNullableIntSimpleRecord& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfAliasedUnionsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadNullableIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StreamsOfAliasedUnionsReaderBase::ReadNullableIntOrSimpleRecord(std::vector<test_model::AliasedNullableIntSimpleRecord>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfAliasedUnionsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadNullableIntOrSimpleRecordImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool StreamsOfAliasedUnionsReaderBase::ReadNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadNullableIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StreamsOfAliasedUnionsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      StreamsOfAliasedUnionsReaderBaseInvalidState(4, state_);
    }
  }

  CloseImpl();
}
void StreamsOfAliasedUnionsReaderBase::CopyTo(StreamsOfAliasedUnionsWriterBase& writer, size_t int_or_simple_record_buffer_size, size_t nullable_int_or_simple_record_buffer_size) {
  if (int_or_simple_record_buffer_size > 1) {
    std::vector<test_model::AliasedIntOrSimpleRecord> values;
    values.reserve(int_or_simple_record_buffer_size);
    while(ReadIntOrSimpleRecord(values)) {
      writer.WriteIntOrSimpleRecord(values);
    }
    writer.EndIntOrSimpleRecord();
  } else {
    test_model::AliasedIntOrSimpleRecord value;
    while(ReadIntOrSimpleRecord(value)) {
      writer.WriteIntOrSimpleRecord(value);
    }
    writer.EndIntOrSimpleRecord();
  }
  if (nullable_int_or_simple_record_buffer_size > 1) {
    std::vector<test_model::AliasedNullableIntSimpleRecord> values;
    values.reserve(nullable_int_or_simple_record_buffer_size);
    while(ReadNullableIntOrSimpleRecord(values)) {
      writer.WriteNullableIntOrSimpleRecord(values);
    }
    writer.EndNullableIntOrSimpleRecord();
  } else {
    test_model::AliasedNullableIntSimpleRecord value;
    while(ReadNullableIntOrSimpleRecord(value)) {
      writer.WriteNullableIntOrSimpleRecord(value);
    }
    writer.EndNullableIntOrSimpleRecord();
  }
}

namespace {
void ProtocolWithComputedFieldsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteRecordWithComputedFields()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteRecordWithComputedFields()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ProtocolWithComputedFieldsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadRecordWithComputedFields()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ProtocolWithComputedFieldsWriterBase::schema_ = R"({"protocol":{"name":"ProtocolWithComputedFields","sequence":[{"name":"recordWithComputedFields","type":"TestModel.RecordWithComputedFields"}]},"types":[{"name":"GenericRecordWithComputedFields","typeParameters":["T0","T1"],"fields":[{"name":"f1","type":[{"tag":"T0","type":"T0"},{"tag":"T1","type":"T1"}]}]},{"name":"MyTuple","typeParameters":["T1","T2"],"type":{"name":"Tuples.Tuple","typeArguments":["T1","T2"]}},{"name":"MyTuple","typeParameters":["T1","T2"],"type":{"name":"BasicTypes.MyTuple","typeArguments":["T1","T2"]}},{"name":"NamedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA"},{"name":"dimB"}]}}},{"name":"RecordWithComputedFields","fields":[{"name":"arrayField","type":{"array":{"items":"int32","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"arrayFieldMapDimensions","type":{"array":{"items":"int32","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"dynamicArrayField","type":{"array":{"items":"int32"}}},{"name":"fixedArrayField","type":{"array":{"items":"int32","dimensions":[{"name":"x","length":3},{"name":"y","length":4}]}}},{"name":"intField","type":"int32"},{"name":"int8Field","type":"int8"},{"name":"uint8Field","type":"uint8"},{"name":"int16Field","type":"int16"},{"name":"uint16Field","type":"uint16"},{"name":"uint32Field","type":"uint32"},{"name":"int64Field","type":"int64"},{"name":"uint64Field","type":"uint64"},{"name":"sizeField","type":"size"},{"name":"float32Field","type":"float32"},{"name":"float64Field","type":"float64"},{"name":"complexfloat32Field","type":"complexfloat32"},{"name":"complexfloat64Field","type":"complexfloat64"},{"name":"stringField","type":"string"},{"name":"tupleField","type":{"name":"TestModel.MyTuple","typeArguments":["int32","int32"]}},{"name":"vectorField","type":{"vector":{"items":"int32"}}},{"name":"vectorOfVectorsField","type":{"vector":{"items":{"vector":{"items":"int32"}}}}},{"name":"fixedVectorField","type":{"vector":{"items":"int32","length":3}}},{"name":"fixedVectorOfVectorsField","type":{"vector":{"items":{"vector":{"items":"int32","length":3}},"length":2}}},{"name":"optionalNamedArray","type":[null,"TestModel.NamedNDArray"]},{"name":"intFloatUnion","type":[{"tag":"int32","type":"int32"},{"tag":"float32","type":"float32"}]},{"name":"nullableIntFloatUnion","type":[null,{"tag":"int32","type":"int32"},{"tag":"float32","type":"float32"}]},{"name":"unionWithNestedGenericUnion","type":[{"tag":"int","explicitTag":true,"type":"int32"},{"tag":"genericRecordWithComputedFields","explicitTag":true,"type":{"name":"BasicTypes.GenericRecordWithComputedFields","typeArguments":["string","float32"]}}]},{"name":"mapField","type":{"map":{"keys":"string","values":"string"}}}]},{"name":"Tuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

std::vector<std::string> ProtocolWithComputedFieldsWriterBase::previous_schemas_ = {
};

std::string ProtocolWithComputedFieldsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return ProtocolWithComputedFieldsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol ProtocolWithComputedFields.");
  }

}
void ProtocolWithComputedFieldsWriterBase::WriteRecordWithComputedFields(test_model::RecordWithComputedFields const& value) {
  if (unlikely(state_ != 0)) {
    ProtocolWithComputedFieldsWriterBaseInvalidState(0, false, state_);
  }

  WriteRecordWithComputedFieldsImpl(value);
  state_ = 1;
}

void ProtocolWithComputedFieldsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    ProtocolWithComputedFieldsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string ProtocolWithComputedFieldsReaderBase::schema_ = ProtocolWithComputedFieldsWriterBase::schema_;

std::vector<std::string> ProtocolWithComputedFieldsReaderBase::previous_schemas_ = ProtocolWithComputedFieldsWriterBase::previous_schemas_;

Version ProtocolWithComputedFieldsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == ProtocolWithComputedFieldsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol ProtocolWithComputedFields.");
}
void ProtocolWithComputedFieldsReaderBase::ReadRecordWithComputedFields(test_model::RecordWithComputedFields& value) {
  if (unlikely(state_ != 0)) {
    ProtocolWithComputedFieldsReaderBaseInvalidState(0, state_);
  }

  ReadRecordWithComputedFieldsImpl(value);
  state_ = 2;
}

void ProtocolWithComputedFieldsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    ProtocolWithComputedFieldsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void ProtocolWithComputedFieldsReaderBase::CopyTo(ProtocolWithComputedFieldsWriterBase& writer) {
  {
    test_model::RecordWithComputedFields value;
    ReadRecordWithComputedFields(value);
    writer.WriteRecordWithComputedFields(value);
  }
}

namespace {
void ProtocolWithKeywordStepsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInt() or EndInt()"; break;
  case 1: expected_method = "WriteFloat()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndInt()" : "WriteInt()"; break;
  case 1: attempted_method = "WriteFloat()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ProtocolWithKeywordStepsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInt()";
    case 1: return "ReadFloat()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ProtocolWithKeywordStepsWriterBase::schema_ = R"({"protocol":{"name":"ProtocolWithKeywordSteps","sequence":[{"name":"int","type":{"stream":{"items":"TestModel.RecordWithKeywordFields"}}},{"name":"float","type":"TestModel.EnumWithKeywordSymbols"}]},"types":[{"name":"ArrayWithKeywordDimensionNames","type":{"array":{"items":"int32","dimensions":[{"name":"while"},{"name":"do"}]}}},{"name":"EnumWithKeywordSymbols","values":[{"symbol":"try","value":2},{"symbol":"catch","value":1}]},{"name":"RecordWithKeywordFields","fields":[{"name":"int","type":"string"},{"name":"sizeof","type":"TestModel.ArrayWithKeywordDimensionNames"},{"name":"if","type":"TestModel.EnumWithKeywordSymbols"}]}]})";

std::vector<std::string> ProtocolWithKeywordStepsWriterBase::previous_schemas_ = {
};

std::string ProtocolWithKeywordStepsWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return ProtocolWithKeywordStepsWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol ProtocolWithKeywordSteps.");
  }

}
void ProtocolWithKeywordStepsWriterBase::WriteInt(test_model::RecordWithKeywordFields const& value) {
  if (unlikely(state_ != 0)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntImpl(value);
}

void ProtocolWithKeywordStepsWriterBase::WriteInt(std::vector<test_model::RecordWithKeywordFields> const& values) {
  if (unlikely(state_ != 0)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntImpl(values);
}

void ProtocolWithKeywordStepsWriterBase::EndInt() {
  if (unlikely(state_ != 0)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(0, true, state_);
  }

  EndIntImpl();
  state_ = 1;
}

// fallback implementation
void ProtocolWithKeywordStepsWriterBase::WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& values) {
  for (auto const& v : values) {
    WriteIntImpl(v);
  }
}

void ProtocolWithKeywordStepsWriterBase::WriteFloat(test_model::EnumWithKeywordSymbols const& value) {
  if (unlikely(state_ != 1)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(1, false, state_);
  }

  WriteFloatImpl(value);
  state_ = 2;
}

void ProtocolWithKeywordStepsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string ProtocolWithKeywordStepsReaderBase::schema_ = ProtocolWithKeywordStepsWriterBase::schema_;

std::vector<std::string> ProtocolWithKeywordStepsReaderBase::previous_schemas_ = ProtocolWithKeywordStepsWriterBase::previous_schemas_;

Version ProtocolWithKeywordStepsReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == ProtocolWithKeywordStepsWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol ProtocolWithKeywordSteps.");
}
bool ProtocolWithKeywordStepsReaderBase::ReadInt(test_model::RecordWithKeywordFields& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    ProtocolWithKeywordStepsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool ProtocolWithKeywordStepsReaderBase::ReadInt(std::vector<test_model::RecordWithKeywordFields>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    ProtocolWithKeywordStepsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntImpl(values)) {
    state_ = 1;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool ProtocolWithKeywordStepsReaderBase::ReadIntImpl(std::vector<test_model::RecordWithKeywordFields>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void ProtocolWithKeywordStepsReaderBase::ReadFloat(test_model::EnumWithKeywordSymbols& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      ProtocolWithKeywordStepsReaderBaseInvalidState(2, state_);
    }
  }

  ReadFloatImpl(value);
  state_ = 4;
}

void ProtocolWithKeywordStepsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    ProtocolWithKeywordStepsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void ProtocolWithKeywordStepsReaderBase::CopyTo(ProtocolWithKeywordStepsWriterBase& writer, size_t int_buffer_size) {
  if (int_buffer_size > 1) {
    std::vector<test_model::RecordWithKeywordFields> values;
    values.reserve(int_buffer_size);
    while(ReadInt(values)) {
      writer.WriteInt(values);
    }
    writer.EndInt();
  } else {
    test_model::RecordWithKeywordFields value;
    while(ReadInt(value)) {
      writer.WriteInt(value);
    }
    writer.EndInt();
  }
  {
    test_model::EnumWithKeywordSymbols value;
    ReadFloat(value);
    writer.WriteFloat(value);
  }
}
} // namespace test_model
