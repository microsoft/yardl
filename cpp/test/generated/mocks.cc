// This file was generated by the "yardl" tool. DO NOT EDIT.

#include <functional>
#include <queue>

#include <gtest/gtest.h>

#include "../yardl_testing.h"
#include "binary/protocols.h"
#include "hdf5/protocols.h"
#include "ndjson/protocols.h"
#include "types.h"

namespace test_model {
namespace {
class MockBenchmarkFloat256x256Writer : public BenchmarkFloat256x256WriterBase {
  public:
  void WriteFloat256x256Impl (yardl::FixedNDArray<float, 256, 256> const& value) override {
    if (WriteFloat256x256Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloat256x256Impl");
    }
    if (WriteFloat256x256Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloat256x256Impl");
    }
    WriteFloat256x256Impl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<float, 256, 256>> WriteFloat256x256Impl_expected_values_;

  void ExpectWriteFloat256x256Impl (yardl::FixedNDArray<float, 256, 256> const& value) {
    WriteFloat256x256Impl_expected_values_.push(value);
  }

  void EndFloat256x256Impl () override {
    if (--EndFloat256x256Impl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFloat256x256Impl");
    }
  }

  int EndFloat256x256Impl_expected_call_count_ = 0;

  void ExpectEndFloat256x256Impl () {
    EndFloat256x256Impl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteFloat256x256Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloat256x256Impl was not received");
    }
    if (EndFloat256x256Impl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFloat256x256Impl was not received");
    }
  }
};

class TestBenchmarkFloat256x256WriterBase : public BenchmarkFloat256x256WriterBase {
  public:
  TestBenchmarkFloat256x256WriterBase(std::unique_ptr<test_model::BenchmarkFloat256x256WriterBase> writer, std::function<std::unique_ptr<BenchmarkFloat256x256ReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkFloat256x256WriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkFloat256x256WriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloat256x256Impl(yardl::FixedNDArray<float, 256, 256> const& value) override {
    writer_->WriteFloat256x256(value);
    mock_writer_.ExpectWriteFloat256x256Impl(value);
  }

  void WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) override {
    writer_->WriteFloat256x256(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFloat256x256Impl(v);
    }
  }

  void EndFloat256x256Impl() override {
    writer_->EndFloat256x256();
    mock_writer_.ExpectEndFloat256x256Impl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkFloat256x256ReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkFloat256x256WriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkFloat256x256ReaderBase>()> create_reader_;
  MockBenchmarkFloat256x256Writer mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkInt256x256Writer : public BenchmarkInt256x256WriterBase {
  public:
  void WriteInt256x256Impl (yardl::FixedNDArray<int32_t, 256, 256> const& value) override {
    if (WriteInt256x256Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteInt256x256Impl");
    }
    if (WriteInt256x256Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteInt256x256Impl");
    }
    WriteInt256x256Impl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<int32_t, 256, 256>> WriteInt256x256Impl_expected_values_;

  void ExpectWriteInt256x256Impl (yardl::FixedNDArray<int32_t, 256, 256> const& value) {
    WriteInt256x256Impl_expected_values_.push(value);
  }

  void EndInt256x256Impl () override {
    if (--EndInt256x256Impl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndInt256x256Impl");
    }
  }

  int EndInt256x256Impl_expected_call_count_ = 0;

  void ExpectEndInt256x256Impl () {
    EndInt256x256Impl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteInt256x256Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteInt256x256Impl was not received");
    }
    if (EndInt256x256Impl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndInt256x256Impl was not received");
    }
  }
};

class TestBenchmarkInt256x256WriterBase : public BenchmarkInt256x256WriterBase {
  public:
  TestBenchmarkInt256x256WriterBase(std::unique_ptr<test_model::BenchmarkInt256x256WriterBase> writer, std::function<std::unique_ptr<BenchmarkInt256x256ReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkInt256x256WriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkInt256x256WriterBase' to verify mocks";
    }
  }

  protected:
  void WriteInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256> const& value) override {
    writer_->WriteInt256x256(value);
    mock_writer_.ExpectWriteInt256x256Impl(value);
  }

  void WriteInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>> const& values) override {
    writer_->WriteInt256x256(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteInt256x256Impl(v);
    }
  }

  void EndInt256x256Impl() override {
    writer_->EndInt256x256();
    mock_writer_.ExpectEndInt256x256Impl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkInt256x256ReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkInt256x256WriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkInt256x256ReaderBase>()> create_reader_;
  MockBenchmarkInt256x256Writer mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkFloatVlenWriter : public BenchmarkFloatVlenWriterBase {
  public:
  void WriteFloatArrayImpl (yardl::NDArray<float, 2> const& value) override {
    if (WriteFloatArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatArrayImpl");
    }
    if (WriteFloatArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatArrayImpl");
    }
    WriteFloatArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<float, 2>> WriteFloatArrayImpl_expected_values_;

  void ExpectWriteFloatArrayImpl (yardl::NDArray<float, 2> const& value) {
    WriteFloatArrayImpl_expected_values_.push(value);
  }

  void EndFloatArrayImpl () override {
    if (--EndFloatArrayImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFloatArrayImpl");
    }
  }

  int EndFloatArrayImpl_expected_call_count_ = 0;

  void ExpectEndFloatArrayImpl () {
    EndFloatArrayImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteFloatArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatArrayImpl was not received");
    }
    if (EndFloatArrayImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFloatArrayImpl was not received");
    }
  }
};

class TestBenchmarkFloatVlenWriterBase : public BenchmarkFloatVlenWriterBase {
  public:
  TestBenchmarkFloatVlenWriterBase(std::unique_ptr<test_model::BenchmarkFloatVlenWriterBase> writer, std::function<std::unique_ptr<BenchmarkFloatVlenReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkFloatVlenWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkFloatVlenWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloatArrayImpl(yardl::NDArray<float, 2> const& value) override {
    writer_->WriteFloatArray(value);
    mock_writer_.ExpectWriteFloatArrayImpl(value);
  }

  void WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& values) override {
    writer_->WriteFloatArray(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFloatArrayImpl(v);
    }
  }

  void EndFloatArrayImpl() override {
    writer_->EndFloatArray();
    mock_writer_.ExpectEndFloatArrayImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkFloatVlenReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkFloatVlenWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkFloatVlenReaderBase>()> create_reader_;
  MockBenchmarkFloatVlenWriter mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkSmallRecordWriter : public BenchmarkSmallRecordWriterBase {
  public:
  void WriteSmallRecordImpl (test_model::SmallBenchmarkRecord const& value) override {
    if (WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSmallRecordImpl");
    }
    if (WriteSmallRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSmallRecordImpl");
    }
    WriteSmallRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::SmallBenchmarkRecord> WriteSmallRecordImpl_expected_values_;

  void ExpectWriteSmallRecordImpl (test_model::SmallBenchmarkRecord const& value) {
    WriteSmallRecordImpl_expected_values_.push(value);
  }

  void EndSmallRecordImpl () override {
    if (--EndSmallRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndSmallRecordImpl");
    }
  }

  int EndSmallRecordImpl_expected_call_count_ = 0;

  void ExpectEndSmallRecordImpl () {
    EndSmallRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSmallRecordImpl was not received");
    }
    if (EndSmallRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndSmallRecordImpl was not received");
    }
  }
};

class TestBenchmarkSmallRecordWriterBase : public BenchmarkSmallRecordWriterBase {
  public:
  TestBenchmarkSmallRecordWriterBase(std::unique_ptr<test_model::BenchmarkSmallRecordWriterBase> writer, std::function<std::unique_ptr<BenchmarkSmallRecordReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkSmallRecordWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkSmallRecordWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSmallRecordImpl(test_model::SmallBenchmarkRecord const& value) override {
    writer_->WriteSmallRecord(value);
    mock_writer_.ExpectWriteSmallRecordImpl(value);
  }

  void WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& values) override {
    writer_->WriteSmallRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteSmallRecordImpl(v);
    }
  }

  void EndSmallRecordImpl() override {
    writer_->EndSmallRecord();
    mock_writer_.ExpectEndSmallRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkSmallRecordReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkSmallRecordWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkSmallRecordReaderBase>()> create_reader_;
  MockBenchmarkSmallRecordWriter mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkSmallRecordWithOptionalsWriter : public BenchmarkSmallRecordWithOptionalsWriterBase {
  public:
  void WriteSmallRecordImpl (test_model::SimpleEncodingCounters const& value) override {
    if (WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSmallRecordImpl");
    }
    if (WriteSmallRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSmallRecordImpl");
    }
    WriteSmallRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::SimpleEncodingCounters> WriteSmallRecordImpl_expected_values_;

  void ExpectWriteSmallRecordImpl (test_model::SimpleEncodingCounters const& value) {
    WriteSmallRecordImpl_expected_values_.push(value);
  }

  void EndSmallRecordImpl () override {
    if (--EndSmallRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndSmallRecordImpl");
    }
  }

  int EndSmallRecordImpl_expected_call_count_ = 0;

  void ExpectEndSmallRecordImpl () {
    EndSmallRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteSmallRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSmallRecordImpl was not received");
    }
    if (EndSmallRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndSmallRecordImpl was not received");
    }
  }
};

class TestBenchmarkSmallRecordWithOptionalsWriterBase : public BenchmarkSmallRecordWithOptionalsWriterBase {
  public:
  TestBenchmarkSmallRecordWithOptionalsWriterBase(std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsWriterBase> writer, std::function<std::unique_ptr<BenchmarkSmallRecordWithOptionalsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkSmallRecordWithOptionalsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkSmallRecordWithOptionalsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSmallRecordImpl(test_model::SimpleEncodingCounters const& value) override {
    writer_->WriteSmallRecord(value);
    mock_writer_.ExpectWriteSmallRecordImpl(value);
  }

  void WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& values) override {
    writer_->WriteSmallRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteSmallRecordImpl(v);
    }
  }

  void EndSmallRecordImpl() override {
    writer_->EndSmallRecord();
    mock_writer_.ExpectEndSmallRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkSmallRecordWithOptionalsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsReaderBase>()> create_reader_;
  MockBenchmarkSmallRecordWithOptionalsWriter mock_writer_;
  bool close_called_ = false;
};

class MockBenchmarkSimpleMrdWriter : public BenchmarkSimpleMrdWriterBase {
  public:
  void WriteDataImpl (std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) override {
    if (WriteDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDataImpl");
    }
    if (WriteDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDataImpl");
    }
    WriteDataImpl_expected_values_.pop();
  }

  std::queue<std::variant<test_model::SimpleAcquisition, image::Image<float>>> WriteDataImpl_expected_values_;

  void ExpectWriteDataImpl (std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) {
    WriteDataImpl_expected_values_.push(value);
  }

  void EndDataImpl () override {
    if (--EndDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndDataImpl");
    }
  }

  int EndDataImpl_expected_call_count_ = 0;

  void ExpectEndDataImpl () {
    EndDataImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDataImpl was not received");
    }
    if (EndDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndDataImpl was not received");
    }
  }
};

class TestBenchmarkSimpleMrdWriterBase : public BenchmarkSimpleMrdWriterBase {
  public:
  TestBenchmarkSimpleMrdWriterBase(std::unique_ptr<test_model::BenchmarkSimpleMrdWriterBase> writer, std::function<std::unique_ptr<BenchmarkSimpleMrdReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestBenchmarkSimpleMrdWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestBenchmarkSimpleMrdWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) override {
    writer_->WriteData(value);
    mock_writer_.ExpectWriteDataImpl(value);
  }

  void WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> const& values) override {
    writer_->WriteData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteDataImpl(v);
    }
  }

  void EndDataImpl() override {
    writer_->EndData();
    mock_writer_.ExpectEndDataImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<BenchmarkSimpleMrdReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::BenchmarkSimpleMrdWriterBase> writer_;
  std::function<std::unique_ptr<test_model::BenchmarkSimpleMrdReaderBase>()> create_reader_;
  MockBenchmarkSimpleMrdWriter mock_writer_;
  bool close_called_ = false;
};

class MockScalarsWriter : public ScalarsWriterBase {
  public:
  void WriteInt32Impl (int32_t const& value) override {
    if (WriteInt32Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteInt32Impl");
    }
    if (WriteInt32Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteInt32Impl");
    }
    WriteInt32Impl_expected_values_.pop();
  }

  std::queue<int32_t> WriteInt32Impl_expected_values_;

  void ExpectWriteInt32Impl (int32_t const& value) {
    WriteInt32Impl_expected_values_.push(value);
  }

  void WriteRecordImpl (test_model::RecordWithPrimitives const& value) override {
    if (WriteRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordImpl");
    }
    if (WriteRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordImpl");
    }
    WriteRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithPrimitives> WriteRecordImpl_expected_values_;

  void ExpectWriteRecordImpl (test_model::RecordWithPrimitives const& value) {
    WriteRecordImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteInt32Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteInt32Impl was not received");
    }
    if (!WriteRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordImpl was not received");
    }
  }
};

class TestScalarsWriterBase : public ScalarsWriterBase {
  public:
  TestScalarsWriterBase(std::unique_ptr<test_model::ScalarsWriterBase> writer, std::function<std::unique_ptr<ScalarsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestScalarsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestScalarsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteInt32Impl(int32_t const& value) override {
    writer_->WriteInt32(value);
    mock_writer_.ExpectWriteInt32Impl(value);
  }

  void WriteRecordImpl(test_model::RecordWithPrimitives const& value) override {
    writer_->WriteRecord(value);
    mock_writer_.ExpectWriteRecordImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ScalarsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ScalarsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ScalarsReaderBase>()> create_reader_;
  MockScalarsWriter mock_writer_;
  bool close_called_ = false;
};

class MockScalarOptionalsWriter : public ScalarOptionalsWriterBase {
  public:
  void WriteOptionalIntImpl (std::optional<int32_t> const& value) override {
    if (WriteOptionalIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalIntImpl");
    }
    if (WriteOptionalIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalIntImpl");
    }
    WriteOptionalIntImpl_expected_values_.pop();
  }

  std::queue<std::optional<int32_t>> WriteOptionalIntImpl_expected_values_;

  void ExpectWriteOptionalIntImpl (std::optional<int32_t> const& value) {
    WriteOptionalIntImpl_expected_values_.push(value);
  }

  void WriteOptionalRecordImpl (std::optional<test_model::SimpleRecord> const& value) override {
    if (WriteOptionalRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalRecordImpl");
    }
    if (WriteOptionalRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalRecordImpl");
    }
    WriteOptionalRecordImpl_expected_values_.pop();
  }

  std::queue<std::optional<test_model::SimpleRecord>> WriteOptionalRecordImpl_expected_values_;

  void ExpectWriteOptionalRecordImpl (std::optional<test_model::SimpleRecord> const& value) {
    WriteOptionalRecordImpl_expected_values_.push(value);
  }

  void WriteRecordWithOptionalFieldsImpl (test_model::RecordWithOptionalFields const& value) override {
    if (WriteRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithOptionalFieldsImpl");
    }
    if (WriteRecordWithOptionalFieldsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithOptionalFieldsImpl");
    }
    WriteRecordWithOptionalFieldsImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithOptionalFields> WriteRecordWithOptionalFieldsImpl_expected_values_;

  void ExpectWriteRecordWithOptionalFieldsImpl (test_model::RecordWithOptionalFields const& value) {
    WriteRecordWithOptionalFieldsImpl_expected_values_.push(value);
  }

  void WriteOptionalRecordWithOptionalFieldsImpl (std::optional<test_model::RecordWithOptionalFields> const& value) override {
    if (WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalRecordWithOptionalFieldsImpl");
    }
    if (WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalRecordWithOptionalFieldsImpl");
    }
    WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.pop();
  }

  std::queue<std::optional<test_model::RecordWithOptionalFields>> WriteOptionalRecordWithOptionalFieldsImpl_expected_values_;

  void ExpectWriteOptionalRecordWithOptionalFieldsImpl (std::optional<test_model::RecordWithOptionalFields> const& value) {
    WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteOptionalIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalIntImpl was not received");
    }
    if (!WriteOptionalRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalRecordImpl was not received");
    }
    if (!WriteRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithOptionalFieldsImpl was not received");
    }
    if (!WriteOptionalRecordWithOptionalFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalRecordWithOptionalFieldsImpl was not received");
    }
  }
};

class TestScalarOptionalsWriterBase : public ScalarOptionalsWriterBase {
  public:
  TestScalarOptionalsWriterBase(std::unique_ptr<test_model::ScalarOptionalsWriterBase> writer, std::function<std::unique_ptr<ScalarOptionalsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestScalarOptionalsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestScalarOptionalsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteOptionalIntImpl(std::optional<int32_t> const& value) override {
    writer_->WriteOptionalInt(value);
    mock_writer_.ExpectWriteOptionalIntImpl(value);
  }

  void WriteOptionalRecordImpl(std::optional<test_model::SimpleRecord> const& value) override {
    writer_->WriteOptionalRecord(value);
    mock_writer_.ExpectWriteOptionalRecordImpl(value);
  }

  void WriteRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields const& value) override {
    writer_->WriteRecordWithOptionalFields(value);
    mock_writer_.ExpectWriteRecordWithOptionalFieldsImpl(value);
  }

  void WriteOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields> const& value) override {
    writer_->WriteOptionalRecordWithOptionalFields(value);
    mock_writer_.ExpectWriteOptionalRecordWithOptionalFieldsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ScalarOptionalsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ScalarOptionalsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ScalarOptionalsReaderBase>()> create_reader_;
  MockScalarOptionalsWriter mock_writer_;
  bool close_called_ = false;
};

class MockNestedRecordsWriter : public NestedRecordsWriterBase {
  public:
  void WriteTupleWithRecordsImpl (test_model::TupleWithRecords const& value) override {
    if (WriteTupleWithRecordsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleWithRecordsImpl");
    }
    if (WriteTupleWithRecordsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleWithRecordsImpl");
    }
    WriteTupleWithRecordsImpl_expected_values_.pop();
  }

  std::queue<test_model::TupleWithRecords> WriteTupleWithRecordsImpl_expected_values_;

  void ExpectWriteTupleWithRecordsImpl (test_model::TupleWithRecords const& value) {
    WriteTupleWithRecordsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteTupleWithRecordsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleWithRecordsImpl was not received");
    }
  }
};

class TestNestedRecordsWriterBase : public NestedRecordsWriterBase {
  public:
  TestNestedRecordsWriterBase(std::unique_ptr<test_model::NestedRecordsWriterBase> writer, std::function<std::unique_ptr<NestedRecordsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestNestedRecordsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestNestedRecordsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteTupleWithRecordsImpl(test_model::TupleWithRecords const& value) override {
    writer_->WriteTupleWithRecords(value);
    mock_writer_.ExpectWriteTupleWithRecordsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<NestedRecordsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::NestedRecordsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::NestedRecordsReaderBase>()> create_reader_;
  MockNestedRecordsWriter mock_writer_;
  bool close_called_ = false;
};

class MockVlensWriter : public VlensWriterBase {
  public:
  void WriteIntVectorImpl (std::vector<int32_t> const& value) override {
    if (WriteIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntVectorImpl");
    }
    if (WriteIntVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntVectorImpl");
    }
    WriteIntVectorImpl_expected_values_.pop();
  }

  std::queue<std::vector<int32_t>> WriteIntVectorImpl_expected_values_;

  void ExpectWriteIntVectorImpl (std::vector<int32_t> const& value) {
    WriteIntVectorImpl_expected_values_.push(value);
  }

  void WriteComplexVectorImpl (std::vector<std::complex<float>> const& value) override {
    if (WriteComplexVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteComplexVectorImpl");
    }
    if (WriteComplexVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteComplexVectorImpl");
    }
    WriteComplexVectorImpl_expected_values_.pop();
  }

  std::queue<std::vector<std::complex<float>>> WriteComplexVectorImpl_expected_values_;

  void ExpectWriteComplexVectorImpl (std::vector<std::complex<float>> const& value) {
    WriteComplexVectorImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensImpl (test_model::RecordWithVlens const& value) override {
    if (WriteRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensImpl");
    }
    if (WriteRecordWithVlensImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensImpl");
    }
    WriteRecordWithVlensImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithVlens> WriteRecordWithVlensImpl_expected_values_;

  void ExpectWriteRecordWithVlensImpl (test_model::RecordWithVlens const& value) {
    WriteRecordWithVlensImpl_expected_values_.push(value);
  }

  void WriteVlenOfRecordWithVlensImpl (std::vector<test_model::RecordWithVlens> const& value) override {
    if (WriteVlenOfRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteVlenOfRecordWithVlensImpl");
    }
    if (WriteVlenOfRecordWithVlensImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteVlenOfRecordWithVlensImpl");
    }
    WriteVlenOfRecordWithVlensImpl_expected_values_.pop();
  }

  std::queue<std::vector<test_model::RecordWithVlens>> WriteVlenOfRecordWithVlensImpl_expected_values_;

  void ExpectWriteVlenOfRecordWithVlensImpl (std::vector<test_model::RecordWithVlens> const& value) {
    WriteVlenOfRecordWithVlensImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntVectorImpl was not received");
    }
    if (!WriteComplexVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteComplexVectorImpl was not received");
    }
    if (!WriteRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensImpl was not received");
    }
    if (!WriteVlenOfRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteVlenOfRecordWithVlensImpl was not received");
    }
  }
};

class TestVlensWriterBase : public VlensWriterBase {
  public:
  TestVlensWriterBase(std::unique_ptr<test_model::VlensWriterBase> writer, std::function<std::unique_ptr<VlensReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestVlensWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestVlensWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntVectorImpl(std::vector<int32_t> const& value) override {
    writer_->WriteIntVector(value);
    mock_writer_.ExpectWriteIntVectorImpl(value);
  }

  void WriteComplexVectorImpl(std::vector<std::complex<float>> const& value) override {
    writer_->WriteComplexVector(value);
    mock_writer_.ExpectWriteComplexVectorImpl(value);
  }

  void WriteRecordWithVlensImpl(test_model::RecordWithVlens const& value) override {
    writer_->WriteRecordWithVlens(value);
    mock_writer_.ExpectWriteRecordWithVlensImpl(value);
  }

  void WriteVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens> const& value) override {
    writer_->WriteVlenOfRecordWithVlens(value);
    mock_writer_.ExpectWriteVlenOfRecordWithVlensImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<VlensReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::VlensWriterBase> writer_;
  std::function<std::unique_ptr<test_model::VlensReaderBase>()> create_reader_;
  MockVlensWriter mock_writer_;
  bool close_called_ = false;
};

class MockStringsWriter : public StringsWriterBase {
  public:
  void WriteSingleStringImpl (std::string const& value) override {
    if (WriteSingleStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSingleStringImpl");
    }
    if (WriteSingleStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSingleStringImpl");
    }
    WriteSingleStringImpl_expected_values_.pop();
  }

  std::queue<std::string> WriteSingleStringImpl_expected_values_;

  void ExpectWriteSingleStringImpl (std::string const& value) {
    WriteSingleStringImpl_expected_values_.push(value);
  }

  void WriteRecWithStringImpl (test_model::RecordWithStrings const& value) override {
    if (WriteRecWithStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecWithStringImpl");
    }
    if (WriteRecWithStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecWithStringImpl");
    }
    WriteRecWithStringImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithStrings> WriteRecWithStringImpl_expected_values_;

  void ExpectWriteRecWithStringImpl (test_model::RecordWithStrings const& value) {
    WriteRecWithStringImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteSingleStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSingleStringImpl was not received");
    }
    if (!WriteRecWithStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecWithStringImpl was not received");
    }
  }
};

class TestStringsWriterBase : public StringsWriterBase {
  public:
  TestStringsWriterBase(std::unique_ptr<test_model::StringsWriterBase> writer, std::function<std::unique_ptr<StringsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStringsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStringsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSingleStringImpl(std::string const& value) override {
    writer_->WriteSingleString(value);
    mock_writer_.ExpectWriteSingleStringImpl(value);
  }

  void WriteRecWithStringImpl(test_model::RecordWithStrings const& value) override {
    writer_->WriteRecWithString(value);
    mock_writer_.ExpectWriteRecWithStringImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StringsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StringsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StringsReaderBase>()> create_reader_;
  MockStringsWriter mock_writer_;
  bool close_called_ = false;
};

class MockOptionalVectorsWriter : public OptionalVectorsWriterBase {
  public:
  void WriteRecordWithOptionalVectorImpl (test_model::RecordWithOptionalVector const& value) override {
    if (WriteRecordWithOptionalVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithOptionalVectorImpl");
    }
    if (WriteRecordWithOptionalVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithOptionalVectorImpl");
    }
    WriteRecordWithOptionalVectorImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithOptionalVector> WriteRecordWithOptionalVectorImpl_expected_values_;

  void ExpectWriteRecordWithOptionalVectorImpl (test_model::RecordWithOptionalVector const& value) {
    WriteRecordWithOptionalVectorImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteRecordWithOptionalVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithOptionalVectorImpl was not received");
    }
  }
};

class TestOptionalVectorsWriterBase : public OptionalVectorsWriterBase {
  public:
  TestOptionalVectorsWriterBase(std::unique_ptr<test_model::OptionalVectorsWriterBase> writer, std::function<std::unique_ptr<OptionalVectorsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestOptionalVectorsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestOptionalVectorsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector const& value) override {
    writer_->WriteRecordWithOptionalVector(value);
    mock_writer_.ExpectWriteRecordWithOptionalVectorImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<OptionalVectorsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::OptionalVectorsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::OptionalVectorsReaderBase>()> create_reader_;
  MockOptionalVectorsWriter mock_writer_;
  bool close_called_ = false;
};

class MockFixedVectorsWriter : public FixedVectorsWriterBase {
  public:
  void WriteFixedIntVectorImpl (std::array<int32_t, 5> const& value) override {
    if (WriteFixedIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedIntVectorImpl");
    }
    if (WriteFixedIntVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedIntVectorImpl");
    }
    WriteFixedIntVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<int32_t, 5>> WriteFixedIntVectorImpl_expected_values_;

  void ExpectWriteFixedIntVectorImpl (std::array<int32_t, 5> const& value) {
    WriteFixedIntVectorImpl_expected_values_.push(value);
  }

  void WriteFixedSimpleRecordVectorImpl (std::array<test_model::SimpleRecord, 3> const& value) override {
    if (WriteFixedSimpleRecordVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedSimpleRecordVectorImpl");
    }
    if (WriteFixedSimpleRecordVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedSimpleRecordVectorImpl");
    }
    WriteFixedSimpleRecordVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<test_model::SimpleRecord, 3>> WriteFixedSimpleRecordVectorImpl_expected_values_;

  void ExpectWriteFixedSimpleRecordVectorImpl (std::array<test_model::SimpleRecord, 3> const& value) {
    WriteFixedSimpleRecordVectorImpl_expected_values_.push(value);
  }

  void WriteFixedRecordWithVlensVectorImpl (std::array<test_model::RecordWithVlens, 2> const& value) override {
    if (WriteFixedRecordWithVlensVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedRecordWithVlensVectorImpl");
    }
    if (WriteFixedRecordWithVlensVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedRecordWithVlensVectorImpl");
    }
    WriteFixedRecordWithVlensVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<test_model::RecordWithVlens, 2>> WriteFixedRecordWithVlensVectorImpl_expected_values_;

  void ExpectWriteFixedRecordWithVlensVectorImpl (std::array<test_model::RecordWithVlens, 2> const& value) {
    WriteFixedRecordWithVlensVectorImpl_expected_values_.push(value);
  }

  void WriteRecordWithFixedVectorsImpl (test_model::RecordWithFixedVectors const& value) override {
    if (WriteRecordWithFixedVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithFixedVectorsImpl");
    }
    if (WriteRecordWithFixedVectorsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithFixedVectorsImpl");
    }
    WriteRecordWithFixedVectorsImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithFixedVectors> WriteRecordWithFixedVectorsImpl_expected_values_;

  void ExpectWriteRecordWithFixedVectorsImpl (test_model::RecordWithFixedVectors const& value) {
    WriteRecordWithFixedVectorsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteFixedIntVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedIntVectorImpl was not received");
    }
    if (!WriteFixedSimpleRecordVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedSimpleRecordVectorImpl was not received");
    }
    if (!WriteFixedRecordWithVlensVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedRecordWithVlensVectorImpl was not received");
    }
    if (!WriteRecordWithFixedVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithFixedVectorsImpl was not received");
    }
  }
};

class TestFixedVectorsWriterBase : public FixedVectorsWriterBase {
  public:
  TestFixedVectorsWriterBase(std::unique_ptr<test_model::FixedVectorsWriterBase> writer, std::function<std::unique_ptr<FixedVectorsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestFixedVectorsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestFixedVectorsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFixedIntVectorImpl(std::array<int32_t, 5> const& value) override {
    writer_->WriteFixedIntVector(value);
    mock_writer_.ExpectWriteFixedIntVectorImpl(value);
  }

  void WriteFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3> const& value) override {
    writer_->WriteFixedSimpleRecordVector(value);
    mock_writer_.ExpectWriteFixedSimpleRecordVectorImpl(value);
  }

  void WriteFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2> const& value) override {
    writer_->WriteFixedRecordWithVlensVector(value);
    mock_writer_.ExpectWriteFixedRecordWithVlensVectorImpl(value);
  }

  void WriteRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors const& value) override {
    writer_->WriteRecordWithFixedVectors(value);
    mock_writer_.ExpectWriteRecordWithFixedVectorsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<FixedVectorsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::FixedVectorsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::FixedVectorsReaderBase>()> create_reader_;
  MockFixedVectorsWriter mock_writer_;
  bool close_called_ = false;
};

class MockStreamsWriter : public StreamsWriterBase {
  public:
  void WriteIntDataImpl (int32_t const& value) override {
    if (WriteIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntDataImpl");
    }
    if (WriteIntDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntDataImpl");
    }
    WriteIntDataImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteIntDataImpl_expected_values_;

  void ExpectWriteIntDataImpl (int32_t const& value) {
    WriteIntDataImpl_expected_values_.push(value);
  }

  void EndIntDataImpl () override {
    if (--EndIntDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntDataImpl");
    }
  }

  int EndIntDataImpl_expected_call_count_ = 0;

  void ExpectEndIntDataImpl () {
    EndIntDataImpl_expected_call_count_++;
  }

  void WriteOptionalIntDataImpl (std::optional<int32_t> const& value) override {
    if (WriteOptionalIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteOptionalIntDataImpl");
    }
    if (WriteOptionalIntDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteOptionalIntDataImpl");
    }
    WriteOptionalIntDataImpl_expected_values_.pop();
  }

  std::queue<std::optional<int32_t>> WriteOptionalIntDataImpl_expected_values_;

  void ExpectWriteOptionalIntDataImpl (std::optional<int32_t> const& value) {
    WriteOptionalIntDataImpl_expected_values_.push(value);
  }

  void EndOptionalIntDataImpl () override {
    if (--EndOptionalIntDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndOptionalIntDataImpl");
    }
  }

  int EndOptionalIntDataImpl_expected_call_count_ = 0;

  void ExpectEndOptionalIntDataImpl () {
    EndOptionalIntDataImpl_expected_call_count_++;
  }

  void WriteRecordWithOptionalVectorDataImpl (test_model::RecordWithOptionalVector const& value) override {
    if (WriteRecordWithOptionalVectorDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithOptionalVectorDataImpl");
    }
    if (WriteRecordWithOptionalVectorDataImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithOptionalVectorDataImpl");
    }
    WriteRecordWithOptionalVectorDataImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithOptionalVector> WriteRecordWithOptionalVectorDataImpl_expected_values_;

  void ExpectWriteRecordWithOptionalVectorDataImpl (test_model::RecordWithOptionalVector const& value) {
    WriteRecordWithOptionalVectorDataImpl_expected_values_.push(value);
  }

  void EndRecordWithOptionalVectorDataImpl () override {
    if (--EndRecordWithOptionalVectorDataImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndRecordWithOptionalVectorDataImpl");
    }
  }

  int EndRecordWithOptionalVectorDataImpl_expected_call_count_ = 0;

  void ExpectEndRecordWithOptionalVectorDataImpl () {
    EndRecordWithOptionalVectorDataImpl_expected_call_count_++;
  }

  void WriteFixedVectorImpl (std::array<int32_t, 3> const& value) override {
    if (WriteFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedVectorImpl");
    }
    if (WriteFixedVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedVectorImpl");
    }
    WriteFixedVectorImpl_expected_values_.pop();
  }

  std::queue<std::array<int32_t, 3>> WriteFixedVectorImpl_expected_values_;

  void ExpectWriteFixedVectorImpl (std::array<int32_t, 3> const& value) {
    WriteFixedVectorImpl_expected_values_.push(value);
  }

  void EndFixedVectorImpl () override {
    if (--EndFixedVectorImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFixedVectorImpl");
    }
  }

  int EndFixedVectorImpl_expected_call_count_ = 0;

  void ExpectEndFixedVectorImpl () {
    EndFixedVectorImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntDataImpl was not received");
    }
    if (EndIntDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntDataImpl was not received");
    }
    if (!WriteOptionalIntDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteOptionalIntDataImpl was not received");
    }
    if (EndOptionalIntDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndOptionalIntDataImpl was not received");
    }
    if (!WriteRecordWithOptionalVectorDataImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithOptionalVectorDataImpl was not received");
    }
    if (EndRecordWithOptionalVectorDataImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndRecordWithOptionalVectorDataImpl was not received");
    }
    if (!WriteFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedVectorImpl was not received");
    }
    if (EndFixedVectorImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFixedVectorImpl was not received");
    }
  }
};

class TestStreamsWriterBase : public StreamsWriterBase {
  public:
  TestStreamsWriterBase(std::unique_ptr<test_model::StreamsWriterBase> writer, std::function<std::unique_ptr<StreamsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStreamsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStreamsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntDataImpl(int32_t const& value) override {
    writer_->WriteIntData(value);
    mock_writer_.ExpectWriteIntDataImpl(value);
  }

  void WriteIntDataImpl(std::vector<int32_t> const& values) override {
    writer_->WriteIntData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntDataImpl(v);
    }
  }

  void EndIntDataImpl() override {
    writer_->EndIntData();
    mock_writer_.ExpectEndIntDataImpl();
  }

  void WriteOptionalIntDataImpl(std::optional<int32_t> const& value) override {
    writer_->WriteOptionalIntData(value);
    mock_writer_.ExpectWriteOptionalIntDataImpl(value);
  }

  void WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& values) override {
    writer_->WriteOptionalIntData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteOptionalIntDataImpl(v);
    }
  }

  void EndOptionalIntDataImpl() override {
    writer_->EndOptionalIntData();
    mock_writer_.ExpectEndOptionalIntDataImpl();
  }

  void WriteRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector const& value) override {
    writer_->WriteRecordWithOptionalVectorData(value);
    mock_writer_.ExpectWriteRecordWithOptionalVectorDataImpl(value);
  }

  void WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& values) override {
    writer_->WriteRecordWithOptionalVectorData(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteRecordWithOptionalVectorDataImpl(v);
    }
  }

  void EndRecordWithOptionalVectorDataImpl() override {
    writer_->EndRecordWithOptionalVectorData();
    mock_writer_.ExpectEndRecordWithOptionalVectorDataImpl();
  }

  void WriteFixedVectorImpl(std::array<int32_t, 3> const& value) override {
    writer_->WriteFixedVector(value);
    mock_writer_.ExpectWriteFixedVectorImpl(value);
  }

  void WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& values) override {
    writer_->WriteFixedVector(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFixedVectorImpl(v);
    }
  }

  void EndFixedVectorImpl() override {
    writer_->EndFixedVector();
    mock_writer_.ExpectEndFixedVectorImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StreamsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1, 4, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StreamsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StreamsReaderBase>()> create_reader_;
  MockStreamsWriter mock_writer_;
  bool close_called_ = false;
};

class MockFixedArraysWriter : public FixedArraysWriterBase {
  public:
  void WriteIntsImpl (yardl::FixedNDArray<int32_t, 2, 3> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<int32_t, 2, 3>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::FixedNDArray<int32_t, 2, 3> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteFixedSimpleRecordArrayImpl (yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) override {
    if (WriteFixedSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedSimpleRecordArrayImpl");
    }
    if (WriteFixedSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedSimpleRecordArrayImpl");
    }
    WriteFixedSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>> WriteFixedSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteFixedSimpleRecordArrayImpl (yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) {
    WriteFixedSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteFixedRecordWithVlensArrayImpl (yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) override {
    if (WriteFixedRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedRecordWithVlensArrayImpl");
    }
    if (WriteFixedRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedRecordWithVlensArrayImpl");
    }
    WriteFixedRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>> WriteFixedRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteFixedRecordWithVlensArrayImpl (yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) {
    WriteFixedRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithFixedArraysImpl (test_model::RecordWithFixedArrays const& value) override {
    if (WriteRecordWithFixedArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithFixedArraysImpl");
    }
    if (WriteRecordWithFixedArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithFixedArraysImpl");
    }
    WriteRecordWithFixedArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithFixedArrays> WriteRecordWithFixedArraysImpl_expected_values_;

  void ExpectWriteRecordWithFixedArraysImpl (test_model::RecordWithFixedArrays const& value) {
    WriteRecordWithFixedArraysImpl_expected_values_.push(value);
  }

  void WriteNamedArrayImpl (test_model::NamedFixedNDArray const& value) override {
    if (WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNamedArrayImpl");
    }
    if (WriteNamedArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNamedArrayImpl");
    }
    WriteNamedArrayImpl_expected_values_.pop();
  }

  std::queue<test_model::NamedFixedNDArray> WriteNamedArrayImpl_expected_values_;

  void ExpectWriteNamedArrayImpl (test_model::NamedFixedNDArray const& value) {
    WriteNamedArrayImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteFixedSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedSimpleRecordArrayImpl was not received");
    }
    if (!WriteFixedRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithFixedArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithFixedArraysImpl was not received");
    }
    if (!WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNamedArrayImpl was not received");
    }
  }
};

class TestFixedArraysWriterBase : public FixedArraysWriterBase {
  public:
  TestFixedArraysWriterBase(std::unique_ptr<test_model::FixedArraysWriterBase> writer, std::function<std::unique_ptr<FixedArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestFixedArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestFixedArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::FixedNDArray<int32_t, 2, 3> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) override {
    writer_->WriteFixedSimpleRecordArray(value);
    mock_writer_.ExpectWriteFixedSimpleRecordArrayImpl(value);
  }

  void WriteFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) override {
    writer_->WriteFixedRecordWithVlensArray(value);
    mock_writer_.ExpectWriteFixedRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays const& value) override {
    writer_->WriteRecordWithFixedArrays(value);
    mock_writer_.ExpectWriteRecordWithFixedArraysImpl(value);
  }

  void WriteNamedArrayImpl(test_model::NamedFixedNDArray const& value) override {
    writer_->WriteNamedArray(value);
    mock_writer_.ExpectWriteNamedArrayImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<FixedArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::FixedArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::FixedArraysReaderBase>()> create_reader_;
  MockFixedArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockSubarraysWriter : public SubarraysWriterBase {
  public:
  void WriteDynamicWithFixedIntSubarrayImpl (yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) override {
    if (WriteDynamicWithFixedIntSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDynamicWithFixedIntSubarrayImpl");
    }
    if (WriteDynamicWithFixedIntSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDynamicWithFixedIntSubarrayImpl");
    }
    WriteDynamicWithFixedIntSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>>> WriteDynamicWithFixedIntSubarrayImpl_expected_values_;

  void ExpectWriteDynamicWithFixedIntSubarrayImpl (yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) {
    WriteDynamicWithFixedIntSubarrayImpl_expected_values_.push(value);
  }

  void WriteDynamicWithFixedFloatSubarrayImpl (yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) override {
    if (WriteDynamicWithFixedFloatSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDynamicWithFixedFloatSubarrayImpl");
    }
    if (WriteDynamicWithFixedFloatSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDynamicWithFixedFloatSubarrayImpl");
    }
    WriteDynamicWithFixedFloatSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>>> WriteDynamicWithFixedFloatSubarrayImpl_expected_values_;

  void ExpectWriteDynamicWithFixedFloatSubarrayImpl (yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) {
    WriteDynamicWithFixedFloatSubarrayImpl_expected_values_.push(value);
  }

  void WriteKnownDimCountWithFixedIntSubarrayImpl (yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) override {
    if (WriteKnownDimCountWithFixedIntSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteKnownDimCountWithFixedIntSubarrayImpl");
    }
    if (WriteKnownDimCountWithFixedIntSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteKnownDimCountWithFixedIntSubarrayImpl");
    }
    WriteKnownDimCountWithFixedIntSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1>> WriteKnownDimCountWithFixedIntSubarrayImpl_expected_values_;

  void ExpectWriteKnownDimCountWithFixedIntSubarrayImpl (yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) {
    WriteKnownDimCountWithFixedIntSubarrayImpl_expected_values_.push(value);
  }

  void WriteKnownDimCountWithFixedFloatSubarrayImpl (yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) override {
    if (WriteKnownDimCountWithFixedFloatSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteKnownDimCountWithFixedFloatSubarrayImpl");
    }
    if (WriteKnownDimCountWithFixedFloatSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteKnownDimCountWithFixedFloatSubarrayImpl");
    }
    WriteKnownDimCountWithFixedFloatSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<yardl::FixedNDArray<float, 3>, 1>> WriteKnownDimCountWithFixedFloatSubarrayImpl_expected_values_;

  void ExpectWriteKnownDimCountWithFixedFloatSubarrayImpl (yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) {
    WriteKnownDimCountWithFixedFloatSubarrayImpl_expected_values_.push(value);
  }

  void WriteFixedWithFixedIntSubarrayImpl (yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) override {
    if (WriteFixedWithFixedIntSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedWithFixedIntSubarrayImpl");
    }
    if (WriteFixedWithFixedIntSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedWithFixedIntSubarrayImpl");
    }
    WriteFixedWithFixedIntSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> WriteFixedWithFixedIntSubarrayImpl_expected_values_;

  void ExpectWriteFixedWithFixedIntSubarrayImpl (yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) {
    WriteFixedWithFixedIntSubarrayImpl_expected_values_.push(value);
  }

  void WriteFixedWithFixedFloatSubarrayImpl (yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) override {
    if (WriteFixedWithFixedFloatSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFixedWithFixedFloatSubarrayImpl");
    }
    if (WriteFixedWithFixedFloatSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFixedWithFixedFloatSubarrayImpl");
    }
    WriteFixedWithFixedFloatSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2>> WriteFixedWithFixedFloatSubarrayImpl_expected_values_;

  void ExpectWriteFixedWithFixedFloatSubarrayImpl (yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) {
    WriteFixedWithFixedFloatSubarrayImpl_expected_values_.push(value);
  }

  void WriteNestedSubarrayImpl (yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) override {
    if (WriteNestedSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNestedSubarrayImpl");
    }
    if (WriteNestedSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNestedSubarrayImpl");
    }
    WriteNestedSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>>> WriteNestedSubarrayImpl_expected_values_;

  void ExpectWriteNestedSubarrayImpl (yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) {
    WriteNestedSubarrayImpl_expected_values_.push(value);
  }

  void WriteDynamicWithFixedVectorSubarrayImpl (yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) override {
    if (WriteDynamicWithFixedVectorSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDynamicWithFixedVectorSubarrayImpl");
    }
    if (WriteDynamicWithFixedVectorSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDynamicWithFixedVectorSubarrayImpl");
    }
    WriteDynamicWithFixedVectorSubarrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<std::array<int32_t, 3>>> WriteDynamicWithFixedVectorSubarrayImpl_expected_values_;

  void ExpectWriteDynamicWithFixedVectorSubarrayImpl (yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) {
    WriteDynamicWithFixedVectorSubarrayImpl_expected_values_.push(value);
  }

  void WriteGenericSubarrayImpl (test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) override {
    if (WriteGenericSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteGenericSubarrayImpl");
    }
    if (WriteGenericSubarrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteGenericSubarrayImpl");
    }
    WriteGenericSubarrayImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<yardl::FixedNDArray<int32_t, 3>>> WriteGenericSubarrayImpl_expected_values_;

  void ExpectWriteGenericSubarrayImpl (test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) {
    WriteGenericSubarrayImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteDynamicWithFixedIntSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDynamicWithFixedIntSubarrayImpl was not received");
    }
    if (!WriteDynamicWithFixedFloatSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDynamicWithFixedFloatSubarrayImpl was not received");
    }
    if (!WriteKnownDimCountWithFixedIntSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteKnownDimCountWithFixedIntSubarrayImpl was not received");
    }
    if (!WriteKnownDimCountWithFixedFloatSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteKnownDimCountWithFixedFloatSubarrayImpl was not received");
    }
    if (!WriteFixedWithFixedIntSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedWithFixedIntSubarrayImpl was not received");
    }
    if (!WriteFixedWithFixedFloatSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFixedWithFixedFloatSubarrayImpl was not received");
    }
    if (!WriteNestedSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNestedSubarrayImpl was not received");
    }
    if (!WriteDynamicWithFixedVectorSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDynamicWithFixedVectorSubarrayImpl was not received");
    }
    if (!WriteGenericSubarrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteGenericSubarrayImpl was not received");
    }
  }
};

class TestSubarraysWriterBase : public SubarraysWriterBase {
  public:
  TestSubarraysWriterBase(std::unique_ptr<test_model::SubarraysWriterBase> writer, std::function<std::unique_ptr<SubarraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestSubarraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestSubarraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) override {
    writer_->WriteDynamicWithFixedIntSubarray(value);
    mock_writer_.ExpectWriteDynamicWithFixedIntSubarrayImpl(value);
  }

  void WriteDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) override {
    writer_->WriteDynamicWithFixedFloatSubarray(value);
    mock_writer_.ExpectWriteDynamicWithFixedFloatSubarrayImpl(value);
  }

  void WriteKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) override {
    writer_->WriteKnownDimCountWithFixedIntSubarray(value);
    mock_writer_.ExpectWriteKnownDimCountWithFixedIntSubarrayImpl(value);
  }

  void WriteKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) override {
    writer_->WriteKnownDimCountWithFixedFloatSubarray(value);
    mock_writer_.ExpectWriteKnownDimCountWithFixedFloatSubarrayImpl(value);
  }

  void WriteFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) override {
    writer_->WriteFixedWithFixedIntSubarray(value);
    mock_writer_.ExpectWriteFixedWithFixedIntSubarrayImpl(value);
  }

  void WriteFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) override {
    writer_->WriteFixedWithFixedFloatSubarray(value);
    mock_writer_.ExpectWriteFixedWithFixedFloatSubarrayImpl(value);
  }

  void WriteNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) override {
    writer_->WriteNestedSubarray(value);
    mock_writer_.ExpectWriteNestedSubarrayImpl(value);
  }

  void WriteDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) override {
    writer_->WriteDynamicWithFixedVectorSubarray(value);
    mock_writer_.ExpectWriteDynamicWithFixedVectorSubarrayImpl(value);
  }

  void WriteGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) override {
    writer_->WriteGenericSubarray(value);
    mock_writer_.ExpectWriteGenericSubarrayImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<SubarraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::SubarraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::SubarraysReaderBase>()> create_reader_;
  MockSubarraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockSubarraysInRecordsWriter : public SubarraysInRecordsWriterBase {
  public:
  void WriteWithFixedSubarraysImpl (yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) override {
    if (WriteWithFixedSubarraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteWithFixedSubarraysImpl");
    }
    if (WriteWithFixedSubarraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteWithFixedSubarraysImpl");
    }
    WriteWithFixedSubarraysImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<test_model::RecordWithFixedCollections>> WriteWithFixedSubarraysImpl_expected_values_;

  void ExpectWriteWithFixedSubarraysImpl (yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) {
    WriteWithFixedSubarraysImpl_expected_values_.push(value);
  }

  void WriteWithVlenSubarraysImpl (yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) override {
    if (WriteWithVlenSubarraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteWithVlenSubarraysImpl");
    }
    if (WriteWithVlenSubarraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteWithVlenSubarraysImpl");
    }
    WriteWithVlenSubarraysImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<test_model::RecordWithVlenCollections>> WriteWithVlenSubarraysImpl_expected_values_;

  void ExpectWriteWithVlenSubarraysImpl (yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) {
    WriteWithVlenSubarraysImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteWithFixedSubarraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteWithFixedSubarraysImpl was not received");
    }
    if (!WriteWithVlenSubarraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteWithVlenSubarraysImpl was not received");
    }
  }
};

class TestSubarraysInRecordsWriterBase : public SubarraysInRecordsWriterBase {
  public:
  TestSubarraysInRecordsWriterBase(std::unique_ptr<test_model::SubarraysInRecordsWriterBase> writer, std::function<std::unique_ptr<SubarraysInRecordsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestSubarraysInRecordsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestSubarraysInRecordsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) override {
    writer_->WriteWithFixedSubarrays(value);
    mock_writer_.ExpectWriteWithFixedSubarraysImpl(value);
  }

  void WriteWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) override {
    writer_->WriteWithVlenSubarrays(value);
    mock_writer_.ExpectWriteWithVlenSubarraysImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<SubarraysInRecordsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::SubarraysInRecordsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::SubarraysInRecordsReaderBase>()> create_reader_;
  MockSubarraysInRecordsWriter mock_writer_;
  bool close_called_ = false;
};

class MockNDArraysWriter : public NDArraysWriterBase {
  public:
  void WriteIntsImpl (yardl::NDArray<int32_t, 2> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<int32_t, 2>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::NDArray<int32_t, 2> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 2> const& value) override {
    if (WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSimpleRecordArrayImpl");
    }
    if (WriteSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSimpleRecordArrayImpl");
    }
    WriteSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::SimpleRecord, 2>> WriteSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 2> const& value) {
    WriteSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 2> const& value) override {
    if (WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensArrayImpl");
    }
    if (WriteRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensArrayImpl");
    }
    WriteRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::RecordWithVlens, 2>> WriteRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 2> const& value) {
    WriteRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithNDArraysImpl (test_model::RecordWithNDArrays const& value) override {
    if (WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithNDArraysImpl");
    }
    if (WriteRecordWithNDArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithNDArraysImpl");
    }
    WriteRecordWithNDArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithNDArrays> WriteRecordWithNDArraysImpl_expected_values_;

  void ExpectWriteRecordWithNDArraysImpl (test_model::RecordWithNDArrays const& value) {
    WriteRecordWithNDArraysImpl_expected_values_.push(value);
  }

  void WriteNamedArrayImpl (test_model::NamedNDArray const& value) override {
    if (WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNamedArrayImpl");
    }
    if (WriteNamedArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNamedArrayImpl");
    }
    WriteNamedArrayImpl_expected_values_.pop();
  }

  std::queue<test_model::NamedNDArray> WriteNamedArrayImpl_expected_values_;

  void ExpectWriteNamedArrayImpl (test_model::NamedNDArray const& value) {
    WriteNamedArrayImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSimpleRecordArrayImpl was not received");
    }
    if (!WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithNDArraysImpl was not received");
    }
    if (!WriteNamedArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNamedArrayImpl was not received");
    }
  }
};

class TestNDArraysWriterBase : public NDArraysWriterBase {
  public:
  TestNDArraysWriterBase(std::unique_ptr<test_model::NDArraysWriterBase> writer, std::function<std::unique_ptr<NDArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestNDArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestNDArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::NDArray<int32_t, 2> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2> const& value) override {
    writer_->WriteSimpleRecordArray(value);
    mock_writer_.ExpectWriteSimpleRecordArrayImpl(value);
  }

  void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) override {
    writer_->WriteRecordWithVlensArray(value);
    mock_writer_.ExpectWriteRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArrays const& value) override {
    writer_->WriteRecordWithNDArrays(value);
    mock_writer_.ExpectWriteRecordWithNDArraysImpl(value);
  }

  void WriteNamedArrayImpl(test_model::NamedNDArray const& value) override {
    writer_->WriteNamedArray(value);
    mock_writer_.ExpectWriteNamedArrayImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<NDArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::NDArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::NDArraysReaderBase>()> create_reader_;
  MockNDArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockNDArraysSingleDimensionWriter : public NDArraysSingleDimensionWriterBase {
  public:
  void WriteIntsImpl (yardl::NDArray<int32_t, 1> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<int32_t, 1>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::NDArray<int32_t, 1> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 1> const& value) override {
    if (WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSimpleRecordArrayImpl");
    }
    if (WriteSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSimpleRecordArrayImpl");
    }
    WriteSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::SimpleRecord, 1>> WriteSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteSimpleRecordArrayImpl (yardl::NDArray<test_model::SimpleRecord, 1> const& value) {
    WriteSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 1> const& value) override {
    if (WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensArrayImpl");
    }
    if (WriteRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensArrayImpl");
    }
    WriteRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<test_model::RecordWithVlens, 1>> WriteRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteRecordWithVlensArrayImpl (yardl::NDArray<test_model::RecordWithVlens, 1> const& value) {
    WriteRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithNDArraysImpl (test_model::RecordWithNDArraysSingleDimension const& value) override {
    if (WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithNDArraysImpl");
    }
    if (WriteRecordWithNDArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithNDArraysImpl");
    }
    WriteRecordWithNDArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithNDArraysSingleDimension> WriteRecordWithNDArraysImpl_expected_values_;

  void ExpectWriteRecordWithNDArraysImpl (test_model::RecordWithNDArraysSingleDimension const& value) {
    WriteRecordWithNDArraysImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSimpleRecordArrayImpl was not received");
    }
    if (!WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithNDArraysImpl was not received");
    }
  }
};

class TestNDArraysSingleDimensionWriterBase : public NDArraysSingleDimensionWriterBase {
  public:
  TestNDArraysSingleDimensionWriterBase(std::unique_ptr<test_model::NDArraysSingleDimensionWriterBase> writer, std::function<std::unique_ptr<NDArraysSingleDimensionReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestNDArraysSingleDimensionWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestNDArraysSingleDimensionWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::NDArray<int32_t, 1> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1> const& value) override {
    writer_->WriteSimpleRecordArray(value);
    mock_writer_.ExpectWriteSimpleRecordArrayImpl(value);
  }

  void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) override {
    writer_->WriteRecordWithVlensArray(value);
    mock_writer_.ExpectWriteRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension const& value) override {
    writer_->WriteRecordWithNDArrays(value);
    mock_writer_.ExpectWriteRecordWithNDArraysImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<NDArraysSingleDimensionReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::NDArraysSingleDimensionWriterBase> writer_;
  std::function<std::unique_ptr<test_model::NDArraysSingleDimensionReaderBase>()> create_reader_;
  MockNDArraysSingleDimensionWriter mock_writer_;
  bool close_called_ = false;
};

class MockDynamicNDArraysWriter : public DynamicNDArraysWriterBase {
  public:
  void WriteIntsImpl (yardl::DynamicNDArray<int32_t> const& value) override {
    if (WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntsImpl");
    }
    if (WriteIntsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntsImpl");
    }
    WriteIntsImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<int32_t>> WriteIntsImpl_expected_values_;

  void ExpectWriteIntsImpl (yardl::DynamicNDArray<int32_t> const& value) {
    WriteIntsImpl_expected_values_.push(value);
  }

  void WriteSimpleRecordArrayImpl (yardl::DynamicNDArray<test_model::SimpleRecord> const& value) override {
    if (WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSimpleRecordArrayImpl");
    }
    if (WriteSimpleRecordArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSimpleRecordArrayImpl");
    }
    WriteSimpleRecordArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<test_model::SimpleRecord>> WriteSimpleRecordArrayImpl_expected_values_;

  void ExpectWriteSimpleRecordArrayImpl (yardl::DynamicNDArray<test_model::SimpleRecord> const& value) {
    WriteSimpleRecordArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithVlensArrayImpl (yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) override {
    if (WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithVlensArrayImpl");
    }
    if (WriteRecordWithVlensArrayImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithVlensArrayImpl");
    }
    WriteRecordWithVlensArrayImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<test_model::RecordWithVlens>> WriteRecordWithVlensArrayImpl_expected_values_;

  void ExpectWriteRecordWithVlensArrayImpl (yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) {
    WriteRecordWithVlensArrayImpl_expected_values_.push(value);
  }

  void WriteRecordWithDynamicNDArraysImpl (test_model::RecordWithDynamicNDArrays const& value) override {
    if (WriteRecordWithDynamicNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithDynamicNDArraysImpl");
    }
    if (WriteRecordWithDynamicNDArraysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithDynamicNDArraysImpl");
    }
    WriteRecordWithDynamicNDArraysImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithDynamicNDArrays> WriteRecordWithDynamicNDArraysImpl_expected_values_;

  void ExpectWriteRecordWithDynamicNDArraysImpl (test_model::RecordWithDynamicNDArrays const& value) {
    WriteRecordWithDynamicNDArraysImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntsImpl was not received");
    }
    if (!WriteSimpleRecordArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSimpleRecordArrayImpl was not received");
    }
    if (!WriteRecordWithVlensArrayImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithVlensArrayImpl was not received");
    }
    if (!WriteRecordWithDynamicNDArraysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithDynamicNDArraysImpl was not received");
    }
  }
};

class TestDynamicNDArraysWriterBase : public DynamicNDArraysWriterBase {
  public:
  TestDynamicNDArraysWriterBase(std::unique_ptr<test_model::DynamicNDArraysWriterBase> writer, std::function<std::unique_ptr<DynamicNDArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestDynamicNDArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestDynamicNDArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntsImpl(yardl::DynamicNDArray<int32_t> const& value) override {
    writer_->WriteInts(value);
    mock_writer_.ExpectWriteIntsImpl(value);
  }

  void WriteSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) override {
    writer_->WriteSimpleRecordArray(value);
    mock_writer_.ExpectWriteSimpleRecordArrayImpl(value);
  }

  void WriteRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) override {
    writer_->WriteRecordWithVlensArray(value);
    mock_writer_.ExpectWriteRecordWithVlensArrayImpl(value);
  }

  void WriteRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays const& value) override {
    writer_->WriteRecordWithDynamicNDArrays(value);
    mock_writer_.ExpectWriteRecordWithDynamicNDArraysImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<DynamicNDArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::DynamicNDArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::DynamicNDArraysReaderBase>()> create_reader_;
  MockDynamicNDArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockMultiDArraysWriter : public MultiDArraysWriterBase {
  public:
  void WriteImagesImpl (yardl::NDArray<float, 4> const& value) override {
    if (WriteImagesImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteImagesImpl");
    }
    if (WriteImagesImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteImagesImpl");
    }
    WriteImagesImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<float, 4>> WriteImagesImpl_expected_values_;

  void ExpectWriteImagesImpl (yardl::NDArray<float, 4> const& value) {
    WriteImagesImpl_expected_values_.push(value);
  }

  void EndImagesImpl () override {
    if (--EndImagesImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndImagesImpl");
    }
  }

  int EndImagesImpl_expected_call_count_ = 0;

  void ExpectEndImagesImpl () {
    EndImagesImpl_expected_call_count_++;
  }

  void WriteFramesImpl (yardl::FixedNDArray<float, 1, 1, 64, 32> const& value) override {
    if (WriteFramesImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFramesImpl");
    }
    if (WriteFramesImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFramesImpl");
    }
    WriteFramesImpl_expected_values_.pop();
  }

  std::queue<yardl::FixedNDArray<float, 1, 1, 64, 32>> WriteFramesImpl_expected_values_;

  void ExpectWriteFramesImpl (yardl::FixedNDArray<float, 1, 1, 64, 32> const& value) {
    WriteFramesImpl_expected_values_.push(value);
  }

  void EndFramesImpl () override {
    if (--EndFramesImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFramesImpl");
    }
  }

  int EndFramesImpl_expected_call_count_ = 0;

  void ExpectEndFramesImpl () {
    EndFramesImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteImagesImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteImagesImpl was not received");
    }
    if (EndImagesImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndImagesImpl was not received");
    }
    if (!WriteFramesImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFramesImpl was not received");
    }
    if (EndFramesImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFramesImpl was not received");
    }
  }
};

class TestMultiDArraysWriterBase : public MultiDArraysWriterBase {
  public:
  TestMultiDArraysWriterBase(std::unique_ptr<test_model::MultiDArraysWriterBase> writer, std::function<std::unique_ptr<MultiDArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestMultiDArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestMultiDArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteImagesImpl(yardl::NDArray<float, 4> const& value) override {
    writer_->WriteImages(value);
    mock_writer_.ExpectWriteImagesImpl(value);
  }

  void WriteImagesImpl(std::vector<yardl::NDArray<float, 4>> const& values) override {
    writer_->WriteImages(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteImagesImpl(v);
    }
  }

  void EndImagesImpl() override {
    writer_->EndImages();
    mock_writer_.ExpectEndImagesImpl();
  }

  void WriteFramesImpl(yardl::FixedNDArray<float, 1, 1, 64, 32> const& value) override {
    writer_->WriteFrames(value);
    mock_writer_.ExpectWriteFramesImpl(value);
  }

  void WriteFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> const& values) override {
    writer_->WriteFrames(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFramesImpl(v);
    }
  }

  void EndFramesImpl() override {
    writer_->EndFrames();
    mock_writer_.ExpectEndFramesImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<MultiDArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::MultiDArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::MultiDArraysReaderBase>()> create_reader_;
  MockMultiDArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockComplexArraysWriter : public ComplexArraysWriterBase {
  public:
  void WriteFloatsImpl (yardl::DynamicNDArray<std::complex<float>> const& value) override {
    if (WriteFloatsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatsImpl");
    }
    if (WriteFloatsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatsImpl");
    }
    WriteFloatsImpl_expected_values_.pop();
  }

  std::queue<yardl::DynamicNDArray<std::complex<float>>> WriteFloatsImpl_expected_values_;

  void ExpectWriteFloatsImpl (yardl::DynamicNDArray<std::complex<float>> const& value) {
    WriteFloatsImpl_expected_values_.push(value);
  }

  void WriteDoublesImpl (yardl::NDArray<std::complex<double>, 2> const& value) override {
    if (WriteDoublesImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDoublesImpl");
    }
    if (WriteDoublesImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDoublesImpl");
    }
    WriteDoublesImpl_expected_values_.pop();
  }

  std::queue<yardl::NDArray<std::complex<double>, 2>> WriteDoublesImpl_expected_values_;

  void ExpectWriteDoublesImpl (yardl::NDArray<std::complex<double>, 2> const& value) {
    WriteDoublesImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteFloatsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatsImpl was not received");
    }
    if (!WriteDoublesImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDoublesImpl was not received");
    }
  }
};

class TestComplexArraysWriterBase : public ComplexArraysWriterBase {
  public:
  TestComplexArraysWriterBase(std::unique_ptr<test_model::ComplexArraysWriterBase> writer, std::function<std::unique_ptr<ComplexArraysReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestComplexArraysWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestComplexArraysWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloatsImpl(yardl::DynamicNDArray<std::complex<float>> const& value) override {
    writer_->WriteFloats(value);
    mock_writer_.ExpectWriteFloatsImpl(value);
  }

  void WriteDoublesImpl(yardl::NDArray<std::complex<double>, 2> const& value) override {
    writer_->WriteDoubles(value);
    mock_writer_.ExpectWriteDoublesImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ComplexArraysReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ComplexArraysWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ComplexArraysReaderBase>()> create_reader_;
  MockComplexArraysWriter mock_writer_;
  bool close_called_ = false;
};

class MockMapsWriter : public MapsWriterBase {
  public:
  void WriteStringToIntImpl (std::unordered_map<std::string, int32_t> const& value) override {
    if (WriteStringToIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStringToIntImpl");
    }
    if (WriteStringToIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStringToIntImpl");
    }
    WriteStringToIntImpl_expected_values_.pop();
  }

  std::queue<std::unordered_map<std::string, int32_t>> WriteStringToIntImpl_expected_values_;

  void ExpectWriteStringToIntImpl (std::unordered_map<std::string, int32_t> const& value) {
    WriteStringToIntImpl_expected_values_.push(value);
  }

  void WriteIntToStringImpl (std::unordered_map<int32_t, std::string> const& value) override {
    if (WriteIntToStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntToStringImpl");
    }
    if (WriteIntToStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntToStringImpl");
    }
    WriteIntToStringImpl_expected_values_.pop();
  }

  std::queue<std::unordered_map<int32_t, std::string>> WriteIntToStringImpl_expected_values_;

  void ExpectWriteIntToStringImpl (std::unordered_map<int32_t, std::string> const& value) {
    WriteIntToStringImpl_expected_values_.push(value);
  }

  void WriteStringToUnionImpl (std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) override {
    if (WriteStringToUnionImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStringToUnionImpl");
    }
    if (WriteStringToUnionImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStringToUnionImpl");
    }
    WriteStringToUnionImpl_expected_values_.pop();
  }

  std::queue<std::unordered_map<std::string, std::variant<std::string, int32_t>>> WriteStringToUnionImpl_expected_values_;

  void ExpectWriteStringToUnionImpl (std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) {
    WriteStringToUnionImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericImpl (basic_types::AliasedMap<std::string, int32_t> const& value) override {
    if (WriteAliasedGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericImpl");
    }
    if (WriteAliasedGenericImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericImpl");
    }
    WriteAliasedGenericImpl_expected_values_.pop();
  }

  std::queue<basic_types::AliasedMap<std::string, int32_t>> WriteAliasedGenericImpl_expected_values_;

  void ExpectWriteAliasedGenericImpl (basic_types::AliasedMap<std::string, int32_t> const& value) {
    WriteAliasedGenericImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteStringToIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStringToIntImpl was not received");
    }
    if (!WriteIntToStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntToStringImpl was not received");
    }
    if (!WriteStringToUnionImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStringToUnionImpl was not received");
    }
    if (!WriteAliasedGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericImpl was not received");
    }
  }
};

class TestMapsWriterBase : public MapsWriterBase {
  public:
  TestMapsWriterBase(std::unique_ptr<test_model::MapsWriterBase> writer, std::function<std::unique_ptr<MapsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestMapsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestMapsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteStringToIntImpl(std::unordered_map<std::string, int32_t> const& value) override {
    writer_->WriteStringToInt(value);
    mock_writer_.ExpectWriteStringToIntImpl(value);
  }

  void WriteIntToStringImpl(std::unordered_map<int32_t, std::string> const& value) override {
    writer_->WriteIntToString(value);
    mock_writer_.ExpectWriteIntToStringImpl(value);
  }

  void WriteStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) override {
    writer_->WriteStringToUnion(value);
    mock_writer_.ExpectWriteStringToUnionImpl(value);
  }

  void WriteAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t> const& value) override {
    writer_->WriteAliasedGeneric(value);
    mock_writer_.ExpectWriteAliasedGenericImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<MapsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::MapsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::MapsReaderBase>()> create_reader_;
  MockMapsWriter mock_writer_;
  bool close_called_ = false;
};

class MockUnionsWriter : public UnionsWriterBase {
  public:
  void WriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrSimpleRecordImpl");
    }
    if (WriteIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrSimpleRecordImpl");
    }
    WriteIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<int32_t, test_model::SimpleRecord>> WriteIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) {
    WriteIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void WriteIntOrRecordWithVlensImpl (std::variant<int32_t, test_model::RecordWithVlens> const& value) override {
    if (WriteIntOrRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrRecordWithVlensImpl");
    }
    if (WriteIntOrRecordWithVlensImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrRecordWithVlensImpl");
    }
    WriteIntOrRecordWithVlensImpl_expected_values_.pop();
  }

  std::queue<std::variant<int32_t, test_model::RecordWithVlens>> WriteIntOrRecordWithVlensImpl_expected_values_;

  void ExpectWriteIntOrRecordWithVlensImpl (std::variant<int32_t, test_model::RecordWithVlens> const& value) {
    WriteIntOrRecordWithVlensImpl_expected_values_.push(value);
  }

  void WriteMonosotateOrIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteMonosotateOrIntOrSimpleRecordImpl");
    }
    if (WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteMonosotateOrIntOrSimpleRecordImpl");
    }
    WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteMonosotateOrIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
    WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void WriteRecordWithUnionsImpl (basic_types::RecordWithUnions const& value) override {
    if (WriteRecordWithUnionsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithUnionsImpl");
    }
    if (WriteRecordWithUnionsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithUnionsImpl");
    }
    WriteRecordWithUnionsImpl_expected_values_.pop();
  }

  std::queue<basic_types::RecordWithUnions> WriteRecordWithUnionsImpl_expected_values_;

  void ExpectWriteRecordWithUnionsImpl (basic_types::RecordWithUnions const& value) {
    WriteRecordWithUnionsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrSimpleRecordImpl was not received");
    }
    if (!WriteIntOrRecordWithVlensImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrRecordWithVlensImpl was not received");
    }
    if (!WriteMonosotateOrIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteMonosotateOrIntOrSimpleRecordImpl was not received");
    }
    if (!WriteRecordWithUnionsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithUnionsImpl was not received");
    }
  }
};

class TestUnionsWriterBase : public UnionsWriterBase {
  public:
  TestUnionsWriterBase(std::unique_ptr<test_model::UnionsWriterBase> writer, std::function<std::unique_ptr<UnionsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestUnionsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestUnionsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteIntOrSimpleRecordImpl(value);
  }

  void WriteIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens> const& value) override {
    writer_->WriteIntOrRecordWithVlens(value);
    mock_writer_.ExpectWriteIntOrRecordWithVlensImpl(value);
  }

  void WriteMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteMonosotateOrIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteMonosotateOrIntOrSimpleRecordImpl(value);
  }

  void WriteRecordWithUnionsImpl(basic_types::RecordWithUnions const& value) override {
    writer_->WriteRecordWithUnions(value);
    mock_writer_.ExpectWriteRecordWithUnionsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<UnionsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::UnionsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::UnionsReaderBase>()> create_reader_;
  MockUnionsWriter mock_writer_;
  bool close_called_ = false;
};

class MockStreamsOfUnionsWriter : public StreamsOfUnionsWriterBase {
  public:
  void WriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrSimpleRecordImpl");
    }
    if (WriteIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrSimpleRecordImpl");
    }
    WriteIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<int32_t, test_model::SimpleRecord>> WriteIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteIntOrSimpleRecordImpl (std::variant<int32_t, test_model::SimpleRecord> const& value) {
    WriteIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndIntOrSimpleRecordImpl () override {
    if (--EndIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntOrSimpleRecordImpl");
    }
  }

  int EndIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndIntOrSimpleRecordImpl () {
    EndIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void WriteNullableIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNullableIntOrSimpleRecordImpl");
    }
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNullableIntOrSimpleRecordImpl");
    }
    WriteNullableIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> WriteNullableIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteNullableIntOrSimpleRecordImpl (std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
    WriteNullableIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndNullableIntOrSimpleRecordImpl () override {
    if (--EndNullableIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndNullableIntOrSimpleRecordImpl");
    }
  }

  int EndNullableIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndNullableIntOrSimpleRecordImpl () {
    EndNullableIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrSimpleRecordImpl was not received");
    }
    if (EndIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntOrSimpleRecordImpl was not received");
    }
    if (!WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNullableIntOrSimpleRecordImpl was not received");
    }
    if (EndNullableIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndNullableIntOrSimpleRecordImpl was not received");
    }
  }
};

class TestStreamsOfUnionsWriterBase : public StreamsOfUnionsWriterBase {
  public:
  TestStreamsOfUnionsWriterBase(std::unique_ptr<test_model::StreamsOfUnionsWriterBase> writer, std::function<std::unique_ptr<StreamsOfUnionsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStreamsOfUnionsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStreamsOfUnionsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteIntOrSimpleRecordImpl(value);
  }

  void WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) override {
    writer_->WriteIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntOrSimpleRecordImpl(v);
    }
  }

  void EndIntOrSimpleRecordImpl() override {
    writer_->EndIntOrSimpleRecord();
    mock_writer_.ExpectEndIntOrSimpleRecordImpl();
  }

  void WriteNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override {
    writer_->WriteNullableIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(value);
  }

  void WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) override {
    writer_->WriteNullableIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(v);
    }
  }

  void EndNullableIntOrSimpleRecordImpl() override {
    writer_->EndNullableIntOrSimpleRecord();
    mock_writer_.ExpectEndNullableIntOrSimpleRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StreamsOfUnionsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StreamsOfUnionsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StreamsOfUnionsReaderBase>()> create_reader_;
  MockStreamsOfUnionsWriter mock_writer_;
  bool close_called_ = false;
};

class MockEnumsWriter : public EnumsWriterBase {
  public:
  void WriteSingleImpl (test_model::Fruits const& value) override {
    if (WriteSingleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSingleImpl");
    }
    if (WriteSingleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSingleImpl");
    }
    WriteSingleImpl_expected_values_.pop();
  }

  std::queue<test_model::Fruits> WriteSingleImpl_expected_values_;

  void ExpectWriteSingleImpl (test_model::Fruits const& value) {
    WriteSingleImpl_expected_values_.push(value);
  }

  void WriteVecImpl (std::vector<test_model::Fruits> const& value) override {
    if (WriteVecImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteVecImpl");
    }
    if (WriteVecImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteVecImpl");
    }
    WriteVecImpl_expected_values_.pop();
  }

  std::queue<std::vector<test_model::Fruits>> WriteVecImpl_expected_values_;

  void ExpectWriteVecImpl (std::vector<test_model::Fruits> const& value) {
    WriteVecImpl_expected_values_.push(value);
  }

  void WriteSizeImpl (test_model::SizeBasedEnum const& value) override {
    if (WriteSizeImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteSizeImpl");
    }
    if (WriteSizeImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteSizeImpl");
    }
    WriteSizeImpl_expected_values_.pop();
  }

  std::queue<test_model::SizeBasedEnum> WriteSizeImpl_expected_values_;

  void ExpectWriteSizeImpl (test_model::SizeBasedEnum const& value) {
    WriteSizeImpl_expected_values_.push(value);
  }

  void WriteRecImpl (test_model::RecordWithEnums const& value) override {
    if (WriteRecImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecImpl");
    }
    if (WriteRecImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecImpl");
    }
    WriteRecImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithEnums> WriteRecImpl_expected_values_;

  void ExpectWriteRecImpl (test_model::RecordWithEnums const& value) {
    WriteRecImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteSingleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSingleImpl was not received");
    }
    if (!WriteVecImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteVecImpl was not received");
    }
    if (!WriteSizeImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteSizeImpl was not received");
    }
    if (!WriteRecImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecImpl was not received");
    }
  }
};

class TestEnumsWriterBase : public EnumsWriterBase {
  public:
  TestEnumsWriterBase(std::unique_ptr<test_model::EnumsWriterBase> writer, std::function<std::unique_ptr<EnumsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestEnumsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestEnumsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteSingleImpl(test_model::Fruits const& value) override {
    writer_->WriteSingle(value);
    mock_writer_.ExpectWriteSingleImpl(value);
  }

  void WriteVecImpl(std::vector<test_model::Fruits> const& value) override {
    writer_->WriteVec(value);
    mock_writer_.ExpectWriteVecImpl(value);
  }

  void WriteSizeImpl(test_model::SizeBasedEnum const& value) override {
    writer_->WriteSize(value);
    mock_writer_.ExpectWriteSizeImpl(value);
  }

  void WriteRecImpl(test_model::RecordWithEnums const& value) override {
    writer_->WriteRec(value);
    mock_writer_.ExpectWriteRecImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<EnumsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::EnumsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::EnumsReaderBase>()> create_reader_;
  MockEnumsWriter mock_writer_;
  bool close_called_ = false;
};

class MockFlagsWriter : public FlagsWriterBase {
  public:
  void WriteDaysImpl (test_model::DaysOfWeek const& value) override {
    if (WriteDaysImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteDaysImpl");
    }
    if (WriteDaysImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteDaysImpl");
    }
    WriteDaysImpl_expected_values_.pop();
  }

  std::queue<test_model::DaysOfWeek> WriteDaysImpl_expected_values_;

  void ExpectWriteDaysImpl (test_model::DaysOfWeek const& value) {
    WriteDaysImpl_expected_values_.push(value);
  }

  void EndDaysImpl () override {
    if (--EndDaysImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndDaysImpl");
    }
  }

  int EndDaysImpl_expected_call_count_ = 0;

  void ExpectEndDaysImpl () {
    EndDaysImpl_expected_call_count_++;
  }

  void WriteFormatsImpl (test_model::TextFormat const& value) override {
    if (WriteFormatsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFormatsImpl");
    }
    if (WriteFormatsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFormatsImpl");
    }
    WriteFormatsImpl_expected_values_.pop();
  }

  std::queue<test_model::TextFormat> WriteFormatsImpl_expected_values_;

  void ExpectWriteFormatsImpl (test_model::TextFormat const& value) {
    WriteFormatsImpl_expected_values_.push(value);
  }

  void EndFormatsImpl () override {
    if (--EndFormatsImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndFormatsImpl");
    }
  }

  int EndFormatsImpl_expected_call_count_ = 0;

  void ExpectEndFormatsImpl () {
    EndFormatsImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteDaysImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteDaysImpl was not received");
    }
    if (EndDaysImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndDaysImpl was not received");
    }
    if (!WriteFormatsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFormatsImpl was not received");
    }
    if (EndFormatsImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndFormatsImpl was not received");
    }
  }
};

class TestFlagsWriterBase : public FlagsWriterBase {
  public:
  TestFlagsWriterBase(std::unique_ptr<test_model::FlagsWriterBase> writer, std::function<std::unique_ptr<FlagsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestFlagsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestFlagsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteDaysImpl(test_model::DaysOfWeek const& value) override {
    writer_->WriteDays(value);
    mock_writer_.ExpectWriteDaysImpl(value);
  }

  void WriteDaysImpl(std::vector<test_model::DaysOfWeek> const& values) override {
    writer_->WriteDays(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteDaysImpl(v);
    }
  }

  void EndDaysImpl() override {
    writer_->EndDays();
    mock_writer_.ExpectEndDaysImpl();
  }

  void WriteFormatsImpl(test_model::TextFormat const& value) override {
    writer_->WriteFormats(value);
    mock_writer_.ExpectWriteFormatsImpl(value);
  }

  void WriteFormatsImpl(std::vector<test_model::TextFormat> const& values) override {
    writer_->WriteFormats(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteFormatsImpl(v);
    }
  }

  void EndFormatsImpl() override {
    writer_->EndFormats();
    mock_writer_.ExpectEndFormatsImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<FlagsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::FlagsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::FlagsReaderBase>()> create_reader_;
  MockFlagsWriter mock_writer_;
  bool close_called_ = false;
};

class MockStateTestWriter : public StateTestWriterBase {
  public:
  void WriteAnIntImpl (int32_t const& value) override {
    if (WriteAnIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAnIntImpl");
    }
    if (WriteAnIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAnIntImpl");
    }
    WriteAnIntImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteAnIntImpl_expected_values_;

  void ExpectWriteAnIntImpl (int32_t const& value) {
    WriteAnIntImpl_expected_values_.push(value);
  }

  void WriteAStreamImpl (int32_t const& value) override {
    if (WriteAStreamImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAStreamImpl");
    }
    if (WriteAStreamImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAStreamImpl");
    }
    WriteAStreamImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteAStreamImpl_expected_values_;

  void ExpectWriteAStreamImpl (int32_t const& value) {
    WriteAStreamImpl_expected_values_.push(value);
  }

  void EndAStreamImpl () override {
    if (--EndAStreamImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndAStreamImpl");
    }
  }

  int EndAStreamImpl_expected_call_count_ = 0;

  void ExpectEndAStreamImpl () {
    EndAStreamImpl_expected_call_count_++;
  }

  void WriteAnotherIntImpl (int32_t const& value) override {
    if (WriteAnotherIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAnotherIntImpl");
    }
    if (WriteAnotherIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAnotherIntImpl");
    }
    WriteAnotherIntImpl_expected_values_.pop();
  }

  std::queue<int32_t> WriteAnotherIntImpl_expected_values_;

  void ExpectWriteAnotherIntImpl (int32_t const& value) {
    WriteAnotherIntImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteAnIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAnIntImpl was not received");
    }
    if (!WriteAStreamImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAStreamImpl was not received");
    }
    if (EndAStreamImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndAStreamImpl was not received");
    }
    if (!WriteAnotherIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAnotherIntImpl was not received");
    }
  }
};

class TestStateTestWriterBase : public StateTestWriterBase {
  public:
  TestStateTestWriterBase(std::unique_ptr<test_model::StateTestWriterBase> writer, std::function<std::unique_ptr<StateTestReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStateTestWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStateTestWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteAnIntImpl(int32_t const& value) override {
    writer_->WriteAnInt(value);
    mock_writer_.ExpectWriteAnIntImpl(value);
  }

  void WriteAStreamImpl(int32_t const& value) override {
    writer_->WriteAStream(value);
    mock_writer_.ExpectWriteAStreamImpl(value);
  }

  void WriteAStreamImpl(std::vector<int32_t> const& values) override {
    writer_->WriteAStream(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteAStreamImpl(v);
    }
  }

  void EndAStreamImpl() override {
    writer_->EndAStream();
    mock_writer_.ExpectEndAStreamImpl();
  }

  void WriteAnotherIntImpl(int32_t const& value) override {
    writer_->WriteAnotherInt(value);
    mock_writer_.ExpectWriteAnotherIntImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StateTestReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StateTestWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StateTestReaderBase>()> create_reader_;
  MockStateTestWriter mock_writer_;
  bool close_called_ = false;
};

class MockSimpleGenericsWriter : public SimpleGenericsWriterBase {
  public:
  void WriteFloatImageImpl (image::FloatImage const& value) override {
    if (WriteFloatImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatImageImpl");
    }
    if (WriteFloatImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatImageImpl");
    }
    WriteFloatImageImpl_expected_values_.pop();
  }

  std::queue<image::FloatImage> WriteFloatImageImpl_expected_values_;

  void ExpectWriteFloatImageImpl (image::FloatImage const& value) {
    WriteFloatImageImpl_expected_values_.push(value);
  }

  void WriteIntImageImpl (image::IntImage const& value) override {
    if (WriteIntImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImageImpl");
    }
    if (WriteIntImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImageImpl");
    }
    WriteIntImageImpl_expected_values_.pop();
  }

  std::queue<image::IntImage> WriteIntImageImpl_expected_values_;

  void ExpectWriteIntImageImpl (image::IntImage const& value) {
    WriteIntImageImpl_expected_values_.push(value);
  }

  void WriteIntImageAlternateSyntaxImpl (test_model::Image<int32_t> const& value) override {
    if (WriteIntImageAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImageAlternateSyntaxImpl");
    }
    if (WriteIntImageAlternateSyntaxImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImageAlternateSyntaxImpl");
    }
    WriteIntImageAlternateSyntaxImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<int32_t>> WriteIntImageAlternateSyntaxImpl_expected_values_;

  void ExpectWriteIntImageAlternateSyntaxImpl (test_model::Image<int32_t> const& value) {
    WriteIntImageAlternateSyntaxImpl_expected_values_.push(value);
  }

  void WriteStringImageImpl (test_model::Image<std::string> const& value) override {
    if (WriteStringImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStringImageImpl");
    }
    if (WriteStringImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStringImageImpl");
    }
    WriteStringImageImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<std::string>> WriteStringImageImpl_expected_values_;

  void ExpectWriteStringImageImpl (test_model::Image<std::string> const& value) {
    WriteStringImageImpl_expected_values_.push(value);
  }

  void WriteIntFloatTupleImpl (tuples::Tuple<int32_t, float> const& value) override {
    if (WriteIntFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntFloatTupleImpl");
    }
    if (WriteIntFloatTupleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntFloatTupleImpl");
    }
    WriteIntFloatTupleImpl_expected_values_.pop();
  }

  std::queue<tuples::Tuple<int32_t, float>> WriteIntFloatTupleImpl_expected_values_;

  void ExpectWriteIntFloatTupleImpl (tuples::Tuple<int32_t, float> const& value) {
    WriteIntFloatTupleImpl_expected_values_.push(value);
  }

  void WriteFloatFloatTupleImpl (tuples::Tuple<float, float> const& value) override {
    if (WriteFloatFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatFloatTupleImpl");
    }
    if (WriteFloatFloatTupleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatFloatTupleImpl");
    }
    WriteFloatFloatTupleImpl_expected_values_.pop();
  }

  std::queue<tuples::Tuple<float, float>> WriteFloatFloatTupleImpl_expected_values_;

  void ExpectWriteFloatFloatTupleImpl (tuples::Tuple<float, float> const& value) {
    WriteFloatFloatTupleImpl_expected_values_.push(value);
  }

  void WriteIntFloatTupleAlternateSyntaxImpl (tuples::Tuple<int32_t, float> const& value) override {
    if (WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntFloatTupleAlternateSyntaxImpl");
    }
    if (WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntFloatTupleAlternateSyntaxImpl");
    }
    WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.pop();
  }

  std::queue<tuples::Tuple<int32_t, float>> WriteIntFloatTupleAlternateSyntaxImpl_expected_values_;

  void ExpectWriteIntFloatTupleAlternateSyntaxImpl (tuples::Tuple<int32_t, float> const& value) {
    WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.push(value);
  }

  void WriteIntStringTupleImpl (tuples::Tuple<int32_t, std::string> const& value) override {
    if (WriteIntStringTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntStringTupleImpl");
    }
    if (WriteIntStringTupleImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntStringTupleImpl");
    }
    WriteIntStringTupleImpl_expected_values_.pop();
  }

  std::queue<tuples::Tuple<int32_t, std::string>> WriteIntStringTupleImpl_expected_values_;

  void ExpectWriteIntStringTupleImpl (tuples::Tuple<int32_t, std::string> const& value) {
    WriteIntStringTupleImpl_expected_values_.push(value);
  }

  void WriteStreamOfTypeVariantsImpl (std::variant<image::FloatImage, test_model::Image<double>> const& value) override {
    if (WriteStreamOfTypeVariantsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStreamOfTypeVariantsImpl");
    }
    if (WriteStreamOfTypeVariantsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStreamOfTypeVariantsImpl");
    }
    WriteStreamOfTypeVariantsImpl_expected_values_.pop();
  }

  std::queue<std::variant<image::FloatImage, test_model::Image<double>>> WriteStreamOfTypeVariantsImpl_expected_values_;

  void ExpectWriteStreamOfTypeVariantsImpl (std::variant<image::FloatImage, test_model::Image<double>> const& value) {
    WriteStreamOfTypeVariantsImpl_expected_values_.push(value);
  }

  void EndStreamOfTypeVariantsImpl () override {
    if (--EndStreamOfTypeVariantsImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndStreamOfTypeVariantsImpl");
    }
  }

  int EndStreamOfTypeVariantsImpl_expected_call_count_ = 0;

  void ExpectEndStreamOfTypeVariantsImpl () {
    EndStreamOfTypeVariantsImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteFloatImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatImageImpl was not received");
    }
    if (!WriteIntImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImageImpl was not received");
    }
    if (!WriteIntImageAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImageAlternateSyntaxImpl was not received");
    }
    if (!WriteStringImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStringImageImpl was not received");
    }
    if (!WriteIntFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntFloatTupleImpl was not received");
    }
    if (!WriteFloatFloatTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatFloatTupleImpl was not received");
    }
    if (!WriteIntFloatTupleAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntFloatTupleAlternateSyntaxImpl was not received");
    }
    if (!WriteIntStringTupleImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntStringTupleImpl was not received");
    }
    if (!WriteStreamOfTypeVariantsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStreamOfTypeVariantsImpl was not received");
    }
    if (EndStreamOfTypeVariantsImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndStreamOfTypeVariantsImpl was not received");
    }
  }
};

class TestSimpleGenericsWriterBase : public SimpleGenericsWriterBase {
  public:
  TestSimpleGenericsWriterBase(std::unique_ptr<test_model::SimpleGenericsWriterBase> writer, std::function<std::unique_ptr<SimpleGenericsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestSimpleGenericsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestSimpleGenericsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloatImageImpl(image::FloatImage const& value) override {
    writer_->WriteFloatImage(value);
    mock_writer_.ExpectWriteFloatImageImpl(value);
  }

  void WriteIntImageImpl(image::IntImage const& value) override {
    writer_->WriteIntImage(value);
    mock_writer_.ExpectWriteIntImageImpl(value);
  }

  void WriteIntImageAlternateSyntaxImpl(test_model::Image<int32_t> const& value) override {
    writer_->WriteIntImageAlternateSyntax(value);
    mock_writer_.ExpectWriteIntImageAlternateSyntaxImpl(value);
  }

  void WriteStringImageImpl(test_model::Image<std::string> const& value) override {
    writer_->WriteStringImage(value);
    mock_writer_.ExpectWriteStringImageImpl(value);
  }

  void WriteIntFloatTupleImpl(tuples::Tuple<int32_t, float> const& value) override {
    writer_->WriteIntFloatTuple(value);
    mock_writer_.ExpectWriteIntFloatTupleImpl(value);
  }

  void WriteFloatFloatTupleImpl(tuples::Tuple<float, float> const& value) override {
    writer_->WriteFloatFloatTuple(value);
    mock_writer_.ExpectWriteFloatFloatTupleImpl(value);
  }

  void WriteIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float> const& value) override {
    writer_->WriteIntFloatTupleAlternateSyntax(value);
    mock_writer_.ExpectWriteIntFloatTupleAlternateSyntaxImpl(value);
  }

  void WriteIntStringTupleImpl(tuples::Tuple<int32_t, std::string> const& value) override {
    writer_->WriteIntStringTuple(value);
    mock_writer_.ExpectWriteIntStringTupleImpl(value);
  }

  void WriteStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>> const& value) override {
    writer_->WriteStreamOfTypeVariants(value);
    mock_writer_.ExpectWriteStreamOfTypeVariantsImpl(value);
  }

  void WriteStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>> const& values) override {
    writer_->WriteStreamOfTypeVariants(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteStreamOfTypeVariantsImpl(v);
    }
  }

  void EndStreamOfTypeVariantsImpl() override {
    writer_->EndStreamOfTypeVariants();
    mock_writer_.ExpectEndStreamOfTypeVariantsImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<SimpleGenericsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 10);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::SimpleGenericsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::SimpleGenericsReaderBase>()> create_reader_;
  MockSimpleGenericsWriter mock_writer_;
  bool close_called_ = false;
};

class MockAdvancedGenericsWriter : public AdvancedGenericsWriterBase {
  public:
  void WriteFloatImageImageImpl (test_model::Image<test_model::Image<float>> const& value) override {
    if (WriteFloatImageImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatImageImageImpl");
    }
    if (WriteFloatImageImageImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatImageImageImpl");
    }
    WriteFloatImageImageImpl_expected_values_.pop();
  }

  std::queue<test_model::Image<test_model::Image<float>>> WriteFloatImageImageImpl_expected_values_;

  void ExpectWriteFloatImageImageImpl (test_model::Image<test_model::Image<float>> const& value) {
    WriteFloatImageImageImpl_expected_values_.push(value);
  }

  void WriteGenericRecord1Impl (test_model::GenericRecord<int32_t, std::string> const& value) override {
    if (WriteGenericRecord1Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteGenericRecord1Impl");
    }
    if (WriteGenericRecord1Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteGenericRecord1Impl");
    }
    WriteGenericRecord1Impl_expected_values_.pop();
  }

  std::queue<test_model::GenericRecord<int32_t, std::string>> WriteGenericRecord1Impl_expected_values_;

  void ExpectWriteGenericRecord1Impl (test_model::GenericRecord<int32_t, std::string> const& value) {
    WriteGenericRecord1Impl_expected_values_.push(value);
  }

  void WriteTupleOfOptionalsImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    if (WriteTupleOfOptionalsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleOfOptionalsImpl");
    }
    if (WriteTupleOfOptionalsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleOfOptionalsImpl");
    }
    WriteTupleOfOptionalsImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>> WriteTupleOfOptionalsImpl_expected_values_;

  void ExpectWriteTupleOfOptionalsImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
    WriteTupleOfOptionalsImpl_expected_values_.push(value);
  }

  void WriteTupleOfOptionalsAlternateSyntaxImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    if (WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleOfOptionalsAlternateSyntaxImpl");
    }
    if (WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleOfOptionalsAlternateSyntaxImpl");
    }
    WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>> WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_;

  void ExpectWriteTupleOfOptionalsAlternateSyntaxImpl (test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
    WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.push(value);
  }

  void WriteTupleOfVectorsImpl (test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) override {
    if (WriteTupleOfVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteTupleOfVectorsImpl");
    }
    if (WriteTupleOfVectorsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteTupleOfVectorsImpl");
    }
    WriteTupleOfVectorsImpl_expected_values_.pop();
  }

  std::queue<test_model::MyTuple<std::vector<int32_t>, std::vector<float>>> WriteTupleOfVectorsImpl_expected_values_;

  void ExpectWriteTupleOfVectorsImpl (test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) {
    WriteTupleOfVectorsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteFloatImageImageImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatImageImageImpl was not received");
    }
    if (!WriteGenericRecord1Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteGenericRecord1Impl was not received");
    }
    if (!WriteTupleOfOptionalsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleOfOptionalsImpl was not received");
    }
    if (!WriteTupleOfOptionalsAlternateSyntaxImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleOfOptionalsAlternateSyntaxImpl was not received");
    }
    if (!WriteTupleOfVectorsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteTupleOfVectorsImpl was not received");
    }
  }
};

class TestAdvancedGenericsWriterBase : public AdvancedGenericsWriterBase {
  public:
  TestAdvancedGenericsWriterBase(std::unique_ptr<test_model::AdvancedGenericsWriterBase> writer, std::function<std::unique_ptr<AdvancedGenericsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestAdvancedGenericsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestAdvancedGenericsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteFloatImageImageImpl(test_model::Image<test_model::Image<float>> const& value) override {
    writer_->WriteFloatImageImage(value);
    mock_writer_.ExpectWriteFloatImageImageImpl(value);
  }

  void WriteGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string> const& value) override {
    writer_->WriteGenericRecord1(value);
    mock_writer_.ExpectWriteGenericRecord1Impl(value);
  }

  void WriteTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    writer_->WriteTupleOfOptionals(value);
    mock_writer_.ExpectWriteTupleOfOptionalsImpl(value);
  }

  void WriteTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override {
    writer_->WriteTupleOfOptionalsAlternateSyntax(value);
    mock_writer_.ExpectWriteTupleOfOptionalsAlternateSyntaxImpl(value);
  }

  void WriteTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) override {
    writer_->WriteTupleOfVectors(value);
    mock_writer_.ExpectWriteTupleOfVectorsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<AdvancedGenericsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::AdvancedGenericsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::AdvancedGenericsReaderBase>()> create_reader_;
  MockAdvancedGenericsWriter mock_writer_;
  bool close_called_ = false;
};

class MockAliasesWriter : public AliasesWriterBase {
  public:
  void WriteAliasedStringImpl (test_model::AliasedString const& value) override {
    if (WriteAliasedStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedStringImpl");
    }
    if (WriteAliasedStringImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedStringImpl");
    }
    WriteAliasedStringImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedString> WriteAliasedStringImpl_expected_values_;

  void ExpectWriteAliasedStringImpl (test_model::AliasedString const& value) {
    WriteAliasedStringImpl_expected_values_.push(value);
  }

  void WriteAliasedEnumImpl (test_model::AliasedEnum const& value) override {
    if (WriteAliasedEnumImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedEnumImpl");
    }
    if (WriteAliasedEnumImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedEnumImpl");
    }
    WriteAliasedEnumImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedEnum> WriteAliasedEnumImpl_expected_values_;

  void ExpectWriteAliasedEnumImpl (test_model::AliasedEnum const& value) {
    WriteAliasedEnumImpl_expected_values_.push(value);
  }

  void WriteAliasedOpenGenericImpl (test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    if (WriteAliasedOpenGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedOpenGenericImpl");
    }
    if (WriteAliasedOpenGenericImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedOpenGenericImpl");
    }
    WriteAliasedOpenGenericImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>> WriteAliasedOpenGenericImpl_expected_values_;

  void ExpectWriteAliasedOpenGenericImpl (test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    WriteAliasedOpenGenericImpl_expected_values_.push(value);
  }

  void WriteAliasedClosedGenericImpl (test_model::AliasedClosedGeneric const& value) override {
    if (WriteAliasedClosedGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedClosedGenericImpl");
    }
    if (WriteAliasedClosedGenericImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedClosedGenericImpl");
    }
    WriteAliasedClosedGenericImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedClosedGeneric> WriteAliasedClosedGenericImpl_expected_values_;

  void ExpectWriteAliasedClosedGenericImpl (test_model::AliasedClosedGeneric const& value) {
    WriteAliasedClosedGenericImpl_expected_values_.push(value);
  }

  void WriteAliasedOptionalImpl (test_model::AliasedOptional const& value) override {
    if (WriteAliasedOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedOptionalImpl");
    }
    if (WriteAliasedOptionalImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedOptionalImpl");
    }
    WriteAliasedOptionalImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedOptional> WriteAliasedOptionalImpl_expected_values_;

  void ExpectWriteAliasedOptionalImpl (test_model::AliasedOptional const& value) {
    WriteAliasedOptionalImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericOptionalImpl (test_model::AliasedGenericOptional<float> const& value) override {
    if (WriteAliasedGenericOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericOptionalImpl");
    }
    if (WriteAliasedGenericOptionalImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericOptionalImpl");
    }
    WriteAliasedGenericOptionalImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericOptional<float>> WriteAliasedGenericOptionalImpl_expected_values_;

  void ExpectWriteAliasedGenericOptionalImpl (test_model::AliasedGenericOptional<float> const& value) {
    WriteAliasedGenericOptionalImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    if (WriteAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericUnion2Impl");
    }
    if (WriteAliasedGenericUnion2Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericUnion2Impl");
    }
    WriteAliasedGenericUnion2Impl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> WriteAliasedGenericUnion2Impl_expected_values_;

  void ExpectWriteAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    WriteAliasedGenericUnion2Impl_expected_values_.push(value);
  }

  void WriteAliasedGenericVectorImpl (test_model::AliasedGenericVector<float> const& value) override {
    if (WriteAliasedGenericVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericVectorImpl");
    }
    if (WriteAliasedGenericVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericVectorImpl");
    }
    WriteAliasedGenericVectorImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericVector<float>> WriteAliasedGenericVectorImpl_expected_values_;

  void ExpectWriteAliasedGenericVectorImpl (test_model::AliasedGenericVector<float> const& value) {
    WriteAliasedGenericVectorImpl_expected_values_.push(value);
  }

  void WriteAliasedGenericFixedVectorImpl (test_model::AliasedGenericFixedVector<float> const& value) override {
    if (WriteAliasedGenericFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteAliasedGenericFixedVectorImpl");
    }
    if (WriteAliasedGenericFixedVectorImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteAliasedGenericFixedVectorImpl");
    }
    WriteAliasedGenericFixedVectorImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericFixedVector<float>> WriteAliasedGenericFixedVectorImpl_expected_values_;

  void ExpectWriteAliasedGenericFixedVectorImpl (test_model::AliasedGenericFixedVector<float> const& value) {
    WriteAliasedGenericFixedVectorImpl_expected_values_.push(value);
  }

  void WriteStreamOfAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    if (WriteStreamOfAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteStreamOfAliasedGenericUnion2Impl");
    }
    if (WriteStreamOfAliasedGenericUnion2Impl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteStreamOfAliasedGenericUnion2Impl");
    }
    WriteStreamOfAliasedGenericUnion2Impl_expected_values_.pop();
  }

  std::queue<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> WriteStreamOfAliasedGenericUnion2Impl_expected_values_;

  void ExpectWriteStreamOfAliasedGenericUnion2Impl (test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
    WriteStreamOfAliasedGenericUnion2Impl_expected_values_.push(value);
  }

  void EndStreamOfAliasedGenericUnion2Impl () override {
    if (--EndStreamOfAliasedGenericUnion2Impl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndStreamOfAliasedGenericUnion2Impl");
    }
  }

  int EndStreamOfAliasedGenericUnion2Impl_expected_call_count_ = 0;

  void ExpectEndStreamOfAliasedGenericUnion2Impl () {
    EndStreamOfAliasedGenericUnion2Impl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteAliasedStringImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedStringImpl was not received");
    }
    if (!WriteAliasedEnumImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedEnumImpl was not received");
    }
    if (!WriteAliasedOpenGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedOpenGenericImpl was not received");
    }
    if (!WriteAliasedClosedGenericImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedClosedGenericImpl was not received");
    }
    if (!WriteAliasedOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedOptionalImpl was not received");
    }
    if (!WriteAliasedGenericOptionalImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericOptionalImpl was not received");
    }
    if (!WriteAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericUnion2Impl was not received");
    }
    if (!WriteAliasedGenericVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericVectorImpl was not received");
    }
    if (!WriteAliasedGenericFixedVectorImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteAliasedGenericFixedVectorImpl was not received");
    }
    if (!WriteStreamOfAliasedGenericUnion2Impl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteStreamOfAliasedGenericUnion2Impl was not received");
    }
    if (EndStreamOfAliasedGenericUnion2Impl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndStreamOfAliasedGenericUnion2Impl was not received");
    }
  }
};

class TestAliasesWriterBase : public AliasesWriterBase {
  public:
  TestAliasesWriterBase(std::unique_ptr<test_model::AliasesWriterBase> writer, std::function<std::unique_ptr<AliasesReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestAliasesWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestAliasesWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteAliasedStringImpl(test_model::AliasedString const& value) override {
    writer_->WriteAliasedString(value);
    mock_writer_.ExpectWriteAliasedStringImpl(value);
  }

  void WriteAliasedEnumImpl(test_model::AliasedEnum const& value) override {
    writer_->WriteAliasedEnum(value);
    mock_writer_.ExpectWriteAliasedEnumImpl(value);
  }

  void WriteAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    writer_->WriteAliasedOpenGeneric(value);
    mock_writer_.ExpectWriteAliasedOpenGenericImpl(value);
  }

  void WriteAliasedClosedGenericImpl(test_model::AliasedClosedGeneric const& value) override {
    writer_->WriteAliasedClosedGeneric(value);
    mock_writer_.ExpectWriteAliasedClosedGenericImpl(value);
  }

  void WriteAliasedOptionalImpl(test_model::AliasedOptional const& value) override {
    writer_->WriteAliasedOptional(value);
    mock_writer_.ExpectWriteAliasedOptionalImpl(value);
  }

  void WriteAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float> const& value) override {
    writer_->WriteAliasedGenericOptional(value);
    mock_writer_.ExpectWriteAliasedGenericOptionalImpl(value);
  }

  void WriteAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    writer_->WriteAliasedGenericUnion2(value);
    mock_writer_.ExpectWriteAliasedGenericUnion2Impl(value);
  }

  void WriteAliasedGenericVectorImpl(test_model::AliasedGenericVector<float> const& value) override {
    writer_->WriteAliasedGenericVector(value);
    mock_writer_.ExpectWriteAliasedGenericVectorImpl(value);
  }

  void WriteAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float> const& value) override {
    writer_->WriteAliasedGenericFixedVector(value);
    mock_writer_.ExpectWriteAliasedGenericFixedVectorImpl(value);
  }

  void WriteStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override {
    writer_->WriteStreamOfAliasedGenericUnion2(value);
    mock_writer_.ExpectWriteStreamOfAliasedGenericUnion2Impl(value);
  }

  void WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) override {
    writer_->WriteStreamOfAliasedGenericUnion2(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteStreamOfAliasedGenericUnion2Impl(v);
    }
  }

  void EndStreamOfAliasedGenericUnion2Impl() override {
    writer_->EndStreamOfAliasedGenericUnion2();
    mock_writer_.ExpectEndStreamOfAliasedGenericUnion2Impl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<AliasesReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::AliasesWriterBase> writer_;
  std::function<std::unique_ptr<test_model::AliasesReaderBase>()> create_reader_;
  MockAliasesWriter mock_writer_;
  bool close_called_ = false;
};

class MockStreamsOfAliasedUnionsWriter : public StreamsOfAliasedUnionsWriterBase {
  public:
  void WriteIntOrSimpleRecordImpl (test_model::AliasedIntOrSimpleRecord const& value) override {
    if (WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntOrSimpleRecordImpl");
    }
    if (WriteIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntOrSimpleRecordImpl");
    }
    WriteIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedIntOrSimpleRecord> WriteIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteIntOrSimpleRecordImpl (test_model::AliasedIntOrSimpleRecord const& value) {
    WriteIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndIntOrSimpleRecordImpl () override {
    if (--EndIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntOrSimpleRecordImpl");
    }
  }

  int EndIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndIntOrSimpleRecordImpl () {
    EndIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void WriteNullableIntOrSimpleRecordImpl (test_model::AliasedNullableIntSimpleRecord const& value) override {
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteNullableIntOrSimpleRecordImpl");
    }
    if (WriteNullableIntOrSimpleRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteNullableIntOrSimpleRecordImpl");
    }
    WriteNullableIntOrSimpleRecordImpl_expected_values_.pop();
  }

  std::queue<test_model::AliasedNullableIntSimpleRecord> WriteNullableIntOrSimpleRecordImpl_expected_values_;

  void ExpectWriteNullableIntOrSimpleRecordImpl (test_model::AliasedNullableIntSimpleRecord const& value) {
    WriteNullableIntOrSimpleRecordImpl_expected_values_.push(value);
  }

  void EndNullableIntOrSimpleRecordImpl () override {
    if (--EndNullableIntOrSimpleRecordImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndNullableIntOrSimpleRecordImpl");
    }
  }

  int EndNullableIntOrSimpleRecordImpl_expected_call_count_ = 0;

  void ExpectEndNullableIntOrSimpleRecordImpl () {
    EndNullableIntOrSimpleRecordImpl_expected_call_count_++;
  }

  void Verify() {
    if (!WriteIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntOrSimpleRecordImpl was not received");
    }
    if (EndIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntOrSimpleRecordImpl was not received");
    }
    if (!WriteNullableIntOrSimpleRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteNullableIntOrSimpleRecordImpl was not received");
    }
    if (EndNullableIntOrSimpleRecordImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndNullableIntOrSimpleRecordImpl was not received");
    }
  }
};

class TestStreamsOfAliasedUnionsWriterBase : public StreamsOfAliasedUnionsWriterBase {
  public:
  TestStreamsOfAliasedUnionsWriterBase(std::unique_ptr<test_model::StreamsOfAliasedUnionsWriterBase> writer, std::function<std::unique_ptr<StreamsOfAliasedUnionsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestStreamsOfAliasedUnionsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestStreamsOfAliasedUnionsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord const& value) override {
    writer_->WriteIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteIntOrSimpleRecordImpl(value);
  }

  void WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) override {
    writer_->WriteIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntOrSimpleRecordImpl(v);
    }
  }

  void EndIntOrSimpleRecordImpl() override {
    writer_->EndIntOrSimpleRecord();
    mock_writer_.ExpectEndIntOrSimpleRecordImpl();
  }

  void WriteNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord const& value) override {
    writer_->WriteNullableIntOrSimpleRecord(value);
    mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(value);
  }

  void WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) override {
    writer_->WriteNullableIntOrSimpleRecord(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteNullableIntOrSimpleRecordImpl(v);
    }
  }

  void EndNullableIntOrSimpleRecordImpl() override {
    writer_->EndNullableIntOrSimpleRecord();
    mock_writer_.ExpectEndNullableIntOrSimpleRecordImpl();
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<StreamsOfAliasedUnionsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2, 1);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::StreamsOfAliasedUnionsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::StreamsOfAliasedUnionsReaderBase>()> create_reader_;
  MockStreamsOfAliasedUnionsWriter mock_writer_;
  bool close_called_ = false;
};

class MockProtocolWithComputedFieldsWriter : public ProtocolWithComputedFieldsWriterBase {
  public:
  void WriteRecordWithComputedFieldsImpl (test_model::RecordWithComputedFields const& value) override {
    if (WriteRecordWithComputedFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordWithComputedFieldsImpl");
    }
    if (WriteRecordWithComputedFieldsImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordWithComputedFieldsImpl");
    }
    WriteRecordWithComputedFieldsImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithComputedFields> WriteRecordWithComputedFieldsImpl_expected_values_;

  void ExpectWriteRecordWithComputedFieldsImpl (test_model::RecordWithComputedFields const& value) {
    WriteRecordWithComputedFieldsImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteRecordWithComputedFieldsImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordWithComputedFieldsImpl was not received");
    }
  }
};

class TestProtocolWithComputedFieldsWriterBase : public ProtocolWithComputedFieldsWriterBase {
  public:
  TestProtocolWithComputedFieldsWriterBase(std::unique_ptr<test_model::ProtocolWithComputedFieldsWriterBase> writer, std::function<std::unique_ptr<ProtocolWithComputedFieldsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestProtocolWithComputedFieldsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestProtocolWithComputedFieldsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields const& value) override {
    writer_->WriteRecordWithComputedFields(value);
    mock_writer_.ExpectWriteRecordWithComputedFieldsImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ProtocolWithComputedFieldsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ProtocolWithComputedFieldsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ProtocolWithComputedFieldsReaderBase>()> create_reader_;
  MockProtocolWithComputedFieldsWriter mock_writer_;
  bool close_called_ = false;
};

class MockProtocolWithKeywordStepsWriter : public ProtocolWithKeywordStepsWriterBase {
  public:
  void WriteIntImpl (test_model::RecordWithKeywordFields const& value) override {
    if (WriteIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteIntImpl");
    }
    if (WriteIntImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteIntImpl");
    }
    WriteIntImpl_expected_values_.pop();
  }

  std::queue<test_model::RecordWithKeywordFields> WriteIntImpl_expected_values_;

  void ExpectWriteIntImpl (test_model::RecordWithKeywordFields const& value) {
    WriteIntImpl_expected_values_.push(value);
  }

  void EndIntImpl () override {
    if (--EndIntImpl_expected_call_count_ < 0) {
      throw std::runtime_error("Unexpected call to EndIntImpl");
    }
  }

  int EndIntImpl_expected_call_count_ = 0;

  void ExpectEndIntImpl () {
    EndIntImpl_expected_call_count_++;
  }

  void WriteFloatImpl (test_model::EnumWithKeywordSymbols const& value) override {
    if (WriteFloatImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteFloatImpl");
    }
    if (WriteFloatImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteFloatImpl");
    }
    WriteFloatImpl_expected_values_.pop();
  }

  std::queue<test_model::EnumWithKeywordSymbols> WriteFloatImpl_expected_values_;

  void ExpectWriteFloatImpl (test_model::EnumWithKeywordSymbols const& value) {
    WriteFloatImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteIntImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteIntImpl was not received");
    }
    if (EndIntImpl_expected_call_count_ > 0) {
      throw std::runtime_error("Expected call to EndIntImpl was not received");
    }
    if (!WriteFloatImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteFloatImpl was not received");
    }
  }
};

class TestProtocolWithKeywordStepsWriterBase : public ProtocolWithKeywordStepsWriterBase {
  public:
  TestProtocolWithKeywordStepsWriterBase(std::unique_ptr<test_model::ProtocolWithKeywordStepsWriterBase> writer, std::function<std::unique_ptr<ProtocolWithKeywordStepsReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestProtocolWithKeywordStepsWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestProtocolWithKeywordStepsWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteIntImpl(test_model::RecordWithKeywordFields const& value) override {
    writer_->WriteInt(value);
    mock_writer_.ExpectWriteIntImpl(value);
  }

  void WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& values) override {
    writer_->WriteInt(values);
    for (auto const& v : values) {
      mock_writer_.ExpectWriteIntImpl(v);
    }
  }

  void EndIntImpl() override {
    writer_->EndInt();
    mock_writer_.ExpectEndIntImpl();
  }

  void WriteFloatImpl(test_model::EnumWithKeywordSymbols const& value) override {
    writer_->WriteFloat(value);
    mock_writer_.ExpectWriteFloatImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ProtocolWithKeywordStepsReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_, 2);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ProtocolWithKeywordStepsWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ProtocolWithKeywordStepsReaderBase>()> create_reader_;
  MockProtocolWithKeywordStepsWriter mock_writer_;
  bool close_called_ = false;
};

class MockProtocolWithOptionalDateWriter : public ProtocolWithOptionalDateWriterBase {
  public:
  void WriteRecordImpl (std::optional<test_model::RecordWithOptionalDate> const& value) override {
    if (WriteRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Unexpected call to WriteRecordImpl");
    }
    if (WriteRecordImpl_expected_values_.front() != value) {
      throw std::runtime_error("Unexpected argument value for call to WriteRecordImpl");
    }
    WriteRecordImpl_expected_values_.pop();
  }

  std::queue<std::optional<test_model::RecordWithOptionalDate>> WriteRecordImpl_expected_values_;

  void ExpectWriteRecordImpl (std::optional<test_model::RecordWithOptionalDate> const& value) {
    WriteRecordImpl_expected_values_.push(value);
  }

  void Verify() {
    if (!WriteRecordImpl_expected_values_.empty()) {
      throw std::runtime_error("Expected call to WriteRecordImpl was not received");
    }
  }
};

class TestProtocolWithOptionalDateWriterBase : public ProtocolWithOptionalDateWriterBase {
  public:
  TestProtocolWithOptionalDateWriterBase(std::unique_ptr<test_model::ProtocolWithOptionalDateWriterBase> writer, std::function<std::unique_ptr<ProtocolWithOptionalDateReaderBase>()> create_reader) : writer_(std::move(writer)), create_reader_(create_reader) {
  }

  ~TestProtocolWithOptionalDateWriterBase() {
    if (!close_called_ && !std::uncaught_exceptions()) {
      ADD_FAILURE() << "Close() needs to be called on 'TestProtocolWithOptionalDateWriterBase' to verify mocks";
    }
  }

  protected:
  void WriteRecordImpl(std::optional<test_model::RecordWithOptionalDate> const& value) override {
    writer_->WriteRecord(value);
    mock_writer_.ExpectWriteRecordImpl(value);
  }

  void CloseImpl() override {
    close_called_ = true;
    writer_->Close();
    std::unique_ptr<ProtocolWithOptionalDateReaderBase> reader = create_reader_();
    reader->CopyTo(mock_writer_);
    mock_writer_.Verify();
  }

  private:
  std::unique_ptr<test_model::ProtocolWithOptionalDateWriterBase> writer_;
  std::function<std::unique_ptr<test_model::ProtocolWithOptionalDateReaderBase>()> create_reader_;
  MockProtocolWithOptionalDateWriter mock_writer_;
  bool close_called_ = false;
};
} // namespace
} // namespace test_model

namespace yardl::testing {
template<>
std::unique_ptr<test_model::BenchmarkFloat256x256WriterBase> CreateValidatingWriter<test_model::BenchmarkFloat256x256WriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestBenchmarkFloat256x256WriterBase>(
    CreateWriter<test_model::BenchmarkFloat256x256WriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::BenchmarkFloat256x256ReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::BenchmarkInt256x256WriterBase> CreateValidatingWriter<test_model::BenchmarkInt256x256WriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestBenchmarkInt256x256WriterBase>(
    CreateWriter<test_model::BenchmarkInt256x256WriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::BenchmarkInt256x256ReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::BenchmarkFloatVlenWriterBase> CreateValidatingWriter<test_model::BenchmarkFloatVlenWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestBenchmarkFloatVlenWriterBase>(
    CreateWriter<test_model::BenchmarkFloatVlenWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::BenchmarkFloatVlenReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::BenchmarkSmallRecordWriterBase> CreateValidatingWriter<test_model::BenchmarkSmallRecordWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestBenchmarkSmallRecordWriterBase>(
    CreateWriter<test_model::BenchmarkSmallRecordWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::BenchmarkSmallRecordReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::BenchmarkSmallRecordWithOptionalsWriterBase> CreateValidatingWriter<test_model::BenchmarkSmallRecordWithOptionalsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestBenchmarkSmallRecordWithOptionalsWriterBase>(
    CreateWriter<test_model::BenchmarkSmallRecordWithOptionalsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::BenchmarkSmallRecordWithOptionalsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::BenchmarkSimpleMrdWriterBase> CreateValidatingWriter<test_model::BenchmarkSimpleMrdWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestBenchmarkSimpleMrdWriterBase>(
    CreateWriter<test_model::BenchmarkSimpleMrdWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::BenchmarkSimpleMrdReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::ScalarsWriterBase> CreateValidatingWriter<test_model::ScalarsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestScalarsWriterBase>(
    CreateWriter<test_model::ScalarsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::ScalarsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::ScalarOptionalsWriterBase> CreateValidatingWriter<test_model::ScalarOptionalsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestScalarOptionalsWriterBase>(
    CreateWriter<test_model::ScalarOptionalsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::ScalarOptionalsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::NestedRecordsWriterBase> CreateValidatingWriter<test_model::NestedRecordsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestNestedRecordsWriterBase>(
    CreateWriter<test_model::NestedRecordsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::NestedRecordsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::VlensWriterBase> CreateValidatingWriter<test_model::VlensWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestVlensWriterBase>(
    CreateWriter<test_model::VlensWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::VlensReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::StringsWriterBase> CreateValidatingWriter<test_model::StringsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestStringsWriterBase>(
    CreateWriter<test_model::StringsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::StringsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::OptionalVectorsWriterBase> CreateValidatingWriter<test_model::OptionalVectorsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestOptionalVectorsWriterBase>(
    CreateWriter<test_model::OptionalVectorsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::OptionalVectorsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::FixedVectorsWriterBase> CreateValidatingWriter<test_model::FixedVectorsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestFixedVectorsWriterBase>(
    CreateWriter<test_model::FixedVectorsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::FixedVectorsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::StreamsWriterBase> CreateValidatingWriter<test_model::StreamsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestStreamsWriterBase>(
    CreateWriter<test_model::StreamsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::StreamsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::FixedArraysWriterBase> CreateValidatingWriter<test_model::FixedArraysWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestFixedArraysWriterBase>(
    CreateWriter<test_model::FixedArraysWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::FixedArraysReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::SubarraysWriterBase> CreateValidatingWriter<test_model::SubarraysWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestSubarraysWriterBase>(
    CreateWriter<test_model::SubarraysWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::SubarraysReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::SubarraysInRecordsWriterBase> CreateValidatingWriter<test_model::SubarraysInRecordsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestSubarraysInRecordsWriterBase>(
    CreateWriter<test_model::SubarraysInRecordsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::SubarraysInRecordsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::NDArraysWriterBase> CreateValidatingWriter<test_model::NDArraysWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestNDArraysWriterBase>(
    CreateWriter<test_model::NDArraysWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::NDArraysReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::NDArraysSingleDimensionWriterBase> CreateValidatingWriter<test_model::NDArraysSingleDimensionWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestNDArraysSingleDimensionWriterBase>(
    CreateWriter<test_model::NDArraysSingleDimensionWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::NDArraysSingleDimensionReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::DynamicNDArraysWriterBase> CreateValidatingWriter<test_model::DynamicNDArraysWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestDynamicNDArraysWriterBase>(
    CreateWriter<test_model::DynamicNDArraysWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::DynamicNDArraysReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::MultiDArraysWriterBase> CreateValidatingWriter<test_model::MultiDArraysWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestMultiDArraysWriterBase>(
    CreateWriter<test_model::MultiDArraysWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::MultiDArraysReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::ComplexArraysWriterBase> CreateValidatingWriter<test_model::ComplexArraysWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestComplexArraysWriterBase>(
    CreateWriter<test_model::ComplexArraysWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::ComplexArraysReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::MapsWriterBase> CreateValidatingWriter<test_model::MapsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestMapsWriterBase>(
    CreateWriter<test_model::MapsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::MapsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::UnionsWriterBase> CreateValidatingWriter<test_model::UnionsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestUnionsWriterBase>(
    CreateWriter<test_model::UnionsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::UnionsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::StreamsOfUnionsWriterBase> CreateValidatingWriter<test_model::StreamsOfUnionsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestStreamsOfUnionsWriterBase>(
    CreateWriter<test_model::StreamsOfUnionsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::StreamsOfUnionsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::EnumsWriterBase> CreateValidatingWriter<test_model::EnumsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestEnumsWriterBase>(
    CreateWriter<test_model::EnumsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::EnumsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::FlagsWriterBase> CreateValidatingWriter<test_model::FlagsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestFlagsWriterBase>(
    CreateWriter<test_model::FlagsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::FlagsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::StateTestWriterBase> CreateValidatingWriter<test_model::StateTestWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestStateTestWriterBase>(
    CreateWriter<test_model::StateTestWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::StateTestReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::SimpleGenericsWriterBase> CreateValidatingWriter<test_model::SimpleGenericsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestSimpleGenericsWriterBase>(
    CreateWriter<test_model::SimpleGenericsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::SimpleGenericsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::AdvancedGenericsWriterBase> CreateValidatingWriter<test_model::AdvancedGenericsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestAdvancedGenericsWriterBase>(
    CreateWriter<test_model::AdvancedGenericsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::AdvancedGenericsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::AliasesWriterBase> CreateValidatingWriter<test_model::AliasesWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestAliasesWriterBase>(
    CreateWriter<test_model::AliasesWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::AliasesReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::StreamsOfAliasedUnionsWriterBase> CreateValidatingWriter<test_model::StreamsOfAliasedUnionsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestStreamsOfAliasedUnionsWriterBase>(
    CreateWriter<test_model::StreamsOfAliasedUnionsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::StreamsOfAliasedUnionsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::ProtocolWithComputedFieldsWriterBase> CreateValidatingWriter<test_model::ProtocolWithComputedFieldsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestProtocolWithComputedFieldsWriterBase>(
    CreateWriter<test_model::ProtocolWithComputedFieldsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::ProtocolWithComputedFieldsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::ProtocolWithKeywordStepsWriterBase> CreateValidatingWriter<test_model::ProtocolWithKeywordStepsWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestProtocolWithKeywordStepsWriterBase>(
    CreateWriter<test_model::ProtocolWithKeywordStepsWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::ProtocolWithKeywordStepsReaderBase>(format, filename);}
  );
}

template<>
std::unique_ptr<test_model::ProtocolWithOptionalDateWriterBase> CreateValidatingWriter<test_model::ProtocolWithOptionalDateWriterBase>(Format format, std::string const& filename) {
  return std::make_unique<test_model::TestProtocolWithOptionalDateWriterBase>(
    CreateWriter<test_model::ProtocolWithOptionalDateWriterBase>(format, filename),
    [format, filename](){ return CreateReader<test_model::ProtocolWithOptionalDateReaderBase>(format, filename);}
  );
}

}
