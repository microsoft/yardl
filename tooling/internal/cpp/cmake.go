// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package cpp

import (
	"bytes"
	"fmt"
	"path"

	"github.com/microsoft/yardl/tooling/internal/formatting"
	"github.com/microsoft/yardl/tooling/internal/iocommon"
	"github.com/microsoft/yardl/tooling/pkg/dsl"
	"github.com/microsoft/yardl/tooling/pkg/packaging"
)

func writeCMakeLists(env *dsl.Environment, options packaging.CppCodegenOptions) error {
	b := bytes.Buffer{}
	w := formatting.NewIndentedWriter(&b, "  ")

	objectLibraryName := fmt.Sprintf("%s_generated", formatting.ToSnakeCase(options.PackageInfo.Namespace))
	cmakePrefix := fmt.Sprintf("%s_GENERATED", options.PackageInfo.Namespace)

	fmt.Fprintf(w, `# This file was generated by the "yardl" tool. DO NOT EDIT.

# To opt out of generating this file, set cpp.generateCMakeLists to false in the _package.yml file.

# To use the object library defined in this file, add the following to your CMakeLists.txt file:
# target_link_libraries(<your target> %s)
# add_subdirectory(<path to this directory>)

set(%s_SOURCES
  protocols.cc
  types.cc
  binary/protocols.cc
)

set(%s_LINK_LIBRARIES
  xtensor
  date::date
)

set(HOWARD_HINNANT_DATE_MINIMUM_VERSION "3.0.0")
find_package(date ${HOWARD_HINNANT_DATE_MINIMUM_VERSION} REQUIRED)

set(XTENSOR_MINIMUM_VERSION "0.21.10")
find_package(xtensor ${XTENSOR_MINIMUM_VERSION} REQUIRED)
`, objectLibraryName, cmakePrefix, cmakePrefix)

	if options.GenerateHDF5 {
		fmt.Fprintf(w, `
option(%s_USE_HDF5 "Whether to use HDF5 in the generated code" ON)
if(%s_USE_HDF5)
	if(VCPKG_TARGET_TRIPLET)
		set(HDF5_CXX_LIBRARIES hdf5::hdf5_cpp-shared)
	else()
		set(HDF5_CXX_LIBRARIES hdf5::hdf5_cpp)
	endif()

	set(HDF5_MINIMUM_VERSION "1.10.5")
	find_package(HDF5 ${HDF5_MINIMUM_VERSION} REQUIRED COMPONENTS CXX)

	list(APPEND %s_SOURCES hdf5/protocols.cc)
	list(APPEND %s_LINK_LIBRARIES HDF5::HDF5)
endif()
`, cmakePrefix, cmakePrefix, cmakePrefix, cmakePrefix)
	}

	if options.GenerateNDJson {
		fmt.Fprintf(w, `
option(%s_USE_NDJSON "Whether to use NDJSON in the generated code" ON)
if(%s_USE_NDJSON)
	set(NLOHMANN_JSON_MINIMUM_VERSION "3.11.1")
	find_package(nlohmann_json ${NLOHMANN_JSON_MINIMUM_VERSION} REQUIRED)

	list(APPEND %s_SOURCES ndjson/protocols.cc)
	list(APPEND %s_LINK_LIBRARIES nlohmann_json::nlohmann_json)
endif()
`, cmakePrefix, cmakePrefix, cmakePrefix, cmakePrefix)
	}

	w.WriteStringln("")

	if options.InternalGenerateTranslator {
		fmt.Fprintf(w, "list(APPEND %s_SOURCES factories.cc translator_impl.cc)\n\n", cmakePrefix)
	}

	fmt.Fprintf(w, "add_library(%s OBJECT ${%s_SOURCES})\n", objectLibraryName, cmakePrefix)
	fmt.Fprintf(w, "target_link_libraries(%s ${%s_LINK_LIBRARIES})\n", objectLibraryName, cmakePrefix)

	if options.InternalGenerateMocks {
		w.WriteStringln("")

		mocksObjectLibraryName := fmt.Sprintf("%s_mocks", objectLibraryName)
		fmt.Fprintf(w, "add_library(%s OBJECT mocks.cc)\n", mocksObjectLibraryName)

		fmt.Fprintf(w, "target_link_libraries(%s\n", mocksObjectLibraryName)
		w.Indented(func() {
			fmt.Fprintf(w, "PUBLIC %s\n", objectLibraryName)
			w.WriteStringln("PUBLIC gtest")
		})
		w.WriteString(")\n")
	}

	definitionsPath := path.Join(options.SourcesOutputDir, "CMakeLists.txt")
	return iocommon.WriteFileIfNeeded(definitionsPath, b.Bytes(), 0644)
}
