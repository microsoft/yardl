# This file was generated by the "yardl" tool. DO NOT EDIT.


import dataclasses
import datetime
import enum
import types
import typing
import numpy as np
import numpy.typing as npt
from . import yardl_types as yardl
from . import _dtypes

K = typing.TypeVar("K")
K_NP = typing.TypeVar("K_NP", bound=np.generic)
V = typing.TypeVar("V")
V_NP = typing.TypeVar("V_NP", bound=np.generic)
T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)
T1 = typing.TypeVar("T1")
T1_NP = typing.TypeVar("T1_NP", bound=np.generic)
T2 = typing.TypeVar("T2")
T2_NP = typing.TypeVar("T2_NP", bound=np.generic)
T0 = typing.TypeVar("T0")
T0_NP = typing.TypeVar("T0_NP", bound=np.generic)


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class SmallBenchmarkRecord:
    a: yardl.Float64 = 0.0

    b: yardl.Float32 = 0.0

    c: yardl.Float32 = 0.0

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SmallBenchmarkRecord):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.a == other["a"]
                and self.b == other["b"]
                and self.c == other["c"]
            )
        return (
            self.a == other.a
            and self.b == other.b
            and self.c == other.c
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class SimpleEncodingCounters:
    e1: yardl.UInt32 | None = None

    e2: yardl.UInt32 | None = None

    slice: yardl.UInt32 | None = None

    repetition: yardl.UInt32 | None = None

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SimpleEncodingCounters):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 4
            ):
                return False
            return (
                self.e1 == other["e1"]
                and self.e2 == other["e2"]
                and self.slice == other["slice"]
                and self.repetition == other["repetition"]
            )
        return (
            self.e1 == other.e1
            and self.e2 == other.e2
            and self.slice == other.slice
            and self.repetition == other.repetition
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class SimpleAcquisition:
    flags: yardl.UInt64 = 0

    idx: SimpleEncodingCounters = dataclasses.field(
        default_factory=SimpleEncodingCounters
    )

    data: npt.NDArray[np.complex64] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.complex64))
    )

    trajectory: npt.NDArray[np.float32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.float32))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SimpleAcquisition):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 4
            ):
                return False
            return (
                self.flags == other["flags"]
                and self.idx == other["idx"]
                and yardl.structural_equal(self.data, other["data"])
                and yardl.structural_equal(self.trajectory, other["trajectory"])
            )
        return (
            self.flags == other.flags
            and self.idx == other.idx
            and yardl.structural_equal(self.data, other.data)
            and yardl.structural_equal(self.trajectory, other.trajectory)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class SimpleRecord:
    x: yardl.Int32 = 0

    y: yardl.Int32 = 0

    z: yardl.Int32 = 0

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SimpleRecord):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.x == other["x"]
                and self.y == other["y"]
                and self.z == other["z"]
            )
        return (
            self.x == other.x
            and self.y == other.y
            and self.z == other.z
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithPrimitives:
    bool_field: yardl.Bool = False

    int_8_field: yardl.Int8 = 0

    uint_8_field: yardl.UInt8 = 0

    int_16_field: yardl.Int16 = 0

    uint_16_field: yardl.UInt16 = 0

    int_32_field: yardl.Int32 = 0

    uint_32_field: yardl.UInt32 = 0

    int_64_field: yardl.Int64 = 0

    uint_64_field: yardl.UInt64 = 0

    size_field: yardl.Size = 0

    float_32_field: yardl.Float32 = 0.0

    float_64_field: yardl.Float64 = 0.0

    complexfloat_32_field: yardl.ComplexFloat = 0j

    complexfloat_64_field: yardl.ComplexDouble = 0j

    date_field: yardl.Date = dataclasses.field(
        default_factory=lambda: datetime.date(1970, 1, 1)
    )

    time_field: yardl.Time = dataclasses.field(
        default_factory=yardl.Time
    )

    datetime_field: yardl.DateTime = dataclasses.field(
        default_factory=yardl.DateTime
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithPrimitives):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 17
            ):
                return False
            return (
                self.bool_field == other["bool_field"]
                and self.int_8_field == other["int_8_field"]
                and self.uint_8_field == other["uint_8_field"]
                and self.int_16_field == other["int_16_field"]
                and self.uint_16_field == other["uint_16_field"]
                and self.int_32_field == other["int_32_field"]
                and self.uint_32_field == other["uint_32_field"]
                and self.int_64_field == other["int_64_field"]
                and self.uint_64_field == other["uint_64_field"]
                and self.size_field == other["size_field"]
                and self.float_32_field == other["float_32_field"]
                and self.float_64_field == other["float_64_field"]
                and self.complexfloat_32_field == other["complexfloat_32_field"]
                and self.complexfloat_64_field == other["complexfloat_64_field"]
                and yardl.dates_equal(self.date_field, other["date_field"])
                and yardl.times_equal(self.time_field, other["time_field"])
                and yardl.datetimes_equal(self.datetime_field, other["datetime_field"])
            )
        return (
            self.bool_field == other.bool_field
            and self.int_8_field == other.int_8_field
            and self.uint_8_field == other.uint_8_field
            and self.int_16_field == other.int_16_field
            and self.uint_16_field == other.uint_16_field
            and self.int_32_field == other.int_32_field
            and self.uint_32_field == other.uint_32_field
            and self.int_64_field == other.int_64_field
            and self.uint_64_field == other.uint_64_field
            and self.size_field == other.size_field
            and self.float_32_field == other.float_32_field
            and self.float_64_field == other.float_64_field
            and self.complexfloat_32_field == other.complexfloat_32_field
            and self.complexfloat_64_field == other.complexfloat_64_field
            and yardl.dates_equal(self.date_field, other.date_field)
            and yardl.times_equal(self.time_field, other.time_field)
            and yardl.datetimes_equal(self.datetime_field, other.datetime_field)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithPrimitiveAliases:
    byte_field: yardl.UInt8 = 0

    int_field: yardl.Int32 = 0

    uint_field: yardl.UInt32 = 0

    long_field: yardl.Int64 = 0

    ulong_field: yardl.UInt64 = 0

    float_field: yardl.Float32 = 0.0

    double_field: yardl.Float64 = 0.0

    complexfloat_field: yardl.ComplexFloat = 0j

    complexdouble_field: yardl.ComplexDouble = 0j

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithPrimitiveAliases):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 9
            ):
                return False
            return (
                self.byte_field == other["byte_field"]
                and self.int_field == other["int_field"]
                and self.uint_field == other["uint_field"]
                and self.long_field == other["long_field"]
                and self.ulong_field == other["ulong_field"]
                and self.float_field == other["float_field"]
                and self.double_field == other["double_field"]
                and self.complexfloat_field == other["complexfloat_field"]
                and self.complexdouble_field == other["complexdouble_field"]
            )
        return (
            self.byte_field == other.byte_field
            and self.int_field == other.int_field
            and self.uint_field == other.uint_field
            and self.long_field == other.long_field
            and self.ulong_field == other.ulong_field
            and self.float_field == other.float_field
            and self.double_field == other.double_field
            and self.complexfloat_field == other.complexfloat_field
            and self.complexdouble_field == other.complexdouble_field
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class TupleWithRecords:
    a: SimpleRecord = dataclasses.field(
        default_factory=SimpleRecord
    )

    b: SimpleRecord = dataclasses.field(
        default_factory=SimpleRecord
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, TupleWithRecords):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 2
            ):
                return False
            return (
                self.a == other["a"]
                and self.b == other["b"]
            )
        return (
            self.a == other.a
            and self.b == other.b
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithVectors:
    default_vector: list[yardl.Int32] = dataclasses.field(
        default_factory=list
    )

    default_vector_fixed_length: list[yardl.Int32] = dataclasses.field(
        default_factory=lambda: [0] * 3
    )

    vector_of_vectors: list[list[yardl.Int32]] = dataclasses.field(
        default_factory=list
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithVectors):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.default_vector == other["default_vector"]
                and self.default_vector_fixed_length == other["default_vector_fixed_length"]
                and self.vector_of_vectors == other["vector_of_vectors"]
            )
        return (
            self.default_vector == other.default_vector
            and self.default_vector_fixed_length == other.default_vector_fixed_length
            and self.vector_of_vectors == other.vector_of_vectors
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithVectorOfTimes:
    times: list[yardl.Time] = dataclasses.field(
        default_factory=list
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithVectorOfTimes):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 1
            ):
                return False
            return (
                len(self.times) == len(other["times"]) and all(yardl.times_equal(a, b) for a, b in zip(self.times, other["times"]))
            )
        return (
            len(self.times) == len(other.times) and all(yardl.times_equal(a, b) for a, b in zip(self.times, other.times))
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithArrays:
    default_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    default_array_with_empty_dimension: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    rank_1_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0), dtype=np.dtype(np.int32))
    )

    rank_2_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    rank_2_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    rank_2_fixed_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32))
    )

    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32))
    )

    dynamic_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    array_of_vectors: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((5,), dtype=np.dtype(np.object_))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithArrays):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 9
            ):
                return False
            return (
                yardl.structural_equal(self.default_array, other["default_array"])
                and yardl.structural_equal(self.default_array_with_empty_dimension, other["default_array_with_empty_dimension"])
                and yardl.structural_equal(self.rank_1_array, other["rank_1_array"])
                and yardl.structural_equal(self.rank_2_array, other["rank_2_array"])
                and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other["rank_2_array_with_named_dimensions"])
                and yardl.structural_equal(self.rank_2_fixed_array, other["rank_2_fixed_array"])
                and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other["rank_2_fixed_array_with_named_dimensions"])
                and yardl.structural_equal(self.dynamic_array, other["dynamic_array"])
                and yardl.structural_equal(self.array_of_vectors, other["array_of_vectors"])
            )
        return (
            yardl.structural_equal(self.default_array, other.default_array)
            and yardl.structural_equal(self.default_array_with_empty_dimension, other.default_array_with_empty_dimension)
            and yardl.structural_equal(self.rank_1_array, other.rank_1_array)
            and yardl.structural_equal(self.rank_2_array, other.rank_2_array)
            and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other.rank_2_array_with_named_dimensions)
            and yardl.structural_equal(self.rank_2_fixed_array, other.rank_2_fixed_array)
            and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other.rank_2_fixed_array_with_named_dimensions)
            and yardl.structural_equal(self.dynamic_array, other.dynamic_array)
            and yardl.structural_equal(self.array_of_vectors, other.array_of_vectors)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithArraysSimpleSyntax:
    default_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    default_array_with_empty_dimension: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    rank_1_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0), dtype=np.dtype(np.int32))
    )

    rank_2_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    rank_2_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    rank_2_fixed_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32))
    )

    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32))
    )

    dynamic_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    array_of_vectors: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((5,), dtype=np.dtype(np.object_))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithArraysSimpleSyntax):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 9
            ):
                return False
            return (
                yardl.structural_equal(self.default_array, other["default_array"])
                and yardl.structural_equal(self.default_array_with_empty_dimension, other["default_array_with_empty_dimension"])
                and yardl.structural_equal(self.rank_1_array, other["rank_1_array"])
                and yardl.structural_equal(self.rank_2_array, other["rank_2_array"])
                and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other["rank_2_array_with_named_dimensions"])
                and yardl.structural_equal(self.rank_2_fixed_array, other["rank_2_fixed_array"])
                and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other["rank_2_fixed_array_with_named_dimensions"])
                and yardl.structural_equal(self.dynamic_array, other["dynamic_array"])
                and yardl.structural_equal(self.array_of_vectors, other["array_of_vectors"])
            )
        return (
            yardl.structural_equal(self.default_array, other.default_array)
            and yardl.structural_equal(self.default_array_with_empty_dimension, other.default_array_with_empty_dimension)
            and yardl.structural_equal(self.rank_1_array, other.rank_1_array)
            and yardl.structural_equal(self.rank_2_array, other.rank_2_array)
            and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other.rank_2_array_with_named_dimensions)
            and yardl.structural_equal(self.rank_2_fixed_array, other.rank_2_fixed_array)
            and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other.rank_2_fixed_array_with_named_dimensions)
            and yardl.structural_equal(self.dynamic_array, other.dynamic_array)
            and yardl.structural_equal(self.array_of_vectors, other.array_of_vectors)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithOptionalFields:
    optional_int: yardl.Int32 | None = None

    optional_int_alternate_syntax: yardl.Int32 | None = None

    optional_time: yardl.Time | None = None

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithOptionalFields):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.optional_int == other["optional_int"]
                and self.optional_int_alternate_syntax == other["optional_int_alternate_syntax"]
                and other["optional_time"] is None if self.optional_time is None else (other["optional_time"] is not None and yardl.times_equal(self.optional_time, other["optional_time"]))
            )
        return (
            self.optional_int == other.optional_int
            and self.optional_int_alternate_syntax == other.optional_int_alternate_syntax
            and other.optional_time is None if self.optional_time is None else (other.optional_time is not None and yardl.times_equal(self.optional_time, other.optional_time))
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithVlens:
    a: list[SimpleRecord] = dataclasses.field(
        default_factory=list
    )

    b: yardl.Int32 = 0

    c: yardl.Int32 = 0

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithVlens):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.a == other["a"]
                and self.b == other["b"]
                and self.c == other["c"]
            )
        return (
            self.a == other.a
            and self.b == other.b
            and self.c == other.c
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithStrings:
    a: str = ""

    b: str = ""

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithStrings):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 2
            ):
                return False
            return (
                self.a == other["a"]
                and self.b == other["b"]
            )
        return (
            self.a == other.a
            and self.b == other.b
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithOptionalVector:
    optional_vector: list[yardl.Int32] | None = None

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithOptionalVector):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 1
            ):
                return False
            return (
                self.optional_vector == other["optional_vector"]
            )
        return (
            self.optional_vector == other.optional_vector
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithFixedVectors:
    fixed_int_vector: list[yardl.Int32] = dataclasses.field(
        default_factory=lambda: [0] * 5
    )

    fixed_simple_record_vector: list[SimpleRecord] = dataclasses.field(
        default_factory=lambda: [SimpleRecord() for _ in range(3)]
    )

    fixed_record_with_vlens_vector: list[RecordWithVlens] = dataclasses.field(
        default_factory=lambda: [RecordWithVlens() for _ in range(2)]
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithFixedVectors):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.fixed_int_vector == other["fixed_int_vector"]
                and self.fixed_simple_record_vector == other["fixed_simple_record_vector"]
                and self.fixed_record_with_vlens_vector == other["fixed_record_with_vlens_vector"]
            )
        return (
            self.fixed_int_vector == other.fixed_int_vector
            and self.fixed_simple_record_vector == other.fixed_simple_record_vector
            and self.fixed_record_with_vlens_vector == other.fixed_record_with_vlens_vector
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithFixedArrays:
    ints: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((2, 3,), dtype=np.dtype(np.int32))
    )

    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((3, 2,), dtype=get_dtype(SimpleRecord))
    )

    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((2, 2,), dtype=get_dtype(RecordWithVlens))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithFixedArrays):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                yardl.structural_equal(self.ints, other["ints"])
                and yardl.structural_equal(self.fixed_simple_record_array, other["fixed_simple_record_array"])
                and yardl.structural_equal(self.fixed_record_with_vlens_array, other["fixed_record_with_vlens_array"])
            )
        return (
            yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithNDArrays:
    ints: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=get_dtype(SimpleRecord))
    )

    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=get_dtype(RecordWithVlens))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithNDArrays):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                yardl.structural_equal(self.ints, other["ints"])
                and yardl.structural_equal(self.fixed_simple_record_array, other["fixed_simple_record_array"])
                and yardl.structural_equal(self.fixed_record_with_vlens_array, other["fixed_record_with_vlens_array"])
            )
        return (
            yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithNDArraysSingleDimension:
    ints: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0), dtype=np.dtype(np.int32))
    )

    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((0), dtype=get_dtype(SimpleRecord))
    )

    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((0), dtype=get_dtype(RecordWithVlens))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithNDArraysSingleDimension):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                yardl.structural_equal(self.ints, other["ints"])
                and yardl.structural_equal(self.fixed_simple_record_array, other["fixed_simple_record_array"])
                and yardl.structural_equal(self.fixed_record_with_vlens_array, other["fixed_record_with_vlens_array"])
            )
        return (
            yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithDynamicNDArrays:
    ints: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    simple_record_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=get_dtype(SimpleRecord))
    )

    record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=get_dtype(RecordWithVlens))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithDynamicNDArrays):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                yardl.structural_equal(self.ints, other["ints"])
                and yardl.structural_equal(self.simple_record_array, other["simple_record_array"])
                and yardl.structural_equal(self.record_with_vlens_array, other["record_with_vlens_array"])
            )
        return (
            yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.simple_record_array, other.simple_record_array)
            and yardl.structural_equal(self.record_with_vlens_array, other.record_with_vlens_array)
        )


NamedFixedNDArray = npt.NDArray[np.int32]

@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithFixedCollections:
    fixed_vector: list[yardl.Int32] = dataclasses.field(
        default_factory=lambda: [0] * 3
    )

    fixed_array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((2, 3,), dtype=np.dtype(np.int32))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithFixedCollections):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 2
            ):
                return False
            return (
                self.fixed_vector == other["fixed_vector"]
                and yardl.structural_equal(self.fixed_array, other["fixed_array"])
            )
        return (
            self.fixed_vector == other.fixed_vector
            and yardl.structural_equal(self.fixed_array, other.fixed_array)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithVlenCollections:
    vector: list[yardl.Int32] = dataclasses.field(
        default_factory=list
    )

    array: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithVlenCollections):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 2
            ):
                return False
            return (
                self.vector == other["vector"]
                and yardl.structural_equal(self.array, other["array"])
            )
        return (
            self.vector == other.vector
            and yardl.structural_equal(self.array, other.array)
        )


NamedNDArray = npt.NDArray[np.int32]

AliasedMap = dict[K, V]

@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithUnions:
    null_or_int_or_string: (
        tuple[typing.Literal["int32"], yardl.Int32]
        | tuple[typing.Literal["string"], str]
        | None
    ) = None

    date_or_datetime: (
        tuple[typing.Literal["time"], yardl.Time]
        | tuple[typing.Literal["datetime"], yardl.DateTime]
    ) = dataclasses.field(
        default_factory=lambda: ("time", yardl.Time())
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithUnions):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 2
            ):
                return False
            return (
                self.null_or_int_or_string == other["null_or_int_or_string"]
                and yardl.structural_equal(self.date_or_datetime, other["date_or_datetime"])
            )
        return (
            self.null_or_int_or_string == other.null_or_int_or_string
            and yardl.structural_equal(self.date_or_datetime, other.date_or_datetime)
        )


class Fruits(yardl.OutOfRangeEnum):
    APPLE = 0
    BANANA = 1
    PEAR = 2

class UInt64Enum(yardl.OutOfRangeEnum):
    A = 9223372036854775808

class Int64Enum(yardl.OutOfRangeEnum):
    B = -4611686018427387904

class SizeBasedEnum(yardl.OutOfRangeEnum):
    A = 0
    B = 1
    C = 2

class DaysOfWeek(enum.IntFlag):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 4
    THURSDAY = 8
    FRIDAY = 16
    SATURDAY = 32
    SUNDAY = 64

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DaysOfWeek) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

class TextFormat(enum.IntFlag):
    REGULAR = 0
    BOLD = 1
    ITALIC = 2
    UNDERLINE = 4
    STRIKETHROUGH = 8

    def __eq__(self, other: object) -> bool:
        return isinstance(other, TextFormat) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithEnums:
    enum: Fruits = Fruits.APPLE

    flags: DaysOfWeek = DaysOfWeek(0)

    flags_2: TextFormat = TextFormat.REGULAR

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithEnums):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.enum == other["enum"]
                and self.flags == other["flags"]
                and self.flags_2 == other["flags_2"]
            )
        return (
            self.enum == other.enum
            and self.flags == other.flags
            and self.flags_2 == other.flags_2
        )


Image = npt.NDArray[T_NP]

@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class GenericRecord(typing.Generic[T1, T2, T2_NP]):
    scalar_1: T1
    scalar_2: T2
    vector_1: list[T1]
    image_2: Image[T2_NP]
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, GenericRecord):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 4
            ):
                return False
            return (
                yardl.structural_equal(self.scalar_1, other["scalar_1"])
                and yardl.structural_equal(self.scalar_2, other["scalar_2"])
                and len(self.vector_1) == len(other["vector_1"]) and all(yardl.structural_equal(a, b) for a, b in zip(self.vector_1, other["vector_1"]))
                and yardl.structural_equal(self.image_2, other["image_2"])
            )
        return (
            yardl.structural_equal(self.scalar_1, other.scalar_1)
            and yardl.structural_equal(self.scalar_2, other.scalar_2)
            and len(self.vector_1) == len(other.vector_1) and all(yardl.structural_equal(a, b) for a, b in zip(self.vector_1, other.vector_1))
            and yardl.structural_equal(self.image_2, other.image_2)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class MyTuple(typing.Generic[T1, T2]):
    v1: T1
    v2: T2
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, MyTuple):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 2
            ):
                return False
            return (
                yardl.structural_equal(self.v1, other["v1"])
                and yardl.structural_equal(self.v2, other["v2"])
            )
        return (
            yardl.structural_equal(self.v1, other.v1)
            and yardl.structural_equal(self.v2, other.v2)
        )


AliasedString = str

AliasedEnum = Fruits

AliasedOpenGeneric = MyTuple[T1, T2]

AliasedClosedGeneric = MyTuple[AliasedString, AliasedEnum]

AliasedOptional = yardl.Int32 | None

AliasedGenericOptional = T | None

AliasedGenericUnion2 = (
    tuple[typing.Literal["T1"], T1]
    | tuple[typing.Literal["T2"], T2]
)

AliasedGenericVector = list[T]

AliasedGenericFixedVector = list[T]

AliasedIntOrSimpleRecord = (
    tuple[typing.Literal["int32"], yardl.Int32]
    | tuple[typing.Literal["SimpleRecord"], SimpleRecord]
)

AliasedNullableIntSimpleRecord = (
    tuple[typing.Literal["int32"], yardl.Int32]
    | tuple[typing.Literal["SimpleRecord"], SimpleRecord]
    | None
)

@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class GenericRecordWithComputedFields(typing.Generic[T0, T1]):
    f1: (
        tuple[typing.Literal["T0"], T0]
        | tuple[typing.Literal["T1"], T1]
    )
    def type_index(self) -> yardl.UInt8:
        _var0 = self.f1
        if _var0[0] == "T0":
            return 0
        if _var0[0] == "T1":
            return 1
        raise RuntimeError("Unexpected union case")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, GenericRecordWithComputedFields):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 1
            ):
                return False
            return (
                yardl.structural_equal(self.f1, other["f1"])
            )
        return (
            yardl.structural_equal(self.f1, other.f1)
        )


@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithComputedFields:
    array_field: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    array_field_map_dimensions: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    dynamic_array_field: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32))
    )

    fixed_array_field: npt.NDArray[np.int32] = dataclasses.field(
        default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32))
    )

    int_field: yardl.Int32 = 0

    string_field: str = ""

    tuple_field: MyTuple[yardl.Int32, yardl.Int32] = dataclasses.field(
        default_factory=lambda: MyTuple(v1=0, v2=0)
    )

    vector_field: list[yardl.Int32] = dataclasses.field(
        default_factory=list
    )

    vector_of_vectors_field: list[list[yardl.Int32]] = dataclasses.field(
        default_factory=list
    )

    fixed_vector_field: list[yardl.Int32] = dataclasses.field(
        default_factory=lambda: [0] * 3
    )

    optional_named_array: NamedNDArray | None = None

    int_float_union: (
        tuple[typing.Literal["int32"], yardl.Int32]
        | tuple[typing.Literal["float32"], yardl.Float32]
    ) = ("int32", 0)

    nullable_int_float_union: (
        tuple[typing.Literal["int32"], yardl.Int32]
        | tuple[typing.Literal["float32"], yardl.Float32]
        | None
    ) = None

    union_with_nested_generic_union: (
        tuple[typing.Literal["int32"], yardl.Int32]
        | tuple[typing.Literal["GenericRecordWithComputedFields<string, float32>"], GenericRecordWithComputedFields[str, yardl.Float32]]
    ) = ("int32", 0)

    map_field: dict[str, str] = dataclasses.field(
        default_factory=dict
    )

    def int_literal(self) -> yardl.UInt8:
        return 42

    def large_negative_int_64_literal(self) -> yardl.Int64:
        return -4611686018427387904

    def large_u_int_64_literal(self) -> yardl.UInt64:
        return 9223372036854775808

    def string_literal(self) -> str:
        return "hello"

    def string_literal_2(self) -> str:
        return "hello"

    def string_literal_3(self) -> str:
        return "hello"

    def string_literal_4(self) -> str:
        return "hello"

    def access_other_computed_field(self) -> yardl.Int32:
        return self.int_field

    def access_int_field(self) -> yardl.Int32:
        return self.int_field

    def access_string_field(self) -> str:
        return self.string_field

    def access_tuple_field(self) -> MyTuple[yardl.Int32, yardl.Int32]:
        return self.tuple_field

    def access_nested_tuple_field(self) -> yardl.Int32:
        return self.tuple_field.v2

    def access_array_field(self) -> npt.NDArray[np.int32]:
        return self.array_field

    def access_array_field_element(self) -> yardl.Int32:
        return typing.cast(yardl.Int32, self.array_field[0, 1])

    def access_array_field_element_by_name(self) -> yardl.Int32:
        return typing.cast(yardl.Int32, self.array_field[0, 1])

    def access_vector_field(self) -> list[yardl.Int32]:
        return self.vector_field

    def access_vector_field_element(self) -> yardl.Int32:
        return self.vector_field[1]

    def access_vector_of_vectors_field(self) -> yardl.Int32:
        return self.vector_of_vectors_field[1][2]

    def array_size(self) -> yardl.Size:
        return self.array_field.size

    def array_x_size(self) -> yardl.Size:
        return self.array_field.shape[0]

    def array_y_size(self) -> yardl.Size:
        return self.array_field.shape[1]

    def array_0_size(self) -> yardl.Size:
        return self.array_field.shape[0]

    def array_1_size(self) -> yardl.Size:
        return self.array_field.shape[1]

    def array_size_from_int_field(self) -> yardl.Size:
        return self.array_field.shape[self.int_field]

    def array_size_from_string_field(self) -> yardl.Size:
        def _helper_0(dim_name: str) -> int:
            if dim_name == "x":
                return 0
            if dim_name == "y":
                return 1
            raise KeyError(f"Unknown dimension name: '{dim_name}'")

        return self.array_field.shape[_helper_0(self.string_field)]

    def array_size_from_nested_int_field(self) -> yardl.Size:
        return self.array_field.shape[self.tuple_field.v1]

    def array_field_map_dimensions_x_size(self) -> yardl.Size:
        return self.array_field_map_dimensions.shape[0]

    def fixed_array_size(self) -> yardl.Size:
        return 12

    def fixed_array_x_size(self) -> yardl.Size:
        return 3

    def fixed_array_0_size(self) -> yardl.Size:
        return 3

    def vector_size(self) -> yardl.Size:
        return len(self.vector_field)

    def fixed_vector_size(self) -> yardl.Size:
        return 3

    def array_dimension_x_index(self) -> yardl.Size:
        return 0

    def array_dimension_y_index(self) -> yardl.Size:
        return 1

    def array_dimension_index_from_string_field(self) -> yardl.Size:
        def _helper_0(dim_name: str) -> int:
            if dim_name == "x":
                return 0
            if dim_name == "y":
                return 1
            raise KeyError(f"Unknown dimension name: '{dim_name}'")

        return _helper_0(self.string_field)

    def array_dimension_count(self) -> yardl.Size:
        return 2

    def dynamic_array_dimension_count(self) -> yardl.Size:
        return self.dynamic_array_field.ndim

    def access_map(self) -> dict[str, str]:
        return self.map_field

    def map_size(self) -> yardl.Size:
        return len(self.map_field)

    def access_map_entry(self) -> str:
        return self.map_field["hello"]

    def string_computed_field(self) -> str:
        return "hello"

    def access_map_entry_with_computed_field(self) -> str:
        return self.map_field[self.string_computed_field()]

    def access_map_entry_with_computed_field_nested(self) -> str:
        return self.map_field[self.map_field[self.string_computed_field()]]

    def access_missing_map_entry(self) -> str:
        return self.map_field["missing"]

    def optional_named_array_length(self) -> yardl.Size:
        _var0 = self.optional_named_array
        if _var0 is not None:
            arr = _var0
            return arr.size
        return 0

    def optional_named_array_length_with_discard(self) -> yardl.Size:
        _var0 = self.optional_named_array
        if _var0 is not None:
            arr = _var0
            return arr.size
        return 0

    def int_float_union_as_float(self) -> yardl.Float32:
        _var0 = self.int_float_union
        if _var0[0] == "int32":
            i_foo = _var0[1]
            return float(i_foo)
        if _var0[0] == "float32":
            f = _var0[1]
            return f
        raise RuntimeError("Unexpected union case")

    def nullable_int_float_union_string(self) -> str:
        _var0 = self.nullable_int_float_union
        if _var0 is None:
            return "null"
        if _var0[0] == "int32":
            return "int"
        return "float"
        raise RuntimeError("Unexpected union case")

    def nested_switch(self) -> yardl.Int16:
        _var0 = self.union_with_nested_generic_union
        if _var0[0] == "int32":
            return -1
        if _var0[0] == "GenericRecordWithComputedFields<string, float32>":
            rec = _var0[1]
            _var1 = rec.f1
            if _var1[0] == "T1":
                return int(20)
            if _var1[0] == "T0":
                return int(10)
            raise RuntimeError("Unexpected union case")
        raise RuntimeError("Unexpected union case")

    def use_nested_computed_field(self) -> yardl.Int16:
        _var0 = self.union_with_nested_generic_union
        if _var0[0] == "int32":
            return -1
        if _var0[0] == "GenericRecordWithComputedFields<string, float32>":
            rec = _var0[1]
            return int(rec.type_index())
        raise RuntimeError("Unexpected union case")

    def switch_over_sigle_value(self) -> yardl.Int32:
        _var0 = self.int_field
        i = _var0
        return i

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithComputedFields):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 15
            ):
                return False
            return (
                yardl.structural_equal(self.array_field, other["array_field"])
                and yardl.structural_equal(self.array_field_map_dimensions, other["array_field_map_dimensions"])
                and yardl.structural_equal(self.dynamic_array_field, other["dynamic_array_field"])
                and yardl.structural_equal(self.fixed_array_field, other["fixed_array_field"])
                and self.int_field == other["int_field"]
                and self.string_field == other["string_field"]
                and self.tuple_field == other["tuple_field"]
                and self.vector_field == other["vector_field"]
                and self.vector_of_vectors_field == other["vector_of_vectors_field"]
                and self.fixed_vector_field == other["fixed_vector_field"]
                and other["optional_named_array"] is None if self.optional_named_array is None else (other["optional_named_array"] is not None and yardl.structural_equal(self.optional_named_array, other["optional_named_array"]))
                and self.int_float_union == other["int_float_union"]
                and self.nullable_int_float_union == other["nullable_int_float_union"]
                and self.union_with_nested_generic_union == other["union_with_nested_generic_union"]
                and self.map_field == other["map_field"]
            )
        return (
            yardl.structural_equal(self.array_field, other.array_field)
            and yardl.structural_equal(self.array_field_map_dimensions, other.array_field_map_dimensions)
            and yardl.structural_equal(self.dynamic_array_field, other.dynamic_array_field)
            and yardl.structural_equal(self.fixed_array_field, other.fixed_array_field)
            and self.int_field == other.int_field
            and self.string_field == other.string_field
            and self.tuple_field == other.tuple_field
            and self.vector_field == other.vector_field
            and self.vector_of_vectors_field == other.vector_of_vectors_field
            and self.fixed_vector_field == other.fixed_vector_field
            and other.optional_named_array is None if self.optional_named_array is None else (other.optional_named_array is not None and yardl.structural_equal(self.optional_named_array, other.optional_named_array))
            and self.int_float_union == other.int_float_union
            and self.nullable_int_float_union == other.nullable_int_float_union
            and self.union_with_nested_generic_union == other.union_with_nested_generic_union
            and self.map_field == other.map_field
        )


ArrayWithKeywordDimensionNames = npt.NDArray[np.int32]

class EnumWithKeywordSymbols(yardl.OutOfRangeEnum):
    TRY = 2
    CATCH = 1

@dataclasses.dataclass(slots=True, kw_only=True, eq=False)
class RecordWithKeywordFields:
    int_: str = ""

    sizeof: ArrayWithKeywordDimensionNames = dataclasses.field(
        default_factory=lambda: np.zeros((0, 0), dtype=np.dtype(np.int32))
    )

    if_: EnumWithKeywordSymbols

    def float_(self) -> str:
        return self.int_

    def double(self) -> str:
        return self.float_()

    def return_(self) -> yardl.Int32:
        return self.sizeof[1, 2]

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RecordWithKeywordFields):
            if (
                not isinstance(other, np.void)
                or other.dtype.fields is None
                or len(other.dtype.fields) != 3
            ):
                return False
            return (
                self.int_ == other["int_"]
                and yardl.structural_equal(self.sizeof, other["sizeof"])
                and self.if_ == other["if_"]
            )
        return (
            self.int_ == other.int_
            and yardl.structural_equal(self.sizeof, other.sizeof)
            and self.if_ == other.if_
        )


def _mk_get_dtype():
    dtype_map: dict[type | types.GenericAlias, np.dtype[typing.Any] | typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map[SmallBenchmarkRecord] = np.dtype([('a', np.dtype(np.float64)), ('b', np.dtype(np.float32)), ('c', np.dtype(np.float32))], align=True)
    dtype_map[SimpleEncodingCounters] = np.dtype([('e1', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('e2', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('slice', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('repetition', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True))], align=True)
    dtype_map[SimpleAcquisition] = np.dtype([('flags', np.dtype(np.uint64)), ('idx', get_dtype(SimpleEncodingCounters)), ('data', np.dtype(np.object_)), ('trajectory', np.dtype(np.object_))], align=True)
    dtype_map[SimpleRecord] = np.dtype([('x', np.dtype(np.int32)), ('y', np.dtype(np.int32)), ('z', np.dtype(np.int32))], align=True)
    dtype_map[RecordWithPrimitives] = np.dtype([('bool_field', np.dtype(np.bool_)), ('int_8_field', np.dtype(np.int8)), ('uint_8_field', np.dtype(np.uint8)), ('int_16_field', np.dtype(np.int16)), ('uint_16_field', np.dtype(np.uint16)), ('int_32_field', np.dtype(np.int32)), ('uint_32_field', np.dtype(np.uint32)), ('int_64_field', np.dtype(np.int64)), ('uint_64_field', np.dtype(np.uint64)), ('size_field', np.dtype(np.uint64)), ('float_32_field', np.dtype(np.float32)), ('float_64_field', np.dtype(np.float64)), ('complexfloat_32_field', np.dtype(np.complex64)), ('complexfloat_64_field', np.dtype(np.complex128)), ('date_field', np.dtype(np.datetime64)), ('time_field', np.dtype(np.timedelta64)), ('datetime_field', np.dtype(np.datetime64))], align=True)
    dtype_map[RecordWithPrimitiveAliases] = np.dtype([('byte_field', np.dtype(np.uint8)), ('int_field', np.dtype(np.int32)), ('uint_field', np.dtype(np.uint32)), ('long_field', np.dtype(np.int64)), ('ulong_field', np.dtype(np.uint64)), ('float_field', np.dtype(np.float32)), ('double_field', np.dtype(np.float64)), ('complexfloat_field', np.dtype(np.complex64)), ('complexdouble_field', np.dtype(np.complex128))], align=True)
    dtype_map[TupleWithRecords] = np.dtype([('a', get_dtype(SimpleRecord)), ('b', get_dtype(SimpleRecord))], align=True)
    dtype_map[RecordWithVectors] = np.dtype([('default_vector', np.dtype(np.object_)), ('default_vector_fixed_length', np.dtype(np.int32), (3,)), ('vector_of_vectors', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithVectorOfTimes] = np.dtype([('times', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithArrays] = np.dtype([('default_array', np.dtype(np.object_)), ('default_array_with_empty_dimension', np.dtype(np.object_)), ('rank_1_array', np.dtype(np.object_)), ('rank_2_array', np.dtype(np.object_)), ('rank_2_array_with_named_dimensions', np.dtype(np.object_)), ('rank_2_fixed_array', np.dtype(np.int32), (3, 4,)), ('rank_2_fixed_array_with_named_dimensions', np.dtype(np.int32), (3, 4,)), ('dynamic_array', np.dtype(np.object_)), ('array_of_vectors', np.dtype(np.object_), (5,))], align=True)
    dtype_map[RecordWithArraysSimpleSyntax] = np.dtype([('default_array', np.dtype(np.object_)), ('default_array_with_empty_dimension', np.dtype(np.object_)), ('rank_1_array', np.dtype(np.object_)), ('rank_2_array', np.dtype(np.object_)), ('rank_2_array_with_named_dimensions', np.dtype(np.object_)), ('rank_2_fixed_array', np.dtype(np.int32), (3, 4,)), ('rank_2_fixed_array_with_named_dimensions', np.dtype(np.int32), (3, 4,)), ('dynamic_array', np.dtype(np.object_)), ('array_of_vectors', np.dtype(np.object_), (5,))], align=True)
    dtype_map[RecordWithOptionalFields] = np.dtype([('optional_int', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optional_int_alternate_syntax', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optional_time', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.timedelta64))], align=True))], align=True)
    dtype_map[RecordWithVlens] = np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.int32)), ('c', np.dtype(np.int32))], align=True)
    dtype_map[RecordWithStrings] = np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithOptionalVector] = np.dtype([('optional_vector', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True)
    dtype_map[RecordWithFixedVectors] = np.dtype([('fixed_int_vector', np.dtype(np.int32), (5,)), ('fixed_simple_record_vector', get_dtype(SimpleRecord), (3,)), ('fixed_record_with_vlens_vector', get_dtype(RecordWithVlens), (2,))], align=True)
    dtype_map[RecordWithFixedArrays] = np.dtype([('ints', np.dtype(np.int32), (2, 3,)), ('fixed_simple_record_array', get_dtype(SimpleRecord), (3, 2,)), ('fixed_record_with_vlens_array', get_dtype(RecordWithVlens), (2, 2,))], align=True)
    dtype_map[RecordWithNDArrays] = np.dtype([('ints', np.dtype(np.object_)), ('fixed_simple_record_array', np.dtype(np.object_)), ('fixed_record_with_vlens_array', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithNDArraysSingleDimension] = np.dtype([('ints', np.dtype(np.object_)), ('fixed_simple_record_array', np.dtype(np.object_)), ('fixed_record_with_vlens_array', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithDynamicNDArrays] = np.dtype([('ints', np.dtype(np.object_)), ('simple_record_array', np.dtype(np.object_)), ('record_with_vlens_array', np.dtype(np.object_))], align=True)
    dtype_map[NamedFixedNDArray] = np.dtype(np.int32)
    dtype_map[RecordWithFixedCollections] = np.dtype([('fixed_vector', np.dtype(np.int32), (3,)), ('fixed_array', np.dtype(np.int32), (2, 3,))], align=True)
    dtype_map[RecordWithVlenCollections] = np.dtype([('vector', np.dtype(np.object_)), ('array', np.dtype(np.object_))], align=True)
    dtype_map[NamedNDArray] = np.dtype(np.object_)
    dtype_map[AliasedMap] = lambda type_args: np.dtype(np.object_)
    dtype_map[RecordWithUnions] = np.dtype([('null_or_int_or_string', np.dtype(np.object_)), ('date_or_datetime', np.dtype(np.object_))], align=True)
    dtype_map[Fruits] = np.dtype(np.int32)
    dtype_map[UInt64Enum] = np.dtype(np.uint64)
    dtype_map[Int64Enum] = np.dtype(np.int64)
    dtype_map[SizeBasedEnum] = np.dtype(np.uint64)
    dtype_map[DaysOfWeek] = np.dtype(np.int32)
    dtype_map[TextFormat] = np.dtype(np.uint64)
    dtype_map[RecordWithEnums] = np.dtype([('enum', get_dtype(Fruits)), ('flags', get_dtype(DaysOfWeek)), ('flags_2', get_dtype(TextFormat))], align=True)
    dtype_map[Image] = lambda type_args: np.dtype(np.object_)
    dtype_map[GenericRecord] = lambda type_args: np.dtype([('scalar_1', get_dtype(type_args[0])), ('scalar_2', get_dtype(type_args[1])), ('vector_1', np.dtype(np.object_)), ('image_2', get_dtype(types.GenericAlias(Image, (type_args[1],))))], align=True)
    dtype_map[MyTuple] = lambda type_args: np.dtype([('v1', get_dtype(type_args[0])), ('v2', get_dtype(type_args[1]))], align=True)
    dtype_map[AliasedString] = np.dtype(np.object_)
    dtype_map[AliasedEnum] = get_dtype(Fruits)
    dtype_map[AliasedOpenGeneric] = lambda type_args: get_dtype(types.GenericAlias(MyTuple, (type_args[0], type_args[1],)))
    dtype_map[AliasedClosedGeneric] = get_dtype(types.GenericAlias(MyTuple, (AliasedString, AliasedEnum,)))
    dtype_map[AliasedOptional] = np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)
    dtype_map[AliasedGenericOptional] = lambda type_args: np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(type_args[0]))], align=True)
    dtype_map[AliasedGenericUnion2] = lambda type_args: np.dtype(np.object_)
    dtype_map[AliasedGenericVector] = lambda type_args: np.dtype(np.object_)
    dtype_map[AliasedGenericFixedVector] = lambda type_args: get_dtype(type_args[0])
    dtype_map[AliasedIntOrSimpleRecord] = np.dtype(np.object_)
    dtype_map[AliasedNullableIntSimpleRecord] = np.dtype(np.object_)
    dtype_map[GenericRecordWithComputedFields] = lambda type_args: np.dtype([('f1', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithComputedFields] = np.dtype([('array_field', np.dtype(np.object_)), ('array_field_map_dimensions', np.dtype(np.object_)), ('dynamic_array_field', np.dtype(np.object_)), ('fixed_array_field', np.dtype(np.int32), (3, 4,)), ('int_field', np.dtype(np.int32)), ('string_field', np.dtype(np.object_)), ('tuple_field', get_dtype(types.GenericAlias(MyTuple, (yardl.Int32, yardl.Int32,)))), ('vector_field', np.dtype(np.object_)), ('vector_of_vectors_field', np.dtype(np.object_)), ('fixed_vector_field', np.dtype(np.int32), (3,)), ('optional_named_array', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(NamedNDArray))], align=True)), ('int_float_union', np.dtype(np.object_)), ('nullable_int_float_union', np.dtype(np.object_)), ('union_with_nested_generic_union', np.dtype(np.object_)), ('map_field', np.dtype(np.object_))], align=True)
    dtype_map[ArrayWithKeywordDimensionNames] = np.dtype(np.object_)
    dtype_map[EnumWithKeywordSymbols] = np.dtype(np.int32)
    dtype_map[RecordWithKeywordFields] = np.dtype([('int_', np.dtype(np.object_)), ('sizeof', get_dtype(ArrayWithKeywordDimensionNames)), ('if_', get_dtype(EnumWithKeywordSymbols))], align=True)

    return get_dtype

get_dtype = _mk_get_dtype()

