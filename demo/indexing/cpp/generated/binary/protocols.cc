// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#include <cstddef>

#include "../yardl/detail/binary/coded_stream.h"
#include "../yardl/detail/binary/serializers.h"

namespace yardl::binary {
#ifndef _MSC_VER
// Values of offsetof() are only used if types are standard-layout.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

template <>
struct IsTriviallySerializable<sketch::Header> {
  using __T__ = sketch::Header;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::subject)>::value &&
    (sizeof(__T__) == (sizeof(__T__::subject)));
};

template <>
struct IsTriviallySerializable<sketch::Sample> {
  using __T__ = sketch::Sample;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::id)>::value &&
    IsTriviallySerializable<decltype(__T__::data)>::value &&
    (sizeof(__T__) == (sizeof(__T__::id) + sizeof(__T__::data))) &&
    offsetof(__T__, id) < offsetof(__T__, data);
};

#ifndef _MSC_VER
#pragma GCC diagnostic pop // #pragma GCC diagnostic ignored "-Winvalid-offsetof" 
#endif
} //namespace yardl::binary 

namespace sketch::binary {
namespace {
[[maybe_unused]] void WriteHeader(yardl::binary::CodedOutputStream& stream, sketch::Header const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::Header>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.subject);
}

[[maybe_unused]] void ReadHeader(yardl::binary::CodedInputStream& stream, sketch::Header& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::Header>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.subject);
}

[[maybe_unused]] void WriteSample(yardl::binary::CodedOutputStream& stream, sketch::Sample const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::Sample>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.id);
  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, value.data);
}

[[maybe_unused]] void ReadSample(yardl::binary::CodedInputStream& stream, sketch::Sample& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::Sample>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.id);
  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, value.data);
}

} // namespace

void MyProtocolWriter::WriteHeaderImpl(sketch::Header const& value) {
  sketch::binary::WriteHeader(stream_, value);
}

void MyProtocolWriter::WriteSamplesImpl(sketch::Sample const& value) {
  yardl::binary::WriteBlock<sketch::Sample, sketch::binary::WriteSample>(stream_, value);
}

void MyProtocolWriter::WriteSamplesImpl(std::vector<sketch::Sample> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<sketch::Sample, sketch::binary::WriteSample>(stream_, values);
  }
}

void MyProtocolWriter::EndSamplesImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MyProtocolWriter::Flush() {
  stream_.Flush();
}

void MyProtocolWriter::CloseImpl() {
  stream_.Flush();
}

void MyProtocolReader::ReadHeaderImpl(sketch::Header& value) {
  sketch::binary::ReadHeader(stream_, value);
}

bool MyProtocolReader::ReadSamplesImpl(sketch::Sample& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<sketch::Sample, sketch::binary::ReadSample>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MyProtocolReader::ReadSamplesImpl(std::vector<sketch::Sample>& values) {
  yardl::binary::ReadBlocksIntoVector<sketch::Sample, sketch::binary::ReadSample>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void MyProtocolReader::CloseImpl() {
  stream_.VerifyFinished();
}

void MyProtocolIndexedWriter::WriteHeaderImpl(sketch::Header const& value) {
  auto pos = stream_.Pos();
  step_index_.set_step_offset("Header", pos);
  sketch::binary::WriteHeader(stream_, value);
}

void MyProtocolIndexedWriter::WriteSamplesImpl(sketch::Sample const& value) {
  auto pos = stream_.Pos();
  step_index_.set_step_offset("Samples", pos);
  size_t item_offset = 0;
  yardl::binary::WriteBlockAndSaveOffset<sketch::Sample, sketch::binary::WriteSample>(stream_, value, item_offset);
  step_index_.add_stream_offset("Samples", item_offset);
}

void MyProtocolIndexedWriter::WriteSamplesImpl(std::vector<sketch::Sample> const& values) {
  if (!values.empty()) {
    step_index_.set_step_offset("Samples", stream_.Pos());
    std::vector<size_t> item_offsets;
    item_offsets.reserve(values.size());
    yardl::binary::WriteVectorAndSaveOffsets<sketch::Sample, sketch::binary::WriteSample>(stream_, values, item_offsets);
    step_index_.add_stream_offsets("Samples", item_offsets);
  }
}

void MyProtocolIndexedWriter::EndSamplesImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MyProtocolIndexedWriter::Flush() {
  stream_.Flush();
}

void MyProtocolIndexedWriter::CloseImpl() {
  yardl::binary::WriteIndex(stream_, step_index_);

  stream_.Flush();
}

void MyProtocolIndexedReader::ReadHeaderImpl(sketch::Header& value) {
  auto pos = step_index_.get_step_offset("Header");
  stream_.Seek(pos);
  sketch::binary::ReadHeader(stream_, value);
}

bool MyProtocolIndexedReader::ReadSamplesImpl(sketch::Sample& value, size_t idx) {
  size_t abs_offset = 0, items_remaining = 0;
  if (!step_index_.find_stream_item("Samples", idx, abs_offset, items_remaining)) {
    return false;
  }
  stream_.Seek(abs_offset);
  current_block_remaining_ = items_remaining;
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<sketch::Sample, sketch::binary::ReadSample>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MyProtocolIndexedReader::ReadSamplesImpl(std::vector<sketch::Sample>& values, size_t idx) {
  size_t abs_offset = 0, items_remaining = 0;
  if (!step_index_.find_stream_item("Samples", idx, abs_offset, items_remaining)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  current_block_remaining_ = items_remaining;
  yardl::binary::ReadBlocksIntoVector<sketch::Sample, sketch::binary::ReadSample>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void MyProtocolIndexedReader::CloseImpl() {
}

} // namespace sketch::binary

