# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedClass=false
# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import collections.abc
import io
import typing

import numpy as np
import numpy.typing as npt

from .types import *

from .protocols import *
from . import _ndjson
from . import yardl_types as yardl

class SmallBenchmarkRecordConverter(_ndjson.JsonConverter[SmallBenchmarkRecord, np.void]):
    def __init__(self) -> None:
        self._a_converter = _ndjson.float64_converter
        self._b_converter = _ndjson.float32_converter
        self._c_converter = _ndjson.float32_converter
        super().__init__(np.dtype([
            ("a", self._a_converter.overall_dtype()),
            ("b", self._b_converter.overall_dtype()),
            ("c", self._c_converter.overall_dtype()),
        ]))

    def to_json(self, value: SmallBenchmarkRecord) -> object:
        if not isinstance(value, SmallBenchmarkRecord): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'SmallBenchmarkRecord' instance")
        json_object = {}

        json_object["a"] = self._a_converter.to_json(value.a)
        json_object["b"] = self._b_converter.to_json(value.b)
        json_object["c"] = self._c_converter.to_json(value.c)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["a"] = self._a_converter.numpy_to_json(value["a"])
        json_object["b"] = self._b_converter.numpy_to_json(value["b"])
        json_object["c"] = self._c_converter.numpy_to_json(value["c"])
        return json_object

    def from_json(self, json_object: object) -> SmallBenchmarkRecord:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return SmallBenchmarkRecord(
            a=self._a_converter.from_json(json_object["a"],),
            b=self._b_converter.from_json(json_object["b"],),
            c=self._c_converter.from_json(json_object["c"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._a_converter.from_json_to_numpy(json_object["a"]),
            self._b_converter.from_json_to_numpy(json_object["b"]),
            self._c_converter.from_json_to_numpy(json_object["c"]),
        ) # type:ignore 


class SimpleEncodingCountersConverter(_ndjson.JsonConverter[SimpleEncodingCounters, np.void]):
    def __init__(self) -> None:
        self._e1_converter = _ndjson.OptionalConverter(_ndjson.uint32_converter)
        self._e2_converter = _ndjson.OptionalConverter(_ndjson.uint32_converter)
        self._slice_converter = _ndjson.OptionalConverter(_ndjson.uint32_converter)
        self._repetition_converter = _ndjson.OptionalConverter(_ndjson.uint32_converter)
        super().__init__(np.dtype([
            ("e1", self._e1_converter.overall_dtype()),
            ("e2", self._e2_converter.overall_dtype()),
            ("slice", self._slice_converter.overall_dtype()),
            ("repetition", self._repetition_converter.overall_dtype()),
        ]))

    def to_json(self, value: SimpleEncodingCounters) -> object:
        if not isinstance(value, SimpleEncodingCounters): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'SimpleEncodingCounters' instance")
        json_object = {}

        if value.e1 is not None:
            json_object["e1"] = self._e1_converter.to_json(value.e1)
        if value.e2 is not None:
            json_object["e2"] = self._e2_converter.to_json(value.e2)
        if value.slice is not None:
            json_object["slice"] = self._slice_converter.to_json(value.slice)
        if value.repetition is not None:
            json_object["repetition"] = self._repetition_converter.to_json(value.repetition)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["e1"]) is not None:
            json_object["e1"] = self._e1_converter.numpy_to_json(field_val)
        if (field_val := value["e2"]) is not None:
            json_object["e2"] = self._e2_converter.numpy_to_json(field_val)
        if (field_val := value["slice"]) is not None:
            json_object["slice"] = self._slice_converter.numpy_to_json(field_val)
        if (field_val := value["repetition"]) is not None:
            json_object["repetition"] = self._repetition_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> SimpleEncodingCounters:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return SimpleEncodingCounters(
            e1=self._e1_converter.from_json(json_object.get("e1")),
            e2=self._e2_converter.from_json(json_object.get("e2")),
            slice=self._slice_converter.from_json(json_object.get("slice")),
            repetition=self._repetition_converter.from_json(json_object.get("repetition")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._e1_converter.from_json_to_numpy(json_object.get("e1")),
            self._e2_converter.from_json_to_numpy(json_object.get("e2")),
            self._slice_converter.from_json_to_numpy(json_object.get("slice")),
            self._repetition_converter.from_json_to_numpy(json_object.get("repetition")),
        ) # type:ignore 


class SimpleAcquisitionConverter(_ndjson.JsonConverter[SimpleAcquisition, np.void]):
    def __init__(self) -> None:
        self._flags_converter = _ndjson.uint64_converter
        self._idx_converter = SimpleEncodingCountersConverter()
        self._data_converter = _ndjson.NDArrayConverter(_ndjson.complexfloat32_converter, 2)
        self._trajectory_converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 2)
        super().__init__(np.dtype([
            ("flags", self._flags_converter.overall_dtype()),
            ("idx", self._idx_converter.overall_dtype()),
            ("data", self._data_converter.overall_dtype()),
            ("trajectory", self._trajectory_converter.overall_dtype()),
        ]))

    def to_json(self, value: SimpleAcquisition) -> object:
        if not isinstance(value, SimpleAcquisition): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'SimpleAcquisition' instance")
        json_object = {}

        json_object["flags"] = self._flags_converter.to_json(value.flags)
        json_object["idx"] = self._idx_converter.to_json(value.idx)
        json_object["data"] = self._data_converter.to_json(value.data)
        json_object["trajectory"] = self._trajectory_converter.to_json(value.trajectory)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["flags"] = self._flags_converter.numpy_to_json(value["flags"])
        json_object["idx"] = self._idx_converter.numpy_to_json(value["idx"])
        json_object["data"] = self._data_converter.numpy_to_json(value["data"])
        json_object["trajectory"] = self._trajectory_converter.numpy_to_json(value["trajectory"])
        return json_object

    def from_json(self, json_object: object) -> SimpleAcquisition:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return SimpleAcquisition(
            flags=self._flags_converter.from_json(json_object["flags"],),
            idx=self._idx_converter.from_json(json_object["idx"],),
            data=self._data_converter.from_json(json_object["data"],),
            trajectory=self._trajectory_converter.from_json(json_object["trajectory"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._flags_converter.from_json_to_numpy(json_object["flags"]),
            self._idx_converter.from_json_to_numpy(json_object["idx"]),
            self._data_converter.from_json_to_numpy(json_object["data"]),
            self._trajectory_converter.from_json_to_numpy(json_object["trajectory"]),
        ) # type:ignore 


class SimpleRecordConverter(_ndjson.JsonConverter[SimpleRecord, np.void]):
    def __init__(self) -> None:
        self._x_converter = _ndjson.int32_converter
        self._y_converter = _ndjson.int32_converter
        self._z_converter = _ndjson.int32_converter
        super().__init__(np.dtype([
            ("x", self._x_converter.overall_dtype()),
            ("y", self._y_converter.overall_dtype()),
            ("z", self._z_converter.overall_dtype()),
        ]))

    def to_json(self, value: SimpleRecord) -> object:
        if not isinstance(value, SimpleRecord): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'SimpleRecord' instance")
        json_object = {}

        json_object["x"] = self._x_converter.to_json(value.x)
        json_object["y"] = self._y_converter.to_json(value.y)
        json_object["z"] = self._z_converter.to_json(value.z)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["x"] = self._x_converter.numpy_to_json(value["x"])
        json_object["y"] = self._y_converter.numpy_to_json(value["y"])
        json_object["z"] = self._z_converter.numpy_to_json(value["z"])
        return json_object

    def from_json(self, json_object: object) -> SimpleRecord:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return SimpleRecord(
            x=self._x_converter.from_json(json_object["x"],),
            y=self._y_converter.from_json(json_object["y"],),
            z=self._z_converter.from_json(json_object["z"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._x_converter.from_json_to_numpy(json_object["x"]),
            self._y_converter.from_json_to_numpy(json_object["y"]),
            self._z_converter.from_json_to_numpy(json_object["z"]),
        ) # type:ignore 


class RecordWithPrimitivesConverter(_ndjson.JsonConverter[RecordWithPrimitives, np.void]):
    def __init__(self) -> None:
        self._bool_field_converter = _ndjson.bool_converter
        self._int8_field_converter = _ndjson.int8_converter
        self._uint8_field_converter = _ndjson.uint8_converter
        self._int16_field_converter = _ndjson.int16_converter
        self._uint16_field_converter = _ndjson.uint16_converter
        self._int32_field_converter = _ndjson.int32_converter
        self._uint32_field_converter = _ndjson.uint32_converter
        self._int64_field_converter = _ndjson.int64_converter
        self._uint64_field_converter = _ndjson.uint64_converter
        self._size_field_converter = _ndjson.size_converter
        self._float32_field_converter = _ndjson.float32_converter
        self._float64_field_converter = _ndjson.float64_converter
        self._complexfloat32_field_converter = _ndjson.complexfloat32_converter
        self._complexfloat64_field_converter = _ndjson.complexfloat64_converter
        self._date_field_converter = _ndjson.date_converter
        self._time_field_converter = _ndjson.time_converter
        self._datetime_field_converter = _ndjson.datetime_converter
        super().__init__(np.dtype([
            ("bool_field", self._bool_field_converter.overall_dtype()),
            ("int8_field", self._int8_field_converter.overall_dtype()),
            ("uint8_field", self._uint8_field_converter.overall_dtype()),
            ("int16_field", self._int16_field_converter.overall_dtype()),
            ("uint16_field", self._uint16_field_converter.overall_dtype()),
            ("int32_field", self._int32_field_converter.overall_dtype()),
            ("uint32_field", self._uint32_field_converter.overall_dtype()),
            ("int64_field", self._int64_field_converter.overall_dtype()),
            ("uint64_field", self._uint64_field_converter.overall_dtype()),
            ("size_field", self._size_field_converter.overall_dtype()),
            ("float32_field", self._float32_field_converter.overall_dtype()),
            ("float64_field", self._float64_field_converter.overall_dtype()),
            ("complexfloat32_field", self._complexfloat32_field_converter.overall_dtype()),
            ("complexfloat64_field", self._complexfloat64_field_converter.overall_dtype()),
            ("date_field", self._date_field_converter.overall_dtype()),
            ("time_field", self._time_field_converter.overall_dtype()),
            ("datetime_field", self._datetime_field_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithPrimitives) -> object:
        if not isinstance(value, RecordWithPrimitives): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithPrimitives' instance")
        json_object = {}

        json_object["boolField"] = self._bool_field_converter.to_json(value.bool_field)
        json_object["int8Field"] = self._int8_field_converter.to_json(value.int8_field)
        json_object["uint8Field"] = self._uint8_field_converter.to_json(value.uint8_field)
        json_object["int16Field"] = self._int16_field_converter.to_json(value.int16_field)
        json_object["uint16Field"] = self._uint16_field_converter.to_json(value.uint16_field)
        json_object["int32Field"] = self._int32_field_converter.to_json(value.int32_field)
        json_object["uint32Field"] = self._uint32_field_converter.to_json(value.uint32_field)
        json_object["int64Field"] = self._int64_field_converter.to_json(value.int64_field)
        json_object["uint64Field"] = self._uint64_field_converter.to_json(value.uint64_field)
        json_object["sizeField"] = self._size_field_converter.to_json(value.size_field)
        json_object["float32Field"] = self._float32_field_converter.to_json(value.float32_field)
        json_object["float64Field"] = self._float64_field_converter.to_json(value.float64_field)
        json_object["complexfloat32Field"] = self._complexfloat32_field_converter.to_json(value.complexfloat32_field)
        json_object["complexfloat64Field"] = self._complexfloat64_field_converter.to_json(value.complexfloat64_field)
        json_object["dateField"] = self._date_field_converter.to_json(value.date_field)
        json_object["timeField"] = self._time_field_converter.to_json(value.time_field)
        json_object["datetimeField"] = self._datetime_field_converter.to_json(value.datetime_field)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["boolField"] = self._bool_field_converter.numpy_to_json(value["bool_field"])
        json_object["int8Field"] = self._int8_field_converter.numpy_to_json(value["int8_field"])
        json_object["uint8Field"] = self._uint8_field_converter.numpy_to_json(value["uint8_field"])
        json_object["int16Field"] = self._int16_field_converter.numpy_to_json(value["int16_field"])
        json_object["uint16Field"] = self._uint16_field_converter.numpy_to_json(value["uint16_field"])
        json_object["int32Field"] = self._int32_field_converter.numpy_to_json(value["int32_field"])
        json_object["uint32Field"] = self._uint32_field_converter.numpy_to_json(value["uint32_field"])
        json_object["int64Field"] = self._int64_field_converter.numpy_to_json(value["int64_field"])
        json_object["uint64Field"] = self._uint64_field_converter.numpy_to_json(value["uint64_field"])
        json_object["sizeField"] = self._size_field_converter.numpy_to_json(value["size_field"])
        json_object["float32Field"] = self._float32_field_converter.numpy_to_json(value["float32_field"])
        json_object["float64Field"] = self._float64_field_converter.numpy_to_json(value["float64_field"])
        json_object["complexfloat32Field"] = self._complexfloat32_field_converter.numpy_to_json(value["complexfloat32_field"])
        json_object["complexfloat64Field"] = self._complexfloat64_field_converter.numpy_to_json(value["complexfloat64_field"])
        json_object["dateField"] = self._date_field_converter.numpy_to_json(value["date_field"])
        json_object["timeField"] = self._time_field_converter.numpy_to_json(value["time_field"])
        json_object["datetimeField"] = self._datetime_field_converter.numpy_to_json(value["datetime_field"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithPrimitives:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithPrimitives(
            bool_field=self._bool_field_converter.from_json(json_object["boolField"],),
            int8_field=self._int8_field_converter.from_json(json_object["int8Field"],),
            uint8_field=self._uint8_field_converter.from_json(json_object["uint8Field"],),
            int16_field=self._int16_field_converter.from_json(json_object["int16Field"],),
            uint16_field=self._uint16_field_converter.from_json(json_object["uint16Field"],),
            int32_field=self._int32_field_converter.from_json(json_object["int32Field"],),
            uint32_field=self._uint32_field_converter.from_json(json_object["uint32Field"],),
            int64_field=self._int64_field_converter.from_json(json_object["int64Field"],),
            uint64_field=self._uint64_field_converter.from_json(json_object["uint64Field"],),
            size_field=self._size_field_converter.from_json(json_object["sizeField"],),
            float32_field=self._float32_field_converter.from_json(json_object["float32Field"],),
            float64_field=self._float64_field_converter.from_json(json_object["float64Field"],),
            complexfloat32_field=self._complexfloat32_field_converter.from_json(json_object["complexfloat32Field"],),
            complexfloat64_field=self._complexfloat64_field_converter.from_json(json_object["complexfloat64Field"],),
            date_field=self._date_field_converter.from_json(json_object["dateField"],),
            time_field=self._time_field_converter.from_json(json_object["timeField"],),
            datetime_field=self._datetime_field_converter.from_json(json_object["datetimeField"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._bool_field_converter.from_json_to_numpy(json_object["boolField"]),
            self._int8_field_converter.from_json_to_numpy(json_object["int8Field"]),
            self._uint8_field_converter.from_json_to_numpy(json_object["uint8Field"]),
            self._int16_field_converter.from_json_to_numpy(json_object["int16Field"]),
            self._uint16_field_converter.from_json_to_numpy(json_object["uint16Field"]),
            self._int32_field_converter.from_json_to_numpy(json_object["int32Field"]),
            self._uint32_field_converter.from_json_to_numpy(json_object["uint32Field"]),
            self._int64_field_converter.from_json_to_numpy(json_object["int64Field"]),
            self._uint64_field_converter.from_json_to_numpy(json_object["uint64Field"]),
            self._size_field_converter.from_json_to_numpy(json_object["sizeField"]),
            self._float32_field_converter.from_json_to_numpy(json_object["float32Field"]),
            self._float64_field_converter.from_json_to_numpy(json_object["float64Field"]),
            self._complexfloat32_field_converter.from_json_to_numpy(json_object["complexfloat32Field"]),
            self._complexfloat64_field_converter.from_json_to_numpy(json_object["complexfloat64Field"]),
            self._date_field_converter.from_json_to_numpy(json_object["dateField"]),
            self._time_field_converter.from_json_to_numpy(json_object["timeField"]),
            self._datetime_field_converter.from_json_to_numpy(json_object["datetimeField"]),
        ) # type:ignore 


class RecordWithPrimitiveAliasesConverter(_ndjson.JsonConverter[RecordWithPrimitiveAliases, np.void]):
    def __init__(self) -> None:
        self._byte_field_converter = _ndjson.uint8_converter
        self._int_field_converter = _ndjson.int32_converter
        self._uint_field_converter = _ndjson.uint32_converter
        self._long_field_converter = _ndjson.int64_converter
        self._ulong_field_converter = _ndjson.uint64_converter
        self._float_field_converter = _ndjson.float32_converter
        self._double_field_converter = _ndjson.float64_converter
        self._complexfloat_field_converter = _ndjson.complexfloat32_converter
        self._complexdouble_field_converter = _ndjson.complexfloat64_converter
        super().__init__(np.dtype([
            ("byte_field", self._byte_field_converter.overall_dtype()),
            ("int_field", self._int_field_converter.overall_dtype()),
            ("uint_field", self._uint_field_converter.overall_dtype()),
            ("long_field", self._long_field_converter.overall_dtype()),
            ("ulong_field", self._ulong_field_converter.overall_dtype()),
            ("float_field", self._float_field_converter.overall_dtype()),
            ("double_field", self._double_field_converter.overall_dtype()),
            ("complexfloat_field", self._complexfloat_field_converter.overall_dtype()),
            ("complexdouble_field", self._complexdouble_field_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithPrimitiveAliases) -> object:
        if not isinstance(value, RecordWithPrimitiveAliases): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithPrimitiveAliases' instance")
        json_object = {}

        json_object["byteField"] = self._byte_field_converter.to_json(value.byte_field)
        json_object["intField"] = self._int_field_converter.to_json(value.int_field)
        json_object["uintField"] = self._uint_field_converter.to_json(value.uint_field)
        json_object["longField"] = self._long_field_converter.to_json(value.long_field)
        json_object["ulongField"] = self._ulong_field_converter.to_json(value.ulong_field)
        json_object["floatField"] = self._float_field_converter.to_json(value.float_field)
        json_object["doubleField"] = self._double_field_converter.to_json(value.double_field)
        json_object["complexfloatField"] = self._complexfloat_field_converter.to_json(value.complexfloat_field)
        json_object["complexdoubleField"] = self._complexdouble_field_converter.to_json(value.complexdouble_field)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["byteField"] = self._byte_field_converter.numpy_to_json(value["byte_field"])
        json_object["intField"] = self._int_field_converter.numpy_to_json(value["int_field"])
        json_object["uintField"] = self._uint_field_converter.numpy_to_json(value["uint_field"])
        json_object["longField"] = self._long_field_converter.numpy_to_json(value["long_field"])
        json_object["ulongField"] = self._ulong_field_converter.numpy_to_json(value["ulong_field"])
        json_object["floatField"] = self._float_field_converter.numpy_to_json(value["float_field"])
        json_object["doubleField"] = self._double_field_converter.numpy_to_json(value["double_field"])
        json_object["complexfloatField"] = self._complexfloat_field_converter.numpy_to_json(value["complexfloat_field"])
        json_object["complexdoubleField"] = self._complexdouble_field_converter.numpy_to_json(value["complexdouble_field"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithPrimitiveAliases:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithPrimitiveAliases(
            byte_field=self._byte_field_converter.from_json(json_object["byteField"],),
            int_field=self._int_field_converter.from_json(json_object["intField"],),
            uint_field=self._uint_field_converter.from_json(json_object["uintField"],),
            long_field=self._long_field_converter.from_json(json_object["longField"],),
            ulong_field=self._ulong_field_converter.from_json(json_object["ulongField"],),
            float_field=self._float_field_converter.from_json(json_object["floatField"],),
            double_field=self._double_field_converter.from_json(json_object["doubleField"],),
            complexfloat_field=self._complexfloat_field_converter.from_json(json_object["complexfloatField"],),
            complexdouble_field=self._complexdouble_field_converter.from_json(json_object["complexdoubleField"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._byte_field_converter.from_json_to_numpy(json_object["byteField"]),
            self._int_field_converter.from_json_to_numpy(json_object["intField"]),
            self._uint_field_converter.from_json_to_numpy(json_object["uintField"]),
            self._long_field_converter.from_json_to_numpy(json_object["longField"]),
            self._ulong_field_converter.from_json_to_numpy(json_object["ulongField"]),
            self._float_field_converter.from_json_to_numpy(json_object["floatField"]),
            self._double_field_converter.from_json_to_numpy(json_object["doubleField"]),
            self._complexfloat_field_converter.from_json_to_numpy(json_object["complexfloatField"]),
            self._complexdouble_field_converter.from_json_to_numpy(json_object["complexdoubleField"]),
        ) # type:ignore 


class TupleWithRecordsConverter(_ndjson.JsonConverter[TupleWithRecords, np.void]):
    def __init__(self) -> None:
        self._a_converter = SimpleRecordConverter()
        self._b_converter = SimpleRecordConverter()
        super().__init__(np.dtype([
            ("a", self._a_converter.overall_dtype()),
            ("b", self._b_converter.overall_dtype()),
        ]))

    def to_json(self, value: TupleWithRecords) -> object:
        if not isinstance(value, TupleWithRecords): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'TupleWithRecords' instance")
        json_object = {}

        json_object["a"] = self._a_converter.to_json(value.a)
        json_object["b"] = self._b_converter.to_json(value.b)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["a"] = self._a_converter.numpy_to_json(value["a"])
        json_object["b"] = self._b_converter.numpy_to_json(value["b"])
        return json_object

    def from_json(self, json_object: object) -> TupleWithRecords:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return TupleWithRecords(
            a=self._a_converter.from_json(json_object["a"],),
            b=self._b_converter.from_json(json_object["b"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._a_converter.from_json_to_numpy(json_object["a"]),
            self._b_converter.from_json_to_numpy(json_object["b"]),
        ) # type:ignore 


class RecordWithVectorsConverter(_ndjson.JsonConverter[RecordWithVectors, np.void]):
    def __init__(self) -> None:
        self._default_vector_converter = _ndjson.VectorConverter(_ndjson.int32_converter)
        self._default_vector_fixed_length_converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 3)
        self._vector_of_vectors_converter = _ndjson.VectorConverter(_ndjson.FixedVectorConverter(_ndjson.int32_converter, 2))
        super().__init__(np.dtype([
            ("default_vector", self._default_vector_converter.overall_dtype()),
            ("default_vector_fixed_length", self._default_vector_fixed_length_converter.overall_dtype()),
            ("vector_of_vectors", self._vector_of_vectors_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithVectors) -> object:
        if not isinstance(value, RecordWithVectors): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithVectors' instance")
        json_object = {}

        json_object["defaultVector"] = self._default_vector_converter.to_json(value.default_vector)
        json_object["defaultVectorFixedLength"] = self._default_vector_fixed_length_converter.to_json(value.default_vector_fixed_length)
        json_object["vectorOfVectors"] = self._vector_of_vectors_converter.to_json(value.vector_of_vectors)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["defaultVector"] = self._default_vector_converter.numpy_to_json(value["default_vector"])
        json_object["defaultVectorFixedLength"] = self._default_vector_fixed_length_converter.numpy_to_json(value["default_vector_fixed_length"])
        json_object["vectorOfVectors"] = self._vector_of_vectors_converter.numpy_to_json(value["vector_of_vectors"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithVectors:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithVectors(
            default_vector=self._default_vector_converter.from_json(json_object["defaultVector"],),
            default_vector_fixed_length=self._default_vector_fixed_length_converter.from_json(json_object["defaultVectorFixedLength"],),
            vector_of_vectors=self._vector_of_vectors_converter.from_json(json_object["vectorOfVectors"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._default_vector_converter.from_json_to_numpy(json_object["defaultVector"]),
            self._default_vector_fixed_length_converter.from_json_to_numpy(json_object["defaultVectorFixedLength"]),
            self._vector_of_vectors_converter.from_json_to_numpy(json_object["vectorOfVectors"]),
        ) # type:ignore 


class RecordWithVectorOfTimesConverter(_ndjson.JsonConverter[RecordWithVectorOfTimes, np.void]):
    def __init__(self) -> None:
        self._times_converter = _ndjson.VectorConverter(_ndjson.time_converter)
        super().__init__(np.dtype([
            ("times", self._times_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithVectorOfTimes) -> object:
        if not isinstance(value, RecordWithVectorOfTimes): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithVectorOfTimes' instance")
        json_object = {}

        json_object["times"] = self._times_converter.to_json(value.times)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["times"] = self._times_converter.numpy_to_json(value["times"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithVectorOfTimes:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithVectorOfTimes(
            times=self._times_converter.from_json(json_object["times"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._times_converter.from_json_to_numpy(json_object["times"]),
        ) # type:ignore 


class RecordWithArraysConverter(_ndjson.JsonConverter[RecordWithArrays, np.void]):
    def __init__(self) -> None:
        self._default_array_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._default_array_with_empty_dimension_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._rank_1_array_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 1)
        self._rank_2_array_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._rank_2_array_with_named_dimensions_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._rank_2_fixed_array_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3, 4,))
        self._rank_2_fixed_array_with_named_dimensions_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3, 4,))
        self._dynamic_array_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._array_of_vectors_converter = _ndjson.FixedNDArrayConverter(_ndjson.FixedVectorConverter(_ndjson.int32_converter, 4), (5,))
        super().__init__(np.dtype([
            ("default_array", self._default_array_converter.overall_dtype()),
            ("default_array_with_empty_dimension", self._default_array_with_empty_dimension_converter.overall_dtype()),
            ("rank_1_array", self._rank_1_array_converter.overall_dtype()),
            ("rank_2_array", self._rank_2_array_converter.overall_dtype()),
            ("rank_2_array_with_named_dimensions", self._rank_2_array_with_named_dimensions_converter.overall_dtype()),
            ("rank_2_fixed_array", self._rank_2_fixed_array_converter.overall_dtype()),
            ("rank_2_fixed_array_with_named_dimensions", self._rank_2_fixed_array_with_named_dimensions_converter.overall_dtype()),
            ("dynamic_array", self._dynamic_array_converter.overall_dtype()),
            ("array_of_vectors", self._array_of_vectors_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithArrays) -> object:
        if not isinstance(value, RecordWithArrays): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithArrays' instance")
        json_object = {}

        json_object["defaultArray"] = self._default_array_converter.to_json(value.default_array)
        json_object["defaultArrayWithEmptyDimension"] = self._default_array_with_empty_dimension_converter.to_json(value.default_array_with_empty_dimension)
        json_object["rank1Array"] = self._rank_1_array_converter.to_json(value.rank_1_array)
        json_object["rank2Array"] = self._rank_2_array_converter.to_json(value.rank_2_array)
        json_object["rank2ArrayWithNamedDimensions"] = self._rank_2_array_with_named_dimensions_converter.to_json(value.rank_2_array_with_named_dimensions)
        json_object["rank2FixedArray"] = self._rank_2_fixed_array_converter.to_json(value.rank_2_fixed_array)
        json_object["rank2FixedArrayWithNamedDimensions"] = self._rank_2_fixed_array_with_named_dimensions_converter.to_json(value.rank_2_fixed_array_with_named_dimensions)
        json_object["dynamicArray"] = self._dynamic_array_converter.to_json(value.dynamic_array)
        json_object["arrayOfVectors"] = self._array_of_vectors_converter.to_json(value.array_of_vectors)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["defaultArray"] = self._default_array_converter.numpy_to_json(value["default_array"])
        json_object["defaultArrayWithEmptyDimension"] = self._default_array_with_empty_dimension_converter.numpy_to_json(value["default_array_with_empty_dimension"])
        json_object["rank1Array"] = self._rank_1_array_converter.numpy_to_json(value["rank_1_array"])
        json_object["rank2Array"] = self._rank_2_array_converter.numpy_to_json(value["rank_2_array"])
        json_object["rank2ArrayWithNamedDimensions"] = self._rank_2_array_with_named_dimensions_converter.numpy_to_json(value["rank_2_array_with_named_dimensions"])
        json_object["rank2FixedArray"] = self._rank_2_fixed_array_converter.numpy_to_json(value["rank_2_fixed_array"])
        json_object["rank2FixedArrayWithNamedDimensions"] = self._rank_2_fixed_array_with_named_dimensions_converter.numpy_to_json(value["rank_2_fixed_array_with_named_dimensions"])
        json_object["dynamicArray"] = self._dynamic_array_converter.numpy_to_json(value["dynamic_array"])
        json_object["arrayOfVectors"] = self._array_of_vectors_converter.numpy_to_json(value["array_of_vectors"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithArrays:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithArrays(
            default_array=self._default_array_converter.from_json(json_object["defaultArray"],),
            default_array_with_empty_dimension=self._default_array_with_empty_dimension_converter.from_json(json_object["defaultArrayWithEmptyDimension"],),
            rank_1_array=self._rank_1_array_converter.from_json(json_object["rank1Array"],),
            rank_2_array=self._rank_2_array_converter.from_json(json_object["rank2Array"],),
            rank_2_array_with_named_dimensions=self._rank_2_array_with_named_dimensions_converter.from_json(json_object["rank2ArrayWithNamedDimensions"],),
            rank_2_fixed_array=self._rank_2_fixed_array_converter.from_json(json_object["rank2FixedArray"],),
            rank_2_fixed_array_with_named_dimensions=self._rank_2_fixed_array_with_named_dimensions_converter.from_json(json_object["rank2FixedArrayWithNamedDimensions"],),
            dynamic_array=self._dynamic_array_converter.from_json(json_object["dynamicArray"],),
            array_of_vectors=self._array_of_vectors_converter.from_json(json_object["arrayOfVectors"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._default_array_converter.from_json_to_numpy(json_object["defaultArray"]),
            self._default_array_with_empty_dimension_converter.from_json_to_numpy(json_object["defaultArrayWithEmptyDimension"]),
            self._rank_1_array_converter.from_json_to_numpy(json_object["rank1Array"]),
            self._rank_2_array_converter.from_json_to_numpy(json_object["rank2Array"]),
            self._rank_2_array_with_named_dimensions_converter.from_json_to_numpy(json_object["rank2ArrayWithNamedDimensions"]),
            self._rank_2_fixed_array_converter.from_json_to_numpy(json_object["rank2FixedArray"]),
            self._rank_2_fixed_array_with_named_dimensions_converter.from_json_to_numpy(json_object["rank2FixedArrayWithNamedDimensions"]),
            self._dynamic_array_converter.from_json_to_numpy(json_object["dynamicArray"]),
            self._array_of_vectors_converter.from_json_to_numpy(json_object["arrayOfVectors"]),
        ) # type:ignore 


class RecordWithArraysSimpleSyntaxConverter(_ndjson.JsonConverter[RecordWithArraysSimpleSyntax, np.void]):
    def __init__(self) -> None:
        self._default_array_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._default_array_with_empty_dimension_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._rank_1_array_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 1)
        self._rank_2_array_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._rank_2_array_with_named_dimensions_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._rank_2_fixed_array_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3, 4,))
        self._rank_2_fixed_array_with_named_dimensions_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3, 4,))
        self._dynamic_array_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._array_of_vectors_converter = _ndjson.FixedNDArrayConverter(_ndjson.FixedVectorConverter(_ndjson.int32_converter, 4), (5,))
        super().__init__(np.dtype([
            ("default_array", self._default_array_converter.overall_dtype()),
            ("default_array_with_empty_dimension", self._default_array_with_empty_dimension_converter.overall_dtype()),
            ("rank_1_array", self._rank_1_array_converter.overall_dtype()),
            ("rank_2_array", self._rank_2_array_converter.overall_dtype()),
            ("rank_2_array_with_named_dimensions", self._rank_2_array_with_named_dimensions_converter.overall_dtype()),
            ("rank_2_fixed_array", self._rank_2_fixed_array_converter.overall_dtype()),
            ("rank_2_fixed_array_with_named_dimensions", self._rank_2_fixed_array_with_named_dimensions_converter.overall_dtype()),
            ("dynamic_array", self._dynamic_array_converter.overall_dtype()),
            ("array_of_vectors", self._array_of_vectors_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithArraysSimpleSyntax) -> object:
        if not isinstance(value, RecordWithArraysSimpleSyntax): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithArraysSimpleSyntax' instance")
        json_object = {}

        json_object["defaultArray"] = self._default_array_converter.to_json(value.default_array)
        json_object["defaultArrayWithEmptyDimension"] = self._default_array_with_empty_dimension_converter.to_json(value.default_array_with_empty_dimension)
        json_object["rank1Array"] = self._rank_1_array_converter.to_json(value.rank_1_array)
        json_object["rank2Array"] = self._rank_2_array_converter.to_json(value.rank_2_array)
        json_object["rank2ArrayWithNamedDimensions"] = self._rank_2_array_with_named_dimensions_converter.to_json(value.rank_2_array_with_named_dimensions)
        json_object["rank2FixedArray"] = self._rank_2_fixed_array_converter.to_json(value.rank_2_fixed_array)
        json_object["rank2FixedArrayWithNamedDimensions"] = self._rank_2_fixed_array_with_named_dimensions_converter.to_json(value.rank_2_fixed_array_with_named_dimensions)
        json_object["dynamicArray"] = self._dynamic_array_converter.to_json(value.dynamic_array)
        json_object["arrayOfVectors"] = self._array_of_vectors_converter.to_json(value.array_of_vectors)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["defaultArray"] = self._default_array_converter.numpy_to_json(value["default_array"])
        json_object["defaultArrayWithEmptyDimension"] = self._default_array_with_empty_dimension_converter.numpy_to_json(value["default_array_with_empty_dimension"])
        json_object["rank1Array"] = self._rank_1_array_converter.numpy_to_json(value["rank_1_array"])
        json_object["rank2Array"] = self._rank_2_array_converter.numpy_to_json(value["rank_2_array"])
        json_object["rank2ArrayWithNamedDimensions"] = self._rank_2_array_with_named_dimensions_converter.numpy_to_json(value["rank_2_array_with_named_dimensions"])
        json_object["rank2FixedArray"] = self._rank_2_fixed_array_converter.numpy_to_json(value["rank_2_fixed_array"])
        json_object["rank2FixedArrayWithNamedDimensions"] = self._rank_2_fixed_array_with_named_dimensions_converter.numpy_to_json(value["rank_2_fixed_array_with_named_dimensions"])
        json_object["dynamicArray"] = self._dynamic_array_converter.numpy_to_json(value["dynamic_array"])
        json_object["arrayOfVectors"] = self._array_of_vectors_converter.numpy_to_json(value["array_of_vectors"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithArraysSimpleSyntax:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithArraysSimpleSyntax(
            default_array=self._default_array_converter.from_json(json_object["defaultArray"],),
            default_array_with_empty_dimension=self._default_array_with_empty_dimension_converter.from_json(json_object["defaultArrayWithEmptyDimension"],),
            rank_1_array=self._rank_1_array_converter.from_json(json_object["rank1Array"],),
            rank_2_array=self._rank_2_array_converter.from_json(json_object["rank2Array"],),
            rank_2_array_with_named_dimensions=self._rank_2_array_with_named_dimensions_converter.from_json(json_object["rank2ArrayWithNamedDimensions"],),
            rank_2_fixed_array=self._rank_2_fixed_array_converter.from_json(json_object["rank2FixedArray"],),
            rank_2_fixed_array_with_named_dimensions=self._rank_2_fixed_array_with_named_dimensions_converter.from_json(json_object["rank2FixedArrayWithNamedDimensions"],),
            dynamic_array=self._dynamic_array_converter.from_json(json_object["dynamicArray"],),
            array_of_vectors=self._array_of_vectors_converter.from_json(json_object["arrayOfVectors"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._default_array_converter.from_json_to_numpy(json_object["defaultArray"]),
            self._default_array_with_empty_dimension_converter.from_json_to_numpy(json_object["defaultArrayWithEmptyDimension"]),
            self._rank_1_array_converter.from_json_to_numpy(json_object["rank1Array"]),
            self._rank_2_array_converter.from_json_to_numpy(json_object["rank2Array"]),
            self._rank_2_array_with_named_dimensions_converter.from_json_to_numpy(json_object["rank2ArrayWithNamedDimensions"]),
            self._rank_2_fixed_array_converter.from_json_to_numpy(json_object["rank2FixedArray"]),
            self._rank_2_fixed_array_with_named_dimensions_converter.from_json_to_numpy(json_object["rank2FixedArrayWithNamedDimensions"]),
            self._dynamic_array_converter.from_json_to_numpy(json_object["dynamicArray"]),
            self._array_of_vectors_converter.from_json_to_numpy(json_object["arrayOfVectors"]),
        ) # type:ignore 


class RecordWithOptionalFieldsConverter(_ndjson.JsonConverter[RecordWithOptionalFields, np.void]):
    def __init__(self) -> None:
        self._optional_int_converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        self._optional_int_alternate_syntax_converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        self._optional_time_converter = _ndjson.OptionalConverter(_ndjson.time_converter)
        super().__init__(np.dtype([
            ("optional_int", self._optional_int_converter.overall_dtype()),
            ("optional_int_alternate_syntax", self._optional_int_alternate_syntax_converter.overall_dtype()),
            ("optional_time", self._optional_time_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithOptionalFields) -> object:
        if not isinstance(value, RecordWithOptionalFields): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithOptionalFields' instance")
        json_object = {}

        if value.optional_int is not None:
            json_object["optionalInt"] = self._optional_int_converter.to_json(value.optional_int)
        if value.optional_int_alternate_syntax is not None:
            json_object["optionalIntAlternateSyntax"] = self._optional_int_alternate_syntax_converter.to_json(value.optional_int_alternate_syntax)
        if value.optional_time is not None:
            json_object["optionalTime"] = self._optional_time_converter.to_json(value.optional_time)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["optional_int"]) is not None:
            json_object["optionalInt"] = self._optional_int_converter.numpy_to_json(field_val)
        if (field_val := value["optional_int_alternate_syntax"]) is not None:
            json_object["optionalIntAlternateSyntax"] = self._optional_int_alternate_syntax_converter.numpy_to_json(field_val)
        if (field_val := value["optional_time"]) is not None:
            json_object["optionalTime"] = self._optional_time_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithOptionalFields:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithOptionalFields(
            optional_int=self._optional_int_converter.from_json(json_object.get("optionalInt")),
            optional_int_alternate_syntax=self._optional_int_alternate_syntax_converter.from_json(json_object.get("optionalIntAlternateSyntax")),
            optional_time=self._optional_time_converter.from_json(json_object.get("optionalTime")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._optional_int_converter.from_json_to_numpy(json_object.get("optionalInt")),
            self._optional_int_alternate_syntax_converter.from_json_to_numpy(json_object.get("optionalIntAlternateSyntax")),
            self._optional_time_converter.from_json_to_numpy(json_object.get("optionalTime")),
        ) # type:ignore 


class RecordWithVlensConverter(_ndjson.JsonConverter[RecordWithVlens, np.void]):
    def __init__(self) -> None:
        self._a_converter = _ndjson.VectorConverter(SimpleRecordConverter())
        self._b_converter = _ndjson.int32_converter
        self._c_converter = _ndjson.int32_converter
        super().__init__(np.dtype([
            ("a", self._a_converter.overall_dtype()),
            ("b", self._b_converter.overall_dtype()),
            ("c", self._c_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithVlens) -> object:
        if not isinstance(value, RecordWithVlens): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithVlens' instance")
        json_object = {}

        json_object["a"] = self._a_converter.to_json(value.a)
        json_object["b"] = self._b_converter.to_json(value.b)
        json_object["c"] = self._c_converter.to_json(value.c)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["a"] = self._a_converter.numpy_to_json(value["a"])
        json_object["b"] = self._b_converter.numpy_to_json(value["b"])
        json_object["c"] = self._c_converter.numpy_to_json(value["c"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithVlens:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithVlens(
            a=self._a_converter.from_json(json_object["a"],),
            b=self._b_converter.from_json(json_object["b"],),
            c=self._c_converter.from_json(json_object["c"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._a_converter.from_json_to_numpy(json_object["a"]),
            self._b_converter.from_json_to_numpy(json_object["b"]),
            self._c_converter.from_json_to_numpy(json_object["c"]),
        ) # type:ignore 


class RecordWithStringsConverter(_ndjson.JsonConverter[RecordWithStrings, np.void]):
    def __init__(self) -> None:
        self._a_converter = _ndjson.string_converter
        self._b_converter = _ndjson.string_converter
        super().__init__(np.dtype([
            ("a", self._a_converter.overall_dtype()),
            ("b", self._b_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithStrings) -> object:
        if not isinstance(value, RecordWithStrings): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithStrings' instance")
        json_object = {}

        json_object["a"] = self._a_converter.to_json(value.a)
        json_object["b"] = self._b_converter.to_json(value.b)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["a"] = self._a_converter.numpy_to_json(value["a"])
        json_object["b"] = self._b_converter.numpy_to_json(value["b"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithStrings:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithStrings(
            a=self._a_converter.from_json(json_object["a"],),
            b=self._b_converter.from_json(json_object["b"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._a_converter.from_json_to_numpy(json_object["a"]),
            self._b_converter.from_json_to_numpy(json_object["b"]),
        ) # type:ignore 


class RecordWithOptionalVectorConverter(_ndjson.JsonConverter[RecordWithOptionalVector, np.void]):
    def __init__(self) -> None:
        self._optional_vector_converter = _ndjson.OptionalConverter(_ndjson.VectorConverter(_ndjson.int32_converter))
        super().__init__(np.dtype([
            ("optional_vector", self._optional_vector_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithOptionalVector) -> object:
        if not isinstance(value, RecordWithOptionalVector): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithOptionalVector' instance")
        json_object = {}

        if value.optional_vector is not None:
            json_object["optionalVector"] = self._optional_vector_converter.to_json(value.optional_vector)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["optional_vector"]) is not None:
            json_object["optionalVector"] = self._optional_vector_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithOptionalVector:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithOptionalVector(
            optional_vector=self._optional_vector_converter.from_json(json_object.get("optionalVector")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._optional_vector_converter.from_json_to_numpy(json_object.get("optionalVector")),
        ) # type:ignore 


class RecordWithFixedVectorsConverter(_ndjson.JsonConverter[RecordWithFixedVectors, np.void]):
    def __init__(self) -> None:
        self._fixed_int_vector_converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 5)
        self._fixed_simple_record_vector_converter = _ndjson.FixedVectorConverter(SimpleRecordConverter(), 3)
        self._fixed_record_with_vlens_vector_converter = _ndjson.FixedVectorConverter(RecordWithVlensConverter(), 2)
        super().__init__(np.dtype([
            ("fixed_int_vector", self._fixed_int_vector_converter.overall_dtype()),
            ("fixed_simple_record_vector", self._fixed_simple_record_vector_converter.overall_dtype()),
            ("fixed_record_with_vlens_vector", self._fixed_record_with_vlens_vector_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithFixedVectors) -> object:
        if not isinstance(value, RecordWithFixedVectors): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithFixedVectors' instance")
        json_object = {}

        json_object["fixedIntVector"] = self._fixed_int_vector_converter.to_json(value.fixed_int_vector)
        json_object["fixedSimpleRecordVector"] = self._fixed_simple_record_vector_converter.to_json(value.fixed_simple_record_vector)
        json_object["fixedRecordWithVlensVector"] = self._fixed_record_with_vlens_vector_converter.to_json(value.fixed_record_with_vlens_vector)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["fixedIntVector"] = self._fixed_int_vector_converter.numpy_to_json(value["fixed_int_vector"])
        json_object["fixedSimpleRecordVector"] = self._fixed_simple_record_vector_converter.numpy_to_json(value["fixed_simple_record_vector"])
        json_object["fixedRecordWithVlensVector"] = self._fixed_record_with_vlens_vector_converter.numpy_to_json(value["fixed_record_with_vlens_vector"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithFixedVectors:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithFixedVectors(
            fixed_int_vector=self._fixed_int_vector_converter.from_json(json_object["fixedIntVector"],),
            fixed_simple_record_vector=self._fixed_simple_record_vector_converter.from_json(json_object["fixedSimpleRecordVector"],),
            fixed_record_with_vlens_vector=self._fixed_record_with_vlens_vector_converter.from_json(json_object["fixedRecordWithVlensVector"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._fixed_int_vector_converter.from_json_to_numpy(json_object["fixedIntVector"]),
            self._fixed_simple_record_vector_converter.from_json_to_numpy(json_object["fixedSimpleRecordVector"]),
            self._fixed_record_with_vlens_vector_converter.from_json_to_numpy(json_object["fixedRecordWithVlensVector"]),
        ) # type:ignore 


class RecordWithFixedArraysConverter(_ndjson.JsonConverter[RecordWithFixedArrays, np.void]):
    def __init__(self) -> None:
        self._ints_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 3,))
        self._fixed_simple_record_array_converter = _ndjson.FixedNDArrayConverter(SimpleRecordConverter(), (3, 2,))
        self._fixed_record_with_vlens_array_converter = _ndjson.FixedNDArrayConverter(RecordWithVlensConverter(), (2, 2,))
        super().__init__(np.dtype([
            ("ints", self._ints_converter.overall_dtype()),
            ("fixed_simple_record_array", self._fixed_simple_record_array_converter.overall_dtype()),
            ("fixed_record_with_vlens_array", self._fixed_record_with_vlens_array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithFixedArrays) -> object:
        if not isinstance(value, RecordWithFixedArrays): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithFixedArrays' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.to_json(value.ints)
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.to_json(value.fixed_simple_record_array)
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.to_json(value.fixed_record_with_vlens_array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.numpy_to_json(value["ints"])
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.numpy_to_json(value["fixed_simple_record_array"])
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.numpy_to_json(value["fixed_record_with_vlens_array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithFixedArrays:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithFixedArrays(
            ints=self._ints_converter.from_json(json_object["ints"],),
            fixed_simple_record_array=self._fixed_simple_record_array_converter.from_json(json_object["fixedSimpleRecordArray"],),
            fixed_record_with_vlens_array=self._fixed_record_with_vlens_array_converter.from_json(json_object["fixedRecordWithVlensArray"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._ints_converter.from_json_to_numpy(json_object["ints"]),
            self._fixed_simple_record_array_converter.from_json_to_numpy(json_object["fixedSimpleRecordArray"]),
            self._fixed_record_with_vlens_array_converter.from_json_to_numpy(json_object["fixedRecordWithVlensArray"]),
        ) # type:ignore 


class RecordWithNamedFixedArraysConverter(_ndjson.JsonConverter[RecordWithNamedFixedArrays, np.void]):
    def __init__(self) -> None:
        self._ints_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 3,))
        self._fixed_simple_record_array_converter = _ndjson.FixedNDArrayConverter(SimpleRecordConverter(), (3, 2,))
        self._fixed_record_with_vlens_array_converter = _ndjson.FixedNDArrayConverter(RecordWithVlensConverter(), (2, 2,))
        super().__init__(np.dtype([
            ("ints", self._ints_converter.overall_dtype()),
            ("fixed_simple_record_array", self._fixed_simple_record_array_converter.overall_dtype()),
            ("fixed_record_with_vlens_array", self._fixed_record_with_vlens_array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithNamedFixedArrays) -> object:
        if not isinstance(value, RecordWithNamedFixedArrays): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithNamedFixedArrays' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.to_json(value.ints)
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.to_json(value.fixed_simple_record_array)
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.to_json(value.fixed_record_with_vlens_array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.numpy_to_json(value["ints"])
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.numpy_to_json(value["fixed_simple_record_array"])
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.numpy_to_json(value["fixed_record_with_vlens_array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithNamedFixedArrays:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithNamedFixedArrays(
            ints=self._ints_converter.from_json(json_object["ints"],),
            fixed_simple_record_array=self._fixed_simple_record_array_converter.from_json(json_object["fixedSimpleRecordArray"],),
            fixed_record_with_vlens_array=self._fixed_record_with_vlens_array_converter.from_json(json_object["fixedRecordWithVlensArray"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._ints_converter.from_json_to_numpy(json_object["ints"]),
            self._fixed_simple_record_array_converter.from_json_to_numpy(json_object["fixedSimpleRecordArray"]),
            self._fixed_record_with_vlens_array_converter.from_json_to_numpy(json_object["fixedRecordWithVlensArray"]),
        ) # type:ignore 


class RecordWithNDArraysConverter(_ndjson.JsonConverter[RecordWithNDArrays, np.void]):
    def __init__(self) -> None:
        self._ints_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._fixed_simple_record_array_converter = _ndjson.NDArrayConverter(SimpleRecordConverter(), 2)
        self._fixed_record_with_vlens_array_converter = _ndjson.NDArrayConverter(RecordWithVlensConverter(), 2)
        super().__init__(np.dtype([
            ("ints", self._ints_converter.overall_dtype()),
            ("fixed_simple_record_array", self._fixed_simple_record_array_converter.overall_dtype()),
            ("fixed_record_with_vlens_array", self._fixed_record_with_vlens_array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithNDArrays) -> object:
        if not isinstance(value, RecordWithNDArrays): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithNDArrays' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.to_json(value.ints)
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.to_json(value.fixed_simple_record_array)
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.to_json(value.fixed_record_with_vlens_array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.numpy_to_json(value["ints"])
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.numpy_to_json(value["fixed_simple_record_array"])
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.numpy_to_json(value["fixed_record_with_vlens_array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithNDArrays:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithNDArrays(
            ints=self._ints_converter.from_json(json_object["ints"],),
            fixed_simple_record_array=self._fixed_simple_record_array_converter.from_json(json_object["fixedSimpleRecordArray"],),
            fixed_record_with_vlens_array=self._fixed_record_with_vlens_array_converter.from_json(json_object["fixedRecordWithVlensArray"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._ints_converter.from_json_to_numpy(json_object["ints"]),
            self._fixed_simple_record_array_converter.from_json_to_numpy(json_object["fixedSimpleRecordArray"]),
            self._fixed_record_with_vlens_array_converter.from_json_to_numpy(json_object["fixedRecordWithVlensArray"]),
        ) # type:ignore 


class RecordWithNDArraysSingleDimensionConverter(_ndjson.JsonConverter[RecordWithNDArraysSingleDimension, np.void]):
    def __init__(self) -> None:
        self._ints_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 1)
        self._fixed_simple_record_array_converter = _ndjson.NDArrayConverter(SimpleRecordConverter(), 1)
        self._fixed_record_with_vlens_array_converter = _ndjson.NDArrayConverter(RecordWithVlensConverter(), 1)
        super().__init__(np.dtype([
            ("ints", self._ints_converter.overall_dtype()),
            ("fixed_simple_record_array", self._fixed_simple_record_array_converter.overall_dtype()),
            ("fixed_record_with_vlens_array", self._fixed_record_with_vlens_array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithNDArraysSingleDimension) -> object:
        if not isinstance(value, RecordWithNDArraysSingleDimension): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithNDArraysSingleDimension' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.to_json(value.ints)
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.to_json(value.fixed_simple_record_array)
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.to_json(value.fixed_record_with_vlens_array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.numpy_to_json(value["ints"])
        json_object["fixedSimpleRecordArray"] = self._fixed_simple_record_array_converter.numpy_to_json(value["fixed_simple_record_array"])
        json_object["fixedRecordWithVlensArray"] = self._fixed_record_with_vlens_array_converter.numpy_to_json(value["fixed_record_with_vlens_array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithNDArraysSingleDimension:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithNDArraysSingleDimension(
            ints=self._ints_converter.from_json(json_object["ints"],),
            fixed_simple_record_array=self._fixed_simple_record_array_converter.from_json(json_object["fixedSimpleRecordArray"],),
            fixed_record_with_vlens_array=self._fixed_record_with_vlens_array_converter.from_json(json_object["fixedRecordWithVlensArray"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._ints_converter.from_json_to_numpy(json_object["ints"]),
            self._fixed_simple_record_array_converter.from_json_to_numpy(json_object["fixedSimpleRecordArray"]),
            self._fixed_record_with_vlens_array_converter.from_json_to_numpy(json_object["fixedRecordWithVlensArray"]),
        ) # type:ignore 


class RecordWithDynamicNDArraysConverter(_ndjson.JsonConverter[RecordWithDynamicNDArrays, np.void]):
    def __init__(self) -> None:
        self._ints_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._simple_record_array_converter = _ndjson.DynamicNDArrayConverter(SimpleRecordConverter())
        self._record_with_vlens_array_converter = _ndjson.DynamicNDArrayConverter(RecordWithVlensConverter())
        super().__init__(np.dtype([
            ("ints", self._ints_converter.overall_dtype()),
            ("simple_record_array", self._simple_record_array_converter.overall_dtype()),
            ("record_with_vlens_array", self._record_with_vlens_array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithDynamicNDArrays) -> object:
        if not isinstance(value, RecordWithDynamicNDArrays): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithDynamicNDArrays' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.to_json(value.ints)
        json_object["simpleRecordArray"] = self._simple_record_array_converter.to_json(value.simple_record_array)
        json_object["recordWithVlensArray"] = self._record_with_vlens_array_converter.to_json(value.record_with_vlens_array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["ints"] = self._ints_converter.numpy_to_json(value["ints"])
        json_object["simpleRecordArray"] = self._simple_record_array_converter.numpy_to_json(value["simple_record_array"])
        json_object["recordWithVlensArray"] = self._record_with_vlens_array_converter.numpy_to_json(value["record_with_vlens_array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithDynamicNDArrays:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithDynamicNDArrays(
            ints=self._ints_converter.from_json(json_object["ints"],),
            simple_record_array=self._simple_record_array_converter.from_json(json_object["simpleRecordArray"],),
            record_with_vlens_array=self._record_with_vlens_array_converter.from_json(json_object["recordWithVlensArray"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._ints_converter.from_json_to_numpy(json_object["ints"]),
            self._simple_record_array_converter.from_json_to_numpy(json_object["simpleRecordArray"]),
            self._record_with_vlens_array_converter.from_json_to_numpy(json_object["recordWithVlensArray"]),
        ) # type:ignore 


class RecordWithFixedCollectionsConverter(_ndjson.JsonConverter[RecordWithFixedCollections, np.void]):
    def __init__(self) -> None:
        self._fixed_vector_converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 3)
        self._fixed_array_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 3,))
        super().__init__(np.dtype([
            ("fixed_vector", self._fixed_vector_converter.overall_dtype()),
            ("fixed_array", self._fixed_array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithFixedCollections) -> object:
        if not isinstance(value, RecordWithFixedCollections): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithFixedCollections' instance")
        json_object = {}

        json_object["fixedVector"] = self._fixed_vector_converter.to_json(value.fixed_vector)
        json_object["fixedArray"] = self._fixed_array_converter.to_json(value.fixed_array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["fixedVector"] = self._fixed_vector_converter.numpy_to_json(value["fixed_vector"])
        json_object["fixedArray"] = self._fixed_array_converter.numpy_to_json(value["fixed_array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithFixedCollections:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithFixedCollections(
            fixed_vector=self._fixed_vector_converter.from_json(json_object["fixedVector"],),
            fixed_array=self._fixed_array_converter.from_json(json_object["fixedArray"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._fixed_vector_converter.from_json_to_numpy(json_object["fixedVector"]),
            self._fixed_array_converter.from_json_to_numpy(json_object["fixedArray"]),
        ) # type:ignore 


class RecordWithVlenCollectionsConverter(_ndjson.JsonConverter[RecordWithVlenCollections, np.void]):
    def __init__(self) -> None:
        self._vector_converter = _ndjson.VectorConverter(_ndjson.int32_converter)
        self._array_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        super().__init__(np.dtype([
            ("vector", self._vector_converter.overall_dtype()),
            ("array", self._array_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithVlenCollections) -> object:
        if not isinstance(value, RecordWithVlenCollections): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithVlenCollections' instance")
        json_object = {}

        json_object["vector"] = self._vector_converter.to_json(value.vector)
        json_object["array"] = self._array_converter.to_json(value.array)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["vector"] = self._vector_converter.numpy_to_json(value["vector"])
        json_object["array"] = self._array_converter.numpy_to_json(value["array"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithVlenCollections:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithVlenCollections(
            vector=self._vector_converter.from_json(json_object["vector"],),
            array=self._array_converter.from_json(json_object["array"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._vector_converter.from_json_to_numpy(json_object["vector"]),
            self._array_converter.from_json_to_numpy(json_object["array"]),
        ) # type:ignore 


class RecordWithUnionsOfContainersConverter(_ndjson.JsonConverter[RecordWithUnionsOfContainers, np.void]):
    def __init__(self) -> None:
        self._map_or_scalar_converter = _ndjson.UnionConverter(MapOrScalar, [(MapOrScalar.Map, _ndjson.MapConverter(_ndjson.string_converter, _ndjson.int32_converter), [dict]), (MapOrScalar.Scalar, _ndjson.int32_converter, [int, float])], True)
        self._vector_or_scalar_converter = _ndjson.UnionConverter(VectorOrScalar, [(VectorOrScalar.Vector, _ndjson.VectorConverter(_ndjson.int32_converter), [list]), (VectorOrScalar.Scalar, _ndjson.int32_converter, [int, float])], True)
        self._array_or_scalar_converter = _ndjson.UnionConverter(ArrayOrScalar, [(ArrayOrScalar.Array, _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter), [dict]), (ArrayOrScalar.Scalar, _ndjson.int32_converter, [int, float])], True)
        super().__init__(np.dtype([
            ("map_or_scalar", self._map_or_scalar_converter.overall_dtype()),
            ("vector_or_scalar", self._vector_or_scalar_converter.overall_dtype()),
            ("array_or_scalar", self._array_or_scalar_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithUnionsOfContainers) -> object:
        if not isinstance(value, RecordWithUnionsOfContainers): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithUnionsOfContainers' instance")
        json_object = {}

        json_object["mapOrScalar"] = self._map_or_scalar_converter.to_json(value.map_or_scalar)
        json_object["vectorOrScalar"] = self._vector_or_scalar_converter.to_json(value.vector_or_scalar)
        json_object["arrayOrScalar"] = self._array_or_scalar_converter.to_json(value.array_or_scalar)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["mapOrScalar"] = self._map_or_scalar_converter.numpy_to_json(value["map_or_scalar"])
        json_object["vectorOrScalar"] = self._vector_or_scalar_converter.numpy_to_json(value["vector_or_scalar"])
        json_object["arrayOrScalar"] = self._array_or_scalar_converter.numpy_to_json(value["array_or_scalar"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithUnionsOfContainers:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithUnionsOfContainers(
            map_or_scalar=self._map_or_scalar_converter.from_json(json_object["mapOrScalar"],),
            vector_or_scalar=self._vector_or_scalar_converter.from_json(json_object["vectorOrScalar"],),
            array_or_scalar=self._array_or_scalar_converter.from_json(json_object["arrayOrScalar"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._map_or_scalar_converter.from_json_to_numpy(json_object["mapOrScalar"]),
            self._vector_or_scalar_converter.from_json_to_numpy(json_object["vectorOrScalar"]),
            self._array_or_scalar_converter.from_json_to_numpy(json_object["arrayOrScalar"]),
        ) # type:ignore 


class RecordWithMapsConverter(_ndjson.JsonConverter[RecordWithMaps, np.void]):
    def __init__(self) -> None:
        self._set_1_converter = _ndjson.MapConverter(_ndjson.uint32_converter, _ndjson.uint32_converter)
        self._set_2_converter = _ndjson.MapConverter(_ndjson.int32_converter, _ndjson.bool_converter)
        super().__init__(np.dtype([
            ("set_1", self._set_1_converter.overall_dtype()),
            ("set_2", self._set_2_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithMaps) -> object:
        if not isinstance(value, RecordWithMaps): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithMaps' instance")
        json_object = {}

        json_object["set1"] = self._set_1_converter.to_json(value.set_1)
        json_object["set2"] = self._set_2_converter.to_json(value.set_2)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["set1"] = self._set_1_converter.numpy_to_json(value["set_1"])
        json_object["set2"] = self._set_2_converter.numpy_to_json(value["set_2"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithMaps:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithMaps(
            set_1=self._set_1_converter.from_json(json_object["set1"],),
            set_2=self._set_2_converter.from_json(json_object["set2"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._set_1_converter.from_json_to_numpy(json_object["set1"]),
            self._set_2_converter.from_json_to_numpy(json_object["set2"]),
        ) # type:ignore 


u_int64_enum_name_to_value_map = {
    "a": UInt64Enum.A,
}
u_int64_enum_value_to_name_map = {v: n for n, v in u_int64_enum_name_to_value_map.items()}

int64_enum_name_to_value_map = {
    "b": Int64Enum.B,
}
int64_enum_value_to_name_map = {v: n for n, v in int64_enum_name_to_value_map.items()}

size_based_enum_name_to_value_map = {
    "a": SizeBasedEnum.A,
    "b": SizeBasedEnum.B,
    "c": SizeBasedEnum.C,
}
size_based_enum_value_to_name_map = {v: n for n, v in size_based_enum_name_to_value_map.items()}

class RecordWithNoDefaultEnumConverter(_ndjson.JsonConverter[RecordWithNoDefaultEnum, np.void]):
    def __init__(self) -> None:
        self._enum_converter = _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map)
        super().__init__(np.dtype([
            ("enum", self._enum_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithNoDefaultEnum) -> object:
        if not isinstance(value, RecordWithNoDefaultEnum): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithNoDefaultEnum' instance")
        json_object = {}

        json_object["enum"] = self._enum_converter.to_json(value.enum)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["enum"] = self._enum_converter.numpy_to_json(value["enum"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithNoDefaultEnum:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithNoDefaultEnum(
            enum=self._enum_converter.from_json(json_object["enum"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._enum_converter.from_json_to_numpy(json_object["enum"]),
        ) # type:ignore 


class RecordWithEnumsConverter(_ndjson.JsonConverter[RecordWithEnums, np.void]):
    def __init__(self) -> None:
        self._enum_converter = _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map)
        self._flags_converter = _ndjson.FlagsConverter(basic_types.DaysOfWeek, np.int32, basic_types.ndjson.days_of_week_name_to_value_map, basic_types.ndjson.days_of_week_value_to_name_map)
        self._flags_2_converter = _ndjson.FlagsConverter(basic_types.TextFormat, np.uint64, basic_types.ndjson.text_format_name_to_value_map, basic_types.ndjson.text_format_value_to_name_map)
        self._rec_converter = RecordWithNoDefaultEnumConverter()
        super().__init__(np.dtype([
            ("enum", self._enum_converter.overall_dtype()),
            ("flags", self._flags_converter.overall_dtype()),
            ("flags_2", self._flags_2_converter.overall_dtype()),
            ("rec", self._rec_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithEnums) -> object:
        if not isinstance(value, RecordWithEnums): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithEnums' instance")
        json_object = {}

        json_object["enum"] = self._enum_converter.to_json(value.enum)
        json_object["flags"] = self._flags_converter.to_json(value.flags)
        json_object["flags2"] = self._flags_2_converter.to_json(value.flags_2)
        json_object["rec"] = self._rec_converter.to_json(value.rec)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["enum"] = self._enum_converter.numpy_to_json(value["enum"])
        json_object["flags"] = self._flags_converter.numpy_to_json(value["flags"])
        json_object["flags2"] = self._flags_2_converter.numpy_to_json(value["flags_2"])
        json_object["rec"] = self._rec_converter.numpy_to_json(value["rec"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithEnums:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithEnums(
            enum=self._enum_converter.from_json(json_object["enum"],),
            flags=self._flags_converter.from_json(json_object["flags"],),
            flags_2=self._flags_2_converter.from_json(json_object["flags2"],),
            rec=self._rec_converter.from_json(json_object["rec"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._enum_converter.from_json_to_numpy(json_object["enum"]),
            self._flags_converter.from_json_to_numpy(json_object["flags"]),
            self._flags_2_converter.from_json_to_numpy(json_object["flags2"]),
            self._rec_converter.from_json_to_numpy(json_object["rec"]),
        ) # type:ignore 


class GenericRecordConverter(typing.Generic[T1, T1_NP, T2, T2_NP], _ndjson.JsonConverter[GenericRecord[T1, T2, T2_NP], np.void]):
    def __init__(self, t1_converter: _ndjson.JsonConverter[T1, T1_NP], t2_converter: _ndjson.JsonConverter[T2, T2_NP]) -> None:
        self._scalar_1_converter = t1_converter
        self._scalar_1_supports_none = self._scalar_1_converter.supports_none()
        self._scalar_2_converter = t2_converter
        self._scalar_2_supports_none = self._scalar_2_converter.supports_none()
        self._vector_1_converter = _ndjson.VectorConverter(t1_converter)
        self._image_2_converter = _ndjson.NDArrayConverter(t2_converter, 2)
        super().__init__(np.dtype([
            ("scalar_1", self._scalar_1_converter.overall_dtype()),
            ("scalar_2", self._scalar_2_converter.overall_dtype()),
            ("vector_1", self._vector_1_converter.overall_dtype()),
            ("image_2", self._image_2_converter.overall_dtype()),
        ]))

    def to_json(self, value: GenericRecord[T1, T2, T2_NP]) -> object:
        if not isinstance(value, GenericRecord): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'GenericRecord[T1, T2, T2_NP]' instance")
        json_object = {}

        if not self._scalar_1_supports_none or value.scalar_1 is not None:
            json_object["scalar1"] = self._scalar_1_converter.to_json(value.scalar_1)
        if not self._scalar_2_supports_none or value.scalar_2 is not None:
            json_object["scalar2"] = self._scalar_2_converter.to_json(value.scalar_2)
        json_object["vector1"] = self._vector_1_converter.to_json(value.vector_1)
        json_object["image2"] = self._image_2_converter.to_json(value.image_2)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if not self._scalar_1_supports_none or value["scalar_1"] is not None:
            json_object["scalar1"] = self._scalar_1_converter.numpy_to_json(value["scalar_1"])
        if not self._scalar_2_supports_none or value["scalar_2"] is not None:
            json_object["scalar2"] = self._scalar_2_converter.numpy_to_json(value["scalar_2"])
        json_object["vector1"] = self._vector_1_converter.numpy_to_json(value["vector_1"])
        json_object["image2"] = self._image_2_converter.numpy_to_json(value["image_2"])
        return json_object

    def from_json(self, json_object: object) -> GenericRecord[T1, T2, T2_NP]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return GenericRecord[T1, T2, T2_NP](
            scalar_1=self._scalar_1_converter.from_json(json_object.get("scalar1") if self._scalar_1_supports_none else json_object["scalar1"]),
            scalar_2=self._scalar_2_converter.from_json(json_object.get("scalar2") if self._scalar_2_supports_none else json_object["scalar2"]),
            vector_1=self._vector_1_converter.from_json(json_object["vector1"],),
            image_2=self._image_2_converter.from_json(json_object["image2"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._scalar_1_converter.from_json_to_numpy(json_object.get("scalar1") if self._scalar_1_supports_none else json_object["scalar1"]),
            self._scalar_2_converter.from_json_to_numpy(json_object.get("scalar2") if self._scalar_2_supports_none else json_object["scalar2"]),
            self._vector_1_converter.from_json_to_numpy(json_object["vector1"]),
            self._image_2_converter.from_json_to_numpy(json_object["image2"]),
        ) # type:ignore 


class RecordWithAliasedGenericsConverter(_ndjson.JsonConverter[RecordWithAliasedGenerics, np.void]):
    def __init__(self) -> None:
        self._my_strings_converter = tuples.ndjson.TupleConverter(_ndjson.string_converter, _ndjson.string_converter)
        self._aliased_strings_converter = tuples.ndjson.TupleConverter(_ndjson.string_converter, _ndjson.string_converter)
        super().__init__(np.dtype([
            ("my_strings", self._my_strings_converter.overall_dtype()),
            ("aliased_strings", self._aliased_strings_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithAliasedGenerics) -> object:
        if not isinstance(value, RecordWithAliasedGenerics): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithAliasedGenerics' instance")
        json_object = {}

        json_object["myStrings"] = self._my_strings_converter.to_json(value.my_strings)
        json_object["aliasedStrings"] = self._aliased_strings_converter.to_json(value.aliased_strings)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["myStrings"] = self._my_strings_converter.numpy_to_json(value["my_strings"])
        json_object["aliasedStrings"] = self._aliased_strings_converter.numpy_to_json(value["aliased_strings"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithAliasedGenerics:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithAliasedGenerics(
            my_strings=self._my_strings_converter.from_json(json_object["myStrings"],),
            aliased_strings=self._aliased_strings_converter.from_json(json_object["aliasedStrings"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._my_strings_converter.from_json_to_numpy(json_object["myStrings"]),
            self._aliased_strings_converter.from_json_to_numpy(json_object["aliasedStrings"]),
        ) # type:ignore 


class RecordWithGenericVectorOfRecordsConverter(typing.Generic[T, T_NP, U, U_NP], _ndjson.JsonConverter[RecordWithGenericVectorOfRecords[T, U, U_NP], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP], u_converter: _ndjson.JsonConverter[U, U_NP]) -> None:
        self._v_converter = _ndjson.VectorConverter(_ndjson.VectorConverter(GenericRecordConverter(t_converter, u_converter)))
        super().__init__(np.dtype([
            ("v", self._v_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithGenericVectorOfRecords[T, U, U_NP]) -> object:
        if not isinstance(value, RecordWithGenericVectorOfRecords): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithGenericVectorOfRecords[T, U, U_NP]' instance")
        json_object = {}

        json_object["v"] = self._v_converter.to_json(value.v)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["v"] = self._v_converter.numpy_to_json(value["v"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithGenericVectorOfRecords[T, U, U_NP]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithGenericVectorOfRecords[T, U, U_NP](
            v=self._v_converter.from_json(json_object["v"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._v_converter.from_json_to_numpy(json_object["v"]),
        ) # type:ignore 


class RecordWithOptionalGenericFieldConverter(typing.Generic[T, T_NP], _ndjson.JsonConverter[RecordWithOptionalGenericField[T], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP]) -> None:
        self._v_converter = _ndjson.OptionalConverter(t_converter)
        super().__init__(np.dtype([
            ("v", self._v_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithOptionalGenericField[T]) -> object:
        if not isinstance(value, RecordWithOptionalGenericField): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithOptionalGenericField[T]' instance")
        json_object = {}

        if value.v is not None:
            json_object["v"] = self._v_converter.to_json(value.v)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["v"]) is not None:
            json_object["v"] = self._v_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithOptionalGenericField[T]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithOptionalGenericField[T](
            v=self._v_converter.from_json(json_object.get("v")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._v_converter.from_json_to_numpy(json_object.get("v")),
        ) # type:ignore 


class RecordWithAliasedOptionalGenericFieldConverter(typing.Generic[T, T_NP], _ndjson.JsonConverter[RecordWithAliasedOptionalGenericField[T], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP]) -> None:
        self._v_converter = _ndjson.OptionalConverter(t_converter)
        super().__init__(np.dtype([
            ("v", self._v_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithAliasedOptionalGenericField[T]) -> object:
        if not isinstance(value, RecordWithAliasedOptionalGenericField): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithAliasedOptionalGenericField[T]' instance")
        json_object = {}

        if value.v is not None:
            json_object["v"] = self._v_converter.to_json(value.v)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["v"]) is not None:
            json_object["v"] = self._v_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithAliasedOptionalGenericField[T]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithAliasedOptionalGenericField[T](
            v=self._v_converter.from_json(json_object.get("v")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._v_converter.from_json_to_numpy(json_object.get("v")),
        ) # type:ignore 


class RecordWithOptionalGenericUnionFieldConverter(typing.Generic[U, U_NP, V, V_NP], _ndjson.JsonConverter[RecordWithOptionalGenericUnionField[U, V], np.void]):
    def __init__(self, u_converter: _ndjson.JsonConverter[U, U_NP], v_converter: _ndjson.JsonConverter[V, V_NP]) -> None:
        self._v_converter = _ndjson.UnionConverter(UOrV, [None, (UOrV[U, V].U, u_converter, [dict]), (UOrV[U, V].V, v_converter, [dict])], False)
        super().__init__(np.dtype([
            ("v", self._v_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithOptionalGenericUnionField[U, V]) -> object:
        if not isinstance(value, RecordWithOptionalGenericUnionField): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithOptionalGenericUnionField[U, V]' instance")
        json_object = {}

        if value.v is not None:
            json_object["v"] = self._v_converter.to_json(value.v)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["v"]) is not None:
            json_object["v"] = self._v_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithOptionalGenericUnionField[U, V]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithOptionalGenericUnionField[U, V](
            v=self._v_converter.from_json(json_object.get("v")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._v_converter.from_json_to_numpy(json_object.get("v")),
        ) # type:ignore 


class RecordWithAliasedOptionalGenericUnionFieldConverter(typing.Generic[U, U_NP, V, V_NP], _ndjson.JsonConverter[RecordWithAliasedOptionalGenericUnionField[U, V], np.void]):
    def __init__(self, u_converter: _ndjson.JsonConverter[U, U_NP], v_converter: _ndjson.JsonConverter[V, V_NP]) -> None:
        self._v_converter = _ndjson.UnionConverter(AliasedMultiGenericOptional, [None, (AliasedMultiGenericOptional[U, V].T, u_converter, [dict]), (AliasedMultiGenericOptional[U, V].U, v_converter, [dict])], False)
        super().__init__(np.dtype([
            ("v", self._v_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithAliasedOptionalGenericUnionField[U, V]) -> object:
        if not isinstance(value, RecordWithAliasedOptionalGenericUnionField): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithAliasedOptionalGenericUnionField[U, V]' instance")
        json_object = {}

        if value.v is not None:
            json_object["v"] = self._v_converter.to_json(value.v)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["v"]) is not None:
            json_object["v"] = self._v_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithAliasedOptionalGenericUnionField[U, V]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithAliasedOptionalGenericUnionField[U, V](
            v=self._v_converter.from_json(json_object.get("v")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._v_converter.from_json_to_numpy(json_object.get("v")),
        ) # type:ignore 


class RecordWithGenericVectorsConverter(typing.Generic[T, T_NP], _ndjson.JsonConverter[RecordWithGenericVectors[T], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP]) -> None:
        self._v_converter = _ndjson.VectorConverter(t_converter)
        self._av_converter = _ndjson.VectorConverter(t_converter)
        super().__init__(np.dtype([
            ("v", self._v_converter.overall_dtype()),
            ("av", self._av_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithGenericVectors[T]) -> object:
        if not isinstance(value, RecordWithGenericVectors): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithGenericVectors[T]' instance")
        json_object = {}

        json_object["v"] = self._v_converter.to_json(value.v)
        json_object["av"] = self._av_converter.to_json(value.av)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["v"] = self._v_converter.numpy_to_json(value["v"])
        json_object["av"] = self._av_converter.numpy_to_json(value["av"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithGenericVectors[T]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithGenericVectors[T](
            v=self._v_converter.from_json(json_object["v"],),
            av=self._av_converter.from_json(json_object["av"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._v_converter.from_json_to_numpy(json_object["v"]),
            self._av_converter.from_json_to_numpy(json_object["av"]),
        ) # type:ignore 


class RecordWithGenericFixedVectorsConverter(typing.Generic[T, T_NP], _ndjson.JsonConverter[RecordWithGenericFixedVectors[T], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP]) -> None:
        self._fv_converter = _ndjson.FixedVectorConverter(t_converter, 3)
        self._afv_converter = _ndjson.FixedVectorConverter(t_converter, 3)
        super().__init__(np.dtype([
            ("fv", self._fv_converter.overall_dtype()),
            ("afv", self._afv_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithGenericFixedVectors[T]) -> object:
        if not isinstance(value, RecordWithGenericFixedVectors): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithGenericFixedVectors[T]' instance")
        json_object = {}

        json_object["fv"] = self._fv_converter.to_json(value.fv)
        json_object["afv"] = self._afv_converter.to_json(value.afv)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["fv"] = self._fv_converter.numpy_to_json(value["fv"])
        json_object["afv"] = self._afv_converter.numpy_to_json(value["afv"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithGenericFixedVectors[T]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithGenericFixedVectors[T](
            fv=self._fv_converter.from_json(json_object["fv"],),
            afv=self._afv_converter.from_json(json_object["afv"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._fv_converter.from_json_to_numpy(json_object["fv"]),
            self._afv_converter.from_json_to_numpy(json_object["afv"]),
        ) # type:ignore 


class RecordWithGenericArraysConverter(typing.Generic[T, T_NP], _ndjson.JsonConverter[RecordWithGenericArrays[T_NP], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP]) -> None:
        self._nd_converter = _ndjson.NDArrayConverter(t_converter, 2)
        self._fixed_nd_converter = _ndjson.FixedNDArrayConverter(t_converter, (16, 8,))
        self._dynamic_nd_converter = _ndjson.DynamicNDArrayConverter(t_converter)
        self._aliased_nd_converter = _ndjson.NDArrayConverter(t_converter, 2)
        self._aliased_fixed_nd_converter = _ndjson.FixedNDArrayConverter(t_converter, (16, 8,))
        self._aliased_dynamic_nd_converter = _ndjson.DynamicNDArrayConverter(t_converter)
        super().__init__(np.dtype([
            ("nd", self._nd_converter.overall_dtype()),
            ("fixed_nd", self._fixed_nd_converter.overall_dtype()),
            ("dynamic_nd", self._dynamic_nd_converter.overall_dtype()),
            ("aliased_nd", self._aliased_nd_converter.overall_dtype()),
            ("aliased_fixed_nd", self._aliased_fixed_nd_converter.overall_dtype()),
            ("aliased_dynamic_nd", self._aliased_dynamic_nd_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithGenericArrays[T_NP]) -> object:
        if not isinstance(value, RecordWithGenericArrays): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithGenericArrays[T_NP]' instance")
        json_object = {}

        json_object["nd"] = self._nd_converter.to_json(value.nd)
        json_object["fixedNd"] = self._fixed_nd_converter.to_json(value.fixed_nd)
        json_object["dynamicNd"] = self._dynamic_nd_converter.to_json(value.dynamic_nd)
        json_object["aliasedNd"] = self._aliased_nd_converter.to_json(value.aliased_nd)
        json_object["aliasedFixedNd"] = self._aliased_fixed_nd_converter.to_json(value.aliased_fixed_nd)
        json_object["aliasedDynamicNd"] = self._aliased_dynamic_nd_converter.to_json(value.aliased_dynamic_nd)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["nd"] = self._nd_converter.numpy_to_json(value["nd"])
        json_object["fixedNd"] = self._fixed_nd_converter.numpy_to_json(value["fixed_nd"])
        json_object["dynamicNd"] = self._dynamic_nd_converter.numpy_to_json(value["dynamic_nd"])
        json_object["aliasedNd"] = self._aliased_nd_converter.numpy_to_json(value["aliased_nd"])
        json_object["aliasedFixedNd"] = self._aliased_fixed_nd_converter.numpy_to_json(value["aliased_fixed_nd"])
        json_object["aliasedDynamicNd"] = self._aliased_dynamic_nd_converter.numpy_to_json(value["aliased_dynamic_nd"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithGenericArrays[T_NP]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithGenericArrays[T_NP](
            nd=self._nd_converter.from_json(json_object["nd"],),
            fixed_nd=self._fixed_nd_converter.from_json(json_object["fixedNd"],),
            dynamic_nd=self._dynamic_nd_converter.from_json(json_object["dynamicNd"],),
            aliased_nd=self._aliased_nd_converter.from_json(json_object["aliasedNd"],),
            aliased_fixed_nd=self._aliased_fixed_nd_converter.from_json(json_object["aliasedFixedNd"],),
            aliased_dynamic_nd=self._aliased_dynamic_nd_converter.from_json(json_object["aliasedDynamicNd"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._nd_converter.from_json_to_numpy(json_object["nd"]),
            self._fixed_nd_converter.from_json_to_numpy(json_object["fixedNd"]),
            self._dynamic_nd_converter.from_json_to_numpy(json_object["dynamicNd"]),
            self._aliased_nd_converter.from_json_to_numpy(json_object["aliasedNd"]),
            self._aliased_fixed_nd_converter.from_json_to_numpy(json_object["aliasedFixedNd"]),
            self._aliased_dynamic_nd_converter.from_json_to_numpy(json_object["aliasedDynamicNd"]),
        ) # type:ignore 


class RecordWithGenericMapsConverter(typing.Generic[T, T_NP, U, U_NP], _ndjson.JsonConverter[RecordWithGenericMaps[T, U], np.void]):
    def __init__(self, t_converter: _ndjson.JsonConverter[T, T_NP], u_converter: _ndjson.JsonConverter[U, U_NP]) -> None:
        self._m_converter = _ndjson.MapConverter(t_converter, u_converter)
        self._am_converter = _ndjson.MapConverter(t_converter, u_converter)
        super().__init__(np.dtype([
            ("m", self._m_converter.overall_dtype()),
            ("am", self._am_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithGenericMaps[T, U]) -> object:
        if not isinstance(value, RecordWithGenericMaps): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithGenericMaps[T, U]' instance")
        json_object = {}

        json_object["m"] = self._m_converter.to_json(value.m)
        json_object["am"] = self._am_converter.to_json(value.am)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["m"] = self._m_converter.numpy_to_json(value["m"])
        json_object["am"] = self._am_converter.numpy_to_json(value["am"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithGenericMaps[T, U]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithGenericMaps[T, U](
            m=self._m_converter.from_json(json_object["m"],),
            am=self._am_converter.from_json(json_object["am"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._m_converter.from_json_to_numpy(json_object["m"]),
            self._am_converter.from_json_to_numpy(json_object["am"]),
        ) # type:ignore 


class RecordContainingGenericRecordsConverter(typing.Generic[A, A_NP, B, B_NP], _ndjson.JsonConverter[RecordContainingGenericRecords[A, B, B_NP], np.void]):
    def __init__(self, a_converter: _ndjson.JsonConverter[A, A_NP], b_converter: _ndjson.JsonConverter[B, B_NP]) -> None:
        self._g1_converter = RecordWithOptionalGenericFieldConverter(a_converter)
        self._g1a_converter = RecordWithAliasedOptionalGenericFieldConverter(a_converter)
        self._g2_converter = RecordWithOptionalGenericUnionFieldConverter(a_converter, b_converter)
        self._g2a_converter = RecordWithAliasedOptionalGenericUnionFieldConverter(a_converter, b_converter)
        self._g3_converter = tuples.ndjson.TupleConverter(a_converter, b_converter)
        self._g3a_converter = tuples.ndjson.TupleConverter(a_converter, b_converter)
        self._g4_converter = RecordWithGenericVectorsConverter(b_converter)
        self._g5_converter = RecordWithGenericFixedVectorsConverter(b_converter)
        self._g6_converter = RecordWithGenericArraysConverter(b_converter)
        self._g7_converter = RecordWithGenericMapsConverter(a_converter, b_converter)
        super().__init__(np.dtype([
            ("g1", self._g1_converter.overall_dtype()),
            ("g1a", self._g1a_converter.overall_dtype()),
            ("g2", self._g2_converter.overall_dtype()),
            ("g2a", self._g2a_converter.overall_dtype()),
            ("g3", self._g3_converter.overall_dtype()),
            ("g3a", self._g3a_converter.overall_dtype()),
            ("g4", self._g4_converter.overall_dtype()),
            ("g5", self._g5_converter.overall_dtype()),
            ("g6", self._g6_converter.overall_dtype()),
            ("g7", self._g7_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordContainingGenericRecords[A, B, B_NP]) -> object:
        if not isinstance(value, RecordContainingGenericRecords): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordContainingGenericRecords[A, B, B_NP]' instance")
        json_object = {}

        json_object["g1"] = self._g1_converter.to_json(value.g1)
        json_object["g1a"] = self._g1a_converter.to_json(value.g1a)
        json_object["g2"] = self._g2_converter.to_json(value.g2)
        json_object["g2a"] = self._g2a_converter.to_json(value.g2a)
        json_object["g3"] = self._g3_converter.to_json(value.g3)
        json_object["g3a"] = self._g3a_converter.to_json(value.g3a)
        json_object["g4"] = self._g4_converter.to_json(value.g4)
        json_object["g5"] = self._g5_converter.to_json(value.g5)
        json_object["g6"] = self._g6_converter.to_json(value.g6)
        json_object["g7"] = self._g7_converter.to_json(value.g7)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["g1"] = self._g1_converter.numpy_to_json(value["g1"])
        json_object["g1a"] = self._g1a_converter.numpy_to_json(value["g1a"])
        json_object["g2"] = self._g2_converter.numpy_to_json(value["g2"])
        json_object["g2a"] = self._g2a_converter.numpy_to_json(value["g2a"])
        json_object["g3"] = self._g3_converter.numpy_to_json(value["g3"])
        json_object["g3a"] = self._g3a_converter.numpy_to_json(value["g3a"])
        json_object["g4"] = self._g4_converter.numpy_to_json(value["g4"])
        json_object["g5"] = self._g5_converter.numpy_to_json(value["g5"])
        json_object["g6"] = self._g6_converter.numpy_to_json(value["g6"])
        json_object["g7"] = self._g7_converter.numpy_to_json(value["g7"])
        return json_object

    def from_json(self, json_object: object) -> RecordContainingGenericRecords[A, B, B_NP]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordContainingGenericRecords[A, B, B_NP](
            g1=self._g1_converter.from_json(json_object["g1"],),
            g1a=self._g1a_converter.from_json(json_object["g1a"],),
            g2=self._g2_converter.from_json(json_object["g2"],),
            g2a=self._g2a_converter.from_json(json_object["g2a"],),
            g3=self._g3_converter.from_json(json_object["g3"],),
            g3a=self._g3a_converter.from_json(json_object["g3a"],),
            g4=self._g4_converter.from_json(json_object["g4"],),
            g5=self._g5_converter.from_json(json_object["g5"],),
            g6=self._g6_converter.from_json(json_object["g6"],),
            g7=self._g7_converter.from_json(json_object["g7"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._g1_converter.from_json_to_numpy(json_object["g1"]),
            self._g1a_converter.from_json_to_numpy(json_object["g1a"]),
            self._g2_converter.from_json_to_numpy(json_object["g2"]),
            self._g2a_converter.from_json_to_numpy(json_object["g2a"]),
            self._g3_converter.from_json_to_numpy(json_object["g3"]),
            self._g3a_converter.from_json_to_numpy(json_object["g3a"]),
            self._g4_converter.from_json_to_numpy(json_object["g4"]),
            self._g5_converter.from_json_to_numpy(json_object["g5"]),
            self._g6_converter.from_json_to_numpy(json_object["g6"]),
            self._g7_converter.from_json_to_numpy(json_object["g7"]),
        ) # type:ignore 


class RecordContainingNestedGenericRecordsConverter(_ndjson.JsonConverter[RecordContainingNestedGenericRecords, np.void]):
    def __init__(self) -> None:
        self._f1_converter = RecordWithOptionalGenericFieldConverter(_ndjson.string_converter)
        self._f1a_converter = RecordWithAliasedOptionalGenericFieldConverter(_ndjson.string_converter)
        self._f2_converter = RecordWithOptionalGenericUnionFieldConverter(_ndjson.string_converter, _ndjson.int32_converter)
        self._f2a_converter = RecordWithAliasedOptionalGenericUnionFieldConverter(_ndjson.string_converter, _ndjson.int32_converter)
        self._nested_converter = RecordContainingGenericRecordsConverter(_ndjson.string_converter, _ndjson.int32_converter)
        super().__init__(np.dtype([
            ("f1", self._f1_converter.overall_dtype()),
            ("f1a", self._f1a_converter.overall_dtype()),
            ("f2", self._f2_converter.overall_dtype()),
            ("f2a", self._f2a_converter.overall_dtype()),
            ("nested", self._nested_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordContainingNestedGenericRecords) -> object:
        if not isinstance(value, RecordContainingNestedGenericRecords): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordContainingNestedGenericRecords' instance")
        json_object = {}

        json_object["f1"] = self._f1_converter.to_json(value.f1)
        json_object["f1a"] = self._f1a_converter.to_json(value.f1a)
        json_object["f2"] = self._f2_converter.to_json(value.f2)
        json_object["f2a"] = self._f2a_converter.to_json(value.f2a)
        json_object["nested"] = self._nested_converter.to_json(value.nested)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["f1"] = self._f1_converter.numpy_to_json(value["f1"])
        json_object["f1a"] = self._f1a_converter.numpy_to_json(value["f1a"])
        json_object["f2"] = self._f2_converter.numpy_to_json(value["f2"])
        json_object["f2a"] = self._f2a_converter.numpy_to_json(value["f2a"])
        json_object["nested"] = self._nested_converter.numpy_to_json(value["nested"])
        return json_object

    def from_json(self, json_object: object) -> RecordContainingNestedGenericRecords:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordContainingNestedGenericRecords(
            f1=self._f1_converter.from_json(json_object["f1"],),
            f1a=self._f1a_converter.from_json(json_object["f1a"],),
            f2=self._f2_converter.from_json(json_object["f2"],),
            f2a=self._f2a_converter.from_json(json_object["f2a"],),
            nested=self._nested_converter.from_json(json_object["nested"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._f1_converter.from_json_to_numpy(json_object["f1"]),
            self._f1a_converter.from_json_to_numpy(json_object["f1a"]),
            self._f2_converter.from_json_to_numpy(json_object["f2"]),
            self._f2a_converter.from_json_to_numpy(json_object["f2a"]),
            self._nested_converter.from_json_to_numpy(json_object["nested"]),
        ) # type:ignore 


class RecordContainingVectorsOfAliasesConverter(_ndjson.JsonConverter[RecordContainingVectorsOfAliases, np.void]):
    def __init__(self) -> None:
        self._strings_converter = _ndjson.VectorConverter(_ndjson.string_converter)
        self._maps_converter = _ndjson.VectorConverter(_ndjson.MapConverter(_ndjson.string_converter, _ndjson.int32_converter))
        self._arrays_converter = _ndjson.VectorConverter(_ndjson.NDArrayConverter(_ndjson.float32_converter, 2))
        self._tuples_converter = _ndjson.VectorConverter(tuples.ndjson.TupleConverter(_ndjson.int32_converter, SimpleRecordConverter()))
        super().__init__(np.dtype([
            ("strings", self._strings_converter.overall_dtype()),
            ("maps", self._maps_converter.overall_dtype()),
            ("arrays", self._arrays_converter.overall_dtype()),
            ("tuples", self._tuples_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordContainingVectorsOfAliases) -> object:
        if not isinstance(value, RecordContainingVectorsOfAliases): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordContainingVectorsOfAliases' instance")
        json_object = {}

        json_object["strings"] = self._strings_converter.to_json(value.strings)
        json_object["maps"] = self._maps_converter.to_json(value.maps)
        json_object["arrays"] = self._arrays_converter.to_json(value.arrays)
        json_object["tuples"] = self._tuples_converter.to_json(value.tuples)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["strings"] = self._strings_converter.numpy_to_json(value["strings"])
        json_object["maps"] = self._maps_converter.numpy_to_json(value["maps"])
        json_object["arrays"] = self._arrays_converter.numpy_to_json(value["arrays"])
        json_object["tuples"] = self._tuples_converter.numpy_to_json(value["tuples"])
        return json_object

    def from_json(self, json_object: object) -> RecordContainingVectorsOfAliases:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordContainingVectorsOfAliases(
            strings=self._strings_converter.from_json(json_object["strings"],),
            maps=self._maps_converter.from_json(json_object["maps"],),
            arrays=self._arrays_converter.from_json(json_object["arrays"],),
            tuples=self._tuples_converter.from_json(json_object["tuples"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._strings_converter.from_json_to_numpy(json_object["strings"]),
            self._maps_converter.from_json_to_numpy(json_object["maps"]),
            self._arrays_converter.from_json_to_numpy(json_object["arrays"]),
            self._tuples_converter.from_json_to_numpy(json_object["tuples"]),
        ) # type:ignore 


class RecordWithComputedFieldsConverter(_ndjson.JsonConverter[RecordWithComputedFields, np.void]):
    def __init__(self) -> None:
        self._array_field_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._array_field_map_dimensions_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._dynamic_array_field_converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        self._fixed_array_field_converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3, 4,))
        self._int_field_converter = _ndjson.int32_converter
        self._int8_field_converter = _ndjson.int8_converter
        self._uint8_field_converter = _ndjson.uint8_converter
        self._int16_field_converter = _ndjson.int16_converter
        self._uint16_field_converter = _ndjson.uint16_converter
        self._uint32_field_converter = _ndjson.uint32_converter
        self._int64_field_converter = _ndjson.int64_converter
        self._uint64_field_converter = _ndjson.uint64_converter
        self._size_field_converter = _ndjson.size_converter
        self._float32_field_converter = _ndjson.float32_converter
        self._float64_field_converter = _ndjson.float64_converter
        self._complexfloat32_field_converter = _ndjson.complexfloat32_converter
        self._complexfloat64_field_converter = _ndjson.complexfloat64_converter
        self._string_field_converter = _ndjson.string_converter
        self._tuple_field_converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.int32_converter)
        self._vector_field_converter = _ndjson.VectorConverter(_ndjson.int32_converter)
        self._vector_of_vectors_field_converter = _ndjson.VectorConverter(_ndjson.VectorConverter(_ndjson.int32_converter))
        self._fixed_vector_field_converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 3)
        self._fixed_vector_of_vectors_field_converter = _ndjson.FixedVectorConverter(_ndjson.FixedVectorConverter(_ndjson.int32_converter, 3), 2)
        self._optional_named_array_converter = _ndjson.OptionalConverter(_ndjson.NDArrayConverter(_ndjson.int32_converter, 2))
        self._int_float_union_converter = _ndjson.UnionConverter(Int32OrFloat32, [(Int32OrFloat32.Int32, _ndjson.int32_converter, [int, float]), (Int32OrFloat32.Float32, _ndjson.float32_converter, [int, float])], False)
        self._nullable_int_float_union_converter = _ndjson.UnionConverter(Int32OrFloat32, [None, (Int32OrFloat32.Int32, _ndjson.int32_converter, [int, float]), (Int32OrFloat32.Float32, _ndjson.float32_converter, [int, float])], False)
        self._union_with_nested_generic_union_converter = _ndjson.UnionConverter(IntOrGenericRecordWithComputedFields, [(IntOrGenericRecordWithComputedFields.Int, _ndjson.int32_converter, [int, float]), (IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields, basic_types.ndjson.GenericRecordWithComputedFieldsConverter(_ndjson.string_converter, _ndjson.float32_converter), [dict])], True)
        self._map_field_converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.string_converter)
        super().__init__(np.dtype([
            ("array_field", self._array_field_converter.overall_dtype()),
            ("array_field_map_dimensions", self._array_field_map_dimensions_converter.overall_dtype()),
            ("dynamic_array_field", self._dynamic_array_field_converter.overall_dtype()),
            ("fixed_array_field", self._fixed_array_field_converter.overall_dtype()),
            ("int_field", self._int_field_converter.overall_dtype()),
            ("int8_field", self._int8_field_converter.overall_dtype()),
            ("uint8_field", self._uint8_field_converter.overall_dtype()),
            ("int16_field", self._int16_field_converter.overall_dtype()),
            ("uint16_field", self._uint16_field_converter.overall_dtype()),
            ("uint32_field", self._uint32_field_converter.overall_dtype()),
            ("int64_field", self._int64_field_converter.overall_dtype()),
            ("uint64_field", self._uint64_field_converter.overall_dtype()),
            ("size_field", self._size_field_converter.overall_dtype()),
            ("float32_field", self._float32_field_converter.overall_dtype()),
            ("float64_field", self._float64_field_converter.overall_dtype()),
            ("complexfloat32_field", self._complexfloat32_field_converter.overall_dtype()),
            ("complexfloat64_field", self._complexfloat64_field_converter.overall_dtype()),
            ("string_field", self._string_field_converter.overall_dtype()),
            ("tuple_field", self._tuple_field_converter.overall_dtype()),
            ("vector_field", self._vector_field_converter.overall_dtype()),
            ("vector_of_vectors_field", self._vector_of_vectors_field_converter.overall_dtype()),
            ("fixed_vector_field", self._fixed_vector_field_converter.overall_dtype()),
            ("fixed_vector_of_vectors_field", self._fixed_vector_of_vectors_field_converter.overall_dtype()),
            ("optional_named_array", self._optional_named_array_converter.overall_dtype()),
            ("int_float_union", self._int_float_union_converter.overall_dtype()),
            ("nullable_int_float_union", self._nullable_int_float_union_converter.overall_dtype()),
            ("union_with_nested_generic_union", self._union_with_nested_generic_union_converter.overall_dtype()),
            ("map_field", self._map_field_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithComputedFields) -> object:
        if not isinstance(value, RecordWithComputedFields): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithComputedFields' instance")
        json_object = {}

        json_object["arrayField"] = self._array_field_converter.to_json(value.array_field)
        json_object["arrayFieldMapDimensions"] = self._array_field_map_dimensions_converter.to_json(value.array_field_map_dimensions)
        json_object["dynamicArrayField"] = self._dynamic_array_field_converter.to_json(value.dynamic_array_field)
        json_object["fixedArrayField"] = self._fixed_array_field_converter.to_json(value.fixed_array_field)
        json_object["intField"] = self._int_field_converter.to_json(value.int_field)
        json_object["int8Field"] = self._int8_field_converter.to_json(value.int8_field)
        json_object["uint8Field"] = self._uint8_field_converter.to_json(value.uint8_field)
        json_object["int16Field"] = self._int16_field_converter.to_json(value.int16_field)
        json_object["uint16Field"] = self._uint16_field_converter.to_json(value.uint16_field)
        json_object["uint32Field"] = self._uint32_field_converter.to_json(value.uint32_field)
        json_object["int64Field"] = self._int64_field_converter.to_json(value.int64_field)
        json_object["uint64Field"] = self._uint64_field_converter.to_json(value.uint64_field)
        json_object["sizeField"] = self._size_field_converter.to_json(value.size_field)
        json_object["float32Field"] = self._float32_field_converter.to_json(value.float32_field)
        json_object["float64Field"] = self._float64_field_converter.to_json(value.float64_field)
        json_object["complexfloat32Field"] = self._complexfloat32_field_converter.to_json(value.complexfloat32_field)
        json_object["complexfloat64Field"] = self._complexfloat64_field_converter.to_json(value.complexfloat64_field)
        json_object["stringField"] = self._string_field_converter.to_json(value.string_field)
        json_object["tupleField"] = self._tuple_field_converter.to_json(value.tuple_field)
        json_object["vectorField"] = self._vector_field_converter.to_json(value.vector_field)
        json_object["vectorOfVectorsField"] = self._vector_of_vectors_field_converter.to_json(value.vector_of_vectors_field)
        json_object["fixedVectorField"] = self._fixed_vector_field_converter.to_json(value.fixed_vector_field)
        json_object["fixedVectorOfVectorsField"] = self._fixed_vector_of_vectors_field_converter.to_json(value.fixed_vector_of_vectors_field)
        if value.optional_named_array is not None:
            json_object["optionalNamedArray"] = self._optional_named_array_converter.to_json(value.optional_named_array)
        json_object["intFloatUnion"] = self._int_float_union_converter.to_json(value.int_float_union)
        if value.nullable_int_float_union is not None:
            json_object["nullableIntFloatUnion"] = self._nullable_int_float_union_converter.to_json(value.nullable_int_float_union)
        json_object["unionWithNestedGenericUnion"] = self._union_with_nested_generic_union_converter.to_json(value.union_with_nested_generic_union)
        json_object["mapField"] = self._map_field_converter.to_json(value.map_field)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["arrayField"] = self._array_field_converter.numpy_to_json(value["array_field"])
        json_object["arrayFieldMapDimensions"] = self._array_field_map_dimensions_converter.numpy_to_json(value["array_field_map_dimensions"])
        json_object["dynamicArrayField"] = self._dynamic_array_field_converter.numpy_to_json(value["dynamic_array_field"])
        json_object["fixedArrayField"] = self._fixed_array_field_converter.numpy_to_json(value["fixed_array_field"])
        json_object["intField"] = self._int_field_converter.numpy_to_json(value["int_field"])
        json_object["int8Field"] = self._int8_field_converter.numpy_to_json(value["int8_field"])
        json_object["uint8Field"] = self._uint8_field_converter.numpy_to_json(value["uint8_field"])
        json_object["int16Field"] = self._int16_field_converter.numpy_to_json(value["int16_field"])
        json_object["uint16Field"] = self._uint16_field_converter.numpy_to_json(value["uint16_field"])
        json_object["uint32Field"] = self._uint32_field_converter.numpy_to_json(value["uint32_field"])
        json_object["int64Field"] = self._int64_field_converter.numpy_to_json(value["int64_field"])
        json_object["uint64Field"] = self._uint64_field_converter.numpy_to_json(value["uint64_field"])
        json_object["sizeField"] = self._size_field_converter.numpy_to_json(value["size_field"])
        json_object["float32Field"] = self._float32_field_converter.numpy_to_json(value["float32_field"])
        json_object["float64Field"] = self._float64_field_converter.numpy_to_json(value["float64_field"])
        json_object["complexfloat32Field"] = self._complexfloat32_field_converter.numpy_to_json(value["complexfloat32_field"])
        json_object["complexfloat64Field"] = self._complexfloat64_field_converter.numpy_to_json(value["complexfloat64_field"])
        json_object["stringField"] = self._string_field_converter.numpy_to_json(value["string_field"])
        json_object["tupleField"] = self._tuple_field_converter.numpy_to_json(value["tuple_field"])
        json_object["vectorField"] = self._vector_field_converter.numpy_to_json(value["vector_field"])
        json_object["vectorOfVectorsField"] = self._vector_of_vectors_field_converter.numpy_to_json(value["vector_of_vectors_field"])
        json_object["fixedVectorField"] = self._fixed_vector_field_converter.numpy_to_json(value["fixed_vector_field"])
        json_object["fixedVectorOfVectorsField"] = self._fixed_vector_of_vectors_field_converter.numpy_to_json(value["fixed_vector_of_vectors_field"])
        if (field_val := value["optional_named_array"]) is not None:
            json_object["optionalNamedArray"] = self._optional_named_array_converter.numpy_to_json(field_val)
        json_object["intFloatUnion"] = self._int_float_union_converter.numpy_to_json(value["int_float_union"])
        if (field_val := value["nullable_int_float_union"]) is not None:
            json_object["nullableIntFloatUnion"] = self._nullable_int_float_union_converter.numpy_to_json(field_val)
        json_object["unionWithNestedGenericUnion"] = self._union_with_nested_generic_union_converter.numpy_to_json(value["union_with_nested_generic_union"])
        json_object["mapField"] = self._map_field_converter.numpy_to_json(value["map_field"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithComputedFields:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithComputedFields(
            array_field=self._array_field_converter.from_json(json_object["arrayField"],),
            array_field_map_dimensions=self._array_field_map_dimensions_converter.from_json(json_object["arrayFieldMapDimensions"],),
            dynamic_array_field=self._dynamic_array_field_converter.from_json(json_object["dynamicArrayField"],),
            fixed_array_field=self._fixed_array_field_converter.from_json(json_object["fixedArrayField"],),
            int_field=self._int_field_converter.from_json(json_object["intField"],),
            int8_field=self._int8_field_converter.from_json(json_object["int8Field"],),
            uint8_field=self._uint8_field_converter.from_json(json_object["uint8Field"],),
            int16_field=self._int16_field_converter.from_json(json_object["int16Field"],),
            uint16_field=self._uint16_field_converter.from_json(json_object["uint16Field"],),
            uint32_field=self._uint32_field_converter.from_json(json_object["uint32Field"],),
            int64_field=self._int64_field_converter.from_json(json_object["int64Field"],),
            uint64_field=self._uint64_field_converter.from_json(json_object["uint64Field"],),
            size_field=self._size_field_converter.from_json(json_object["sizeField"],),
            float32_field=self._float32_field_converter.from_json(json_object["float32Field"],),
            float64_field=self._float64_field_converter.from_json(json_object["float64Field"],),
            complexfloat32_field=self._complexfloat32_field_converter.from_json(json_object["complexfloat32Field"],),
            complexfloat64_field=self._complexfloat64_field_converter.from_json(json_object["complexfloat64Field"],),
            string_field=self._string_field_converter.from_json(json_object["stringField"],),
            tuple_field=self._tuple_field_converter.from_json(json_object["tupleField"],),
            vector_field=self._vector_field_converter.from_json(json_object["vectorField"],),
            vector_of_vectors_field=self._vector_of_vectors_field_converter.from_json(json_object["vectorOfVectorsField"],),
            fixed_vector_field=self._fixed_vector_field_converter.from_json(json_object["fixedVectorField"],),
            fixed_vector_of_vectors_field=self._fixed_vector_of_vectors_field_converter.from_json(json_object["fixedVectorOfVectorsField"],),
            optional_named_array=self._optional_named_array_converter.from_json(json_object.get("optionalNamedArray")),
            int_float_union=self._int_float_union_converter.from_json(json_object["intFloatUnion"],),
            nullable_int_float_union=self._nullable_int_float_union_converter.from_json(json_object.get("nullableIntFloatUnion")),
            union_with_nested_generic_union=self._union_with_nested_generic_union_converter.from_json(json_object["unionWithNestedGenericUnion"],),
            map_field=self._map_field_converter.from_json(json_object["mapField"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._array_field_converter.from_json_to_numpy(json_object["arrayField"]),
            self._array_field_map_dimensions_converter.from_json_to_numpy(json_object["arrayFieldMapDimensions"]),
            self._dynamic_array_field_converter.from_json_to_numpy(json_object["dynamicArrayField"]),
            self._fixed_array_field_converter.from_json_to_numpy(json_object["fixedArrayField"]),
            self._int_field_converter.from_json_to_numpy(json_object["intField"]),
            self._int8_field_converter.from_json_to_numpy(json_object["int8Field"]),
            self._uint8_field_converter.from_json_to_numpy(json_object["uint8Field"]),
            self._int16_field_converter.from_json_to_numpy(json_object["int16Field"]),
            self._uint16_field_converter.from_json_to_numpy(json_object["uint16Field"]),
            self._uint32_field_converter.from_json_to_numpy(json_object["uint32Field"]),
            self._int64_field_converter.from_json_to_numpy(json_object["int64Field"]),
            self._uint64_field_converter.from_json_to_numpy(json_object["uint64Field"]),
            self._size_field_converter.from_json_to_numpy(json_object["sizeField"]),
            self._float32_field_converter.from_json_to_numpy(json_object["float32Field"]),
            self._float64_field_converter.from_json_to_numpy(json_object["float64Field"]),
            self._complexfloat32_field_converter.from_json_to_numpy(json_object["complexfloat32Field"]),
            self._complexfloat64_field_converter.from_json_to_numpy(json_object["complexfloat64Field"]),
            self._string_field_converter.from_json_to_numpy(json_object["stringField"]),
            self._tuple_field_converter.from_json_to_numpy(json_object["tupleField"]),
            self._vector_field_converter.from_json_to_numpy(json_object["vectorField"]),
            self._vector_of_vectors_field_converter.from_json_to_numpy(json_object["vectorOfVectorsField"]),
            self._fixed_vector_field_converter.from_json_to_numpy(json_object["fixedVectorField"]),
            self._fixed_vector_of_vectors_field_converter.from_json_to_numpy(json_object["fixedVectorOfVectorsField"]),
            self._optional_named_array_converter.from_json_to_numpy(json_object.get("optionalNamedArray")),
            self._int_float_union_converter.from_json_to_numpy(json_object["intFloatUnion"]),
            self._nullable_int_float_union_converter.from_json_to_numpy(json_object.get("nullableIntFloatUnion")),
            self._union_with_nested_generic_union_converter.from_json_to_numpy(json_object["unionWithNestedGenericUnion"]),
            self._map_field_converter.from_json_to_numpy(json_object["mapField"]),
        ) # type:ignore 


class RecordNotUsedInProtocolConverter(_ndjson.JsonConverter[RecordNotUsedInProtocol, np.void]):
    def __init__(self) -> None:
        self._u1_converter = _ndjson.UnionConverter(GenericUnion3, [(GenericUnion3.T, _ndjson.int32_converter, [int, float]), (GenericUnion3.U, _ndjson.float32_converter, [int, float]), (GenericUnion3.V, _ndjson.string_converter, [str])], False)
        self._u2_converter = _ndjson.UnionConverter(GenericUnion3Alternate, [(GenericUnion3Alternate.U, _ndjson.int32_converter, [int, float]), (GenericUnion3Alternate.V, _ndjson.float32_converter, [int, float]), (GenericUnion3Alternate.W, _ndjson.string_converter, [str])], False)
        super().__init__(np.dtype([
            ("u1", self._u1_converter.overall_dtype()),
            ("u2", self._u2_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordNotUsedInProtocol) -> object:
        if not isinstance(value, RecordNotUsedInProtocol): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordNotUsedInProtocol' instance")
        json_object = {}

        json_object["u1"] = self._u1_converter.to_json(value.u1)
        json_object["u2"] = self._u2_converter.to_json(value.u2)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["u1"] = self._u1_converter.numpy_to_json(value["u1"])
        json_object["u2"] = self._u2_converter.numpy_to_json(value["u2"])
        return json_object

    def from_json(self, json_object: object) -> RecordNotUsedInProtocol:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordNotUsedInProtocol(
            u1=self._u1_converter.from_json(json_object["u1"],),
            u2=self._u2_converter.from_json(json_object["u2"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._u1_converter.from_json_to_numpy(json_object["u1"]),
            self._u2_converter.from_json_to_numpy(json_object["u2"]),
        ) # type:ignore 


enum_with_keyword_symbols_name_to_value_map = {
    "try": EnumWithKeywordSymbols.TRY,
    "catch": EnumWithKeywordSymbols.CATCH,
}
enum_with_keyword_symbols_value_to_name_map = {v: n for n, v in enum_with_keyword_symbols_name_to_value_map.items()}

class RecordWithKeywordFieldsConverter(_ndjson.JsonConverter[RecordWithKeywordFields, np.void]):
    def __init__(self) -> None:
        self._int__converter = _ndjson.string_converter
        self._sizeof_converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        self._if__converter = _ndjson.EnumConverter(EnumWithKeywordSymbols, np.int32, enum_with_keyword_symbols_name_to_value_map, enum_with_keyword_symbols_value_to_name_map)
        super().__init__(np.dtype([
            ("int_", self._int__converter.overall_dtype()),
            ("sizeof", self._sizeof_converter.overall_dtype()),
            ("if_", self._if__converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithKeywordFields) -> object:
        if not isinstance(value, RecordWithKeywordFields): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithKeywordFields' instance")
        json_object = {}

        json_object["int"] = self._int__converter.to_json(value.int_)
        json_object["sizeof"] = self._sizeof_converter.to_json(value.sizeof)
        json_object["if"] = self._if__converter.to_json(value.if_)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["int"] = self._int__converter.numpy_to_json(value["int_"])
        json_object["sizeof"] = self._sizeof_converter.numpy_to_json(value["sizeof"])
        json_object["if"] = self._if__converter.numpy_to_json(value["if_"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithKeywordFields:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithKeywordFields(
            int_=self._int__converter.from_json(json_object["int"],),
            sizeof=self._sizeof_converter.from_json(json_object["sizeof"],),
            if_=self._if__converter.from_json(json_object["if"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._int__converter.from_json_to_numpy(json_object["int"]),
            self._sizeof_converter.from_json_to_numpy(json_object["sizeof"]),
            self._if__converter.from_json_to_numpy(json_object["if"]),
        ) # type:ignore 


class RecordWithOptionalDateConverter(_ndjson.JsonConverter[RecordWithOptionalDate, np.void]):
    def __init__(self) -> None:
        self._date_field_converter = _ndjson.OptionalConverter(_ndjson.date_converter)
        super().__init__(np.dtype([
            ("date_field", self._date_field_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithOptionalDate) -> object:
        if not isinstance(value, RecordWithOptionalDate): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithOptionalDate' instance")
        json_object = {}

        if value.date_field is not None:
            json_object["dateField"] = self._date_field_converter.to_json(value.date_field)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["date_field"]) is not None:
            json_object["dateField"] = self._date_field_converter.numpy_to_json(field_val)
        return json_object

    def from_json(self, json_object: object) -> RecordWithOptionalDate:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithOptionalDate(
            date_field=self._date_field_converter.from_json(json_object.get("dateField")),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._date_field_converter.from_json_to_numpy(json_object.get("dateField")),
        ) # type:ignore 


class NDJsonBenchmarkFloat256x256Writer(_ndjson.NDJsonProtocolWriter, BenchmarkFloat256x256WriterBase):
    """NDJson writer for the BenchmarkFloat256x256 protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        BenchmarkFloat256x256WriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, BenchmarkFloat256x256WriterBase.schema)

    def _write_float256x256(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (256, 256,))
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"float256x256": json_item})


class NDJsonBenchmarkFloat256x256Reader(_ndjson.NDJsonProtocolReader, BenchmarkFloat256x256ReaderBase):
    """NDJson writer for the BenchmarkFloat256x256 protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        BenchmarkFloat256x256ReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, BenchmarkFloat256x256ReaderBase.schema)

    def _read_float256x256(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (256, 256,))
        while (json_object := self._read_json_line("float256x256", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonBenchmarkInt256x256Writer(_ndjson.NDJsonProtocolWriter, BenchmarkInt256x256WriterBase):
    """NDJson writer for the BenchmarkInt256x256 protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        BenchmarkInt256x256WriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, BenchmarkInt256x256WriterBase.schema)

    def _write_int256x256(self, value: collections.abc.Iterable[npt.NDArray[np.int32]]) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (256, 256,))
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"int256x256": json_item})


class NDJsonBenchmarkInt256x256Reader(_ndjson.NDJsonProtocolReader, BenchmarkInt256x256ReaderBase):
    """NDJson writer for the BenchmarkInt256x256 protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        BenchmarkInt256x256ReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, BenchmarkInt256x256ReaderBase.schema)

    def _read_int256x256(self) -> collections.abc.Iterable[npt.NDArray[np.int32]]:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (256, 256,))
        while (json_object := self._read_json_line("int256x256", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonBenchmarkFloatVlenWriter(_ndjson.NDJsonProtocolWriter, BenchmarkFloatVlenWriterBase):
    """NDJson writer for the BenchmarkFloatVlen protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        BenchmarkFloatVlenWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, BenchmarkFloatVlenWriterBase.schema)

    def _write_float_array(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 2)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"floatArray": json_item})


class NDJsonBenchmarkFloatVlenReader(_ndjson.NDJsonProtocolReader, BenchmarkFloatVlenReaderBase):
    """NDJson writer for the BenchmarkFloatVlen protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        BenchmarkFloatVlenReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, BenchmarkFloatVlenReaderBase.schema)

    def _read_float_array(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 2)
        while (json_object := self._read_json_line("floatArray", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonBenchmarkSmallRecordWriter(_ndjson.NDJsonProtocolWriter, BenchmarkSmallRecordWriterBase):
    """NDJson writer for the BenchmarkSmallRecord protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        BenchmarkSmallRecordWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, BenchmarkSmallRecordWriterBase.schema)

    def _write_small_record(self, value: collections.abc.Iterable[SmallBenchmarkRecord]) -> None:
        converter = SmallBenchmarkRecordConverter()
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"smallRecord": json_item})


class NDJsonBenchmarkSmallRecordReader(_ndjson.NDJsonProtocolReader, BenchmarkSmallRecordReaderBase):
    """NDJson writer for the BenchmarkSmallRecord protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        BenchmarkSmallRecordReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, BenchmarkSmallRecordReaderBase.schema)

    def _read_small_record(self) -> collections.abc.Iterable[SmallBenchmarkRecord]:
        converter = SmallBenchmarkRecordConverter()
        while (json_object := self._read_json_line("smallRecord", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonBenchmarkSmallRecordWithOptionalsWriter(_ndjson.NDJsonProtocolWriter, BenchmarkSmallRecordWithOptionalsWriterBase):
    """NDJson writer for the BenchmarkSmallRecordWithOptionals protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        BenchmarkSmallRecordWithOptionalsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, BenchmarkSmallRecordWithOptionalsWriterBase.schema)

    def _write_small_record(self, value: collections.abc.Iterable[SimpleEncodingCounters]) -> None:
        converter = SimpleEncodingCountersConverter()
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"smallRecord": json_item})


class NDJsonBenchmarkSmallRecordWithOptionalsReader(_ndjson.NDJsonProtocolReader, BenchmarkSmallRecordWithOptionalsReaderBase):
    """NDJson writer for the BenchmarkSmallRecordWithOptionals protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        BenchmarkSmallRecordWithOptionalsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, BenchmarkSmallRecordWithOptionalsReaderBase.schema)

    def _read_small_record(self) -> collections.abc.Iterable[SimpleEncodingCounters]:
        converter = SimpleEncodingCountersConverter()
        while (json_object := self._read_json_line("smallRecord", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonBenchmarkSimpleMrdWriter(_ndjson.NDJsonProtocolWriter, BenchmarkSimpleMrdWriterBase):
    """NDJson writer for the BenchmarkSimpleMrd protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        BenchmarkSimpleMrdWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, BenchmarkSimpleMrdWriterBase.schema)

    def _write_data(self, value: collections.abc.Iterable[AcquisitionOrImage]) -> None:
        converter = _ndjson.UnionConverter(AcquisitionOrImage, [(AcquisitionOrImage.Acquisition, SimpleAcquisitionConverter(), [dict]), (AcquisitionOrImage.Image, _ndjson.NDArrayConverter(_ndjson.float32_converter, 2), [dict])], False)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"data": json_item})


class NDJsonBenchmarkSimpleMrdReader(_ndjson.NDJsonProtocolReader, BenchmarkSimpleMrdReaderBase):
    """NDJson writer for the BenchmarkSimpleMrd protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        BenchmarkSimpleMrdReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, BenchmarkSimpleMrdReaderBase.schema)

    def _read_data(self) -> collections.abc.Iterable[AcquisitionOrImage]:
        converter = _ndjson.UnionConverter(AcquisitionOrImage, [(AcquisitionOrImage.Acquisition, SimpleAcquisitionConverter(), [dict]), (AcquisitionOrImage.Image, _ndjson.NDArrayConverter(_ndjson.float32_converter, 2), [dict])], False)
        while (json_object := self._read_json_line("data", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonScalarsWriter(_ndjson.NDJsonProtocolWriter, ScalarsWriterBase):
    """NDJson writer for the Scalars protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        ScalarsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, ScalarsWriterBase.schema)

    def _write_int32(self, value: yardl.Int32) -> None:
        converter = _ndjson.int32_converter
        json_value = converter.to_json(value)
        self._write_json_line({"int32": json_value})

    def _write_record(self, value: RecordWithPrimitives) -> None:
        converter = RecordWithPrimitivesConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"record": json_value})


class NDJsonScalarsReader(_ndjson.NDJsonProtocolReader, ScalarsReaderBase):
    """NDJson writer for the Scalars protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        ScalarsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, ScalarsReaderBase.schema)

    def _read_int32(self) -> yardl.Int32:
        json_object = self._read_json_line("int32", True)
        converter = _ndjson.int32_converter
        return converter.from_json(json_object)

    def _read_record(self) -> RecordWithPrimitives:
        json_object = self._read_json_line("record", True)
        converter = RecordWithPrimitivesConverter()
        return converter.from_json(json_object)

class NDJsonScalarOptionalsWriter(_ndjson.NDJsonProtocolWriter, ScalarOptionalsWriterBase):
    """NDJson writer for the ScalarOptionals protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        ScalarOptionalsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, ScalarOptionalsWriterBase.schema)

    def _write_optional_int(self, value: typing.Optional[yardl.Int32]) -> None:
        converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"optionalInt": json_value})

    def _write_optional_record(self, value: typing.Optional[SimpleRecord]) -> None:
        converter = _ndjson.OptionalConverter(SimpleRecordConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"optionalRecord": json_value})

    def _write_record_with_optional_fields(self, value: RecordWithOptionalFields) -> None:
        converter = RecordWithOptionalFieldsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithOptionalFields": json_value})

    def _write_optional_record_with_optional_fields(self, value: typing.Optional[RecordWithOptionalFields]) -> None:
        converter = _ndjson.OptionalConverter(RecordWithOptionalFieldsConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"optionalRecordWithOptionalFields": json_value})


class NDJsonScalarOptionalsReader(_ndjson.NDJsonProtocolReader, ScalarOptionalsReaderBase):
    """NDJson writer for the ScalarOptionals protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        ScalarOptionalsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, ScalarOptionalsReaderBase.schema)

    def _read_optional_int(self) -> typing.Optional[yardl.Int32]:
        json_object = self._read_json_line("optionalInt", True)
        converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        return converter.from_json(json_object)

    def _read_optional_record(self) -> typing.Optional[SimpleRecord]:
        json_object = self._read_json_line("optionalRecord", True)
        converter = _ndjson.OptionalConverter(SimpleRecordConverter())
        return converter.from_json(json_object)

    def _read_record_with_optional_fields(self) -> RecordWithOptionalFields:
        json_object = self._read_json_line("recordWithOptionalFields", True)
        converter = RecordWithOptionalFieldsConverter()
        return converter.from_json(json_object)

    def _read_optional_record_with_optional_fields(self) -> typing.Optional[RecordWithOptionalFields]:
        json_object = self._read_json_line("optionalRecordWithOptionalFields", True)
        converter = _ndjson.OptionalConverter(RecordWithOptionalFieldsConverter())
        return converter.from_json(json_object)

class NDJsonNestedRecordsWriter(_ndjson.NDJsonProtocolWriter, NestedRecordsWriterBase):
    """NDJson writer for the NestedRecords protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        NestedRecordsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, NestedRecordsWriterBase.schema)

    def _write_tuple_with_records(self, value: TupleWithRecords) -> None:
        converter = TupleWithRecordsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"tupleWithRecords": json_value})


class NDJsonNestedRecordsReader(_ndjson.NDJsonProtocolReader, NestedRecordsReaderBase):
    """NDJson writer for the NestedRecords protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        NestedRecordsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, NestedRecordsReaderBase.schema)

    def _read_tuple_with_records(self) -> TupleWithRecords:
        json_object = self._read_json_line("tupleWithRecords", True)
        converter = TupleWithRecordsConverter()
        return converter.from_json(json_object)

class NDJsonVlensWriter(_ndjson.NDJsonProtocolWriter, VlensWriterBase):
    """NDJson writer for the Vlens protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        VlensWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, VlensWriterBase.schema)

    def _write_int_vector(self, value: list[yardl.Int32]) -> None:
        converter = _ndjson.VectorConverter(_ndjson.int32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"intVector": json_value})

    def _write_complex_vector(self, value: list[yardl.ComplexFloat]) -> None:
        converter = _ndjson.VectorConverter(_ndjson.complexfloat32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"complexVector": json_value})

    def _write_record_with_vlens(self, value: RecordWithVlens) -> None:
        converter = RecordWithVlensConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithVlens": json_value})

    def _write_vlen_of_record_with_vlens(self, value: list[RecordWithVlens]) -> None:
        converter = _ndjson.VectorConverter(RecordWithVlensConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"vlenOfRecordWithVlens": json_value})


class NDJsonVlensReader(_ndjson.NDJsonProtocolReader, VlensReaderBase):
    """NDJson writer for the Vlens protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        VlensReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, VlensReaderBase.schema)

    def _read_int_vector(self) -> list[yardl.Int32]:
        json_object = self._read_json_line("intVector", True)
        converter = _ndjson.VectorConverter(_ndjson.int32_converter)
        return converter.from_json(json_object)

    def _read_complex_vector(self) -> list[yardl.ComplexFloat]:
        json_object = self._read_json_line("complexVector", True)
        converter = _ndjson.VectorConverter(_ndjson.complexfloat32_converter)
        return converter.from_json(json_object)

    def _read_record_with_vlens(self) -> RecordWithVlens:
        json_object = self._read_json_line("recordWithVlens", True)
        converter = RecordWithVlensConverter()
        return converter.from_json(json_object)

    def _read_vlen_of_record_with_vlens(self) -> list[RecordWithVlens]:
        json_object = self._read_json_line("vlenOfRecordWithVlens", True)
        converter = _ndjson.VectorConverter(RecordWithVlensConverter())
        return converter.from_json(json_object)

class NDJsonStringsWriter(_ndjson.NDJsonProtocolWriter, StringsWriterBase):
    """NDJson writer for the Strings protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        StringsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, StringsWriterBase.schema)

    def _write_single_string(self, value: str) -> None:
        converter = _ndjson.string_converter
        json_value = converter.to_json(value)
        self._write_json_line({"singleString": json_value})

    def _write_rec_with_string(self, value: RecordWithStrings) -> None:
        converter = RecordWithStringsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recWithString": json_value})


class NDJsonStringsReader(_ndjson.NDJsonProtocolReader, StringsReaderBase):
    """NDJson writer for the Strings protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        StringsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, StringsReaderBase.schema)

    def _read_single_string(self) -> str:
        json_object = self._read_json_line("singleString", True)
        converter = _ndjson.string_converter
        return converter.from_json(json_object)

    def _read_rec_with_string(self) -> RecordWithStrings:
        json_object = self._read_json_line("recWithString", True)
        converter = RecordWithStringsConverter()
        return converter.from_json(json_object)

class NDJsonOptionalVectorsWriter(_ndjson.NDJsonProtocolWriter, OptionalVectorsWriterBase):
    """NDJson writer for the OptionalVectors protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        OptionalVectorsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, OptionalVectorsWriterBase.schema)

    def _write_record_with_optional_vector(self, value: RecordWithOptionalVector) -> None:
        converter = RecordWithOptionalVectorConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithOptionalVector": json_value})


class NDJsonOptionalVectorsReader(_ndjson.NDJsonProtocolReader, OptionalVectorsReaderBase):
    """NDJson writer for the OptionalVectors protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        OptionalVectorsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, OptionalVectorsReaderBase.schema)

    def _read_record_with_optional_vector(self) -> RecordWithOptionalVector:
        json_object = self._read_json_line("recordWithOptionalVector", True)
        converter = RecordWithOptionalVectorConverter()
        return converter.from_json(json_object)

class NDJsonFixedVectorsWriter(_ndjson.NDJsonProtocolWriter, FixedVectorsWriterBase):
    """NDJson writer for the FixedVectors protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        FixedVectorsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, FixedVectorsWriterBase.schema)

    def _write_fixed_int_vector(self, value: list[yardl.Int32]) -> None:
        converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 5)
        json_value = converter.to_json(value)
        self._write_json_line({"fixedIntVector": json_value})

    def _write_fixed_simple_record_vector(self, value: list[SimpleRecord]) -> None:
        converter = _ndjson.FixedVectorConverter(SimpleRecordConverter(), 3)
        json_value = converter.to_json(value)
        self._write_json_line({"fixedSimpleRecordVector": json_value})

    def _write_fixed_record_with_vlens_vector(self, value: list[RecordWithVlens]) -> None:
        converter = _ndjson.FixedVectorConverter(RecordWithVlensConverter(), 2)
        json_value = converter.to_json(value)
        self._write_json_line({"fixedRecordWithVlensVector": json_value})

    def _write_record_with_fixed_vectors(self, value: RecordWithFixedVectors) -> None:
        converter = RecordWithFixedVectorsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithFixedVectors": json_value})


class NDJsonFixedVectorsReader(_ndjson.NDJsonProtocolReader, FixedVectorsReaderBase):
    """NDJson writer for the FixedVectors protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        FixedVectorsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, FixedVectorsReaderBase.schema)

    def _read_fixed_int_vector(self) -> list[yardl.Int32]:
        json_object = self._read_json_line("fixedIntVector", True)
        converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 5)
        return converter.from_json(json_object)

    def _read_fixed_simple_record_vector(self) -> list[SimpleRecord]:
        json_object = self._read_json_line("fixedSimpleRecordVector", True)
        converter = _ndjson.FixedVectorConverter(SimpleRecordConverter(), 3)
        return converter.from_json(json_object)

    def _read_fixed_record_with_vlens_vector(self) -> list[RecordWithVlens]:
        json_object = self._read_json_line("fixedRecordWithVlensVector", True)
        converter = _ndjson.FixedVectorConverter(RecordWithVlensConverter(), 2)
        return converter.from_json(json_object)

    def _read_record_with_fixed_vectors(self) -> RecordWithFixedVectors:
        json_object = self._read_json_line("recordWithFixedVectors", True)
        converter = RecordWithFixedVectorsConverter()
        return converter.from_json(json_object)

class NDJsonStreamsWriter(_ndjson.NDJsonProtocolWriter, StreamsWriterBase):
    """NDJson writer for the Streams protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        StreamsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, StreamsWriterBase.schema)

    def _write_int_data(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        converter = _ndjson.int32_converter
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"intData": json_item})

    def _write_optional_int_data(self, value: collections.abc.Iterable[typing.Optional[yardl.Int32]]) -> None:
        converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"optionalIntData": json_item})

    def _write_record_with_optional_vector_data(self, value: collections.abc.Iterable[RecordWithOptionalVector]) -> None:
        converter = RecordWithOptionalVectorConverter()
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"recordWithOptionalVectorData": json_item})

    def _write_fixed_vector(self, value: collections.abc.Iterable[list[yardl.Int32]]) -> None:
        converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 3)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"fixedVector": json_item})


class NDJsonStreamsReader(_ndjson.NDJsonProtocolReader, StreamsReaderBase):
    """NDJson writer for the Streams protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        StreamsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, StreamsReaderBase.schema)

    def _read_int_data(self) -> collections.abc.Iterable[yardl.Int32]:
        converter = _ndjson.int32_converter
        while (json_object := self._read_json_line("intData", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_optional_int_data(self) -> collections.abc.Iterable[typing.Optional[yardl.Int32]]:
        converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        while (json_object := self._read_json_line("optionalIntData", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_record_with_optional_vector_data(self) -> collections.abc.Iterable[RecordWithOptionalVector]:
        converter = RecordWithOptionalVectorConverter()
        while (json_object := self._read_json_line("recordWithOptionalVectorData", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_fixed_vector(self) -> collections.abc.Iterable[list[yardl.Int32]]:
        converter = _ndjson.FixedVectorConverter(_ndjson.int32_converter, 3)
        while (json_object := self._read_json_line("fixedVector", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonFixedArraysWriter(_ndjson.NDJsonProtocolWriter, FixedArraysWriterBase):
    """NDJson writer for the FixedArrays protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        FixedArraysWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, FixedArraysWriterBase.schema)

    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 3,))
        json_value = converter.to_json(value)
        self._write_json_line({"ints": json_value})

    def _write_fixed_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.FixedNDArrayConverter(SimpleRecordConverter(), (3, 2,))
        json_value = converter.to_json(value)
        self._write_json_line({"fixedSimpleRecordArray": json_value})

    def _write_fixed_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.FixedNDArrayConverter(RecordWithVlensConverter(), (2, 2,))
        json_value = converter.to_json(value)
        self._write_json_line({"fixedRecordWithVlensArray": json_value})

    def _write_record_with_fixed_arrays(self, value: RecordWithFixedArrays) -> None:
        converter = RecordWithFixedArraysConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithFixedArrays": json_value})

    def _write_named_array(self, value: NamedFixedNDArray) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 4,))
        json_value = converter.to_json(value)
        self._write_json_line({"namedArray": json_value})


class NDJsonFixedArraysReader(_ndjson.NDJsonProtocolReader, FixedArraysReaderBase):
    """NDJson writer for the FixedArrays protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        FixedArraysReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, FixedArraysReaderBase.schema)

    def _read_ints(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("ints", True)
        converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 3,))
        return converter.from_json(json_object)

    def _read_fixed_simple_record_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("fixedSimpleRecordArray", True)
        converter = _ndjson.FixedNDArrayConverter(SimpleRecordConverter(), (3, 2,))
        return converter.from_json(json_object)

    def _read_fixed_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("fixedRecordWithVlensArray", True)
        converter = _ndjson.FixedNDArrayConverter(RecordWithVlensConverter(), (2, 2,))
        return converter.from_json(json_object)

    def _read_record_with_fixed_arrays(self) -> RecordWithFixedArrays:
        json_object = self._read_json_line("recordWithFixedArrays", True)
        converter = RecordWithFixedArraysConverter()
        return converter.from_json(json_object)

    def _read_named_array(self) -> NamedFixedNDArray:
        json_object = self._read_json_line("namedArray", True)
        converter = _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 4,))
        return converter.from_json(json_object)

class NDJsonSubarraysWriter(_ndjson.NDJsonProtocolWriter, SubarraysWriterBase):
    """NDJson writer for the Subarrays protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        SubarraysWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, SubarraysWriterBase.schema)

    def _write_dynamic_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)))
        json_value = converter.to_json(value)
        self._write_json_line({"dynamicWithFixedIntSubarray": json_value})

    def _write_dynamic_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (3,)))
        json_value = converter.to_json(value)
        self._write_json_line({"dynamicWithFixedFloatSubarray": json_value})

    def _write_known_dim_count_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), 1)
        json_value = converter.to_json(value)
        self._write_json_line({"knownDimCountWithFixedIntSubarray": json_value})

    def _write_known_dim_count_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (3,)), 1)
        json_value = converter.to_json(value)
        self._write_json_line({"knownDimCountWithFixedFloatSubarray": json_value})

    def _write_fixed_with_fixed_int_subarray(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), (2,))
        json_value = converter.to_json(value)
        self._write_json_line({"fixedWithFixedIntSubarray": json_value})

    def _write_fixed_with_fixed_float_subarray(self, value: npt.NDArray[np.float32]) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (3,)), (2,))
        json_value = converter.to_json(value)
        self._write_json_line({"fixedWithFixedFloatSubarray": json_value})

    def _write_nested_subarray(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), (2,)))
        json_value = converter.to_json(value)
        self._write_json_line({"nestedSubarray": json_value})

    def _write_dynamic_with_fixed_vector_subarray(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedVectorConverter(_ndjson.int32_converter, 3))
        json_value = converter.to_json(value)
        self._write_json_line({"dynamicWithFixedVectorSubarray": json_value})

    def _write_generic_subarray(self, value: Image[np.int32]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), 2)
        json_value = converter.to_json(value)
        self._write_json_line({"genericSubarray": json_value})


class NDJsonSubarraysReader(_ndjson.NDJsonProtocolReader, SubarraysReaderBase):
    """NDJson writer for the Subarrays protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        SubarraysReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, SubarraysReaderBase.schema)

    def _read_dynamic_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("dynamicWithFixedIntSubarray", True)
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)))
        return converter.from_json(json_object)

    def _read_dynamic_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        json_object = self._read_json_line("dynamicWithFixedFloatSubarray", True)
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (3,)))
        return converter.from_json(json_object)

    def _read_known_dim_count_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("knownDimCountWithFixedIntSubarray", True)
        converter = _ndjson.NDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), 1)
        return converter.from_json(json_object)

    def _read_known_dim_count_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        json_object = self._read_json_line("knownDimCountWithFixedFloatSubarray", True)
        converter = _ndjson.NDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (3,)), 1)
        return converter.from_json(json_object)

    def _read_fixed_with_fixed_int_subarray(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("fixedWithFixedIntSubarray", True)
        converter = _ndjson.FixedNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), (2,))
        return converter.from_json(json_object)

    def _read_fixed_with_fixed_float_subarray(self) -> npt.NDArray[np.float32]:
        json_object = self._read_json_line("fixedWithFixedFloatSubarray", True)
        converter = _ndjson.FixedNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (3,)), (2,))
        return converter.from_json(json_object)

    def _read_nested_subarray(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("nestedSubarray", True)
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), (2,)))
        return converter.from_json(json_object)

    def _read_dynamic_with_fixed_vector_subarray(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("dynamicWithFixedVectorSubarray", True)
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.FixedVectorConverter(_ndjson.int32_converter, 3))
        return converter.from_json(json_object)

    def _read_generic_subarray(self) -> Image[np.int32]:
        json_object = self._read_json_line("genericSubarray", True)
        converter = _ndjson.NDArrayConverter(_ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (3,)), 2)
        return converter.from_json(json_object)

class NDJsonSubarraysInRecordsWriter(_ndjson.NDJsonProtocolWriter, SubarraysInRecordsWriterBase):
    """NDJson writer for the SubarraysInRecords protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        SubarraysInRecordsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, SubarraysInRecordsWriterBase.schema)

    def _write_with_fixed_subarrays(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(RecordWithFixedCollectionsConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"withFixedSubarrays": json_value})

    def _write_with_vlen_subarrays(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(RecordWithVlenCollectionsConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"withVlenSubarrays": json_value})


class NDJsonSubarraysInRecordsReader(_ndjson.NDJsonProtocolReader, SubarraysInRecordsReaderBase):
    """NDJson writer for the SubarraysInRecords protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        SubarraysInRecordsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, SubarraysInRecordsReaderBase.schema)

    def _read_with_fixed_subarrays(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("withFixedSubarrays", True)
        converter = _ndjson.DynamicNDArrayConverter(RecordWithFixedCollectionsConverter())
        return converter.from_json(json_object)

    def _read_with_vlen_subarrays(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("withVlenSubarrays", True)
        converter = _ndjson.DynamicNDArrayConverter(RecordWithVlenCollectionsConverter())
        return converter.from_json(json_object)

class NDJsonNDArraysWriter(_ndjson.NDJsonProtocolWriter, NDArraysWriterBase):
    """NDJson writer for the NDArrays protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        NDArraysWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, NDArraysWriterBase.schema)

    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"ints": json_value})

    def _write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.NDArrayConverter(SimpleRecordConverter(), 2)
        json_value = converter.to_json(value)
        self._write_json_line({"simpleRecordArray": json_value})

    def _write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.NDArrayConverter(RecordWithVlensConverter(), 2)
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithVlensArray": json_value})

    def _write_record_with_nd_arrays(self, value: RecordWithNDArrays) -> None:
        converter = RecordWithNDArraysConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithNDArrays": json_value})

    def _write_named_array(self, value: NamedNDArray) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"namedArray": json_value})


class NDJsonNDArraysReader(_ndjson.NDJsonProtocolReader, NDArraysReaderBase):
    """NDJson writer for the NDArrays protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        NDArraysReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, NDArraysReaderBase.schema)

    def _read_ints(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("ints", True)
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        return converter.from_json(json_object)

    def _read_simple_record_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("simpleRecordArray", True)
        converter = _ndjson.NDArrayConverter(SimpleRecordConverter(), 2)
        return converter.from_json(json_object)

    def _read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("recordWithVlensArray", True)
        converter = _ndjson.NDArrayConverter(RecordWithVlensConverter(), 2)
        return converter.from_json(json_object)

    def _read_record_with_nd_arrays(self) -> RecordWithNDArrays:
        json_object = self._read_json_line("recordWithNDArrays", True)
        converter = RecordWithNDArraysConverter()
        return converter.from_json(json_object)

    def _read_named_array(self) -> NamedNDArray:
        json_object = self._read_json_line("namedArray", True)
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        return converter.from_json(json_object)

class NDJsonNDArraysSingleDimensionWriter(_ndjson.NDJsonProtocolWriter, NDArraysSingleDimensionWriterBase):
    """NDJson writer for the NDArraysSingleDimension protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        NDArraysSingleDimensionWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, NDArraysSingleDimensionWriterBase.schema)

    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 1)
        json_value = converter.to_json(value)
        self._write_json_line({"ints": json_value})

    def _write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.NDArrayConverter(SimpleRecordConverter(), 1)
        json_value = converter.to_json(value)
        self._write_json_line({"simpleRecordArray": json_value})

    def _write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.NDArrayConverter(RecordWithVlensConverter(), 1)
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithVlensArray": json_value})

    def _write_record_with_nd_arrays(self, value: RecordWithNDArraysSingleDimension) -> None:
        converter = RecordWithNDArraysSingleDimensionConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithNDArrays": json_value})


class NDJsonNDArraysSingleDimensionReader(_ndjson.NDJsonProtocolReader, NDArraysSingleDimensionReaderBase):
    """NDJson writer for the NDArraysSingleDimension protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        NDArraysSingleDimensionReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, NDArraysSingleDimensionReaderBase.schema)

    def _read_ints(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("ints", True)
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 1)
        return converter.from_json(json_object)

    def _read_simple_record_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("simpleRecordArray", True)
        converter = _ndjson.NDArrayConverter(SimpleRecordConverter(), 1)
        return converter.from_json(json_object)

    def _read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("recordWithVlensArray", True)
        converter = _ndjson.NDArrayConverter(RecordWithVlensConverter(), 1)
        return converter.from_json(json_object)

    def _read_record_with_nd_arrays(self) -> RecordWithNDArraysSingleDimension:
        json_object = self._read_json_line("recordWithNDArrays", True)
        converter = RecordWithNDArraysSingleDimensionConverter()
        return converter.from_json(json_object)

class NDJsonDynamicNDArraysWriter(_ndjson.NDJsonProtocolWriter, DynamicNDArraysWriterBase):
    """NDJson writer for the DynamicNDArrays protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        DynamicNDArraysWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, DynamicNDArraysWriterBase.schema)

    def _write_ints(self, value: npt.NDArray[np.int32]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"ints": json_value})

    def _write_simple_record_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(SimpleRecordConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"simpleRecordArray": json_value})

    def _write_record_with_vlens_array(self, value: npt.NDArray[np.void]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(RecordWithVlensConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithVlensArray": json_value})

    def _write_record_with_dynamic_nd_arrays(self, value: RecordWithDynamicNDArrays) -> None:
        converter = RecordWithDynamicNDArraysConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithDynamicNDArrays": json_value})


class NDJsonDynamicNDArraysReader(_ndjson.NDJsonProtocolReader, DynamicNDArraysReaderBase):
    """NDJson writer for the DynamicNDArrays protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        DynamicNDArraysReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, DynamicNDArraysReaderBase.schema)

    def _read_ints(self) -> npt.NDArray[np.int32]:
        json_object = self._read_json_line("ints", True)
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.int32_converter)
        return converter.from_json(json_object)

    def _read_simple_record_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("simpleRecordArray", True)
        converter = _ndjson.DynamicNDArrayConverter(SimpleRecordConverter())
        return converter.from_json(json_object)

    def _read_record_with_vlens_array(self) -> npt.NDArray[np.void]:
        json_object = self._read_json_line("recordWithVlensArray", True)
        converter = _ndjson.DynamicNDArrayConverter(RecordWithVlensConverter())
        return converter.from_json(json_object)

    def _read_record_with_dynamic_nd_arrays(self) -> RecordWithDynamicNDArrays:
        json_object = self._read_json_line("recordWithDynamicNDArrays", True)
        converter = RecordWithDynamicNDArraysConverter()
        return converter.from_json(json_object)

class NDJsonMultiDArraysWriter(_ndjson.NDJsonProtocolWriter, MultiDArraysWriterBase):
    """NDJson writer for the MultiDArrays protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        MultiDArraysWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, MultiDArraysWriterBase.schema)

    def _write_images(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 4)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"images": json_item})

    def _write_frames(self, value: collections.abc.Iterable[npt.NDArray[np.float32]]) -> None:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (1, 1, 64, 32,))
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"frames": json_item})


class NDJsonMultiDArraysReader(_ndjson.NDJsonProtocolReader, MultiDArraysReaderBase):
    """NDJson writer for the MultiDArrays protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        MultiDArraysReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, MultiDArraysReaderBase.schema)

    def _read_images(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 4)
        while (json_object := self._read_json_line("images", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_frames(self) -> collections.abc.Iterable[npt.NDArray[np.float32]]:
        converter = _ndjson.FixedNDArrayConverter(_ndjson.float32_converter, (1, 1, 64, 32,))
        while (json_object := self._read_json_line("frames", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonComplexArraysWriter(_ndjson.NDJsonProtocolWriter, ComplexArraysWriterBase):
    """NDJson writer for the ComplexArrays protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        ComplexArraysWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, ComplexArraysWriterBase.schema)

    def _write_floats(self, value: npt.NDArray[np.complex64]) -> None:
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.complexfloat32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"floats": json_value})

    def _write_doubles(self, value: npt.NDArray[np.complex128]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.complexfloat64_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"doubles": json_value})


class NDJsonComplexArraysReader(_ndjson.NDJsonProtocolReader, ComplexArraysReaderBase):
    """NDJson writer for the ComplexArrays protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        ComplexArraysReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, ComplexArraysReaderBase.schema)

    def _read_floats(self) -> npt.NDArray[np.complex64]:
        json_object = self._read_json_line("floats", True)
        converter = _ndjson.DynamicNDArrayConverter(_ndjson.complexfloat32_converter)
        return converter.from_json(json_object)

    def _read_doubles(self) -> npt.NDArray[np.complex128]:
        json_object = self._read_json_line("doubles", True)
        converter = _ndjson.NDArrayConverter(_ndjson.complexfloat64_converter, 2)
        return converter.from_json(json_object)

class NDJsonMapsWriter(_ndjson.NDJsonProtocolWriter, MapsWriterBase):
    """NDJson writer for the Maps protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        MapsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, MapsWriterBase.schema)

    def _write_string_to_int(self, value: dict[str, yardl.Int32]) -> None:
        converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.int32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"stringToInt": json_value})

    def _write_int_to_string(self, value: dict[yardl.Int32, str]) -> None:
        converter = _ndjson.MapConverter(_ndjson.int32_converter, _ndjson.string_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"intToString": json_value})

    def _write_string_to_union(self, value: dict[str, StringOrInt32]) -> None:
        converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.UnionConverter(StringOrInt32, [(StringOrInt32.String, _ndjson.string_converter, [str]), (StringOrInt32.Int32, _ndjson.int32_converter, [int, float])], True))
        json_value = converter.to_json(value)
        self._write_json_line({"stringToUnion": json_value})

    def _write_aliased_generic(self, value: basic_types.AliasedMap[str, yardl.Int32]) -> None:
        converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.int32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedGeneric": json_value})

    def _write_records(self, value: list[RecordWithMaps]) -> None:
        converter = _ndjson.VectorConverter(RecordWithMapsConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"records": json_value})


class NDJsonMapsReader(_ndjson.NDJsonProtocolReader, MapsReaderBase):
    """NDJson writer for the Maps protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        MapsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, MapsReaderBase.schema)

    def _read_string_to_int(self) -> dict[str, yardl.Int32]:
        json_object = self._read_json_line("stringToInt", True)
        converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.int32_converter)
        return converter.from_json(json_object)

    def _read_int_to_string(self) -> dict[yardl.Int32, str]:
        json_object = self._read_json_line("intToString", True)
        converter = _ndjson.MapConverter(_ndjson.int32_converter, _ndjson.string_converter)
        return converter.from_json(json_object)

    def _read_string_to_union(self) -> dict[str, StringOrInt32]:
        json_object = self._read_json_line("stringToUnion", True)
        converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.UnionConverter(StringOrInt32, [(StringOrInt32.String, _ndjson.string_converter, [str]), (StringOrInt32.Int32, _ndjson.int32_converter, [int, float])], True))
        return converter.from_json(json_object)

    def _read_aliased_generic(self) -> basic_types.AliasedMap[str, yardl.Int32]:
        json_object = self._read_json_line("aliasedGeneric", True)
        converter = _ndjson.MapConverter(_ndjson.string_converter, _ndjson.int32_converter)
        return converter.from_json(json_object)

    def _read_records(self) -> list[RecordWithMaps]:
        json_object = self._read_json_line("records", True)
        converter = _ndjson.VectorConverter(RecordWithMapsConverter())
        return converter.from_json(json_object)

class NDJsonUnionsWriter(_ndjson.NDJsonProtocolWriter, UnionsWriterBase):
    """NDJson writer for the Unions protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        UnionsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, UnionsWriterBase.schema)

    def _write_int_or_simple_record(self, value: Int32OrSimpleRecord) -> None:
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [(Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        json_value = converter.to_json(value)
        self._write_json_line({"intOrSimpleRecord": json_value})

    def _write_int_or_record_with_vlens(self, value: Int32OrRecordWithVlens) -> None:
        converter = _ndjson.UnionConverter(Int32OrRecordWithVlens, [(Int32OrRecordWithVlens.Int32, _ndjson.int32_converter, [int, float]), (Int32OrRecordWithVlens.RecordWithVlens, RecordWithVlensConverter(), [dict])], True)
        json_value = converter.to_json(value)
        self._write_json_line({"intOrRecordWithVlens": json_value})

    def _write_monosotate_or_int_or_simple_record(self, value: typing.Optional[Int32OrSimpleRecord]) -> None:
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [None, (Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        json_value = converter.to_json(value)
        self._write_json_line({"monosotateOrIntOrSimpleRecord": json_value})

    def _write_record_with_unions(self, value: basic_types.RecordWithUnions) -> None:
        converter = basic_types.ndjson.RecordWithUnionsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithUnions": json_value})


class NDJsonUnionsReader(_ndjson.NDJsonProtocolReader, UnionsReaderBase):
    """NDJson writer for the Unions protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        UnionsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, UnionsReaderBase.schema)

    def _read_int_or_simple_record(self) -> Int32OrSimpleRecord:
        json_object = self._read_json_line("intOrSimpleRecord", True)
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [(Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        return converter.from_json(json_object)

    def _read_int_or_record_with_vlens(self) -> Int32OrRecordWithVlens:
        json_object = self._read_json_line("intOrRecordWithVlens", True)
        converter = _ndjson.UnionConverter(Int32OrRecordWithVlens, [(Int32OrRecordWithVlens.Int32, _ndjson.int32_converter, [int, float]), (Int32OrRecordWithVlens.RecordWithVlens, RecordWithVlensConverter(), [dict])], True)
        return converter.from_json(json_object)

    def _read_monosotate_or_int_or_simple_record(self) -> typing.Optional[Int32OrSimpleRecord]:
        json_object = self._read_json_line("monosotateOrIntOrSimpleRecord", True)
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [None, (Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        return converter.from_json(json_object)

    def _read_record_with_unions(self) -> basic_types.RecordWithUnions:
        json_object = self._read_json_line("recordWithUnions", True)
        converter = basic_types.ndjson.RecordWithUnionsConverter()
        return converter.from_json(json_object)

class NDJsonStreamsOfUnionsWriter(_ndjson.NDJsonProtocolWriter, StreamsOfUnionsWriterBase):
    """NDJson writer for the StreamsOfUnions protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        StreamsOfUnionsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, StreamsOfUnionsWriterBase.schema)

    def _write_int_or_simple_record(self, value: collections.abc.Iterable[Int32OrSimpleRecord]) -> None:
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [(Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"intOrSimpleRecord": json_item})

    def _write_nullable_int_or_simple_record(self, value: collections.abc.Iterable[typing.Optional[Int32OrSimpleRecord]]) -> None:
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [None, (Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"nullableIntOrSimpleRecord": json_item})

    def _write_many_cases(self, value: collections.abc.Iterable[Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray]) -> None:
        converter = _ndjson.UnionConverter(Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray, [(Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.Int32, _ndjson.int32_converter, [int, float]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.Float32, _ndjson.float32_converter, [int, float]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.String, _ndjson.string_converter, [str]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.SimpleRecord, SimpleRecordConverter(), [dict]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.NamedFixedNDArray, _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 4,)), [list])], False)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"manyCases": json_item})


class NDJsonStreamsOfUnionsReader(_ndjson.NDJsonProtocolReader, StreamsOfUnionsReaderBase):
    """NDJson writer for the StreamsOfUnions protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        StreamsOfUnionsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, StreamsOfUnionsReaderBase.schema)

    def _read_int_or_simple_record(self) -> collections.abc.Iterable[Int32OrSimpleRecord]:
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [(Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        while (json_object := self._read_json_line("intOrSimpleRecord", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_nullable_int_or_simple_record(self) -> collections.abc.Iterable[typing.Optional[Int32OrSimpleRecord]]:
        converter = _ndjson.UnionConverter(Int32OrSimpleRecord, [None, (Int32OrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (Int32OrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        while (json_object := self._read_json_line("nullableIntOrSimpleRecord", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_many_cases(self) -> collections.abc.Iterable[Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray]:
        converter = _ndjson.UnionConverter(Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray, [(Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.Int32, _ndjson.int32_converter, [int, float]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.Float32, _ndjson.float32_converter, [int, float]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.String, _ndjson.string_converter, [str]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.SimpleRecord, SimpleRecordConverter(), [dict]), (Int32OrFloat32OrStringOrSimpleRecordOrNamedFixedNDArray.NamedFixedNDArray, _ndjson.FixedNDArrayConverter(_ndjson.int32_converter, (2, 4,)), [list])], False)
        while (json_object := self._read_json_line("manyCases", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonEnumsWriter(_ndjson.NDJsonProtocolWriter, EnumsWriterBase):
    """NDJson writer for the Enums protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        EnumsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, EnumsWriterBase.schema)

    def _write_single(self, value: Fruits) -> None:
        converter = _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map)
        json_value = converter.to_json(value)
        self._write_json_line({"single": json_value})

    def _write_vec(self, value: list[Fruits]) -> None:
        converter = _ndjson.VectorConverter(_ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map))
        json_value = converter.to_json(value)
        self._write_json_line({"vec": json_value})

    def _write_size(self, value: SizeBasedEnum) -> None:
        converter = _ndjson.EnumConverter(SizeBasedEnum, np.uint64, size_based_enum_name_to_value_map, size_based_enum_value_to_name_map)
        json_value = converter.to_json(value)
        self._write_json_line({"size": json_value})

    def _write_rec(self, value: RecordWithEnums) -> None:
        converter = RecordWithEnumsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"rec": json_value})


class NDJsonEnumsReader(_ndjson.NDJsonProtocolReader, EnumsReaderBase):
    """NDJson writer for the Enums protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        EnumsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, EnumsReaderBase.schema)

    def _read_single(self) -> Fruits:
        json_object = self._read_json_line("single", True)
        converter = _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map)
        return converter.from_json(json_object)

    def _read_vec(self) -> list[Fruits]:
        json_object = self._read_json_line("vec", True)
        converter = _ndjson.VectorConverter(_ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map))
        return converter.from_json(json_object)

    def _read_size(self) -> SizeBasedEnum:
        json_object = self._read_json_line("size", True)
        converter = _ndjson.EnumConverter(SizeBasedEnum, np.uint64, size_based_enum_name_to_value_map, size_based_enum_value_to_name_map)
        return converter.from_json(json_object)

    def _read_rec(self) -> RecordWithEnums:
        json_object = self._read_json_line("rec", True)
        converter = RecordWithEnumsConverter()
        return converter.from_json(json_object)

class NDJsonFlagsWriter(_ndjson.NDJsonProtocolWriter, FlagsWriterBase):
    """NDJson writer for the Flags protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        FlagsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, FlagsWriterBase.schema)

    def _write_days(self, value: collections.abc.Iterable[DaysOfWeek]) -> None:
        converter = _ndjson.FlagsConverter(basic_types.DaysOfWeek, np.int32, basic_types.ndjson.days_of_week_name_to_value_map, basic_types.ndjson.days_of_week_value_to_name_map)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"days": json_item})

    def _write_formats(self, value: collections.abc.Iterable[TextFormat]) -> None:
        converter = _ndjson.FlagsConverter(basic_types.TextFormat, np.uint64, basic_types.ndjson.text_format_name_to_value_map, basic_types.ndjson.text_format_value_to_name_map)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"formats": json_item})


class NDJsonFlagsReader(_ndjson.NDJsonProtocolReader, FlagsReaderBase):
    """NDJson writer for the Flags protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        FlagsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, FlagsReaderBase.schema)

    def _read_days(self) -> collections.abc.Iterable[DaysOfWeek]:
        converter = _ndjson.FlagsConverter(basic_types.DaysOfWeek, np.int32, basic_types.ndjson.days_of_week_name_to_value_map, basic_types.ndjson.days_of_week_value_to_name_map)
        while (json_object := self._read_json_line("days", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_formats(self) -> collections.abc.Iterable[TextFormat]:
        converter = _ndjson.FlagsConverter(basic_types.TextFormat, np.uint64, basic_types.ndjson.text_format_name_to_value_map, basic_types.ndjson.text_format_value_to_name_map)
        while (json_object := self._read_json_line("formats", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonStateTestWriter(_ndjson.NDJsonProtocolWriter, StateTestWriterBase):
    """NDJson writer for the StateTest protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        StateTestWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, StateTestWriterBase.schema)

    def _write_an_int(self, value: yardl.Int32) -> None:
        converter = _ndjson.int32_converter
        json_value = converter.to_json(value)
        self._write_json_line({"anInt": json_value})

    def _write_a_stream(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        converter = _ndjson.int32_converter
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"aStream": json_item})

    def _write_another_int(self, value: yardl.Int32) -> None:
        converter = _ndjson.int32_converter
        json_value = converter.to_json(value)
        self._write_json_line({"anotherInt": json_value})


class NDJsonStateTestReader(_ndjson.NDJsonProtocolReader, StateTestReaderBase):
    """NDJson writer for the StateTest protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        StateTestReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, StateTestReaderBase.schema)

    def _read_an_int(self) -> yardl.Int32:
        json_object = self._read_json_line("anInt", True)
        converter = _ndjson.int32_converter
        return converter.from_json(json_object)

    def _read_a_stream(self) -> collections.abc.Iterable[yardl.Int32]:
        converter = _ndjson.int32_converter
        while (json_object := self._read_json_line("aStream", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_another_int(self) -> yardl.Int32:
        json_object = self._read_json_line("anotherInt", True)
        converter = _ndjson.int32_converter
        return converter.from_json(json_object)

class NDJsonSimpleGenericsWriter(_ndjson.NDJsonProtocolWriter, SimpleGenericsWriterBase):
    """NDJson writer for the SimpleGenerics protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        SimpleGenericsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, SimpleGenericsWriterBase.schema)

    def _write_float_image(self, value: image.FloatImage) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"floatImage": json_value})

    def _write_int_image(self, value: image.IntImage) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"intImage": json_value})

    def _write_int_image_alternate_syntax(self, value: Image[np.int32]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"intImageAlternateSyntax": json_value})

    def _write_string_image(self, value: Image[np.object_]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.string_converter, 2)
        json_value = converter.to_json(value)
        self._write_json_line({"stringImage": json_value})

    def _write_int_float_tuple(self, value: tuples.Tuple[yardl.Int32, yardl.Float32]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.float32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"intFloatTuple": json_value})

    def _write_float_float_tuple(self, value: tuples.Tuple[yardl.Float32, yardl.Float32]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.float32_converter, _ndjson.float32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"floatFloatTuple": json_value})

    def _write_int_float_tuple_alternate_syntax(self, value: tuples.Tuple[yardl.Int32, yardl.Float32]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.float32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"intFloatTupleAlternateSyntax": json_value})

    def _write_int_string_tuple(self, value: tuples.Tuple[yardl.Int32, str]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.string_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"intStringTuple": json_value})

    def _write_stream_of_type_variants(self, value: collections.abc.Iterable[ImageFloatOrImageDouble]) -> None:
        converter = _ndjson.UnionConverter(ImageFloatOrImageDouble, [(ImageFloatOrImageDouble.ImageFloat, _ndjson.NDArrayConverter(_ndjson.float32_converter, 2), [dict]), (ImageFloatOrImageDouble.ImageDouble, _ndjson.NDArrayConverter(_ndjson.float64_converter, 2), [dict])], False)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"streamOfTypeVariants": json_item})


class NDJsonSimpleGenericsReader(_ndjson.NDJsonProtocolReader, SimpleGenericsReaderBase):
    """NDJson writer for the SimpleGenerics protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        SimpleGenericsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, SimpleGenericsReaderBase.schema)

    def _read_float_image(self) -> image.FloatImage:
        json_object = self._read_json_line("floatImage", True)
        converter = _ndjson.NDArrayConverter(_ndjson.float32_converter, 2)
        return converter.from_json(json_object)

    def _read_int_image(self) -> image.IntImage:
        json_object = self._read_json_line("intImage", True)
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        return converter.from_json(json_object)

    def _read_int_image_alternate_syntax(self) -> Image[np.int32]:
        json_object = self._read_json_line("intImageAlternateSyntax", True)
        converter = _ndjson.NDArrayConverter(_ndjson.int32_converter, 2)
        return converter.from_json(json_object)

    def _read_string_image(self) -> Image[np.object_]:
        json_object = self._read_json_line("stringImage", True)
        converter = _ndjson.NDArrayConverter(_ndjson.string_converter, 2)
        return converter.from_json(json_object)

    def _read_int_float_tuple(self) -> tuples.Tuple[yardl.Int32, yardl.Float32]:
        json_object = self._read_json_line("intFloatTuple", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.float32_converter)
        return converter.from_json(json_object)

    def _read_float_float_tuple(self) -> tuples.Tuple[yardl.Float32, yardl.Float32]:
        json_object = self._read_json_line("floatFloatTuple", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.float32_converter, _ndjson.float32_converter)
        return converter.from_json(json_object)

    def _read_int_float_tuple_alternate_syntax(self) -> tuples.Tuple[yardl.Int32, yardl.Float32]:
        json_object = self._read_json_line("intFloatTupleAlternateSyntax", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.float32_converter)
        return converter.from_json(json_object)

    def _read_int_string_tuple(self) -> tuples.Tuple[yardl.Int32, str]:
        json_object = self._read_json_line("intStringTuple", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.int32_converter, _ndjson.string_converter)
        return converter.from_json(json_object)

    def _read_stream_of_type_variants(self) -> collections.abc.Iterable[ImageFloatOrImageDouble]:
        converter = _ndjson.UnionConverter(ImageFloatOrImageDouble, [(ImageFloatOrImageDouble.ImageFloat, _ndjson.NDArrayConverter(_ndjson.float32_converter, 2), [dict]), (ImageFloatOrImageDouble.ImageDouble, _ndjson.NDArrayConverter(_ndjson.float64_converter, 2), [dict])], False)
        while (json_object := self._read_json_line("streamOfTypeVariants", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonAdvancedGenericsWriter(_ndjson.NDJsonProtocolWriter, AdvancedGenericsWriterBase):
    """NDJson writer for the AdvancedGenerics protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        AdvancedGenericsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, AdvancedGenericsWriterBase.schema)

    def _write_float_image_image(self, value: Image[np.object_]) -> None:
        converter = _ndjson.NDArrayConverter(_ndjson.NDArrayConverter(_ndjson.float32_converter, 2), 2)
        json_value = converter.to_json(value)
        self._write_json_line({"floatImageImage": json_value})

    def _write_generic_record_1(self, value: GenericRecord[yardl.Int32, str, np.object_]) -> None:
        converter = GenericRecordConverter(_ndjson.int32_converter, _ndjson.string_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"genericRecord1": json_value})

    def _write_tuple_of_optionals(self, value: MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.OptionalConverter(_ndjson.int32_converter), _ndjson.OptionalConverter(_ndjson.string_converter))
        json_value = converter.to_json(value)
        self._write_json_line({"tupleOfOptionals": json_value})

    def _write_tuple_of_optionals_alternate_syntax(self, value: MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.OptionalConverter(_ndjson.int32_converter), _ndjson.OptionalConverter(_ndjson.string_converter))
        json_value = converter.to_json(value)
        self._write_json_line({"tupleOfOptionalsAlternateSyntax": json_value})

    def _write_tuple_of_vectors(self, value: MyTuple[list[yardl.Int32], list[yardl.Float32]]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.VectorConverter(_ndjson.int32_converter), _ndjson.VectorConverter(_ndjson.float32_converter))
        json_value = converter.to_json(value)
        self._write_json_line({"tupleOfVectors": json_value})


class NDJsonAdvancedGenericsReader(_ndjson.NDJsonProtocolReader, AdvancedGenericsReaderBase):
    """NDJson writer for the AdvancedGenerics protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        AdvancedGenericsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, AdvancedGenericsReaderBase.schema)

    def _read_float_image_image(self) -> Image[np.object_]:
        json_object = self._read_json_line("floatImageImage", True)
        converter = _ndjson.NDArrayConverter(_ndjson.NDArrayConverter(_ndjson.float32_converter, 2), 2)
        return converter.from_json(json_object)

    def _read_generic_record_1(self) -> GenericRecord[yardl.Int32, str, np.object_]:
        json_object = self._read_json_line("genericRecord1", True)
        converter = GenericRecordConverter(_ndjson.int32_converter, _ndjson.string_converter)
        return converter.from_json(json_object)

    def _read_tuple_of_optionals(self) -> MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]:
        json_object = self._read_json_line("tupleOfOptionals", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.OptionalConverter(_ndjson.int32_converter), _ndjson.OptionalConverter(_ndjson.string_converter))
        return converter.from_json(json_object)

    def _read_tuple_of_optionals_alternate_syntax(self) -> MyTuple[typing.Optional[yardl.Int32], typing.Optional[str]]:
        json_object = self._read_json_line("tupleOfOptionalsAlternateSyntax", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.OptionalConverter(_ndjson.int32_converter), _ndjson.OptionalConverter(_ndjson.string_converter))
        return converter.from_json(json_object)

    def _read_tuple_of_vectors(self) -> MyTuple[list[yardl.Int32], list[yardl.Float32]]:
        json_object = self._read_json_line("tupleOfVectors", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.VectorConverter(_ndjson.int32_converter), _ndjson.VectorConverter(_ndjson.float32_converter))
        return converter.from_json(json_object)

class NDJsonAliasesWriter(_ndjson.NDJsonProtocolWriter, AliasesWriterBase):
    """NDJson writer for the Aliases protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        AliasesWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, AliasesWriterBase.schema)

    def _write_aliased_string(self, value: AliasedString) -> None:
        converter = _ndjson.string_converter
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedString": json_value})

    def _write_aliased_enum(self, value: AliasedEnum) -> None:
        converter = _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedEnum": json_value})

    def _write_aliased_open_generic(self, value: AliasedOpenGeneric[AliasedString, AliasedEnum]) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.string_converter, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map))
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedOpenGeneric": json_value})

    def _write_aliased_closed_generic(self, value: AliasedClosedGeneric) -> None:
        converter = tuples.ndjson.TupleConverter(_ndjson.string_converter, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map))
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedClosedGeneric": json_value})

    def _write_aliased_optional(self, value: AliasedOptional) -> None:
        converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedOptional": json_value})

    def _write_aliased_generic_optional(self, value: AliasedGenericOptional[yardl.Float32]) -> None:
        converter = _ndjson.OptionalConverter(_ndjson.float32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedGenericOptional": json_value})

    def _write_aliased_generic_union_2(self, value: AliasedGenericUnion2[AliasedString, AliasedEnum]) -> None:
        converter = _ndjson.UnionConverter(basic_types.GenericUnion2, [(basic_types.GenericUnion2.T1, _ndjson.string_converter, [str]), (basic_types.GenericUnion2.T2, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map), [int, float, str])], False)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedGenericUnion2": json_value})

    def _write_aliased_generic_vector(self, value: AliasedGenericVector[yardl.Float32]) -> None:
        converter = _ndjson.VectorConverter(_ndjson.float32_converter)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedGenericVector": json_value})

    def _write_aliased_generic_fixed_vector(self, value: AliasedGenericFixedVector[yardl.Float32]) -> None:
        converter = _ndjson.FixedVectorConverter(_ndjson.float32_converter, 3)
        json_value = converter.to_json(value)
        self._write_json_line({"aliasedGenericFixedVector": json_value})

    def _write_stream_of_aliased_generic_union_2(self, value: collections.abc.Iterable[AliasedGenericUnion2[AliasedString, AliasedEnum]]) -> None:
        converter = _ndjson.UnionConverter(basic_types.GenericUnion2, [(basic_types.GenericUnion2.T1, _ndjson.string_converter, [str]), (basic_types.GenericUnion2.T2, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map), [int, float, str])], False)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"streamOfAliasedGenericUnion2": json_item})

    def _write_vectors(self, value: list[RecordContainingVectorsOfAliases]) -> None:
        converter = _ndjson.VectorConverter(RecordContainingVectorsOfAliasesConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"vectors": json_value})


class NDJsonAliasesReader(_ndjson.NDJsonProtocolReader, AliasesReaderBase):
    """NDJson writer for the Aliases protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        AliasesReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, AliasesReaderBase.schema)

    def _read_aliased_string(self) -> AliasedString:
        json_object = self._read_json_line("aliasedString", True)
        converter = _ndjson.string_converter
        return converter.from_json(json_object)

    def _read_aliased_enum(self) -> AliasedEnum:
        json_object = self._read_json_line("aliasedEnum", True)
        converter = _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map)
        return converter.from_json(json_object)

    def _read_aliased_open_generic(self) -> AliasedOpenGeneric[AliasedString, AliasedEnum]:
        json_object = self._read_json_line("aliasedOpenGeneric", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.string_converter, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map))
        return converter.from_json(json_object)

    def _read_aliased_closed_generic(self) -> AliasedClosedGeneric:
        json_object = self._read_json_line("aliasedClosedGeneric", True)
        converter = tuples.ndjson.TupleConverter(_ndjson.string_converter, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map))
        return converter.from_json(json_object)

    def _read_aliased_optional(self) -> AliasedOptional:
        json_object = self._read_json_line("aliasedOptional", True)
        converter = _ndjson.OptionalConverter(_ndjson.int32_converter)
        return converter.from_json(json_object)

    def _read_aliased_generic_optional(self) -> AliasedGenericOptional[yardl.Float32]:
        json_object = self._read_json_line("aliasedGenericOptional", True)
        converter = _ndjson.OptionalConverter(_ndjson.float32_converter)
        return converter.from_json(json_object)

    def _read_aliased_generic_union_2(self) -> AliasedGenericUnion2[AliasedString, AliasedEnum]:
        json_object = self._read_json_line("aliasedGenericUnion2", True)
        converter = _ndjson.UnionConverter(basic_types.GenericUnion2, [(basic_types.GenericUnion2.T1, _ndjson.string_converter, [str]), (basic_types.GenericUnion2.T2, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map), [int, float, str])], False)
        return converter.from_json(json_object)

    def _read_aliased_generic_vector(self) -> AliasedGenericVector[yardl.Float32]:
        json_object = self._read_json_line("aliasedGenericVector", True)
        converter = _ndjson.VectorConverter(_ndjson.float32_converter)
        return converter.from_json(json_object)

    def _read_aliased_generic_fixed_vector(self) -> AliasedGenericFixedVector[yardl.Float32]:
        json_object = self._read_json_line("aliasedGenericFixedVector", True)
        converter = _ndjson.FixedVectorConverter(_ndjson.float32_converter, 3)
        return converter.from_json(json_object)

    def _read_stream_of_aliased_generic_union_2(self) -> collections.abc.Iterable[AliasedGenericUnion2[AliasedString, AliasedEnum]]:
        converter = _ndjson.UnionConverter(basic_types.GenericUnion2, [(basic_types.GenericUnion2.T1, _ndjson.string_converter, [str]), (basic_types.GenericUnion2.T2, _ndjson.EnumConverter(basic_types.Fruits, np.int32, basic_types.ndjson.fruits_name_to_value_map, basic_types.ndjson.fruits_value_to_name_map), [int, float, str])], False)
        while (json_object := self._read_json_line("streamOfAliasedGenericUnion2", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_vectors(self) -> list[RecordContainingVectorsOfAliases]:
        json_object = self._read_json_line("vectors", True)
        converter = _ndjson.VectorConverter(RecordContainingVectorsOfAliasesConverter())
        return converter.from_json(json_object)

class NDJsonStreamsOfAliasedUnionsWriter(_ndjson.NDJsonProtocolWriter, StreamsOfAliasedUnionsWriterBase):
    """NDJson writer for the StreamsOfAliasedUnions protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        StreamsOfAliasedUnionsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, StreamsOfAliasedUnionsWriterBase.schema)

    def _write_int_or_simple_record(self, value: collections.abc.Iterable[AliasedIntOrSimpleRecord]) -> None:
        converter = _ndjson.UnionConverter(AliasedIntOrSimpleRecord, [(AliasedIntOrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (AliasedIntOrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"intOrSimpleRecord": json_item})

    def _write_nullable_int_or_simple_record(self, value: collections.abc.Iterable[typing.Optional[AliasedNullableIntSimpleRecord]]) -> None:
        converter = _ndjson.UnionConverter(AliasedNullableIntSimpleRecord, [None, (AliasedNullableIntSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (AliasedNullableIntSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"nullableIntOrSimpleRecord": json_item})


class NDJsonStreamsOfAliasedUnionsReader(_ndjson.NDJsonProtocolReader, StreamsOfAliasedUnionsReaderBase):
    """NDJson writer for the StreamsOfAliasedUnions protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        StreamsOfAliasedUnionsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, StreamsOfAliasedUnionsReaderBase.schema)

    def _read_int_or_simple_record(self) -> collections.abc.Iterable[AliasedIntOrSimpleRecord]:
        converter = _ndjson.UnionConverter(AliasedIntOrSimpleRecord, [(AliasedIntOrSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (AliasedIntOrSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        while (json_object := self._read_json_line("intOrSimpleRecord", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_nullable_int_or_simple_record(self) -> collections.abc.Iterable[typing.Optional[AliasedNullableIntSimpleRecord]]:
        converter = _ndjson.UnionConverter(AliasedNullableIntSimpleRecord, [None, (AliasedNullableIntSimpleRecord.Int32, _ndjson.int32_converter, [int, float]), (AliasedNullableIntSimpleRecord.SimpleRecord, SimpleRecordConverter(), [dict])], True)
        while (json_object := self._read_json_line("nullableIntOrSimpleRecord", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

class NDJsonProtocolWithComputedFieldsWriter(_ndjson.NDJsonProtocolWriter, ProtocolWithComputedFieldsWriterBase):
    """NDJson writer for the ProtocolWithComputedFields protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        ProtocolWithComputedFieldsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, ProtocolWithComputedFieldsWriterBase.schema)

    def _write_record_with_computed_fields(self, value: RecordWithComputedFields) -> None:
        converter = RecordWithComputedFieldsConverter()
        json_value = converter.to_json(value)
        self._write_json_line({"recordWithComputedFields": json_value})


class NDJsonProtocolWithComputedFieldsReader(_ndjson.NDJsonProtocolReader, ProtocolWithComputedFieldsReaderBase):
    """NDJson writer for the ProtocolWithComputedFields protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        ProtocolWithComputedFieldsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, ProtocolWithComputedFieldsReaderBase.schema)

    def _read_record_with_computed_fields(self) -> RecordWithComputedFields:
        json_object = self._read_json_line("recordWithComputedFields", True)
        converter = RecordWithComputedFieldsConverter()
        return converter.from_json(json_object)

class NDJsonProtocolWithKeywordStepsWriter(_ndjson.NDJsonProtocolWriter, ProtocolWithKeywordStepsWriterBase):
    """NDJson writer for the ProtocolWithKeywordSteps protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        ProtocolWithKeywordStepsWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, ProtocolWithKeywordStepsWriterBase.schema)

    def _write_int(self, value: collections.abc.Iterable[RecordWithKeywordFields]) -> None:
        converter = RecordWithKeywordFieldsConverter()
        for item in value:
            json_item = converter.to_json(item)
            self._write_json_line({"int": json_item})

    def _write_float(self, value: EnumWithKeywordSymbols) -> None:
        converter = _ndjson.EnumConverter(EnumWithKeywordSymbols, np.int32, enum_with_keyword_symbols_name_to_value_map, enum_with_keyword_symbols_value_to_name_map)
        json_value = converter.to_json(value)
        self._write_json_line({"float": json_value})


class NDJsonProtocolWithKeywordStepsReader(_ndjson.NDJsonProtocolReader, ProtocolWithKeywordStepsReaderBase):
    """NDJson writer for the ProtocolWithKeywordSteps protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        ProtocolWithKeywordStepsReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, ProtocolWithKeywordStepsReaderBase.schema)

    def _read_int(self) -> collections.abc.Iterable[RecordWithKeywordFields]:
        converter = RecordWithKeywordFieldsConverter()
        while (json_object := self._read_json_line("int", False)) is not _ndjson.MISSING_SENTINEL:
            yield converter.from_json(json_object)

    def _read_float(self) -> EnumWithKeywordSymbols:
        json_object = self._read_json_line("float", True)
        converter = _ndjson.EnumConverter(EnumWithKeywordSymbols, np.int32, enum_with_keyword_symbols_name_to_value_map, enum_with_keyword_symbols_value_to_name_map)
        return converter.from_json(json_object)

class NDJsonProtocolWithOptionalDateWriter(_ndjson.NDJsonProtocolWriter, ProtocolWithOptionalDateWriterBase):
    """NDJson writer for the ProtocolWithOptionalDate protocol."""


    def __init__(self, stream: typing.Union[typing.TextIO, str]) -> None:
        ProtocolWithOptionalDateWriterBase.__init__(self)
        _ndjson.NDJsonProtocolWriter.__init__(self, stream, ProtocolWithOptionalDateWriterBase.schema)

    def _write_record(self, value: typing.Optional[RecordWithOptionalDate]) -> None:
        converter = _ndjson.OptionalConverter(RecordWithOptionalDateConverter())
        json_value = converter.to_json(value)
        self._write_json_line({"record": json_value})


class NDJsonProtocolWithOptionalDateReader(_ndjson.NDJsonProtocolReader, ProtocolWithOptionalDateReaderBase):
    """NDJson writer for the ProtocolWithOptionalDate protocol."""


    def __init__(self, stream: typing.Union[io.BufferedReader, typing.TextIO, str]) -> None:
        ProtocolWithOptionalDateReaderBase.__init__(self)
        _ndjson.NDJsonProtocolReader.__init__(self, stream, ProtocolWithOptionalDateReaderBase.schema)

    def _read_record(self) -> typing.Optional[RecordWithOptionalDate]:
        json_object = self._read_json_line("record", True)
        converter = _ndjson.OptionalConverter(RecordWithOptionalDateConverter())
        return converter.from_json(json_object)

