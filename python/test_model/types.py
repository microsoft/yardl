# This file was generated by the "yardl" tool. DO NOT EDIT.


import dataclasses
import datetime
import enum
import types
import typing
import numpy as np
import numpy.typing as npt
from . import yardl_types as yardl
from . import _dtypes

K = typing.TypeVar('K')
K_NP = typing.TypeVar('K_NP', bound=np.generic)
V = typing.TypeVar('V')
V_NP = typing.TypeVar('V_NP', bound=np.generic)
T = typing.TypeVar('T')
T_NP = typing.TypeVar('T_NP', bound=np.generic)
T1 = typing.TypeVar('T1')
T1_NP = typing.TypeVar('T1_NP', bound=np.generic)
T2 = typing.TypeVar('T2')
T2_NP = typing.TypeVar('T2_NP', bound=np.generic)
T0 = typing.TypeVar('T0')
T0_NP = typing.TypeVar('T0_NP', bound=np.generic)

@dataclasses.dataclass(slots=True, kw_only=True)
class SmallBenchmarkRecord:
    a: yardl.Float64 = 0.0
    b: yardl.Float32 = 0.0
    c: yardl.Float32 = 0.0

@dataclasses.dataclass(slots=True, kw_only=True)
class SimpleEncodingCounters:
    e1: yardl.UInt32 | None = None
    e2: yardl.UInt32 | None = None
    slice: yardl.UInt32 | None = None
    repetition: yardl.UInt32 | None = None

@dataclasses.dataclass(slots=True, kw_only=True)
class SimpleAcquisition:
    flags: yardl.UInt64 = 0
    idx: SimpleEncodingCounters = dataclasses.field(default_factory=SimpleEncodingCounters)
    data: npt.NDArray[np.complex64] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.complex64)))
    trajectory: npt.NDArray[np.float32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.float32)))

@dataclasses.dataclass(slots=True, kw_only=True)
class SimpleRecord:
    x: yardl.Int32 = 0
    y: yardl.Int32 = 0
    z: yardl.Int32 = 0

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithPrimitives:
    bool_field: yardl.Bool = False
    int_8_field: yardl.Int8 = 0
    uint_8_field: yardl.UInt8 = 0
    int_16_field: yardl.Int16 = 0
    uint_16_field: yardl.UInt16 = 0
    int_32_field: yardl.Int32 = 0
    uint_32_field: yardl.UInt32 = 0
    int_64_field: yardl.Int64 = 0
    uint_64_field: yardl.UInt64 = 0
    size_field: yardl.Size = 0
    float_32_field: yardl.Float32 = 0.0
    float_64_field: yardl.Float64 = 0.0
    complexfloat_32_field: yardl.ComplexFloat = 0j
    complexfloat_64_field: yardl.ComplexDouble = 0j
    date_field: yardl.Date = dataclasses.field(default_factory=lambda: datetime.date(1970, 1, 1))
    time_field: yardl.Time = dataclasses.field(default_factory=lambda: datetime.time(0, 0, 0))
    datetime_field: yardl.DateTime = dataclasses.field(default_factory=lambda: datetime.datetime(1970, 1, 1, 0, 0, 0))

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithPrimitiveAliases:
    byte_field: yardl.UInt8 = 0
    int_field: yardl.Int32 = 0
    uint_field: yardl.UInt32 = 0
    long_field: yardl.Int64 = 0
    ulong_field: yardl.UInt64 = 0
    float_field: yardl.Float32 = 0.0
    double_field: yardl.Float64 = 0.0
    complexfloat_field: yardl.ComplexFloat = 0j
    complexdouble_field: yardl.ComplexDouble = 0j

@dataclasses.dataclass(slots=True, kw_only=True)
class TupleWithRecords:
    a: SimpleRecord = dataclasses.field(default_factory=SimpleRecord)
    b: SimpleRecord = dataclasses.field(default_factory=SimpleRecord)

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithVectors:
    default_vector: list[yardl.Int32] = dataclasses.field(default_factory=list)
    default_vector_fixed_length: list[yardl.Int32] = dataclasses.field(default_factory=lambda: [0] * 3)
    vector_of_vectors: list[list[yardl.Int32]] = dataclasses.field(default_factory=list)

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithArrays:
    default_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    default_array_with_empty_dimension: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    rank_1_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0), dtype=np.dtype(np.int32)))
    rank_2_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    rank_2_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    rank_2_fixed_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32)))
    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32)))
    dynamic_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    array_of_vectors: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((5,), dtype=np.dtype(np.object_)))

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithArraysSimpleSyntax:
    default_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    default_array_with_empty_dimension: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    rank_1_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0), dtype=np.dtype(np.int32)))
    rank_2_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    rank_2_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    rank_2_fixed_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32)))
    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32)))
    dynamic_array: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    array_of_vectors: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((5,), dtype=np.dtype(np.object_)))

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithOptionalFields:
    optional_int: yardl.Int32 | None = None
    optional_int_alternate_syntax: yardl.Int32 | None = None

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithVlens:
    a: list[SimpleRecord] = dataclasses.field(default_factory=list)
    b: yardl.Int32 = 0
    c: yardl.Int32 = 0

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithStrings:
    a: str = ""
    b: str = ""

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithOptionalVector:
    optional_vector: list[yardl.Int32] | None = None

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithFixedVectors:
    fixed_int_vector: list[yardl.Int32] = dataclasses.field(default_factory=lambda: [0] * 5)
    fixed_simple_record_vector: list[SimpleRecord] = dataclasses.field(default_factory=lambda: [SimpleRecord() for _ in range(3)])
    fixed_record_with_vlens_vector: list[RecordWithVlens] = dataclasses.field(default_factory=lambda: [RecordWithVlens() for _ in range(2)])

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithFixedArrays:
    ints: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((2, 3,), dtype=np.dtype(np.int32)))
    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((3, 2,), dtype=get_dtype(SimpleRecord)))
    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((2, 2,), dtype=get_dtype(RecordWithVlens)))

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithNDArrays:
    ints: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=get_dtype(SimpleRecord)))
    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=get_dtype(RecordWithVlens)))

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithNDArraysSingleDimension:
    ints: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0), dtype=np.dtype(np.int32)))
    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((0), dtype=get_dtype(SimpleRecord)))
    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((0), dtype=get_dtype(RecordWithVlens)))

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithDynamicNDArrays:
    ints: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    fixed_simple_record_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=get_dtype(SimpleRecord)))
    fixed_record_with_vlens_array: npt.NDArray[np.void] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=get_dtype(RecordWithVlens)))

NamedFixedNDArray = npt.NDArray[np.int32]

NamedNDArray = npt.NDArray[np.int32]

AliasedMap = dict[K, V]

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithUnions:
    null_or_int_or_string: yardl.Int32 | str | None = None

class Fruits(enum.Enum):
    APPLE = 0
    BANANA = 1
    PEAR = 2

class UInt64Enum(enum.Enum):
    A = 9223372036854775808

class Int64Enum(enum.Enum):
    B = -4611686018427387904

class SizeBasedEnum(enum.Enum):
    A = 0
    B = 1
    C = 2

class DaysOfWeek(enum.Flag, boundary=enum.KEEP):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 4
    THURSDAY = 8
    FRIDAY = 16
    SATURDAY = 32
    SUNDAY = 64

class TextFormat(enum.Flag, boundary=enum.KEEP):
    REGULAR = 0
    BOLD = 1
    ITALIC = 2
    UNDERLINE = 4
    STRIKETHROUGH = 8

Image = npt.NDArray[T_NP]

@dataclasses.dataclass(slots=True, kw_only=True)
class GenericRecord(typing.Generic[T1, T2, T2_NP]):
    scalar_1: T1
    scalar_2: T2
    vector_1: list[T1]
    image_2: Image[T2_NP]

@dataclasses.dataclass(slots=True, kw_only=True)
class MyTuple(typing.Generic[T1, T2]):
    v1: T1
    v2: T2

AliasedString = str

AliasedEnum = Fruits

AliasedOpenGeneric = MyTuple[T1, T2]

AliasedClosedGeneric = MyTuple[AliasedString, AliasedEnum]

AliasedOptional = yardl.Int32 | None

AliasedGenericOptional = T | None

AliasedGenericUnion2 = T1 | T2

AliasedGenericVector = list[T]

AliasedGenericFixedVector = list[T]

AliasedIntOrSimpleRecord = yardl.Int32 | SimpleRecord

AliasedNullableIntSimpleRecord = yardl.Int32 | SimpleRecord | None

@dataclasses.dataclass(slots=True, kw_only=True)
class GenericRecordWithComputedFields(typing.Generic[T0, T1]):
    f1: T0 | T1

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithComputedFields:
    array_field: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    array_field_map_dimensions: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    dynamic_array_field: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((), dtype=np.dtype(np.int32)))
    fixed_array_field: npt.NDArray[np.int32] = dataclasses.field(default_factory=lambda: np.zeros((3, 4,), dtype=np.dtype(np.int32)))
    int_field: yardl.Int32 = 0
    string_field: str = ""
    tuple_field: MyTuple[yardl.Int32, yardl.Int32] = dataclasses.field(default_factory=lambda: MyTuple(v1=0, v2=0))
    vector_field: list[yardl.Int32] = dataclasses.field(default_factory=list)
    vector_of_vectors_field: list[list[yardl.Int32]] = dataclasses.field(default_factory=list)
    fixed_vector_field: list[yardl.Int32] = dataclasses.field(default_factory=lambda: [0] * 3)
    optional_named_array: NamedNDArray | None = None
    int_float_union: yardl.Int32 | yardl.Float32 = 0
    nullable_int_float_union: yardl.Int32 | yardl.Float32 | None = None
    union_with_nested_generic_union: yardl.Int32 | GenericRecordWithComputedFields[str, yardl.Float32] = 0
    map_field: dict[str, str] = dataclasses.field(default_factory=dict)

ArrayWithKeywordDimensionNames = npt.NDArray[np.int32]

class EnumWithKeywordSymbols(enum.Enum):
    TRY = 2
    CATCH = 1

@dataclasses.dataclass(slots=True, kw_only=True)
class RecordWithKeywordFields:
    int_: str = ""
    sizeof: ArrayWithKeywordDimensionNames = dataclasses.field(default_factory=lambda: np.zeros((0,0), dtype=np.dtype(np.int32)))
    if_: EnumWithKeywordSymbols

def _mk_get_dtype():
    dtype_map: dict[type | types.GenericAlias, np.dtype[typing.Any] | typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map[SmallBenchmarkRecord] = np.dtype([('a', np.dtype(np.float64)), ('b', np.dtype(np.float32)), ('c', np.dtype(np.float32))], align=True)
    dtype_map[SimpleEncodingCounters] = np.dtype([('e1', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('e2', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('slice', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('repetition', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True))], align=True)
    dtype_map[SimpleAcquisition] = np.dtype([('flags', np.dtype(np.uint64)), ('idx', get_dtype(SimpleEncodingCounters)), ('data', np.dtype(np.object_)), ('trajectory', np.dtype(np.object_))], align=True)
    dtype_map[SimpleRecord] = np.dtype([('x', np.dtype(np.int32)), ('y', np.dtype(np.int32)), ('z', np.dtype(np.int32))], align=True)
    dtype_map[RecordWithPrimitives] = np.dtype([('boolField', np.dtype(np.bool_)), ('int8Field', np.dtype(np.int8)), ('uint8Field', np.dtype(np.uint8)), ('int16Field', np.dtype(np.int16)), ('uint16Field', np.dtype(np.uint16)), ('int32Field', np.dtype(np.int32)), ('uint32Field', np.dtype(np.uint32)), ('int64Field', np.dtype(np.int64)), ('uint64Field', np.dtype(np.uint64)), ('sizeField', np.dtype(np.uint64)), ('float32Field', np.dtype(np.float32)), ('float64Field', np.dtype(np.float64)), ('complexfloat32Field', np.dtype(np.complex64)), ('complexfloat64Field', np.dtype(np.complex128)), ('dateField', np.dtype(np.datetime64)), ('timeField', np.dtype(np.timedelta64)), ('datetimeField', np.dtype(np.datetime64))], align=True)
    dtype_map[RecordWithPrimitiveAliases] = np.dtype([('byteField', np.dtype(np.uint8)), ('intField', np.dtype(np.int32)), ('uintField', np.dtype(np.uint32)), ('longField', np.dtype(np.int64)), ('ulongField', np.dtype(np.uint64)), ('floatField', np.dtype(np.float32)), ('doubleField', np.dtype(np.float64)), ('complexfloatField', np.dtype(np.complex64)), ('complexdoubleField', np.dtype(np.complex128))], align=True)
    dtype_map[TupleWithRecords] = np.dtype([('a', get_dtype(SimpleRecord)), ('b', get_dtype(SimpleRecord))], align=True)
    dtype_map[RecordWithVectors] = np.dtype([('defaultVector', np.dtype(np.object_)), ('defaultVectorFixedLength', np.dtype(np.int32), (3,)), ('vectorOfVectors', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithArrays] = np.dtype([('defaultArray', np.dtype(np.object_)), ('defaultArrayWithEmptyDimension', np.dtype(np.object_)), ('rank1Array', np.dtype(np.object_)), ('rank2Array', np.dtype(np.object_)), ('rank2ArrayWithNamedDimensions', np.dtype(np.object_)), ('rank2FixedArray', np.dtype(np.int32), (3, 4,)), ('rank2FixedArrayWithNamedDimensions', np.dtype(np.int32), (3, 4,)), ('dynamicArray', np.dtype(np.object_)), ('arrayOfVectors', np.dtype(np.object_), (5,))], align=True)
    dtype_map[RecordWithArraysSimpleSyntax] = np.dtype([('defaultArray', np.dtype(np.object_)), ('defaultArrayWithEmptyDimension', np.dtype(np.object_)), ('rank1Array', np.dtype(np.object_)), ('rank2Array', np.dtype(np.object_)), ('rank2ArrayWithNamedDimensions', np.dtype(np.object_)), ('rank2FixedArray', np.dtype(np.int32), (3, 4,)), ('rank2FixedArrayWithNamedDimensions', np.dtype(np.int32), (3, 4,)), ('dynamicArray', np.dtype(np.object_)), ('arrayOfVectors', np.dtype(np.object_), (5,))], align=True)
    dtype_map[RecordWithOptionalFields] = np.dtype([('optionalInt', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optionalIntAlternateSyntax', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True))], align=True)
    dtype_map[RecordWithVlens] = np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.int32)), ('c', np.dtype(np.int32))], align=True)
    dtype_map[RecordWithStrings] = np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithOptionalVector] = np.dtype([('optionalVector', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True)
    dtype_map[RecordWithFixedVectors] = np.dtype([('fixedIntVector', np.dtype(np.int32), (5,)), ('fixedSimpleRecordVector', get_dtype(SimpleRecord), (3,)), ('fixedRecordWithVlensVector', get_dtype(RecordWithVlens), (2,))], align=True)
    dtype_map[RecordWithFixedArrays] = np.dtype([('ints', np.dtype(np.int32), (2, 3,)), ('fixedSimpleRecordArray', get_dtype(SimpleRecord), (3, 2,)), ('fixedRecordWithVlensArray', get_dtype(RecordWithVlens), (2, 2,))], align=True)
    dtype_map[RecordWithNDArrays] = np.dtype([('ints', np.dtype(np.object_)), ('fixedSimpleRecordArray', np.dtype(np.object_)), ('fixedRecordWithVlensArray', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithNDArraysSingleDimension] = np.dtype([('ints', np.dtype(np.object_)), ('fixedSimpleRecordArray', np.dtype(np.object_)), ('fixedRecordWithVlensArray', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithDynamicNDArrays] = np.dtype([('ints', np.dtype(np.object_)), ('fixedSimpleRecordArray', np.dtype(np.object_)), ('fixedRecordWithVlensArray', np.dtype(np.object_))], align=True)
    dtype_map[NamedFixedNDArray] = np.dtype(np.int32)
    dtype_map[NamedNDArray] = np.dtype(np.object_)
    dtype_map[AliasedMap] = lambda type_args: np.dtype(np.object_)
    dtype_map[RecordWithUnions] = np.dtype([('nullOrIntOrString', np.dtype(np.object_))], align=True)
    dtype_map[Fruits] = np.dtype(np.int32)
    dtype_map[UInt64Enum] = np.dtype(np.uint64)
    dtype_map[Int64Enum] = np.dtype(np.int64)
    dtype_map[SizeBasedEnum] = np.dtype(np.uint64)
    dtype_map[DaysOfWeek] = np.dtype(np.int32)
    dtype_map[TextFormat] = np.dtype(np.uint64)
    dtype_map[Image] = lambda type_args: np.dtype(np.object_)
    dtype_map[GenericRecord] = lambda type_args: np.dtype([('scalar1', get_dtype(type_args[0])), ('scalar2', get_dtype(type_args[1])), ('vector1', np.dtype(np.object_)), ('image2', get_dtype(types.GenericAlias(Image, (type_args[1],))))], align=True)
    dtype_map[MyTuple] = lambda type_args: np.dtype([('v1', get_dtype(type_args[0])), ('v2', get_dtype(type_args[1]))], align=True)
    dtype_map[AliasedString] = np.dtype(np.object_)
    dtype_map[AliasedEnum] = get_dtype(Fruits)
    dtype_map[AliasedOpenGeneric] = lambda type_args: get_dtype(types.GenericAlias(MyTuple, (type_args[0], type_args[1],)))
    dtype_map[AliasedClosedGeneric] = get_dtype(types.GenericAlias(MyTuple, (AliasedString, AliasedEnum,)))
    dtype_map[AliasedOptional] = np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)
    dtype_map[AliasedGenericOptional] = lambda type_args: np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(type_args[0]))], align=True)
    dtype_map[AliasedGenericUnion2] = lambda type_args: np.dtype(np.object_)
    dtype_map[AliasedGenericVector] = lambda type_args: np.dtype(np.object_)
    dtype_map[AliasedGenericFixedVector] = lambda type_args: get_dtype(type_args[0])
    dtype_map[AliasedIntOrSimpleRecord] = np.dtype(np.object_)
    dtype_map[AliasedNullableIntSimpleRecord] = np.dtype(np.object_)
    dtype_map[GenericRecordWithComputedFields] = lambda type_args: np.dtype([('f1', np.dtype(np.object_))], align=True)
    dtype_map[RecordWithComputedFields] = np.dtype([('arrayField', np.dtype(np.object_)), ('arrayFieldMapDimensions', np.dtype(np.object_)), ('dynamicArrayField', np.dtype(np.object_)), ('fixedArrayField', np.dtype(np.int32), (3, 4,)), ('intField', np.dtype(np.int32)), ('stringField', np.dtype(np.object_)), ('tupleField', get_dtype(types.GenericAlias(MyTuple, (yardl.Int32, yardl.Int32,)))), ('vectorField', np.dtype(np.object_)), ('vectorOfVectorsField', np.dtype(np.object_)), ('fixedVectorField', np.dtype(np.int32), (3,)), ('optionalNamedArray', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(NamedNDArray))], align=True)), ('intFloatUnion', np.dtype(np.object_)), ('nullableIntFloatUnion', np.dtype(np.object_)), ('unionWithNestedGenericUnion', np.dtype(np.object_)), ('mapField', np.dtype(np.object_))], align=True)
    dtype_map[ArrayWithKeywordDimensionNames] = np.dtype(np.object_)
    dtype_map[EnumWithKeywordSymbols] = np.dtype(np.int32)
    dtype_map[RecordWithKeywordFields] = np.dtype([('int', np.dtype(np.object_)), ('sizeof', get_dtype(ArrayWithKeywordDimensionNames)), ('if', get_dtype(EnumWithKeywordSymbols))], align=True)

    return get_dtype

get_dtype = _mk_get_dtype()

