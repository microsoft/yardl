// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include <array>
#include <complex>
#include <optional>
#include <unordered_map>
#include <variant>
#include <vector>

#include "yardl/yardl.h"

namespace evo_test {
using AliasedInt = int32_t;

using AliasedString = std::string;

using AliasedLongToString = std::string;

struct UnchangedRecord {
  std::string name{};
  int32_t age{};
  std::unordered_map<std::string, double> meta{};

  bool operator==(const UnchangedRecord& other) const {
    return name == other.name &&
      age == other.age &&
      meta == other.meta;
  }

  bool operator!=(const UnchangedRecord& other) const {
    return !(*this == other);
  }
};

struct RecordWithChanges {
  double float_to_double{};
  evo_test::UnchangedRecord unchanged_record{};
  int64_t int_to_long{};
  std::optional<std::string> optional_long_to_string{};

  bool operator==(const RecordWithChanges& other) const {
    return float_to_double == other.float_to_double &&
      unchanged_record == other.unchanged_record &&
      int_to_long == other.int_to_long &&
      optional_long_to_string == other.optional_long_to_string;
  }

  bool operator!=(const RecordWithChanges& other) const {
    return !(*this == other);
  }
};

using AliasedRecordWithChanges = evo_test::RecordWithChanges;

using AliasOfAliasedRecordWithChanges = evo_test::AliasedRecordWithChanges;

using AliasedOptionalRecord = std::optional<evo_test::RecordWithChanges>;

using AliasedRecordOrString = std::variant<evo_test::RecordWithChanges, std::string>;

struct DeprecatedRecord {
  std::string s{};
  int32_t i{};

  bool operator==(const DeprecatedRecord& other) const {
    return s == other.s &&
      i == other.i;
  }

  bool operator!=(const DeprecatedRecord& other) const {
    return !(*this == other);
  }
};

using RenamedRecord = evo_test::DeprecatedRecord;

struct RZ {
  int32_t subject{};

  bool operator==(const RZ& other) const {
    return subject == other.subject;
  }

  bool operator!=(const RZ& other) const {
    return !(*this == other);
  }
};

using RY = evo_test::RZ;

using RNew = evo_test::RY;

using RLink = evo_test::RNew;

using RX = evo_test::RLink;

using RUnion = std::variant<evo_test::RX, std::string>;

struct UnusedButChangedRecord {
  float age{};
  std::string name{};

  bool operator==(const UnusedButChangedRecord& other) const {
    return age == other.age &&
      name == other.name;
  }

  bool operator!=(const UnusedButChangedRecord& other) const {
    return !(*this == other);
  }
};

using AliasedLongToString_v0 = evo_test::AliasedLongToString;

using RecordWithChanges_v0 = evo_test::RecordWithChanges;

using AliasedRecordWithChanges_v0 = evo_test::RecordWithChanges;

using RenamedRecord_v0 = evo_test::DeprecatedRecord;

using RC_v0 = evo_test::RZ;

using RB_v0 = evo_test::RZ;

using RA_v0 = evo_test::RZ;

using RLink_v0 = evo_test::RZ;

} // namespace evo_test

