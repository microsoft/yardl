// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#ifdef _MSC_VER
#define unlikely(x) x
#else
#define unlikely(x) __builtin_expect((x), 0)
#endif

namespace test_model {
namespace {
void BenchmarkFloat256x256WriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloat256x256() or EndFloat256x256()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndFloat256x256()" : "WriteFloat256x256()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkFloat256x256ReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloat256x256()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkFloat256x256WriterBase::schema_ = R"({"protocol":{"name":"BenchmarkFloat256x256","sequence":[{"name":"float256x256","type":{"stream":{"items":{"array":{"items":"float32","dimensions":[{"length":256},{"length":256}]}}}}}]},"types":null})";

void BenchmarkFloat256x256WriterBase::WriteFloat256x256(yardl::FixedNDArray<float, 256, 256> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloat256x256WriterBaseInvalidState(0, false, state_);
  }

  WriteFloat256x256Impl(value);
}

void BenchmarkFloat256x256WriterBase::WriteFloat256x256(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloat256x256WriterBaseInvalidState(0, false, state_);
  }

  WriteFloat256x256Impl(values);
}

void BenchmarkFloat256x256WriterBase::EndFloat256x256() {
  if (unlikely(state_ != 0)) {
    BenchmarkFloat256x256WriterBaseInvalidState(0, true, state_);
  }

  EndFloat256x256Impl();
  state_ = 1;
}

// fallback implementation
void BenchmarkFloat256x256WriterBase::WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) {
  for (auto const& v : values) {
    WriteFloat256x256Impl(v);
  }
}

void BenchmarkFloat256x256WriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkFloat256x256WriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkFloat256x256ReaderBase::schema_ = BenchmarkFloat256x256WriterBase::schema_;

bool BenchmarkFloat256x256ReaderBase::ReadFloat256x256(yardl::FixedNDArray<float, 256, 256>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkFloat256x256ReaderBaseInvalidState(0, state_);
  }

  bool result = ReadFloat256x256Impl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkFloat256x256ReaderBase::ReadFloat256x256(std::vector<yardl::FixedNDArray<float, 256, 256>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkFloat256x256ReaderBaseInvalidState(0, state_);
  }

  if (!ReadFloat256x256Impl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool BenchmarkFloat256x256ReaderBase::ReadFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFloat256x256Impl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkFloat256x256ReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    BenchmarkFloat256x256ReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void BenchmarkFloat256x256ReaderBase::CopyTo(BenchmarkFloat256x256WriterBase& writer, size_t float256x256_buffer_size) {
  if (float256x256_buffer_size > 1) {
    std::vector<yardl::FixedNDArray<float, 256, 256>> values;
    values.reserve(float256x256_buffer_size);
    while(ReadFloat256x256(values)) {
      writer.WriteFloat256x256(values);
    }
    writer.EndFloat256x256();
  } else {
    yardl::FixedNDArray<float, 256, 256> value;
    while(ReadFloat256x256(value)) {
      writer.WriteFloat256x256(value);
    }
    writer.EndFloat256x256();
  }
}

namespace {
void BenchmarkFloatVlenWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloatArray() or EndFloatArray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndFloatArray()" : "WriteFloatArray()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkFloatVlenReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloatArray()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkFloatVlenWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkFloatVlen","sequence":[{"name":"floatArray","type":{"stream":{"items":{"array":{"items":"float32","dimensions":2}}}}}]},"types":null})";

void BenchmarkFloatVlenWriterBase::WriteFloatArray(yardl::NDArray<float, 2> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloatVlenWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatArrayImpl(value);
}

void BenchmarkFloatVlenWriterBase::WriteFloatArray(std::vector<yardl::NDArray<float, 2>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkFloatVlenWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatArrayImpl(values);
}

void BenchmarkFloatVlenWriterBase::EndFloatArray() {
  if (unlikely(state_ != 0)) {
    BenchmarkFloatVlenWriterBaseInvalidState(0, true, state_);
  }

  EndFloatArrayImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkFloatVlenWriterBase::WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& values) {
  for (auto const& v : values) {
    WriteFloatArrayImpl(v);
  }
}

void BenchmarkFloatVlenWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkFloatVlenWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkFloatVlenReaderBase::schema_ = BenchmarkFloatVlenWriterBase::schema_;

bool BenchmarkFloatVlenReaderBase::ReadFloatArray(yardl::NDArray<float, 2>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkFloatVlenReaderBaseInvalidState(0, state_);
  }

  bool result = ReadFloatArrayImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkFloatVlenReaderBase::ReadFloatArray(std::vector<yardl::NDArray<float, 2>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkFloatVlenReaderBaseInvalidState(0, state_);
  }

  if (!ReadFloatArrayImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool BenchmarkFloatVlenReaderBase::ReadFloatArrayImpl(std::vector<yardl::NDArray<float, 2>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFloatArrayImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkFloatVlenReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    BenchmarkFloatVlenReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void BenchmarkFloatVlenReaderBase::CopyTo(BenchmarkFloatVlenWriterBase& writer, size_t float_array_buffer_size) {
  if (float_array_buffer_size > 1) {
    std::vector<yardl::NDArray<float, 2>> values;
    values.reserve(float_array_buffer_size);
    while(ReadFloatArray(values)) {
      writer.WriteFloatArray(values);
    }
    writer.EndFloatArray();
  } else {
    yardl::NDArray<float, 2> value;
    while(ReadFloatArray(value)) {
      writer.WriteFloatArray(value);
    }
    writer.EndFloatArray();
  }
}

namespace {
void BenchmarkSmallRecordWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSmallRecord() or EndSmallRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndSmallRecord()" : "WriteSmallRecord()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkSmallRecordReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSmallRecord()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkSmallRecordWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkSmallRecord","sequence":[{"name":"smallRecord","type":{"stream":{"items":"TestModel.SmallBenchmarkRecord"}}}]},"types":[{"name":"SmallBenchmarkRecord","fields":[{"name":"a","type":"float64"},{"name":"b","type":"float32"},{"name":"c","type":"float32"}]}]})";

void BenchmarkSmallRecordWriterBase::WriteSmallRecord(test_model::SmallBenchmarkRecord const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(value);
}

void BenchmarkSmallRecordWriterBase::WriteSmallRecord(std::vector<test_model::SmallBenchmarkRecord> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(values);
}

void BenchmarkSmallRecordWriterBase::EndSmallRecord() {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWriterBaseInvalidState(0, true, state_);
  }

  EndSmallRecordImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkSmallRecordWriterBase::WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& values) {
  for (auto const& v : values) {
    WriteSmallRecordImpl(v);
  }
}

void BenchmarkSmallRecordWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkSmallRecordWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkSmallRecordReaderBase::schema_ = BenchmarkSmallRecordWriterBase::schema_;

bool BenchmarkSmallRecordReaderBase::ReadSmallRecord(test_model::SmallBenchmarkRecord& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkSmallRecordReaderBaseInvalidState(0, state_);
  }

  bool result = ReadSmallRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkSmallRecordReaderBase::ReadSmallRecord(std::vector<test_model::SmallBenchmarkRecord>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkSmallRecordReaderBaseInvalidState(0, state_);
  }

  if (!ReadSmallRecordImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool BenchmarkSmallRecordReaderBase::ReadSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadSmallRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkSmallRecordReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    BenchmarkSmallRecordReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void BenchmarkSmallRecordReaderBase::CopyTo(BenchmarkSmallRecordWriterBase& writer, size_t small_record_buffer_size) {
  if (small_record_buffer_size > 1) {
    std::vector<test_model::SmallBenchmarkRecord> values;
    values.reserve(small_record_buffer_size);
    while(ReadSmallRecord(values)) {
      writer.WriteSmallRecord(values);
    }
    writer.EndSmallRecord();
  } else {
    test_model::SmallBenchmarkRecord value;
    while(ReadSmallRecord(value)) {
      writer.WriteSmallRecord(value);
    }
    writer.EndSmallRecord();
  }
}

namespace {
void BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSmallRecord() or EndSmallRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndSmallRecord()" : "WriteSmallRecord()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSmallRecord()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkSmallRecordWithOptionalsWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkSmallRecordWithOptionals","sequence":[{"name":"smallRecord","type":{"stream":{"items":"TestModel.SimpleEncodingCounters"}}}]},"types":[{"name":"SimpleEncodingCounters","fields":[{"name":"e1","type":[null,"uint32"]},{"name":"e2","type":[null,"uint32"]},{"name":"slice","type":[null,"uint32"]},{"name":"repetition","type":[null,"uint32"]}]}]})";

void BenchmarkSmallRecordWithOptionalsWriterBase::WriteSmallRecord(test_model::SimpleEncodingCounters const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(value);
}

void BenchmarkSmallRecordWithOptionalsWriterBase::WriteSmallRecord(std::vector<test_model::SimpleEncodingCounters> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(0, false, state_);
  }

  WriteSmallRecordImpl(values);
}

void BenchmarkSmallRecordWithOptionalsWriterBase::EndSmallRecord() {
  if (unlikely(state_ != 0)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(0, true, state_);
  }

  EndSmallRecordImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkSmallRecordWithOptionalsWriterBase::WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& values) {
  for (auto const& v : values) {
    WriteSmallRecordImpl(v);
  }
}

void BenchmarkSmallRecordWithOptionalsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkSmallRecordWithOptionalsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkSmallRecordWithOptionalsReaderBase::schema_ = BenchmarkSmallRecordWithOptionalsWriterBase::schema_;

bool BenchmarkSmallRecordWithOptionalsReaderBase::ReadSmallRecord(test_model::SimpleEncodingCounters& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadSmallRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkSmallRecordWithOptionalsReaderBase::ReadSmallRecord(std::vector<test_model::SimpleEncodingCounters>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(0, state_);
  }

  if (!ReadSmallRecordImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool BenchmarkSmallRecordWithOptionalsReaderBase::ReadSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadSmallRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkSmallRecordWithOptionalsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    BenchmarkSmallRecordWithOptionalsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void BenchmarkSmallRecordWithOptionalsReaderBase::CopyTo(BenchmarkSmallRecordWithOptionalsWriterBase& writer, size_t small_record_buffer_size) {
  if (small_record_buffer_size > 1) {
    std::vector<test_model::SimpleEncodingCounters> values;
    values.reserve(small_record_buffer_size);
    while(ReadSmallRecord(values)) {
      writer.WriteSmallRecord(values);
    }
    writer.EndSmallRecord();
  } else {
    test_model::SimpleEncodingCounters value;
    while(ReadSmallRecord(value)) {
      writer.WriteSmallRecord(value);
    }
    writer.EndSmallRecord();
  }
}

namespace {
void BenchmarkSimpleMrdWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteData() or EndData()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndData()" : "WriteData()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void BenchmarkSimpleMrdReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadData()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string BenchmarkSimpleMrdWriterBase::schema_ = R"({"protocol":{"name":"BenchmarkSimpleMrd","sequence":[{"name":"data","type":{"stream":{"items":[{"label":"SimpleAcquisition","type":"TestModel.SimpleAcquisition"},{"label":"Image\u003cfloat32\u003e","type":{"name":"TestModel.Image","typeArguments":["float32"]}}]}}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"SimpleAcquisition","fields":[{"name":"flags","type":"uint64"},{"name":"idx","type":"TestModel.SimpleEncodingCounters"},{"name":"data","type":{"array":{"items":"complexfloat32","dimensions":2}}},{"name":"trajectory","type":{"array":{"items":"float32","dimensions":2}}}]},{"name":"SimpleEncodingCounters","fields":[{"name":"e1","type":[null,"uint32"]},{"name":"e2","type":[null,"uint32"]},{"name":"slice","type":[null,"uint32"]},{"name":"repetition","type":[null,"uint32"]}]}]})";

void BenchmarkSimpleMrdWriterBase::WriteData(std::variant<test_model::SimpleAcquisition, test_model::Image<float>> const& value) {
  if (unlikely(state_ != 0)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(0, false, state_);
  }

  WriteDataImpl(value);
}

void BenchmarkSimpleMrdWriterBase::WriteData(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>> const& values) {
  if (unlikely(state_ != 0)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(0, false, state_);
  }

  WriteDataImpl(values);
}

void BenchmarkSimpleMrdWriterBase::EndData() {
  if (unlikely(state_ != 0)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(0, true, state_);
  }

  EndDataImpl();
  state_ = 1;
}

// fallback implementation
void BenchmarkSimpleMrdWriterBase::WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>> const& values) {
  for (auto const& v : values) {
    WriteDataImpl(v);
  }
}

void BenchmarkSimpleMrdWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    BenchmarkSimpleMrdWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string BenchmarkSimpleMrdReaderBase::schema_ = BenchmarkSimpleMrdWriterBase::schema_;

bool BenchmarkSimpleMrdReaderBase::ReadData(std::variant<test_model::SimpleAcquisition, test_model::Image<float>>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    BenchmarkSimpleMrdReaderBaseInvalidState(0, state_);
  }

  bool result = ReadDataImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool BenchmarkSimpleMrdReaderBase::ReadData(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    BenchmarkSimpleMrdReaderBaseInvalidState(0, state_);
  }

  if (!ReadDataImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool BenchmarkSimpleMrdReaderBase::ReadDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void BenchmarkSimpleMrdReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    BenchmarkSimpleMrdReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void BenchmarkSimpleMrdReaderBase::CopyTo(BenchmarkSimpleMrdWriterBase& writer, size_t data_buffer_size) {
  if (data_buffer_size > 1) {
    std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>> values;
    values.reserve(data_buffer_size);
    while(ReadData(values)) {
      writer.WriteData(values);
    }
    writer.EndData();
  } else {
    std::variant<test_model::SimpleAcquisition, test_model::Image<float>> value;
    while(ReadData(value)) {
      writer.WriteData(value);
    }
    writer.EndData();
  }
}

namespace {
void ScalarsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInt32()"; break;
  case 1: expected_method = "WriteRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInt32()"; break;
  case 1: attempted_method = "WriteRecord()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ScalarsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInt32()";
    case 1: return "ReadRecord()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ScalarsWriterBase::schema_ = R"({"protocol":{"name":"Scalars","sequence":[{"name":"int32","type":"int32"},{"name":"record","type":"TestModel.RecordWithPrimitives"}]},"types":[{"name":"RecordWithPrimitives","fields":[{"name":"boolField","type":"bool"},{"name":"int8Field","type":"int8"},{"name":"uint8Field","type":"uint8"},{"name":"int16Field","type":"int16"},{"name":"uint16Field","type":"uint16"},{"name":"int32Field","type":"int32"},{"name":"uint32Field","type":"uint32"},{"name":"int64Field","type":"int64"},{"name":"uint64Field","type":"uint64"},{"name":"sizeField","type":"size"},{"name":"float32Field","type":"float32"},{"name":"float64Field","type":"float64"},{"name":"complexfloat32Field","type":"complexfloat32"},{"name":"complexfloat64Field","type":"complexfloat64"},{"name":"dateField","type":"date"},{"name":"timeField","type":"time"},{"name":"datetimeField","type":"datetime"}]}]})";

void ScalarsWriterBase::WriteInt32(int32_t const& value) {
  if (unlikely(state_ != 0)) {
    ScalarsWriterBaseInvalidState(0, false, state_);
  }

  WriteInt32Impl(value);
  state_ = 1;
}

void ScalarsWriterBase::WriteRecord(test_model::RecordWithPrimitives const& value) {
  if (unlikely(state_ != 1)) {
    ScalarsWriterBaseInvalidState(1, false, state_);
  }

  WriteRecordImpl(value);
  state_ = 2;
}

void ScalarsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    ScalarsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string ScalarsReaderBase::schema_ = ScalarsWriterBase::schema_;

void ScalarsReaderBase::ReadInt32(int32_t& value) {
  if (unlikely(state_ != 0)) {
    ScalarsReaderBaseInvalidState(0, state_);
  }

  ReadInt32Impl(value);
  state_ = 2;
}

void ScalarsReaderBase::ReadRecord(test_model::RecordWithPrimitives& value) {
  if (unlikely(state_ != 2)) {
    ScalarsReaderBaseInvalidState(2, state_);
  }

  ReadRecordImpl(value);
  state_ = 4;
}

void ScalarsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    ScalarsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void ScalarsReaderBase::CopyTo(ScalarsWriterBase& writer) {
  {
    int32_t value;
    ReadInt32(value);
    writer.WriteInt32(value);
  }
  {
    test_model::RecordWithPrimitives value;
    ReadRecord(value);
    writer.WriteRecord(value);
  }
}

namespace {
void ScalarOptionalsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteOptionalInt()"; break;
  case 1: expected_method = "WriteOptionalRecord()"; break;
  case 2: expected_method = "WriteRecordWithOptionalFields()"; break;
  case 3: expected_method = "WriteOptionalRecordWithOptionalFields()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteOptionalInt()"; break;
  case 1: attempted_method = "WriteOptionalRecord()"; break;
  case 2: attempted_method = "WriteRecordWithOptionalFields()"; break;
  case 3: attempted_method = "WriteOptionalRecordWithOptionalFields()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ScalarOptionalsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadOptionalInt()";
    case 1: return "ReadOptionalRecord()";
    case 2: return "ReadRecordWithOptionalFields()";
    case 3: return "ReadOptionalRecordWithOptionalFields()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ScalarOptionalsWriterBase::schema_ = R"({"protocol":{"name":"ScalarOptionals","sequence":[{"name":"optionalInt","type":[null,"int32"]},{"name":"optionalRecord","type":[null,"TestModel.SimpleRecord"]},{"name":"recordWithOptionalFields","type":"TestModel.RecordWithOptionalFields"},{"name":"optionalRecordWithOptionalFields","type":[null,"TestModel.RecordWithOptionalFields"]}]},"types":[{"name":"RecordWithOptionalFields","fields":[{"name":"optionalInt","type":[null,"int32"]},{"name":"optionalIntAlternateSyntax","type":[null,"int32"]}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void ScalarOptionalsWriterBase::WriteOptionalInt(std::optional<int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    ScalarOptionalsWriterBaseInvalidState(0, false, state_);
  }

  WriteOptionalIntImpl(value);
  state_ = 1;
}

void ScalarOptionalsWriterBase::WriteOptionalRecord(std::optional<test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 1)) {
    ScalarOptionalsWriterBaseInvalidState(1, false, state_);
  }

  WriteOptionalRecordImpl(value);
  state_ = 2;
}

void ScalarOptionalsWriterBase::WriteRecordWithOptionalFields(test_model::RecordWithOptionalFields const& value) {
  if (unlikely(state_ != 2)) {
    ScalarOptionalsWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithOptionalFieldsImpl(value);
  state_ = 3;
}

void ScalarOptionalsWriterBase::WriteOptionalRecordWithOptionalFields(std::optional<test_model::RecordWithOptionalFields> const& value) {
  if (unlikely(state_ != 3)) {
    ScalarOptionalsWriterBaseInvalidState(3, false, state_);
  }

  WriteOptionalRecordWithOptionalFieldsImpl(value);
  state_ = 4;
}

void ScalarOptionalsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    ScalarOptionalsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string ScalarOptionalsReaderBase::schema_ = ScalarOptionalsWriterBase::schema_;

void ScalarOptionalsReaderBase::ReadOptionalInt(std::optional<int32_t>& value) {
  if (unlikely(state_ != 0)) {
    ScalarOptionalsReaderBaseInvalidState(0, state_);
  }

  ReadOptionalIntImpl(value);
  state_ = 2;
}

void ScalarOptionalsReaderBase::ReadOptionalRecord(std::optional<test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 2)) {
    ScalarOptionalsReaderBaseInvalidState(2, state_);
  }

  ReadOptionalRecordImpl(value);
  state_ = 4;
}

void ScalarOptionalsReaderBase::ReadRecordWithOptionalFields(test_model::RecordWithOptionalFields& value) {
  if (unlikely(state_ != 4)) {
    ScalarOptionalsReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithOptionalFieldsImpl(value);
  state_ = 6;
}

void ScalarOptionalsReaderBase::ReadOptionalRecordWithOptionalFields(std::optional<test_model::RecordWithOptionalFields>& value) {
  if (unlikely(state_ != 6)) {
    ScalarOptionalsReaderBaseInvalidState(6, state_);
  }

  ReadOptionalRecordWithOptionalFieldsImpl(value);
  state_ = 8;
}

void ScalarOptionalsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    ScalarOptionalsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void ScalarOptionalsReaderBase::CopyTo(ScalarOptionalsWriterBase& writer) {
  {
    std::optional<int32_t> value;
    ReadOptionalInt(value);
    writer.WriteOptionalInt(value);
  }
  {
    std::optional<test_model::SimpleRecord> value;
    ReadOptionalRecord(value);
    writer.WriteOptionalRecord(value);
  }
  {
    test_model::RecordWithOptionalFields value;
    ReadRecordWithOptionalFields(value);
    writer.WriteRecordWithOptionalFields(value);
  }
  {
    std::optional<test_model::RecordWithOptionalFields> value;
    ReadOptionalRecordWithOptionalFields(value);
    writer.WriteOptionalRecordWithOptionalFields(value);
  }
}

namespace {
void NestedRecordsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteTupleWithRecords()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteTupleWithRecords()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void NestedRecordsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadTupleWithRecords()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string NestedRecordsWriterBase::schema_ = R"({"protocol":{"name":"NestedRecords","sequence":[{"name":"tupleWithRecords","type":"TestModel.TupleWithRecords"}]},"types":[{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]},{"name":"TupleWithRecords","fields":[{"name":"a","type":"TestModel.SimpleRecord"},{"name":"b","type":"TestModel.SimpleRecord"}]}]})";

void NestedRecordsWriterBase::WriteTupleWithRecords(test_model::TupleWithRecords const& value) {
  if (unlikely(state_ != 0)) {
    NestedRecordsWriterBaseInvalidState(0, false, state_);
  }

  WriteTupleWithRecordsImpl(value);
  state_ = 1;
}

void NestedRecordsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    NestedRecordsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string NestedRecordsReaderBase::schema_ = NestedRecordsWriterBase::schema_;

void NestedRecordsReaderBase::ReadTupleWithRecords(test_model::TupleWithRecords& value) {
  if (unlikely(state_ != 0)) {
    NestedRecordsReaderBaseInvalidState(0, state_);
  }

  ReadTupleWithRecordsImpl(value);
  state_ = 2;
}

void NestedRecordsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    NestedRecordsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void NestedRecordsReaderBase::CopyTo(NestedRecordsWriterBase& writer) {
  {
    test_model::TupleWithRecords value;
    ReadTupleWithRecords(value);
    writer.WriteTupleWithRecords(value);
  }
}

namespace {
void VlensWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntVector()"; break;
  case 1: expected_method = "WriteComplexVector()"; break;
  case 2: expected_method = "WriteRecordWithVlens()"; break;
  case 3: expected_method = "WriteVlenOfRecordWithVlens()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteIntVector()"; break;
  case 1: attempted_method = "WriteComplexVector()"; break;
  case 2: attempted_method = "WriteRecordWithVlens()"; break;
  case 3: attempted_method = "WriteVlenOfRecordWithVlens()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void VlensReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntVector()";
    case 1: return "ReadComplexVector()";
    case 2: return "ReadRecordWithVlens()";
    case 3: return "ReadVlenOfRecordWithVlens()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string VlensWriterBase::schema_ = R"({"protocol":{"name":"Vlens","sequence":[{"name":"intVector","type":{"vector":{"items":"int32"}}},{"name":"complexVector","type":{"vector":{"items":"complexfloat32"}}},{"name":"recordWithVlens","type":"TestModel.RecordWithVlens"},{"name":"vlenOfRecordWithVlens","type":{"vector":{"items":"TestModel.RecordWithVlens"}}}]},"types":[{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void VlensWriterBase::WriteIntVector(std::vector<int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    VlensWriterBaseInvalidState(0, false, state_);
  }

  WriteIntVectorImpl(value);
  state_ = 1;
}

void VlensWriterBase::WriteComplexVector(std::vector<std::complex<float>> const& value) {
  if (unlikely(state_ != 1)) {
    VlensWriterBaseInvalidState(1, false, state_);
  }

  WriteComplexVectorImpl(value);
  state_ = 2;
}

void VlensWriterBase::WriteRecordWithVlens(test_model::RecordWithVlens const& value) {
  if (unlikely(state_ != 2)) {
    VlensWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensImpl(value);
  state_ = 3;
}

void VlensWriterBase::WriteVlenOfRecordWithVlens(std::vector<test_model::RecordWithVlens> const& value) {
  if (unlikely(state_ != 3)) {
    VlensWriterBaseInvalidState(3, false, state_);
  }

  WriteVlenOfRecordWithVlensImpl(value);
  state_ = 4;
}

void VlensWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    VlensWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string VlensReaderBase::schema_ = VlensWriterBase::schema_;

void VlensReaderBase::ReadIntVector(std::vector<int32_t>& value) {
  if (unlikely(state_ != 0)) {
    VlensReaderBaseInvalidState(0, state_);
  }

  ReadIntVectorImpl(value);
  state_ = 2;
}

void VlensReaderBase::ReadComplexVector(std::vector<std::complex<float>>& value) {
  if (unlikely(state_ != 2)) {
    VlensReaderBaseInvalidState(2, state_);
  }

  ReadComplexVectorImpl(value);
  state_ = 4;
}

void VlensReaderBase::ReadRecordWithVlens(test_model::RecordWithVlens& value) {
  if (unlikely(state_ != 4)) {
    VlensReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensImpl(value);
  state_ = 6;
}

void VlensReaderBase::ReadVlenOfRecordWithVlens(std::vector<test_model::RecordWithVlens>& value) {
  if (unlikely(state_ != 6)) {
    VlensReaderBaseInvalidState(6, state_);
  }

  ReadVlenOfRecordWithVlensImpl(value);
  state_ = 8;
}

void VlensReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    VlensReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void VlensReaderBase::CopyTo(VlensWriterBase& writer) {
  {
    std::vector<int32_t> value;
    ReadIntVector(value);
    writer.WriteIntVector(value);
  }
  {
    std::vector<std::complex<float>> value;
    ReadComplexVector(value);
    writer.WriteComplexVector(value);
  }
  {
    test_model::RecordWithVlens value;
    ReadRecordWithVlens(value);
    writer.WriteRecordWithVlens(value);
  }
  {
    std::vector<test_model::RecordWithVlens> value;
    ReadVlenOfRecordWithVlens(value);
    writer.WriteVlenOfRecordWithVlens(value);
  }
}

namespace {
void StringsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSingleString()"; break;
  case 1: expected_method = "WriteRecWithString()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteSingleString()"; break;
  case 1: attempted_method = "WriteRecWithString()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StringsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSingleString()";
    case 1: return "ReadRecWithString()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StringsWriterBase::schema_ = R"({"protocol":{"name":"Strings","sequence":[{"name":"singleString","type":"string"},{"name":"recWithString","type":"TestModel.RecordWithStrings"}]},"types":[{"name":"RecordWithStrings","fields":[{"name":"a","type":"string"},{"name":"b","type":"string"}]}]})";

void StringsWriterBase::WriteSingleString(std::string const& value) {
  if (unlikely(state_ != 0)) {
    StringsWriterBaseInvalidState(0, false, state_);
  }

  WriteSingleStringImpl(value);
  state_ = 1;
}

void StringsWriterBase::WriteRecWithString(test_model::RecordWithStrings const& value) {
  if (unlikely(state_ != 1)) {
    StringsWriterBaseInvalidState(1, false, state_);
  }

  WriteRecWithStringImpl(value);
  state_ = 2;
}

void StringsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    StringsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string StringsReaderBase::schema_ = StringsWriterBase::schema_;

void StringsReaderBase::ReadSingleString(std::string& value) {
  if (unlikely(state_ != 0)) {
    StringsReaderBaseInvalidState(0, state_);
  }

  ReadSingleStringImpl(value);
  state_ = 2;
}

void StringsReaderBase::ReadRecWithString(test_model::RecordWithStrings& value) {
  if (unlikely(state_ != 2)) {
    StringsReaderBaseInvalidState(2, state_);
  }

  ReadRecWithStringImpl(value);
  state_ = 4;
}

void StringsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    StringsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void StringsReaderBase::CopyTo(StringsWriterBase& writer) {
  {
    std::string value;
    ReadSingleString(value);
    writer.WriteSingleString(value);
  }
  {
    test_model::RecordWithStrings value;
    ReadRecWithString(value);
    writer.WriteRecWithString(value);
  }
}

namespace {
void OptionalVectorsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteRecordWithOptionalVector()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteRecordWithOptionalVector()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void OptionalVectorsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadRecordWithOptionalVector()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string OptionalVectorsWriterBase::schema_ = R"({"protocol":{"name":"OptionalVectors","sequence":[{"name":"recordWithOptionalVector","type":"TestModel.RecordWithOptionalVector"}]},"types":[{"name":"RecordWithOptionalVector","fields":[{"name":"optionalVector","type":[null,{"vector":{"items":"int32"}}]}]}]})";

void OptionalVectorsWriterBase::WriteRecordWithOptionalVector(test_model::RecordWithOptionalVector const& value) {
  if (unlikely(state_ != 0)) {
    OptionalVectorsWriterBaseInvalidState(0, false, state_);
  }

  WriteRecordWithOptionalVectorImpl(value);
  state_ = 1;
}

void OptionalVectorsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    OptionalVectorsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string OptionalVectorsReaderBase::schema_ = OptionalVectorsWriterBase::schema_;

void OptionalVectorsReaderBase::ReadRecordWithOptionalVector(test_model::RecordWithOptionalVector& value) {
  if (unlikely(state_ != 0)) {
    OptionalVectorsReaderBaseInvalidState(0, state_);
  }

  ReadRecordWithOptionalVectorImpl(value);
  state_ = 2;
}

void OptionalVectorsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    OptionalVectorsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void OptionalVectorsReaderBase::CopyTo(OptionalVectorsWriterBase& writer) {
  {
    test_model::RecordWithOptionalVector value;
    ReadRecordWithOptionalVector(value);
    writer.WriteRecordWithOptionalVector(value);
  }
}

namespace {
void FixedVectorsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFixedIntVector()"; break;
  case 1: expected_method = "WriteFixedSimpleRecordVector()"; break;
  case 2: expected_method = "WriteFixedRecordWithVlensVector()"; break;
  case 3: expected_method = "WriteRecordWithFixedVectors()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteFixedIntVector()"; break;
  case 1: attempted_method = "WriteFixedSimpleRecordVector()"; break;
  case 2: attempted_method = "WriteFixedRecordWithVlensVector()"; break;
  case 3: attempted_method = "WriteRecordWithFixedVectors()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void FixedVectorsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFixedIntVector()";
    case 1: return "ReadFixedSimpleRecordVector()";
    case 2: return "ReadFixedRecordWithVlensVector()";
    case 3: return "ReadRecordWithFixedVectors()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string FixedVectorsWriterBase::schema_ = R"({"protocol":{"name":"FixedVectors","sequence":[{"name":"fixedIntVector","type":{"vector":{"items":"int32","length":5}}},{"name":"fixedSimpleRecordVector","type":{"vector":{"items":"TestModel.SimpleRecord","length":3}}},{"name":"fixedRecordWithVlensVector","type":{"vector":{"items":"TestModel.RecordWithVlens","length":2}}},{"name":"recordWithFixedVectors","type":"TestModel.RecordWithFixedVectors"}]},"types":[{"name":"RecordWithFixedVectors","fields":[{"name":"fixedIntVector","type":{"vector":{"items":"int32","length":5}}},{"name":"fixedSimpleRecordVector","type":{"vector":{"items":"TestModel.SimpleRecord","length":3}}},{"name":"fixedRecordWithVlensVector","type":{"vector":{"items":"TestModel.RecordWithVlens","length":2}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void FixedVectorsWriterBase::WriteFixedIntVector(std::array<int32_t, 5> const& value) {
  if (unlikely(state_ != 0)) {
    FixedVectorsWriterBaseInvalidState(0, false, state_);
  }

  WriteFixedIntVectorImpl(value);
  state_ = 1;
}

void FixedVectorsWriterBase::WriteFixedSimpleRecordVector(std::array<test_model::SimpleRecord, 3> const& value) {
  if (unlikely(state_ != 1)) {
    FixedVectorsWriterBaseInvalidState(1, false, state_);
  }

  WriteFixedSimpleRecordVectorImpl(value);
  state_ = 2;
}

void FixedVectorsWriterBase::WriteFixedRecordWithVlensVector(std::array<test_model::RecordWithVlens, 2> const& value) {
  if (unlikely(state_ != 2)) {
    FixedVectorsWriterBaseInvalidState(2, false, state_);
  }

  WriteFixedRecordWithVlensVectorImpl(value);
  state_ = 3;
}

void FixedVectorsWriterBase::WriteRecordWithFixedVectors(test_model::RecordWithFixedVectors const& value) {
  if (unlikely(state_ != 3)) {
    FixedVectorsWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithFixedVectorsImpl(value);
  state_ = 4;
}

void FixedVectorsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    FixedVectorsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string FixedVectorsReaderBase::schema_ = FixedVectorsWriterBase::schema_;

void FixedVectorsReaderBase::ReadFixedIntVector(std::array<int32_t, 5>& value) {
  if (unlikely(state_ != 0)) {
    FixedVectorsReaderBaseInvalidState(0, state_);
  }

  ReadFixedIntVectorImpl(value);
  state_ = 2;
}

void FixedVectorsReaderBase::ReadFixedSimpleRecordVector(std::array<test_model::SimpleRecord, 3>& value) {
  if (unlikely(state_ != 2)) {
    FixedVectorsReaderBaseInvalidState(2, state_);
  }

  ReadFixedSimpleRecordVectorImpl(value);
  state_ = 4;
}

void FixedVectorsReaderBase::ReadFixedRecordWithVlensVector(std::array<test_model::RecordWithVlens, 2>& value) {
  if (unlikely(state_ != 4)) {
    FixedVectorsReaderBaseInvalidState(4, state_);
  }

  ReadFixedRecordWithVlensVectorImpl(value);
  state_ = 6;
}

void FixedVectorsReaderBase::ReadRecordWithFixedVectors(test_model::RecordWithFixedVectors& value) {
  if (unlikely(state_ != 6)) {
    FixedVectorsReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithFixedVectorsImpl(value);
  state_ = 8;
}

void FixedVectorsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    FixedVectorsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void FixedVectorsReaderBase::CopyTo(FixedVectorsWriterBase& writer) {
  {
    std::array<int32_t, 5> value;
    ReadFixedIntVector(value);
    writer.WriteFixedIntVector(value);
  }
  {
    std::array<test_model::SimpleRecord, 3> value;
    ReadFixedSimpleRecordVector(value);
    writer.WriteFixedSimpleRecordVector(value);
  }
  {
    std::array<test_model::RecordWithVlens, 2> value;
    ReadFixedRecordWithVlensVector(value);
    writer.WriteFixedRecordWithVlensVector(value);
  }
  {
    test_model::RecordWithFixedVectors value;
    ReadRecordWithFixedVectors(value);
    writer.WriteRecordWithFixedVectors(value);
  }
}

namespace {
void StreamsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntData() or EndIntData()"; break;
  case 1: expected_method = "WriteOptionalIntData() or EndOptionalIntData()"; break;
  case 2: expected_method = "WriteRecordWithOptionalVectorData() or EndRecordWithOptionalVectorData()"; break;
  case 3: expected_method = "WriteFixedVector() or EndFixedVector()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndIntData()" : "WriteIntData()"; break;
  case 1: attempted_method = end ? "EndOptionalIntData()" : "WriteOptionalIntData()"; break;
  case 2: attempted_method = end ? "EndRecordWithOptionalVectorData()" : "WriteRecordWithOptionalVectorData()"; break;
  case 3: attempted_method = end ? "EndFixedVector()" : "WriteFixedVector()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StreamsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntData()";
    case 1: return "ReadOptionalIntData()";
    case 2: return "ReadRecordWithOptionalVectorData()";
    case 3: return "ReadFixedVector()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StreamsWriterBase::schema_ = R"({"protocol":{"name":"Streams","sequence":[{"name":"intData","type":{"stream":{"items":"int32"}}},{"name":"optionalIntData","type":{"stream":{"items":[null,"int32"]}}},{"name":"recordWithOptionalVectorData","type":{"stream":{"items":"TestModel.RecordWithOptionalVector"}}},{"name":"fixedVector","type":{"stream":{"items":{"vector":{"items":"int32","length":3}}}}}]},"types":[{"name":"RecordWithOptionalVector","fields":[{"name":"optionalVector","type":[null,{"vector":{"items":"int32"}}]}]}]})";

void StreamsWriterBase::WriteIntData(int32_t const& value) {
  if (unlikely(state_ != 0)) {
    StreamsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntDataImpl(value);
}

void StreamsWriterBase::WriteIntData(std::vector<int32_t> const& values) {
  if (unlikely(state_ != 0)) {
    StreamsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntDataImpl(values);
}

void StreamsWriterBase::EndIntData() {
  if (unlikely(state_ != 0)) {
    StreamsWriterBaseInvalidState(0, true, state_);
  }

  EndIntDataImpl();
  state_ = 1;
}

// fallback implementation
void StreamsWriterBase::WriteIntDataImpl(std::vector<int32_t> const& values) {
  for (auto const& v : values) {
    WriteIntDataImpl(v);
  }
}

void StreamsWriterBase::WriteOptionalIntData(std::optional<int32_t> const& value) {
  if (unlikely(state_ != 1)) {
    StreamsWriterBaseInvalidState(1, false, state_);
  }

  WriteOptionalIntDataImpl(value);
}

void StreamsWriterBase::WriteOptionalIntData(std::vector<std::optional<int32_t>> const& values) {
  if (unlikely(state_ != 1)) {
    StreamsWriterBaseInvalidState(1, false, state_);
  }

  WriteOptionalIntDataImpl(values);
}

void StreamsWriterBase::EndOptionalIntData() {
  if (unlikely(state_ != 1)) {
    StreamsWriterBaseInvalidState(1, true, state_);
  }

  EndOptionalIntDataImpl();
  state_ = 2;
}

// fallback implementation
void StreamsWriterBase::WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& values) {
  for (auto const& v : values) {
    WriteOptionalIntDataImpl(v);
  }
}

void StreamsWriterBase::WriteRecordWithOptionalVectorData(test_model::RecordWithOptionalVector const& value) {
  if (unlikely(state_ != 2)) {
    StreamsWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithOptionalVectorDataImpl(value);
}

void StreamsWriterBase::WriteRecordWithOptionalVectorData(std::vector<test_model::RecordWithOptionalVector> const& values) {
  if (unlikely(state_ != 2)) {
    StreamsWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithOptionalVectorDataImpl(values);
}

void StreamsWriterBase::EndRecordWithOptionalVectorData() {
  if (unlikely(state_ != 2)) {
    StreamsWriterBaseInvalidState(2, true, state_);
  }

  EndRecordWithOptionalVectorDataImpl();
  state_ = 3;
}

// fallback implementation
void StreamsWriterBase::WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& values) {
  for (auto const& v : values) {
    WriteRecordWithOptionalVectorDataImpl(v);
  }
}

void StreamsWriterBase::WriteFixedVector(std::array<int32_t, 3> const& value) {
  if (unlikely(state_ != 3)) {
    StreamsWriterBaseInvalidState(3, false, state_);
  }

  WriteFixedVectorImpl(value);
}

void StreamsWriterBase::WriteFixedVector(std::vector<std::array<int32_t, 3>> const& values) {
  if (unlikely(state_ != 3)) {
    StreamsWriterBaseInvalidState(3, false, state_);
  }

  WriteFixedVectorImpl(values);
}

void StreamsWriterBase::EndFixedVector() {
  if (unlikely(state_ != 3)) {
    StreamsWriterBaseInvalidState(3, true, state_);
  }

  EndFixedVectorImpl();
  state_ = 4;
}

// fallback implementation
void StreamsWriterBase::WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& values) {
  for (auto const& v : values) {
    WriteFixedVectorImpl(v);
  }
}

void StreamsWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    StreamsWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string StreamsReaderBase::schema_ = StreamsWriterBase::schema_;

bool StreamsReaderBase::ReadIntData(int32_t& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    StreamsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntDataImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool StreamsReaderBase::ReadIntData(std::vector<int32_t>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    StreamsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntDataImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadIntDataImpl(std::vector<int32_t>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsReaderBase::ReadOptionalIntData(std::optional<int32_t>& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadOptionalIntDataImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StreamsReaderBase::ReadOptionalIntData(std::vector<std::optional<int32_t>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadOptionalIntDataImpl(values)) {state_ = 3;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadOptionalIntDataImpl(std::vector<std::optional<int32_t>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadOptionalIntDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsReaderBase::ReadRecordWithOptionalVectorData(test_model::RecordWithOptionalVector& value) {
  if (unlikely(state_ != 4)) {
    if (state_ == 5) {
      state_ = 6;
      return false;
    }
    if (state_ == 3) {
      state_ = 4;
    } else {
      StreamsReaderBaseInvalidState(4, state_);
    }
  }

  bool result = ReadRecordWithOptionalVectorDataImpl(value);
  if (!result) {
    state_ = 6;
  }
  return result;
}

bool StreamsReaderBase::ReadRecordWithOptionalVectorData(std::vector<test_model::RecordWithOptionalVector>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 4)) {
    if (state_ == 5) {
      state_ = 6;
      values.clear();
      return false;
    }
    if (state_ == 3) {
      state_ = 4;
    } else {
      StreamsReaderBaseInvalidState(4, state_);
    }
  }

  if (!ReadRecordWithOptionalVectorDataImpl(values)) {state_ = 5;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadRecordWithOptionalVectorDataImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsReaderBase::ReadFixedVector(std::array<int32_t, 3>& value) {
  if (unlikely(state_ != 6)) {
    if (state_ == 7) {
      state_ = 8;
      return false;
    }
    if (state_ == 5) {
      state_ = 6;
    } else {
      StreamsReaderBaseInvalidState(6, state_);
    }
  }

  bool result = ReadFixedVectorImpl(value);
  if (!result) {
    state_ = 8;
  }
  return result;
}

bool StreamsReaderBase::ReadFixedVector(std::vector<std::array<int32_t, 3>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 6)) {
    if (state_ == 7) {
      state_ = 8;
      values.clear();
      return false;
    }
    if (state_ == 5) {
      state_ = 6;
    } else {
      StreamsReaderBaseInvalidState(6, state_);
    }
  }

  if (!ReadFixedVectorImpl(values)) {state_ = 7;
  }
  return true;
}

// fallback implementation
bool StreamsReaderBase::ReadFixedVectorImpl(std::vector<std::array<int32_t, 3>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadFixedVectorImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StreamsReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    StreamsReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void StreamsReaderBase::CopyTo(StreamsWriterBase& writer, size_t int_data_buffer_size, size_t optional_int_data_buffer_size, size_t record_with_optional_vector_data_buffer_size, size_t fixed_vector_buffer_size) {
  if (int_data_buffer_size > 1) {
    std::vector<int32_t> values;
    values.reserve(int_data_buffer_size);
    while(ReadIntData(values)) {
      writer.WriteIntData(values);
    }
    writer.EndIntData();
  } else {
    int32_t value;
    while(ReadIntData(value)) {
      writer.WriteIntData(value);
    }
    writer.EndIntData();
  }
  if (optional_int_data_buffer_size > 1) {
    std::vector<std::optional<int32_t>> values;
    values.reserve(optional_int_data_buffer_size);
    while(ReadOptionalIntData(values)) {
      writer.WriteOptionalIntData(values);
    }
    writer.EndOptionalIntData();
  } else {
    std::optional<int32_t> value;
    while(ReadOptionalIntData(value)) {
      writer.WriteOptionalIntData(value);
    }
    writer.EndOptionalIntData();
  }
  if (record_with_optional_vector_data_buffer_size > 1) {
    std::vector<test_model::RecordWithOptionalVector> values;
    values.reserve(record_with_optional_vector_data_buffer_size);
    while(ReadRecordWithOptionalVectorData(values)) {
      writer.WriteRecordWithOptionalVectorData(values);
    }
    writer.EndRecordWithOptionalVectorData();
  } else {
    test_model::RecordWithOptionalVector value;
    while(ReadRecordWithOptionalVectorData(value)) {
      writer.WriteRecordWithOptionalVectorData(value);
    }
    writer.EndRecordWithOptionalVectorData();
  }
  if (fixed_vector_buffer_size > 1) {
    std::vector<std::array<int32_t, 3>> values;
    values.reserve(fixed_vector_buffer_size);
    while(ReadFixedVector(values)) {
      writer.WriteFixedVector(values);
    }
    writer.EndFixedVector();
  } else {
    std::array<int32_t, 3> value;
    while(ReadFixedVector(value)) {
      writer.WriteFixedVector(value);
    }
    writer.EndFixedVector();
  }
}

namespace {
void FixedArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteFixedSimpleRecordArray()"; break;
  case 2: expected_method = "WriteFixedRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithFixedArrays()"; break;
  case 4: expected_method = "WriteNamedArray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteFixedSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteFixedRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithFixedArrays()"; break;
  case 4: attempted_method = "WriteNamedArray()"; break;
  case 5: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void FixedArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadFixedSimpleRecordArray()";
    case 2: return "ReadFixedRecordWithVlensArray()";
    case 3: return "ReadRecordWithFixedArrays()";
    case 4: return "ReadNamedArray()";
    case 5: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string FixedArraysWriterBase::schema_ = R"({"protocol":{"name":"FixedArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":[{"length":3},{"length":2}]}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":[{"length":2},{"length":2}]}}},{"name":"recordWithFixedArrays","type":"TestModel.RecordWithFixedArrays"},{"name":"namedArray","type":"TestModel.NamedFixedNDArray"}]},"types":[{"name":"NamedFixedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA","length":2},{"name":"dimB","length":4}]}}},{"name":"RecordWithFixedArrays","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":[{"length":2},{"length":3}]}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":[{"length":3},{"length":2}]}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":[{"length":2},{"length":2}]}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void FixedArraysWriterBase::WriteInts(yardl::FixedNDArray<int32_t, 2, 3> const& value) {
  if (unlikely(state_ != 0)) {
    FixedArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void FixedArraysWriterBase::WriteFixedSimpleRecordArray(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) {
  if (unlikely(state_ != 1)) {
    FixedArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteFixedSimpleRecordArrayImpl(value);
  state_ = 2;
}

void FixedArraysWriterBase::WriteFixedRecordWithVlensArray(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) {
  if (unlikely(state_ != 2)) {
    FixedArraysWriterBaseInvalidState(2, false, state_);
  }

  WriteFixedRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void FixedArraysWriterBase::WriteRecordWithFixedArrays(test_model::RecordWithFixedArrays const& value) {
  if (unlikely(state_ != 3)) {
    FixedArraysWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithFixedArraysImpl(value);
  state_ = 4;
}

void FixedArraysWriterBase::WriteNamedArray(test_model::NamedFixedNDArray const& value) {
  if (unlikely(state_ != 4)) {
    FixedArraysWriterBaseInvalidState(4, false, state_);
  }

  WriteNamedArrayImpl(value);
  state_ = 5;
}

void FixedArraysWriterBase::Close() {
  if (unlikely(state_ != 5)) {
    FixedArraysWriterBaseInvalidState(5, false, state_);
  }

  CloseImpl();
}

std::string FixedArraysReaderBase::schema_ = FixedArraysWriterBase::schema_;

void FixedArraysReaderBase::ReadInts(yardl::FixedNDArray<int32_t, 2, 3>& value) {
  if (unlikely(state_ != 0)) {
    FixedArraysReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void FixedArraysReaderBase::ReadFixedSimpleRecordArray(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value) {
  if (unlikely(state_ != 2)) {
    FixedArraysReaderBaseInvalidState(2, state_);
  }

  ReadFixedSimpleRecordArrayImpl(value);
  state_ = 4;
}

void FixedArraysReaderBase::ReadFixedRecordWithVlensArray(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value) {
  if (unlikely(state_ != 4)) {
    FixedArraysReaderBaseInvalidState(4, state_);
  }

  ReadFixedRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void FixedArraysReaderBase::ReadRecordWithFixedArrays(test_model::RecordWithFixedArrays& value) {
  if (unlikely(state_ != 6)) {
    FixedArraysReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithFixedArraysImpl(value);
  state_ = 8;
}

void FixedArraysReaderBase::ReadNamedArray(test_model::NamedFixedNDArray& value) {
  if (unlikely(state_ != 8)) {
    FixedArraysReaderBaseInvalidState(8, state_);
  }

  ReadNamedArrayImpl(value);
  state_ = 10;
}

void FixedArraysReaderBase::Close() {
  if (unlikely(state_ != 10)) {
    FixedArraysReaderBaseInvalidState(10, state_);
  }

  CloseImpl();
}
void FixedArraysReaderBase::CopyTo(FixedArraysWriterBase& writer) {
  {
    yardl::FixedNDArray<int32_t, 2, 3> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> value;
    ReadFixedSimpleRecordArray(value);
    writer.WriteFixedSimpleRecordArray(value);
  }
  {
    yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> value;
    ReadFixedRecordWithVlensArray(value);
    writer.WriteFixedRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithFixedArrays value;
    ReadRecordWithFixedArrays(value);
    writer.WriteRecordWithFixedArrays(value);
  }
  {
    test_model::NamedFixedNDArray value;
    ReadNamedArray(value);
    writer.WriteNamedArray(value);
  }
}

namespace {
void NDArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteSimpleRecordArray()"; break;
  case 2: expected_method = "WriteRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithNDArrays()"; break;
  case 4: expected_method = "WriteNamedArray()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithNDArrays()"; break;
  case 4: attempted_method = "WriteNamedArray()"; break;
  case 5: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void NDArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadSimpleRecordArray()";
    case 2: return "ReadRecordWithVlensArray()";
    case 3: return "ReadRecordWithNDArrays()";
    case 4: return "ReadNamedArray()";
    case 5: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string NDArraysWriterBase::schema_ = R"({"protocol":{"name":"NDArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":2}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":2}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":2}}},{"name":"recordWithNDArrays","type":"TestModel.RecordWithNDArrays"},{"name":"namedArray","type":"TestModel.NamedNDArray"}]},"types":[{"name":"NamedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA"},{"name":"dimB"}]}}},{"name":"RecordWithNDArrays","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":2}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":2}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":2}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void NDArraysWriterBase::WriteInts(yardl::NDArray<int32_t, 2> const& value) {
  if (unlikely(state_ != 0)) {
    NDArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void NDArraysWriterBase::WriteSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 2> const& value) {
  if (unlikely(state_ != 1)) {
    NDArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteSimpleRecordArrayImpl(value);
  state_ = 2;
}

void NDArraysWriterBase::WriteRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) {
  if (unlikely(state_ != 2)) {
    NDArraysWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void NDArraysWriterBase::WriteRecordWithNDArrays(test_model::RecordWithNDArrays const& value) {
  if (unlikely(state_ != 3)) {
    NDArraysWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithNDArraysImpl(value);
  state_ = 4;
}

void NDArraysWriterBase::WriteNamedArray(test_model::NamedNDArray const& value) {
  if (unlikely(state_ != 4)) {
    NDArraysWriterBaseInvalidState(4, false, state_);
  }

  WriteNamedArrayImpl(value);
  state_ = 5;
}

void NDArraysWriterBase::Close() {
  if (unlikely(state_ != 5)) {
    NDArraysWriterBaseInvalidState(5, false, state_);
  }

  CloseImpl();
}

std::string NDArraysReaderBase::schema_ = NDArraysWriterBase::schema_;

void NDArraysReaderBase::ReadInts(yardl::NDArray<int32_t, 2>& value) {
  if (unlikely(state_ != 0)) {
    NDArraysReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void NDArraysReaderBase::ReadSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 2>& value) {
  if (unlikely(state_ != 2)) {
    NDArraysReaderBaseInvalidState(2, state_);
  }

  ReadSimpleRecordArrayImpl(value);
  state_ = 4;
}

void NDArraysReaderBase::ReadRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 2>& value) {
  if (unlikely(state_ != 4)) {
    NDArraysReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void NDArraysReaderBase::ReadRecordWithNDArrays(test_model::RecordWithNDArrays& value) {
  if (unlikely(state_ != 6)) {
    NDArraysReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithNDArraysImpl(value);
  state_ = 8;
}

void NDArraysReaderBase::ReadNamedArray(test_model::NamedNDArray& value) {
  if (unlikely(state_ != 8)) {
    NDArraysReaderBaseInvalidState(8, state_);
  }

  ReadNamedArrayImpl(value);
  state_ = 10;
}

void NDArraysReaderBase::Close() {
  if (unlikely(state_ != 10)) {
    NDArraysReaderBaseInvalidState(10, state_);
  }

  CloseImpl();
}
void NDArraysReaderBase::CopyTo(NDArraysWriterBase& writer) {
  {
    yardl::NDArray<int32_t, 2> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::NDArray<test_model::SimpleRecord, 2> value;
    ReadSimpleRecordArray(value);
    writer.WriteSimpleRecordArray(value);
  }
  {
    yardl::NDArray<test_model::RecordWithVlens, 2> value;
    ReadRecordWithVlensArray(value);
    writer.WriteRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithNDArrays value;
    ReadRecordWithNDArrays(value);
    writer.WriteRecordWithNDArrays(value);
  }
  {
    test_model::NamedNDArray value;
    ReadNamedArray(value);
    writer.WriteNamedArray(value);
  }
}

namespace {
void NDArraysSingleDimensionWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteSimpleRecordArray()"; break;
  case 2: expected_method = "WriteRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithNDArrays()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithNDArrays()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void NDArraysSingleDimensionReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadSimpleRecordArray()";
    case 2: return "ReadRecordWithVlensArray()";
    case 3: return "ReadRecordWithNDArrays()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string NDArraysSingleDimensionWriterBase::schema_ = R"({"protocol":{"name":"NDArraysSingleDimension","sequence":[{"name":"ints","type":{"array":{"items":"int32","dimensions":1}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":1}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":1}}},{"name":"recordWithNDArrays","type":"TestModel.RecordWithNDArraysSingleDimension"}]},"types":[{"name":"RecordWithNDArraysSingleDimension","fields":[{"name":"ints","type":{"array":{"items":"int32","dimensions":1}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord","dimensions":1}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens","dimensions":1}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void NDArraysSingleDimensionWriterBase::WriteInts(yardl::NDArray<int32_t, 1> const& value) {
  if (unlikely(state_ != 0)) {
    NDArraysSingleDimensionWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void NDArraysSingleDimensionWriterBase::WriteSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 1> const& value) {
  if (unlikely(state_ != 1)) {
    NDArraysSingleDimensionWriterBaseInvalidState(1, false, state_);
  }

  WriteSimpleRecordArrayImpl(value);
  state_ = 2;
}

void NDArraysSingleDimensionWriterBase::WriteRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) {
  if (unlikely(state_ != 2)) {
    NDArraysSingleDimensionWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void NDArraysSingleDimensionWriterBase::WriteRecordWithNDArrays(test_model::RecordWithNDArraysSingleDimension const& value) {
  if (unlikely(state_ != 3)) {
    NDArraysSingleDimensionWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithNDArraysImpl(value);
  state_ = 4;
}

void NDArraysSingleDimensionWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    NDArraysSingleDimensionWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string NDArraysSingleDimensionReaderBase::schema_ = NDArraysSingleDimensionWriterBase::schema_;

void NDArraysSingleDimensionReaderBase::ReadInts(yardl::NDArray<int32_t, 1>& value) {
  if (unlikely(state_ != 0)) {
    NDArraysSingleDimensionReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void NDArraysSingleDimensionReaderBase::ReadSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 1>& value) {
  if (unlikely(state_ != 2)) {
    NDArraysSingleDimensionReaderBaseInvalidState(2, state_);
  }

  ReadSimpleRecordArrayImpl(value);
  state_ = 4;
}

void NDArraysSingleDimensionReaderBase::ReadRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 1>& value) {
  if (unlikely(state_ != 4)) {
    NDArraysSingleDimensionReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void NDArraysSingleDimensionReaderBase::ReadRecordWithNDArrays(test_model::RecordWithNDArraysSingleDimension& value) {
  if (unlikely(state_ != 6)) {
    NDArraysSingleDimensionReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithNDArraysImpl(value);
  state_ = 8;
}

void NDArraysSingleDimensionReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    NDArraysSingleDimensionReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void NDArraysSingleDimensionReaderBase::CopyTo(NDArraysSingleDimensionWriterBase& writer) {
  {
    yardl::NDArray<int32_t, 1> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::NDArray<test_model::SimpleRecord, 1> value;
    ReadSimpleRecordArray(value);
    writer.WriteSimpleRecordArray(value);
  }
  {
    yardl::NDArray<test_model::RecordWithVlens, 1> value;
    ReadRecordWithVlensArray(value);
    writer.WriteRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithNDArraysSingleDimension value;
    ReadRecordWithNDArrays(value);
    writer.WriteRecordWithNDArrays(value);
  }
}

namespace {
void DynamicNDArraysWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInts()"; break;
  case 1: expected_method = "WriteSimpleRecordArray()"; break;
  case 2: expected_method = "WriteRecordWithVlensArray()"; break;
  case 3: expected_method = "WriteRecordWithDynamicNDArrays()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteInts()"; break;
  case 1: attempted_method = "WriteSimpleRecordArray()"; break;
  case 2: attempted_method = "WriteRecordWithVlensArray()"; break;
  case 3: attempted_method = "WriteRecordWithDynamicNDArrays()"; break;
  case 4: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void DynamicNDArraysReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInts()";
    case 1: return "ReadSimpleRecordArray()";
    case 2: return "ReadRecordWithVlensArray()";
    case 3: return "ReadRecordWithDynamicNDArrays()";
    case 4: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string DynamicNDArraysWriterBase::schema_ = R"({"protocol":{"name":"DynamicNDArrays","sequence":[{"name":"ints","type":{"array":{"items":"int32"}}},{"name":"simpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord"}}},{"name":"recordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens"}}},{"name":"recordWithDynamicNDArrays","type":"TestModel.RecordWithDynamicNDArrays"}]},"types":[{"name":"RecordWithDynamicNDArrays","fields":[{"name":"ints","type":{"array":{"items":"int32"}}},{"name":"fixedSimpleRecordArray","type":{"array":{"items":"TestModel.SimpleRecord"}}},{"name":"fixedRecordWithVlensArray","type":{"array":{"items":"TestModel.RecordWithVlens"}}}]},{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void DynamicNDArraysWriterBase::WriteInts(yardl::DynamicNDArray<int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    DynamicNDArraysWriterBaseInvalidState(0, false, state_);
  }

  WriteIntsImpl(value);
  state_ = 1;
}

void DynamicNDArraysWriterBase::WriteSimpleRecordArray(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 1)) {
    DynamicNDArraysWriterBaseInvalidState(1, false, state_);
  }

  WriteSimpleRecordArrayImpl(value);
  state_ = 2;
}

void DynamicNDArraysWriterBase::WriteRecordWithVlensArray(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) {
  if (unlikely(state_ != 2)) {
    DynamicNDArraysWriterBaseInvalidState(2, false, state_);
  }

  WriteRecordWithVlensArrayImpl(value);
  state_ = 3;
}

void DynamicNDArraysWriterBase::WriteRecordWithDynamicNDArrays(test_model::RecordWithDynamicNDArrays const& value) {
  if (unlikely(state_ != 3)) {
    DynamicNDArraysWriterBaseInvalidState(3, false, state_);
  }

  WriteRecordWithDynamicNDArraysImpl(value);
  state_ = 4;
}

void DynamicNDArraysWriterBase::Close() {
  if (unlikely(state_ != 4)) {
    DynamicNDArraysWriterBaseInvalidState(4, false, state_);
  }

  CloseImpl();
}

std::string DynamicNDArraysReaderBase::schema_ = DynamicNDArraysWriterBase::schema_;

void DynamicNDArraysReaderBase::ReadInts(yardl::DynamicNDArray<int32_t>& value) {
  if (unlikely(state_ != 0)) {
    DynamicNDArraysReaderBaseInvalidState(0, state_);
  }

  ReadIntsImpl(value);
  state_ = 2;
}

void DynamicNDArraysReaderBase::ReadSimpleRecordArray(yardl::DynamicNDArray<test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 2)) {
    DynamicNDArraysReaderBaseInvalidState(2, state_);
  }

  ReadSimpleRecordArrayImpl(value);
  state_ = 4;
}

void DynamicNDArraysReaderBase::ReadRecordWithVlensArray(yardl::DynamicNDArray<test_model::RecordWithVlens>& value) {
  if (unlikely(state_ != 4)) {
    DynamicNDArraysReaderBaseInvalidState(4, state_);
  }

  ReadRecordWithVlensArrayImpl(value);
  state_ = 6;
}

void DynamicNDArraysReaderBase::ReadRecordWithDynamicNDArrays(test_model::RecordWithDynamicNDArrays& value) {
  if (unlikely(state_ != 6)) {
    DynamicNDArraysReaderBaseInvalidState(6, state_);
  }

  ReadRecordWithDynamicNDArraysImpl(value);
  state_ = 8;
}

void DynamicNDArraysReaderBase::Close() {
  if (unlikely(state_ != 8)) {
    DynamicNDArraysReaderBaseInvalidState(8, state_);
  }

  CloseImpl();
}
void DynamicNDArraysReaderBase::CopyTo(DynamicNDArraysWriterBase& writer) {
  {
    yardl::DynamicNDArray<int32_t> value;
    ReadInts(value);
    writer.WriteInts(value);
  }
  {
    yardl::DynamicNDArray<test_model::SimpleRecord> value;
    ReadSimpleRecordArray(value);
    writer.WriteSimpleRecordArray(value);
  }
  {
    yardl::DynamicNDArray<test_model::RecordWithVlens> value;
    ReadRecordWithVlensArray(value);
    writer.WriteRecordWithVlensArray(value);
  }
  {
    test_model::RecordWithDynamicNDArrays value;
    ReadRecordWithDynamicNDArrays(value);
    writer.WriteRecordWithDynamicNDArrays(value);
  }
}

namespace {
void MapsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteStringToInt()"; break;
  case 1: expected_method = "WriteStringToUnion()"; break;
  case 2: expected_method = "WriteAliasedGeneric()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteStringToInt()"; break;
  case 1: attempted_method = "WriteStringToUnion()"; break;
  case 2: attempted_method = "WriteAliasedGeneric()"; break;
  case 3: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void MapsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadStringToInt()";
    case 1: return "ReadStringToUnion()";
    case 2: return "ReadAliasedGeneric()";
    case 3: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string MapsWriterBase::schema_ = R"({"protocol":{"name":"Maps","sequence":[{"name":"stringToInt","type":{"map":{"keys":"string","values":"int32"}}},{"name":"stringToUnion","type":{"map":{"keys":"string","values":[{"label":"string","type":"string"},{"label":"int32","type":"int32"}]}}},{"name":"aliasedGeneric","type":{"name":"TestModel.AliasedMap","typeArguments":["string","int32"]}}]},"types":[{"name":"AliasedMap","typeParameters":["K","V"],"type":{"map":{"keys":"K","values":"V"}}}]})";

void MapsWriterBase::WriteStringToInt(std::unordered_map<std::string, int32_t> const& value) {
  if (unlikely(state_ != 0)) {
    MapsWriterBaseInvalidState(0, false, state_);
  }

  WriteStringToIntImpl(value);
  state_ = 1;
}

void MapsWriterBase::WriteStringToUnion(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) {
  if (unlikely(state_ != 1)) {
    MapsWriterBaseInvalidState(1, false, state_);
  }

  WriteStringToUnionImpl(value);
  state_ = 2;
}

void MapsWriterBase::WriteAliasedGeneric(test_model::AliasedMap<std::string, int32_t> const& value) {
  if (unlikely(state_ != 2)) {
    MapsWriterBaseInvalidState(2, false, state_);
  }

  WriteAliasedGenericImpl(value);
  state_ = 3;
}

void MapsWriterBase::Close() {
  if (unlikely(state_ != 3)) {
    MapsWriterBaseInvalidState(3, false, state_);
  }

  CloseImpl();
}

std::string MapsReaderBase::schema_ = MapsWriterBase::schema_;

void MapsReaderBase::ReadStringToInt(std::unordered_map<std::string, int32_t>& value) {
  if (unlikely(state_ != 0)) {
    MapsReaderBaseInvalidState(0, state_);
  }

  ReadStringToIntImpl(value);
  state_ = 2;
}

void MapsReaderBase::ReadStringToUnion(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value) {
  if (unlikely(state_ != 2)) {
    MapsReaderBaseInvalidState(2, state_);
  }

  ReadStringToUnionImpl(value);
  state_ = 4;
}

void MapsReaderBase::ReadAliasedGeneric(test_model::AliasedMap<std::string, int32_t>& value) {
  if (unlikely(state_ != 4)) {
    MapsReaderBaseInvalidState(4, state_);
  }

  ReadAliasedGenericImpl(value);
  state_ = 6;
}

void MapsReaderBase::Close() {
  if (unlikely(state_ != 6)) {
    MapsReaderBaseInvalidState(6, state_);
  }

  CloseImpl();
}
void MapsReaderBase::CopyTo(MapsWriterBase& writer) {
  {
    std::unordered_map<std::string, int32_t> value;
    ReadStringToInt(value);
    writer.WriteStringToInt(value);
  }
  {
    std::unordered_map<std::string, std::variant<std::string, int32_t>> value;
    ReadStringToUnion(value);
    writer.WriteStringToUnion(value);
  }
  {
    test_model::AliasedMap<std::string, int32_t> value;
    ReadAliasedGeneric(value);
    writer.WriteAliasedGeneric(value);
  }
}

namespace {
void UnionsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntOrSimpleRecord()"; break;
  case 1: expected_method = "WriteIntOrRecordWithVlens()"; break;
  case 2: expected_method = "WriteMonosotateOrIntOrSimpleRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteIntOrSimpleRecord()"; break;
  case 1: attempted_method = "WriteIntOrRecordWithVlens()"; break;
  case 2: attempted_method = "WriteMonosotateOrIntOrSimpleRecord()"; break;
  case 3: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void UnionsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntOrSimpleRecord()";
    case 1: return "ReadIntOrRecordWithVlens()";
    case 2: return "ReadMonosotateOrIntOrSimpleRecord()";
    case 3: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string UnionsWriterBase::schema_ = R"({"protocol":{"name":"Unions","sequence":[{"name":"intOrSimpleRecord","type":[{"label":"int32","type":"int32"},{"label":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"intOrRecordWithVlens","type":[{"label":"int32","type":"int32"},{"label":"RecordWithVlens","type":"TestModel.RecordWithVlens"}]},{"name":"monosotateOrIntOrSimpleRecord","type":[null,{"label":"int32","type":"int32"},{"label":"SimpleRecord","type":"TestModel.SimpleRecord"}]}]},"types":[{"name":"RecordWithVlens","fields":[{"name":"a","type":{"vector":{"items":"TestModel.SimpleRecord"}}},{"name":"b","type":"int32"},{"name":"c","type":"int32"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void UnionsWriterBase::WriteIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 0)) {
    UnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(value);
  state_ = 1;
}

void UnionsWriterBase::WriteIntOrRecordWithVlens(std::variant<int32_t, test_model::RecordWithVlens> const& value) {
  if (unlikely(state_ != 1)) {
    UnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteIntOrRecordWithVlensImpl(value);
  state_ = 2;
}

void UnionsWriterBase::WriteMonosotateOrIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 2)) {
    UnionsWriterBaseInvalidState(2, false, state_);
  }

  WriteMonosotateOrIntOrSimpleRecordImpl(value);
  state_ = 3;
}

void UnionsWriterBase::Close() {
  if (unlikely(state_ != 3)) {
    UnionsWriterBaseInvalidState(3, false, state_);
  }

  CloseImpl();
}

std::string UnionsReaderBase::schema_ = UnionsWriterBase::schema_;

void UnionsReaderBase::ReadIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 0)) {
    UnionsReaderBaseInvalidState(0, state_);
  }

  ReadIntOrSimpleRecordImpl(value);
  state_ = 2;
}

void UnionsReaderBase::ReadIntOrRecordWithVlens(std::variant<int32_t, test_model::RecordWithVlens>& value) {
  if (unlikely(state_ != 2)) {
    UnionsReaderBaseInvalidState(2, state_);
  }

  ReadIntOrRecordWithVlensImpl(value);
  state_ = 4;
}

void UnionsReaderBase::ReadMonosotateOrIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 4)) {
    UnionsReaderBaseInvalidState(4, state_);
  }

  ReadMonosotateOrIntOrSimpleRecordImpl(value);
  state_ = 6;
}

void UnionsReaderBase::Close() {
  if (unlikely(state_ != 6)) {
    UnionsReaderBaseInvalidState(6, state_);
  }

  CloseImpl();
}
void UnionsReaderBase::CopyTo(UnionsWriterBase& writer) {
  {
    std::variant<int32_t, test_model::SimpleRecord> value;
    ReadIntOrSimpleRecord(value);
    writer.WriteIntOrSimpleRecord(value);
  }
  {
    std::variant<int32_t, test_model::RecordWithVlens> value;
    ReadIntOrRecordWithVlens(value);
    writer.WriteIntOrRecordWithVlens(value);
  }
  {
    std::variant<std::monostate, int32_t, test_model::SimpleRecord> value;
    ReadMonosotateOrIntOrSimpleRecord(value);
    writer.WriteMonosotateOrIntOrSimpleRecord(value);
  }
}

namespace {
void StreamsOfUnionsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntOrSimpleRecord() or EndIntOrSimpleRecord()"; break;
  case 1: expected_method = "WriteNullableIntOrSimpleRecord() or EndNullableIntOrSimpleRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndIntOrSimpleRecord()" : "WriteIntOrSimpleRecord()"; break;
  case 1: attempted_method = end ? "EndNullableIntOrSimpleRecord()" : "WriteNullableIntOrSimpleRecord()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StreamsOfUnionsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntOrSimpleRecord()";
    case 1: return "ReadNullableIntOrSimpleRecord()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StreamsOfUnionsWriterBase::schema_ = R"({"protocol":{"name":"StreamsOfUnions","sequence":[{"name":"intOrSimpleRecord","type":{"stream":{"items":[{"label":"int32","type":"int32"},{"label":"SimpleRecord","type":"TestModel.SimpleRecord"}]}}},{"name":"nullableIntOrSimpleRecord","type":{"stream":{"items":[null,{"label":"int32","type":"int32"},{"label":"SimpleRecord","type":"TestModel.SimpleRecord"}]}}}]},"types":[{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void StreamsOfUnionsWriterBase::WriteIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 0)) {
    StreamsOfUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(value);
}

void StreamsOfUnionsWriterBase::WriteIntOrSimpleRecord(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) {
  if (unlikely(state_ != 0)) {
    StreamsOfUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(values);
}

void StreamsOfUnionsWriterBase::EndIntOrSimpleRecord() {
  if (unlikely(state_ != 0)) {
    StreamsOfUnionsWriterBaseInvalidState(0, true, state_);
  }

  EndIntOrSimpleRecordImpl();
  state_ = 1;
}

// fallback implementation
void StreamsOfUnionsWriterBase::WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) {
  for (auto const& v : values) {
    WriteIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfUnionsWriterBase::WriteNullableIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  if (unlikely(state_ != 1)) {
    StreamsOfUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(value);
}

void StreamsOfUnionsWriterBase::WriteNullableIntOrSimpleRecord(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) {
  if (unlikely(state_ != 1)) {
    StreamsOfUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(values);
}

void StreamsOfUnionsWriterBase::EndNullableIntOrSimpleRecord() {
  if (unlikely(state_ != 1)) {
    StreamsOfUnionsWriterBaseInvalidState(1, true, state_);
  }

  EndNullableIntOrSimpleRecordImpl();
  state_ = 2;
}

// fallback implementation
void StreamsOfUnionsWriterBase::WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) {
  for (auto const& v : values) {
    WriteNullableIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfUnionsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    StreamsOfUnionsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string StreamsOfUnionsReaderBase::schema_ = StreamsOfUnionsWriterBase::schema_;

bool StreamsOfUnionsReaderBase::ReadIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    StreamsOfUnionsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool StreamsOfUnionsReaderBase::ReadIntOrSimpleRecord(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    StreamsOfUnionsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntOrSimpleRecordImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool StreamsOfUnionsReaderBase::ReadIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsOfUnionsReaderBase::ReadNullableIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfUnionsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadNullableIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StreamsOfUnionsReaderBase::ReadNullableIntOrSimpleRecord(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfUnionsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadNullableIntOrSimpleRecordImpl(values)) {state_ = 3;
  }
  return true;
}

// fallback implementation
bool StreamsOfUnionsReaderBase::ReadNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadNullableIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StreamsOfUnionsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    StreamsOfUnionsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void StreamsOfUnionsReaderBase::CopyTo(StreamsOfUnionsWriterBase& writer, size_t int_or_simple_record_buffer_size, size_t nullable_int_or_simple_record_buffer_size) {
  if (int_or_simple_record_buffer_size > 1) {
    std::vector<std::variant<int32_t, test_model::SimpleRecord>> values;
    values.reserve(int_or_simple_record_buffer_size);
    while(ReadIntOrSimpleRecord(values)) {
      writer.WriteIntOrSimpleRecord(values);
    }
    writer.EndIntOrSimpleRecord();
  } else {
    std::variant<int32_t, test_model::SimpleRecord> value;
    while(ReadIntOrSimpleRecord(value)) {
      writer.WriteIntOrSimpleRecord(value);
    }
    writer.EndIntOrSimpleRecord();
  }
  if (nullable_int_or_simple_record_buffer_size > 1) {
    std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> values;
    values.reserve(nullable_int_or_simple_record_buffer_size);
    while(ReadNullableIntOrSimpleRecord(values)) {
      writer.WriteNullableIntOrSimpleRecord(values);
    }
    writer.EndNullableIntOrSimpleRecord();
  } else {
    std::variant<std::monostate, int32_t, test_model::SimpleRecord> value;
    while(ReadNullableIntOrSimpleRecord(value)) {
      writer.WriteNullableIntOrSimpleRecord(value);
    }
    writer.EndNullableIntOrSimpleRecord();
  }
}

namespace {
void EnumsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteSingle()"; break;
  case 1: expected_method = "WriteVec()"; break;
  case 2: expected_method = "WriteSize()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteSingle()"; break;
  case 1: attempted_method = "WriteVec()"; break;
  case 2: attempted_method = "WriteSize()"; break;
  case 3: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void EnumsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadSingle()";
    case 1: return "ReadVec()";
    case 2: return "ReadSize()";
    case 3: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string EnumsWriterBase::schema_ = R"({"protocol":{"name":"Enums","sequence":[{"name":"single","type":"TestModel.Fruits"},{"name":"vec","type":{"vector":{"items":"TestModel.Fruits"}}},{"name":"size","type":"TestModel.SizeBasedEnum"}]},"types":[{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"SizeBasedEnum","base":"size","values":[{"symbol":"a","value":0},{"symbol":"b","value":1},{"symbol":"c","value":2}]}]})";

void EnumsWriterBase::WriteSingle(test_model::Fruits const& value) {
  if (unlikely(state_ != 0)) {
    EnumsWriterBaseInvalidState(0, false, state_);
  }

  WriteSingleImpl(value);
  state_ = 1;
}

void EnumsWriterBase::WriteVec(std::vector<test_model::Fruits> const& value) {
  if (unlikely(state_ != 1)) {
    EnumsWriterBaseInvalidState(1, false, state_);
  }

  WriteVecImpl(value);
  state_ = 2;
}

void EnumsWriterBase::WriteSize(test_model::SizeBasedEnum const& value) {
  if (unlikely(state_ != 2)) {
    EnumsWriterBaseInvalidState(2, false, state_);
  }

  WriteSizeImpl(value);
  state_ = 3;
}

void EnumsWriterBase::Close() {
  if (unlikely(state_ != 3)) {
    EnumsWriterBaseInvalidState(3, false, state_);
  }

  CloseImpl();
}

std::string EnumsReaderBase::schema_ = EnumsWriterBase::schema_;

void EnumsReaderBase::ReadSingle(test_model::Fruits& value) {
  if (unlikely(state_ != 0)) {
    EnumsReaderBaseInvalidState(0, state_);
  }

  ReadSingleImpl(value);
  state_ = 2;
}

void EnumsReaderBase::ReadVec(std::vector<test_model::Fruits>& value) {
  if (unlikely(state_ != 2)) {
    EnumsReaderBaseInvalidState(2, state_);
  }

  ReadVecImpl(value);
  state_ = 4;
}

void EnumsReaderBase::ReadSize(test_model::SizeBasedEnum& value) {
  if (unlikely(state_ != 4)) {
    EnumsReaderBaseInvalidState(4, state_);
  }

  ReadSizeImpl(value);
  state_ = 6;
}

void EnumsReaderBase::Close() {
  if (unlikely(state_ != 6)) {
    EnumsReaderBaseInvalidState(6, state_);
  }

  CloseImpl();
}
void EnumsReaderBase::CopyTo(EnumsWriterBase& writer) {
  {
    test_model::Fruits value;
    ReadSingle(value);
    writer.WriteSingle(value);
  }
  {
    std::vector<test_model::Fruits> value;
    ReadVec(value);
    writer.WriteVec(value);
  }
  {
    test_model::SizeBasedEnum value;
    ReadSize(value);
    writer.WriteSize(value);
  }
}

namespace {
void StateTestWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteAnInt()"; break;
  case 1: expected_method = "WriteAStream() or EndAStream()"; break;
  case 2: expected_method = "WriteAnotherInt()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteAnInt()"; break;
  case 1: attempted_method = end ? "EndAStream()" : "WriteAStream()"; break;
  case 2: attempted_method = "WriteAnotherInt()"; break;
  case 3: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StateTestReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadAnInt()";
    case 1: return "ReadAStream()";
    case 2: return "ReadAnotherInt()";
    case 3: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StateTestWriterBase::schema_ = R"({"protocol":{"name":"StateTest","sequence":[{"name":"anInt","type":"int32"},{"name":"aStream","type":{"stream":{"items":"int32"}}},{"name":"anotherInt","type":"int32"}]},"types":null})";

void StateTestWriterBase::WriteAnInt(int32_t const& value) {
  if (unlikely(state_ != 0)) {
    StateTestWriterBaseInvalidState(0, false, state_);
  }

  WriteAnIntImpl(value);
  state_ = 1;
}

void StateTestWriterBase::WriteAStream(int32_t const& value) {
  if (unlikely(state_ != 1)) {
    StateTestWriterBaseInvalidState(1, false, state_);
  }

  WriteAStreamImpl(value);
}

void StateTestWriterBase::WriteAStream(std::vector<int32_t> const& values) {
  if (unlikely(state_ != 1)) {
    StateTestWriterBaseInvalidState(1, false, state_);
  }

  WriteAStreamImpl(values);
}

void StateTestWriterBase::EndAStream() {
  if (unlikely(state_ != 1)) {
    StateTestWriterBaseInvalidState(1, true, state_);
  }

  EndAStreamImpl();
  state_ = 2;
}

// fallback implementation
void StateTestWriterBase::WriteAStreamImpl(std::vector<int32_t> const& values) {
  for (auto const& v : values) {
    WriteAStreamImpl(v);
  }
}

void StateTestWriterBase::WriteAnotherInt(int32_t const& value) {
  if (unlikely(state_ != 2)) {
    StateTestWriterBaseInvalidState(2, false, state_);
  }

  WriteAnotherIntImpl(value);
  state_ = 3;
}

void StateTestWriterBase::Close() {
  if (unlikely(state_ != 3)) {
    StateTestWriterBaseInvalidState(3, false, state_);
  }

  CloseImpl();
}

std::string StateTestReaderBase::schema_ = StateTestWriterBase::schema_;

void StateTestReaderBase::ReadAnInt(int32_t& value) {
  if (unlikely(state_ != 0)) {
    StateTestReaderBaseInvalidState(0, state_);
  }

  ReadAnIntImpl(value);
  state_ = 2;
}

bool StateTestReaderBase::ReadAStream(int32_t& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    StateTestReaderBaseInvalidState(2, state_);
  }

  bool result = ReadAStreamImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StateTestReaderBase::ReadAStream(std::vector<int32_t>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    StateTestReaderBaseInvalidState(2, state_);
  }

  if (!ReadAStreamImpl(values)) {state_ = 3;
  }
  return true;
}

// fallback implementation
bool StateTestReaderBase::ReadAStreamImpl(std::vector<int32_t>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadAStreamImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StateTestReaderBase::ReadAnotherInt(int32_t& value) {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      StateTestReaderBaseInvalidState(4, state_);
    }
  }

  ReadAnotherIntImpl(value);
  state_ = 6;
}

void StateTestReaderBase::Close() {
  if (unlikely(state_ != 6)) {
    StateTestReaderBaseInvalidState(6, state_);
  }

  CloseImpl();
}
void StateTestReaderBase::CopyTo(StateTestWriterBase& writer, size_t a_stream_buffer_size) {
  {
    int32_t value;
    ReadAnInt(value);
    writer.WriteAnInt(value);
  }
  if (a_stream_buffer_size > 1) {
    std::vector<int32_t> values;
    values.reserve(a_stream_buffer_size);
    while(ReadAStream(values)) {
      writer.WriteAStream(values);
    }
    writer.EndAStream();
  } else {
    int32_t value;
    while(ReadAStream(value)) {
      writer.WriteAStream(value);
    }
    writer.EndAStream();
  }
  {
    int32_t value;
    ReadAnotherInt(value);
    writer.WriteAnotherInt(value);
  }
}

namespace {
void SimpleGenericsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteFloatImage()"; break;
  case 1: expected_method = "WriteIntImage()"; break;
  case 2: expected_method = "WriteIntImageAlternateSyntax()"; break;
  case 3: expected_method = "WriteStringImage()"; break;
  case 4: expected_method = "WriteIntFloatTuple()"; break;
  case 5: expected_method = "WriteFloatFloatTuple()"; break;
  case 6: expected_method = "WriteIntFloatTupleAlternateSyntax()"; break;
  case 7: expected_method = "WriteIntStringTuple()"; break;
  case 8: expected_method = "WriteStreamOfTypeVariants() or EndStreamOfTypeVariants()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteFloatImage()"; break;
  case 1: attempted_method = "WriteIntImage()"; break;
  case 2: attempted_method = "WriteIntImageAlternateSyntax()"; break;
  case 3: attempted_method = "WriteStringImage()"; break;
  case 4: attempted_method = "WriteIntFloatTuple()"; break;
  case 5: attempted_method = "WriteFloatFloatTuple()"; break;
  case 6: attempted_method = "WriteIntFloatTupleAlternateSyntax()"; break;
  case 7: attempted_method = "WriteIntStringTuple()"; break;
  case 8: attempted_method = end ? "EndStreamOfTypeVariants()" : "WriteStreamOfTypeVariants()"; break;
  case 9: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void SimpleGenericsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadFloatImage()";
    case 1: return "ReadIntImage()";
    case 2: return "ReadIntImageAlternateSyntax()";
    case 3: return "ReadStringImage()";
    case 4: return "ReadIntFloatTuple()";
    case 5: return "ReadFloatFloatTuple()";
    case 6: return "ReadIntFloatTupleAlternateSyntax()";
    case 7: return "ReadIntStringTuple()";
    case 8: return "ReadStreamOfTypeVariants()";
    case 9: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string SimpleGenericsWriterBase::schema_ = R"({"protocol":{"name":"SimpleGenerics","sequence":[{"name":"floatImage","type":{"name":"TestModel.Image","typeArguments":["float32"]}},{"name":"intImage","type":{"name":"TestModel.Image","typeArguments":["int32"]}},{"name":"intImageAlternateSyntax","type":{"name":"TestModel.Image","typeArguments":["int32"]}},{"name":"stringImage","type":{"name":"TestModel.Image","typeArguments":["string"]}},{"name":"intFloatTuple","type":{"name":"TestModel.MyTuple","typeArguments":["int32","float32"]}},{"name":"floatFloatTuple","type":{"name":"TestModel.MyTuple","typeArguments":["float32","float32"]}},{"name":"intFloatTupleAlternateSyntax","type":{"name":"TestModel.MyTuple","typeArguments":["int32","float32"]}},{"name":"intStringTuple","type":{"name":"TestModel.MyTuple","typeArguments":["int32","string"]}},{"name":"streamOfTypeVariants","type":{"stream":{"items":[{"label":"Image\u003cfloat32\u003e","type":{"name":"TestModel.Image","typeArguments":["float32"]}},{"label":"Image\u003cfloat64\u003e","type":{"name":"TestModel.Image","typeArguments":["float64"]}}]}}}]},"types":[{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

void SimpleGenericsWriterBase::WriteFloatImage(test_model::Image<float> const& value) {
  if (unlikely(state_ != 0)) {
    SimpleGenericsWriterBaseInvalidState(0, false, state_);
  }

  WriteFloatImageImpl(value);
  state_ = 1;
}

void SimpleGenericsWriterBase::WriteIntImage(test_model::Image<int32_t> const& value) {
  if (unlikely(state_ != 1)) {
    SimpleGenericsWriterBaseInvalidState(1, false, state_);
  }

  WriteIntImageImpl(value);
  state_ = 2;
}

void SimpleGenericsWriterBase::WriteIntImageAlternateSyntax(test_model::Image<int32_t> const& value) {
  if (unlikely(state_ != 2)) {
    SimpleGenericsWriterBaseInvalidState(2, false, state_);
  }

  WriteIntImageAlternateSyntaxImpl(value);
  state_ = 3;
}

void SimpleGenericsWriterBase::WriteStringImage(test_model::Image<std::string> const& value) {
  if (unlikely(state_ != 3)) {
    SimpleGenericsWriterBaseInvalidState(3, false, state_);
  }

  WriteStringImageImpl(value);
  state_ = 4;
}

void SimpleGenericsWriterBase::WriteIntFloatTuple(test_model::MyTuple<int32_t, float> const& value) {
  if (unlikely(state_ != 4)) {
    SimpleGenericsWriterBaseInvalidState(4, false, state_);
  }

  WriteIntFloatTupleImpl(value);
  state_ = 5;
}

void SimpleGenericsWriterBase::WriteFloatFloatTuple(test_model::MyTuple<float, float> const& value) {
  if (unlikely(state_ != 5)) {
    SimpleGenericsWriterBaseInvalidState(5, false, state_);
  }

  WriteFloatFloatTupleImpl(value);
  state_ = 6;
}

void SimpleGenericsWriterBase::WriteIntFloatTupleAlternateSyntax(test_model::MyTuple<int32_t, float> const& value) {
  if (unlikely(state_ != 6)) {
    SimpleGenericsWriterBaseInvalidState(6, false, state_);
  }

  WriteIntFloatTupleAlternateSyntaxImpl(value);
  state_ = 7;
}

void SimpleGenericsWriterBase::WriteIntStringTuple(test_model::MyTuple<int32_t, std::string> const& value) {
  if (unlikely(state_ != 7)) {
    SimpleGenericsWriterBaseInvalidState(7, false, state_);
  }

  WriteIntStringTupleImpl(value);
  state_ = 8;
}

void SimpleGenericsWriterBase::WriteStreamOfTypeVariants(std::variant<test_model::Image<float>, test_model::Image<double>> const& value) {
  if (unlikely(state_ != 8)) {
    SimpleGenericsWriterBaseInvalidState(8, false, state_);
  }

  WriteStreamOfTypeVariantsImpl(value);
}

void SimpleGenericsWriterBase::WriteStreamOfTypeVariants(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>> const& values) {
  if (unlikely(state_ != 8)) {
    SimpleGenericsWriterBaseInvalidState(8, false, state_);
  }

  WriteStreamOfTypeVariantsImpl(values);
}

void SimpleGenericsWriterBase::EndStreamOfTypeVariants() {
  if (unlikely(state_ != 8)) {
    SimpleGenericsWriterBaseInvalidState(8, true, state_);
  }

  EndStreamOfTypeVariantsImpl();
  state_ = 9;
}

// fallback implementation
void SimpleGenericsWriterBase::WriteStreamOfTypeVariantsImpl(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>> const& values) {
  for (auto const& v : values) {
    WriteStreamOfTypeVariantsImpl(v);
  }
}

void SimpleGenericsWriterBase::Close() {
  if (unlikely(state_ != 9)) {
    SimpleGenericsWriterBaseInvalidState(9, false, state_);
  }

  CloseImpl();
}

std::string SimpleGenericsReaderBase::schema_ = SimpleGenericsWriterBase::schema_;

void SimpleGenericsReaderBase::ReadFloatImage(test_model::Image<float>& value) {
  if (unlikely(state_ != 0)) {
    SimpleGenericsReaderBaseInvalidState(0, state_);
  }

  ReadFloatImageImpl(value);
  state_ = 2;
}

void SimpleGenericsReaderBase::ReadIntImage(test_model::Image<int32_t>& value) {
  if (unlikely(state_ != 2)) {
    SimpleGenericsReaderBaseInvalidState(2, state_);
  }

  ReadIntImageImpl(value);
  state_ = 4;
}

void SimpleGenericsReaderBase::ReadIntImageAlternateSyntax(test_model::Image<int32_t>& value) {
  if (unlikely(state_ != 4)) {
    SimpleGenericsReaderBaseInvalidState(4, state_);
  }

  ReadIntImageAlternateSyntaxImpl(value);
  state_ = 6;
}

void SimpleGenericsReaderBase::ReadStringImage(test_model::Image<std::string>& value) {
  if (unlikely(state_ != 6)) {
    SimpleGenericsReaderBaseInvalidState(6, state_);
  }

  ReadStringImageImpl(value);
  state_ = 8;
}

void SimpleGenericsReaderBase::ReadIntFloatTuple(test_model::MyTuple<int32_t, float>& value) {
  if (unlikely(state_ != 8)) {
    SimpleGenericsReaderBaseInvalidState(8, state_);
  }

  ReadIntFloatTupleImpl(value);
  state_ = 10;
}

void SimpleGenericsReaderBase::ReadFloatFloatTuple(test_model::MyTuple<float, float>& value) {
  if (unlikely(state_ != 10)) {
    SimpleGenericsReaderBaseInvalidState(10, state_);
  }

  ReadFloatFloatTupleImpl(value);
  state_ = 12;
}

void SimpleGenericsReaderBase::ReadIntFloatTupleAlternateSyntax(test_model::MyTuple<int32_t, float>& value) {
  if (unlikely(state_ != 12)) {
    SimpleGenericsReaderBaseInvalidState(12, state_);
  }

  ReadIntFloatTupleAlternateSyntaxImpl(value);
  state_ = 14;
}

void SimpleGenericsReaderBase::ReadIntStringTuple(test_model::MyTuple<int32_t, std::string>& value) {
  if (unlikely(state_ != 14)) {
    SimpleGenericsReaderBaseInvalidState(14, state_);
  }

  ReadIntStringTupleImpl(value);
  state_ = 16;
}

bool SimpleGenericsReaderBase::ReadStreamOfTypeVariants(std::variant<test_model::Image<float>, test_model::Image<double>>& value) {
  if (unlikely(state_ != 16)) {
    if (state_ == 17) {
      state_ = 18;
      return false;
    }
    SimpleGenericsReaderBaseInvalidState(16, state_);
  }

  bool result = ReadStreamOfTypeVariantsImpl(value);
  if (!result) {
    state_ = 18;
  }
  return result;
}

bool SimpleGenericsReaderBase::ReadStreamOfTypeVariants(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 16)) {
    if (state_ == 17) {
      state_ = 18;
      values.clear();
      return false;
    }
    SimpleGenericsReaderBaseInvalidState(16, state_);
  }

  if (!ReadStreamOfTypeVariantsImpl(values)) {state_ = 17;
  }
  return true;
}

// fallback implementation
bool SimpleGenericsReaderBase::ReadStreamOfTypeVariantsImpl(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadStreamOfTypeVariantsImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void SimpleGenericsReaderBase::Close() {
  if (unlikely(state_ != 18)) {
    SimpleGenericsReaderBaseInvalidState(18, state_);
  }

  CloseImpl();
}
void SimpleGenericsReaderBase::CopyTo(SimpleGenericsWriterBase& writer, size_t stream_of_type_variants_buffer_size) {
  {
    test_model::Image<float> value;
    ReadFloatImage(value);
    writer.WriteFloatImage(value);
  }
  {
    test_model::Image<int32_t> value;
    ReadIntImage(value);
    writer.WriteIntImage(value);
  }
  {
    test_model::Image<int32_t> value;
    ReadIntImageAlternateSyntax(value);
    writer.WriteIntImageAlternateSyntax(value);
  }
  {
    test_model::Image<std::string> value;
    ReadStringImage(value);
    writer.WriteStringImage(value);
  }
  {
    test_model::MyTuple<int32_t, float> value;
    ReadIntFloatTuple(value);
    writer.WriteIntFloatTuple(value);
  }
  {
    test_model::MyTuple<float, float> value;
    ReadFloatFloatTuple(value);
    writer.WriteFloatFloatTuple(value);
  }
  {
    test_model::MyTuple<int32_t, float> value;
    ReadIntFloatTupleAlternateSyntax(value);
    writer.WriteIntFloatTupleAlternateSyntax(value);
  }
  {
    test_model::MyTuple<int32_t, std::string> value;
    ReadIntStringTuple(value);
    writer.WriteIntStringTuple(value);
  }
  if (stream_of_type_variants_buffer_size > 1) {
    std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>> values;
    values.reserve(stream_of_type_variants_buffer_size);
    while(ReadStreamOfTypeVariants(values)) {
      writer.WriteStreamOfTypeVariants(values);
    }
    writer.EndStreamOfTypeVariants();
  } else {
    std::variant<test_model::Image<float>, test_model::Image<double>> value;
    while(ReadStreamOfTypeVariants(value)) {
      writer.WriteStreamOfTypeVariants(value);
    }
    writer.EndStreamOfTypeVariants();
  }
}

namespace {
void AdvancedGenericsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntImageImage()"; break;
  case 1: expected_method = "WriteGenericRecord1()"; break;
  case 2: expected_method = "WriteTupleOfOptionals()"; break;
  case 3: expected_method = "WriteTupleOfOptionalsAlternateSyntax()"; break;
  case 4: expected_method = "WriteTupleOfVectors()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteIntImageImage()"; break;
  case 1: attempted_method = "WriteGenericRecord1()"; break;
  case 2: attempted_method = "WriteTupleOfOptionals()"; break;
  case 3: attempted_method = "WriteTupleOfOptionalsAlternateSyntax()"; break;
  case 4: attempted_method = "WriteTupleOfVectors()"; break;
  case 5: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void AdvancedGenericsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntImageImage()";
    case 1: return "ReadGenericRecord1()";
    case 2: return "ReadTupleOfOptionals()";
    case 3: return "ReadTupleOfOptionalsAlternateSyntax()";
    case 4: return "ReadTupleOfVectors()";
    case 5: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string AdvancedGenericsWriterBase::schema_ = R"({"protocol":{"name":"AdvancedGenerics","sequence":[{"name":"intImageImage","type":{"name":"TestModel.Image","typeArguments":[{"name":"TestModel.Image","typeArguments":["float32"]}]}},{"name":"genericRecord1","type":{"name":"TestModel.GenericRecord","typeArguments":["int32","string"]}},{"name":"tupleOfOptionals","type":{"name":"TestModel.MyTuple","typeArguments":[[null,"int32"],[null,"string"]]}},{"name":"tupleOfOptionalsAlternateSyntax","type":{"name":"TestModel.MyTuple","typeArguments":[[null,"int32"],[null,"string"]]}},{"name":"tupleOfVectors","type":{"name":"TestModel.MyTuple","typeArguments":[{"vector":{"items":"int32"}},{"vector":{"items":"float32"}}]}}]},"types":[{"name":"GenericRecord","typeParameters":["T1","T2"],"fields":[{"name":"scalar1","type":"T1"},{"name":"scalar2","type":"T2"},{"name":"vector1","type":{"vector":{"items":"T1"}}},{"name":"image2","type":{"name":"TestModel.Image","typeArguments":["T2"]}}]},{"name":"Image","typeParameters":["T"],"type":{"array":{"items":"T","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

void AdvancedGenericsWriterBase::WriteIntImageImage(test_model::Image<test_model::Image<float>> const& value) {
  if (unlikely(state_ != 0)) {
    AdvancedGenericsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntImageImageImpl(value);
  state_ = 1;
}

void AdvancedGenericsWriterBase::WriteGenericRecord1(test_model::GenericRecord<int32_t, std::string> const& value) {
  if (unlikely(state_ != 1)) {
    AdvancedGenericsWriterBaseInvalidState(1, false, state_);
  }

  WriteGenericRecord1Impl(value);
  state_ = 2;
}

void AdvancedGenericsWriterBase::WriteTupleOfOptionals(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  if (unlikely(state_ != 2)) {
    AdvancedGenericsWriterBaseInvalidState(2, false, state_);
  }

  WriteTupleOfOptionalsImpl(value);
  state_ = 3;
}

void AdvancedGenericsWriterBase::WriteTupleOfOptionalsAlternateSyntax(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  if (unlikely(state_ != 3)) {
    AdvancedGenericsWriterBaseInvalidState(3, false, state_);
  }

  WriteTupleOfOptionalsAlternateSyntaxImpl(value);
  state_ = 4;
}

void AdvancedGenericsWriterBase::WriteTupleOfVectors(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) {
  if (unlikely(state_ != 4)) {
    AdvancedGenericsWriterBaseInvalidState(4, false, state_);
  }

  WriteTupleOfVectorsImpl(value);
  state_ = 5;
}

void AdvancedGenericsWriterBase::Close() {
  if (unlikely(state_ != 5)) {
    AdvancedGenericsWriterBaseInvalidState(5, false, state_);
  }

  CloseImpl();
}

std::string AdvancedGenericsReaderBase::schema_ = AdvancedGenericsWriterBase::schema_;

void AdvancedGenericsReaderBase::ReadIntImageImage(test_model::Image<test_model::Image<float>>& value) {
  if (unlikely(state_ != 0)) {
    AdvancedGenericsReaderBaseInvalidState(0, state_);
  }

  ReadIntImageImageImpl(value);
  state_ = 2;
}

void AdvancedGenericsReaderBase::ReadGenericRecord1(test_model::GenericRecord<int32_t, std::string>& value) {
  if (unlikely(state_ != 2)) {
    AdvancedGenericsReaderBaseInvalidState(2, state_);
  }

  ReadGenericRecord1Impl(value);
  state_ = 4;
}

void AdvancedGenericsReaderBase::ReadTupleOfOptionals(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  if (unlikely(state_ != 4)) {
    AdvancedGenericsReaderBaseInvalidState(4, state_);
  }

  ReadTupleOfOptionalsImpl(value);
  state_ = 6;
}

void AdvancedGenericsReaderBase::ReadTupleOfOptionalsAlternateSyntax(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  if (unlikely(state_ != 6)) {
    AdvancedGenericsReaderBaseInvalidState(6, state_);
  }

  ReadTupleOfOptionalsAlternateSyntaxImpl(value);
  state_ = 8;
}

void AdvancedGenericsReaderBase::ReadTupleOfVectors(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value) {
  if (unlikely(state_ != 8)) {
    AdvancedGenericsReaderBaseInvalidState(8, state_);
  }

  ReadTupleOfVectorsImpl(value);
  state_ = 10;
}

void AdvancedGenericsReaderBase::Close() {
  if (unlikely(state_ != 10)) {
    AdvancedGenericsReaderBaseInvalidState(10, state_);
  }

  CloseImpl();
}
void AdvancedGenericsReaderBase::CopyTo(AdvancedGenericsWriterBase& writer) {
  {
    test_model::Image<test_model::Image<float>> value;
    ReadIntImageImage(value);
    writer.WriteIntImageImage(value);
  }
  {
    test_model::GenericRecord<int32_t, std::string> value;
    ReadGenericRecord1(value);
    writer.WriteGenericRecord1(value);
  }
  {
    test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> value;
    ReadTupleOfOptionals(value);
    writer.WriteTupleOfOptionals(value);
  }
  {
    test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> value;
    ReadTupleOfOptionalsAlternateSyntax(value);
    writer.WriteTupleOfOptionalsAlternateSyntax(value);
  }
  {
    test_model::MyTuple<std::vector<int32_t>, std::vector<float>> value;
    ReadTupleOfVectors(value);
    writer.WriteTupleOfVectors(value);
  }
}

namespace {
void AliasesWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteAliasedString()"; break;
  case 1: expected_method = "WriteAliasedEnum()"; break;
  case 2: expected_method = "WriteAliasedOpenGeneric()"; break;
  case 3: expected_method = "WriteAliasedClosedGeneric()"; break;
  case 4: expected_method = "WriteAliasedOptional()"; break;
  case 5: expected_method = "WriteAliasedGenericOptional()"; break;
  case 6: expected_method = "WriteAliasedGenericUnion2()"; break;
  case 7: expected_method = "WriteAliasedGenericVector()"; break;
  case 8: expected_method = "WriteAliasedGenericFixedVector()"; break;
  case 9: expected_method = "WriteStreamOfAliasedGenericUnion2() or EndStreamOfAliasedGenericUnion2()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteAliasedString()"; break;
  case 1: attempted_method = "WriteAliasedEnum()"; break;
  case 2: attempted_method = "WriteAliasedOpenGeneric()"; break;
  case 3: attempted_method = "WriteAliasedClosedGeneric()"; break;
  case 4: attempted_method = "WriteAliasedOptional()"; break;
  case 5: attempted_method = "WriteAliasedGenericOptional()"; break;
  case 6: attempted_method = "WriteAliasedGenericUnion2()"; break;
  case 7: attempted_method = "WriteAliasedGenericVector()"; break;
  case 8: attempted_method = "WriteAliasedGenericFixedVector()"; break;
  case 9: attempted_method = end ? "EndStreamOfAliasedGenericUnion2()" : "WriteStreamOfAliasedGenericUnion2()"; break;
  case 10: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void AliasesReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadAliasedString()";
    case 1: return "ReadAliasedEnum()";
    case 2: return "ReadAliasedOpenGeneric()";
    case 3: return "ReadAliasedClosedGeneric()";
    case 4: return "ReadAliasedOptional()";
    case 5: return "ReadAliasedGenericOptional()";
    case 6: return "ReadAliasedGenericUnion2()";
    case 7: return "ReadAliasedGenericVector()";
    case 8: return "ReadAliasedGenericFixedVector()";
    case 9: return "ReadStreamOfAliasedGenericUnion2()";
    case 10: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string AliasesWriterBase::schema_ = R"({"protocol":{"name":"Aliases","sequence":[{"name":"aliasedString","type":"TestModel.AliasedString"},{"name":"aliasedEnum","type":"TestModel.AliasedEnum"},{"name":"aliasedOpenGeneric","type":{"name":"TestModel.AliasedOpenGeneric","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"aliasedClosedGeneric","type":"TestModel.AliasedClosedGeneric"},{"name":"aliasedOptional","type":"TestModel.AliasedOptional"},{"name":"aliasedGenericOptional","type":{"name":"TestModel.AliasedGenericOptional","typeArguments":["float32"]}},{"name":"aliasedGenericUnion2","type":{"name":"TestModel.AliasedGenericUnion2","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"aliasedGenericVector","type":{"name":"TestModel.AliasedGenericVector","typeArguments":["float32"]}},{"name":"aliasedGenericFixedVector","type":{"name":"TestModel.AliasedGenericFixedVector","typeArguments":["float32"]}},{"name":"streamOfAliasedGenericUnion2","type":{"stream":{"items":{"name":"TestModel.AliasedGenericUnion2","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}}}}]},"types":[{"name":"AliasedClosedGeneric","type":{"name":"TestModel.MyTuple","typeArguments":["TestModel.AliasedString","TestModel.AliasedEnum"]}},{"name":"AliasedEnum","type":"TestModel.Fruits"},{"name":"AliasedGenericFixedVector","typeParameters":["T"],"type":{"vector":{"items":"T","length":3}}},{"name":"AliasedGenericOptional","typeParameters":["T"],"type":[null,"T"]},{"name":"AliasedGenericUnion2","typeParameters":["T1","T2"],"type":[{"label":"T1","type":"T1"},{"label":"T2","type":"T2"}]},{"name":"AliasedGenericVector","typeParameters":["T"],"type":{"vector":{"items":"T"}}},{"name":"AliasedOpenGeneric","typeParameters":["T1","T2"],"type":{"name":"TestModel.MyTuple","typeArguments":["T1","T2"]}},{"name":"AliasedOptional","type":[null,"int32"]},{"name":"AliasedString","type":"string"},{"name":"Fruits","values":[{"symbol":"apple","value":0},{"symbol":"banana","value":1},{"symbol":"pear","value":2}]},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]}]})";

void AliasesWriterBase::WriteAliasedString(test_model::AliasedString const& value) {
  if (unlikely(state_ != 0)) {
    AliasesWriterBaseInvalidState(0, false, state_);
  }

  WriteAliasedStringImpl(value);
  state_ = 1;
}

void AliasesWriterBase::WriteAliasedEnum(test_model::AliasedEnum const& value) {
  if (unlikely(state_ != 1)) {
    AliasesWriterBaseInvalidState(1, false, state_);
  }

  WriteAliasedEnumImpl(value);
  state_ = 2;
}

void AliasesWriterBase::WriteAliasedOpenGeneric(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  if (unlikely(state_ != 2)) {
    AliasesWriterBaseInvalidState(2, false, state_);
  }

  WriteAliasedOpenGenericImpl(value);
  state_ = 3;
}

void AliasesWriterBase::WriteAliasedClosedGeneric(test_model::AliasedClosedGeneric const& value) {
  if (unlikely(state_ != 3)) {
    AliasesWriterBaseInvalidState(3, false, state_);
  }

  WriteAliasedClosedGenericImpl(value);
  state_ = 4;
}

void AliasesWriterBase::WriteAliasedOptional(test_model::AliasedOptional const& value) {
  if (unlikely(state_ != 4)) {
    AliasesWriterBaseInvalidState(4, false, state_);
  }

  WriteAliasedOptionalImpl(value);
  state_ = 5;
}

void AliasesWriterBase::WriteAliasedGenericOptional(test_model::AliasedGenericOptional<float> const& value) {
  if (unlikely(state_ != 5)) {
    AliasesWriterBaseInvalidState(5, false, state_);
  }

  WriteAliasedGenericOptionalImpl(value);
  state_ = 6;
}

void AliasesWriterBase::WriteAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  if (unlikely(state_ != 6)) {
    AliasesWriterBaseInvalidState(6, false, state_);
  }

  WriteAliasedGenericUnion2Impl(value);
  state_ = 7;
}

void AliasesWriterBase::WriteAliasedGenericVector(test_model::AliasedGenericVector<float> const& value) {
  if (unlikely(state_ != 7)) {
    AliasesWriterBaseInvalidState(7, false, state_);
  }

  WriteAliasedGenericVectorImpl(value);
  state_ = 8;
}

void AliasesWriterBase::WriteAliasedGenericFixedVector(test_model::AliasedGenericFixedVector<float> const& value) {
  if (unlikely(state_ != 8)) {
    AliasesWriterBaseInvalidState(8, false, state_);
  }

  WriteAliasedGenericFixedVectorImpl(value);
  state_ = 9;
}

void AliasesWriterBase::WriteStreamOfAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  if (unlikely(state_ != 9)) {
    AliasesWriterBaseInvalidState(9, false, state_);
  }

  WriteStreamOfAliasedGenericUnion2Impl(value);
}

void AliasesWriterBase::WriteStreamOfAliasedGenericUnion2(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) {
  if (unlikely(state_ != 9)) {
    AliasesWriterBaseInvalidState(9, false, state_);
  }

  WriteStreamOfAliasedGenericUnion2Impl(values);
}

void AliasesWriterBase::EndStreamOfAliasedGenericUnion2() {
  if (unlikely(state_ != 9)) {
    AliasesWriterBaseInvalidState(9, true, state_);
  }

  EndStreamOfAliasedGenericUnion2Impl();
  state_ = 10;
}

// fallback implementation
void AliasesWriterBase::WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) {
  for (auto const& v : values) {
    WriteStreamOfAliasedGenericUnion2Impl(v);
  }
}

void AliasesWriterBase::Close() {
  if (unlikely(state_ != 10)) {
    AliasesWriterBaseInvalidState(10, false, state_);
  }

  CloseImpl();
}

std::string AliasesReaderBase::schema_ = AliasesWriterBase::schema_;

void AliasesReaderBase::ReadAliasedString(test_model::AliasedString& value) {
  if (unlikely(state_ != 0)) {
    AliasesReaderBaseInvalidState(0, state_);
  }

  ReadAliasedStringImpl(value);
  state_ = 2;
}

void AliasesReaderBase::ReadAliasedEnum(test_model::AliasedEnum& value) {
  if (unlikely(state_ != 2)) {
    AliasesReaderBaseInvalidState(2, state_);
  }

  ReadAliasedEnumImpl(value);
  state_ = 4;
}

void AliasesReaderBase::ReadAliasedOpenGeneric(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value) {
  if (unlikely(state_ != 4)) {
    AliasesReaderBaseInvalidState(4, state_);
  }

  ReadAliasedOpenGenericImpl(value);
  state_ = 6;
}

void AliasesReaderBase::ReadAliasedClosedGeneric(test_model::AliasedClosedGeneric& value) {
  if (unlikely(state_ != 6)) {
    AliasesReaderBaseInvalidState(6, state_);
  }

  ReadAliasedClosedGenericImpl(value);
  state_ = 8;
}

void AliasesReaderBase::ReadAliasedOptional(test_model::AliasedOptional& value) {
  if (unlikely(state_ != 8)) {
    AliasesReaderBaseInvalidState(8, state_);
  }

  ReadAliasedOptionalImpl(value);
  state_ = 10;
}

void AliasesReaderBase::ReadAliasedGenericOptional(test_model::AliasedGenericOptional<float>& value) {
  if (unlikely(state_ != 10)) {
    AliasesReaderBaseInvalidState(10, state_);
  }

  ReadAliasedGenericOptionalImpl(value);
  state_ = 12;
}

void AliasesReaderBase::ReadAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  if (unlikely(state_ != 12)) {
    AliasesReaderBaseInvalidState(12, state_);
  }

  ReadAliasedGenericUnion2Impl(value);
  state_ = 14;
}

void AliasesReaderBase::ReadAliasedGenericVector(test_model::AliasedGenericVector<float>& value) {
  if (unlikely(state_ != 14)) {
    AliasesReaderBaseInvalidState(14, state_);
  }

  ReadAliasedGenericVectorImpl(value);
  state_ = 16;
}

void AliasesReaderBase::ReadAliasedGenericFixedVector(test_model::AliasedGenericFixedVector<float>& value) {
  if (unlikely(state_ != 16)) {
    AliasesReaderBaseInvalidState(16, state_);
  }

  ReadAliasedGenericFixedVectorImpl(value);
  state_ = 18;
}

bool AliasesReaderBase::ReadStreamOfAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  if (unlikely(state_ != 18)) {
    if (state_ == 19) {
      state_ = 20;
      return false;
    }
    AliasesReaderBaseInvalidState(18, state_);
  }

  bool result = ReadStreamOfAliasedGenericUnion2Impl(value);
  if (!result) {
    state_ = 20;
  }
  return result;
}

bool AliasesReaderBase::ReadStreamOfAliasedGenericUnion2(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 18)) {
    if (state_ == 19) {
      state_ = 20;
      values.clear();
      return false;
    }
    AliasesReaderBaseInvalidState(18, state_);
  }

  if (!ReadStreamOfAliasedGenericUnion2Impl(values)) {state_ = 19;
  }
  return true;
}

// fallback implementation
bool AliasesReaderBase::ReadStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadStreamOfAliasedGenericUnion2Impl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void AliasesReaderBase::Close() {
  if (unlikely(state_ != 20)) {
    AliasesReaderBaseInvalidState(20, state_);
  }

  CloseImpl();
}
void AliasesReaderBase::CopyTo(AliasesWriterBase& writer, size_t stream_of_aliased_generic_union2_buffer_size) {
  {
    test_model::AliasedString value;
    ReadAliasedString(value);
    writer.WriteAliasedString(value);
  }
  {
    test_model::AliasedEnum value;
    ReadAliasedEnum(value);
    writer.WriteAliasedEnum(value);
  }
  {
    test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> value;
    ReadAliasedOpenGeneric(value);
    writer.WriteAliasedOpenGeneric(value);
  }
  {
    test_model::AliasedClosedGeneric value;
    ReadAliasedClosedGeneric(value);
    writer.WriteAliasedClosedGeneric(value);
  }
  {
    test_model::AliasedOptional value;
    ReadAliasedOptional(value);
    writer.WriteAliasedOptional(value);
  }
  {
    test_model::AliasedGenericOptional<float> value;
    ReadAliasedGenericOptional(value);
    writer.WriteAliasedGenericOptional(value);
  }
  {
    test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> value;
    ReadAliasedGenericUnion2(value);
    writer.WriteAliasedGenericUnion2(value);
  }
  {
    test_model::AliasedGenericVector<float> value;
    ReadAliasedGenericVector(value);
    writer.WriteAliasedGenericVector(value);
  }
  {
    test_model::AliasedGenericFixedVector<float> value;
    ReadAliasedGenericFixedVector(value);
    writer.WriteAliasedGenericFixedVector(value);
  }
  if (stream_of_aliased_generic_union2_buffer_size > 1) {
    std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> values;
    values.reserve(stream_of_aliased_generic_union2_buffer_size);
    while(ReadStreamOfAliasedGenericUnion2(values)) {
      writer.WriteStreamOfAliasedGenericUnion2(values);
    }
    writer.EndStreamOfAliasedGenericUnion2();
  } else {
    test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> value;
    while(ReadStreamOfAliasedGenericUnion2(value)) {
      writer.WriteStreamOfAliasedGenericUnion2(value);
    }
    writer.EndStreamOfAliasedGenericUnion2();
  }
}

namespace {
void StreamsOfAliasedUnionsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteIntOrSimpleRecord() or EndIntOrSimpleRecord()"; break;
  case 1: expected_method = "WriteNullableIntOrSimpleRecord() or EndNullableIntOrSimpleRecord()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndIntOrSimpleRecord()" : "WriteIntOrSimpleRecord()"; break;
  case 1: attempted_method = end ? "EndNullableIntOrSimpleRecord()" : "WriteNullableIntOrSimpleRecord()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void StreamsOfAliasedUnionsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadIntOrSimpleRecord()";
    case 1: return "ReadNullableIntOrSimpleRecord()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string StreamsOfAliasedUnionsWriterBase::schema_ = R"({"protocol":{"name":"StreamsOfAliasedUnions","sequence":[{"name":"intOrSimpleRecord","type":{"stream":{"items":"TestModel.AliasedIntOrSimpleRecord"}}},{"name":"nullableIntOrSimpleRecord","type":{"stream":{"items":"TestModel.AliasedNullableIntSimpleRecord"}}}]},"types":[{"name":"AliasedIntOrSimpleRecord","type":[{"label":"int32","type":"int32"},{"label":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"AliasedNullableIntSimpleRecord","type":[null,{"label":"int32","type":"int32"},{"label":"SimpleRecord","type":"TestModel.SimpleRecord"}]},{"name":"SimpleRecord","fields":[{"name":"x","type":"int32"},{"name":"y","type":"int32"},{"name":"z","type":"int32"}]}]})";

void StreamsOfAliasedUnionsWriterBase::WriteIntOrSimpleRecord(test_model::AliasedIntOrSimpleRecord const& value) {
  if (unlikely(state_ != 0)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(value);
}

void StreamsOfAliasedUnionsWriterBase::WriteIntOrSimpleRecord(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) {
  if (unlikely(state_ != 0)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntOrSimpleRecordImpl(values);
}

void StreamsOfAliasedUnionsWriterBase::EndIntOrSimpleRecord() {
  if (unlikely(state_ != 0)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(0, true, state_);
  }

  EndIntOrSimpleRecordImpl();
  state_ = 1;
}

// fallback implementation
void StreamsOfAliasedUnionsWriterBase::WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) {
  for (auto const& v : values) {
    WriteIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfAliasedUnionsWriterBase::WriteNullableIntOrSimpleRecord(test_model::AliasedNullableIntSimpleRecord const& value) {
  if (unlikely(state_ != 1)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(value);
}

void StreamsOfAliasedUnionsWriterBase::WriteNullableIntOrSimpleRecord(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) {
  if (unlikely(state_ != 1)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(1, false, state_);
  }

  WriteNullableIntOrSimpleRecordImpl(values);
}

void StreamsOfAliasedUnionsWriterBase::EndNullableIntOrSimpleRecord() {
  if (unlikely(state_ != 1)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(1, true, state_);
  }

  EndNullableIntOrSimpleRecordImpl();
  state_ = 2;
}

// fallback implementation
void StreamsOfAliasedUnionsWriterBase::WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) {
  for (auto const& v : values) {
    WriteNullableIntOrSimpleRecordImpl(v);
  }
}

void StreamsOfAliasedUnionsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    StreamsOfAliasedUnionsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string StreamsOfAliasedUnionsReaderBase::schema_ = StreamsOfAliasedUnionsWriterBase::schema_;

bool StreamsOfAliasedUnionsReaderBase::ReadIntOrSimpleRecord(test_model::AliasedIntOrSimpleRecord& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    StreamsOfAliasedUnionsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool StreamsOfAliasedUnionsReaderBase::ReadIntOrSimpleRecord(std::vector<test_model::AliasedIntOrSimpleRecord>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    StreamsOfAliasedUnionsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntOrSimpleRecordImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool StreamsOfAliasedUnionsReaderBase::ReadIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

bool StreamsOfAliasedUnionsReaderBase::ReadNullableIntOrSimpleRecord(test_model::AliasedNullableIntSimpleRecord& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfAliasedUnionsReaderBaseInvalidState(2, state_);
    }
  }

  bool result = ReadNullableIntOrSimpleRecordImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool StreamsOfAliasedUnionsReaderBase::ReadNullableIntOrSimpleRecord(std::vector<test_model::AliasedNullableIntSimpleRecord>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    if (state_ == 1) {
      state_ = 2;
    } else {
      StreamsOfAliasedUnionsReaderBaseInvalidState(2, state_);
    }
  }

  if (!ReadNullableIntOrSimpleRecordImpl(values)) {state_ = 3;
  }
  return true;
}

// fallback implementation
bool StreamsOfAliasedUnionsReaderBase::ReadNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadNullableIntOrSimpleRecordImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void StreamsOfAliasedUnionsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    StreamsOfAliasedUnionsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void StreamsOfAliasedUnionsReaderBase::CopyTo(StreamsOfAliasedUnionsWriterBase& writer, size_t int_or_simple_record_buffer_size, size_t nullable_int_or_simple_record_buffer_size) {
  if (int_or_simple_record_buffer_size > 1) {
    std::vector<test_model::AliasedIntOrSimpleRecord> values;
    values.reserve(int_or_simple_record_buffer_size);
    while(ReadIntOrSimpleRecord(values)) {
      writer.WriteIntOrSimpleRecord(values);
    }
    writer.EndIntOrSimpleRecord();
  } else {
    test_model::AliasedIntOrSimpleRecord value;
    while(ReadIntOrSimpleRecord(value)) {
      writer.WriteIntOrSimpleRecord(value);
    }
    writer.EndIntOrSimpleRecord();
  }
  if (nullable_int_or_simple_record_buffer_size > 1) {
    std::vector<test_model::AliasedNullableIntSimpleRecord> values;
    values.reserve(nullable_int_or_simple_record_buffer_size);
    while(ReadNullableIntOrSimpleRecord(values)) {
      writer.WriteNullableIntOrSimpleRecord(values);
    }
    writer.EndNullableIntOrSimpleRecord();
  } else {
    test_model::AliasedNullableIntSimpleRecord value;
    while(ReadNullableIntOrSimpleRecord(value)) {
      writer.WriteNullableIntOrSimpleRecord(value);
    }
    writer.EndNullableIntOrSimpleRecord();
  }
}

namespace {
void ProtocolWithComputedFieldsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteRecordWithComputedFields()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteRecordWithComputedFields()"; break;
  case 1: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ProtocolWithComputedFieldsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadRecordWithComputedFields()";
    case 1: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ProtocolWithComputedFieldsWriterBase::schema_ = R"({"protocol":{"name":"ProtocolWithComputedFields","sequence":[{"name":"recordWithComputedFields","type":"TestModel.RecordWithComputedFields"}]},"types":[{"name":"GenericRecordWithComputedFields","typeParameters":["T0","T1"],"fields":[{"name":"f1","type":[{"label":"T0","type":"T0"},{"label":"T1","type":"T1"}]}]},{"name":"MyTuple","typeParameters":["T1","T2"],"fields":[{"name":"v1","type":"T1"},{"name":"v2","type":"T2"}]},{"name":"NamedNDArray","type":{"array":{"items":"int32","dimensions":[{"name":"dimA"},{"name":"dimB"}]}}},{"name":"RecordWithComputedFields","fields":[{"name":"arrayField","type":{"array":{"items":"int32","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"arrayFieldMapDimensions","type":{"array":{"items":"int32","dimensions":[{"name":"x"},{"name":"y"}]}}},{"name":"dynamicArrayField","type":{"array":{"items":"int32"}}},{"name":"fixedArrayField","type":{"array":{"items":"int32","dimensions":[{"name":"x","length":3},{"name":"y","length":4}]}}},{"name":"intField","type":"int32"},{"name":"stringField","type":"string"},{"name":"tupleField","type":{"name":"TestModel.MyTuple","typeArguments":["int32","int32"]}},{"name":"vectorField","type":{"vector":{"items":"int32"}}},{"name":"vectorOfVectorsField","type":{"vector":{"items":{"vector":{"items":"int32"}}}}},{"name":"fixedVectorField","type":{"vector":{"items":"int32","length":3}}},{"name":"optionalNamedArray","type":[null,"TestModel.NamedNDArray"]},{"name":"intFloatUnion","type":[{"label":"int32","type":"int32"},{"label":"float32","type":"float32"}]},{"name":"nullableIntFloatUnion","type":[null,{"label":"int32","type":"int32"},{"label":"float32","type":"float32"}]},{"name":"unionWithNestedGenericUnion","type":[{"label":"int32","type":"int32"},{"label":"GenericRecordWithComputedFields\u003cstring,float32\u003e","type":{"name":"TestModel.GenericRecordWithComputedFields","typeArguments":["string","float32"]}}]},{"name":"mapField","type":{"map":{"keys":"string","values":"string"}}}]}]})";

void ProtocolWithComputedFieldsWriterBase::WriteRecordWithComputedFields(test_model::RecordWithComputedFields const& value) {
  if (unlikely(state_ != 0)) {
    ProtocolWithComputedFieldsWriterBaseInvalidState(0, false, state_);
  }

  WriteRecordWithComputedFieldsImpl(value);
  state_ = 1;
}

void ProtocolWithComputedFieldsWriterBase::Close() {
  if (unlikely(state_ != 1)) {
    ProtocolWithComputedFieldsWriterBaseInvalidState(1, false, state_);
  }

  CloseImpl();
}

std::string ProtocolWithComputedFieldsReaderBase::schema_ = ProtocolWithComputedFieldsWriterBase::schema_;

void ProtocolWithComputedFieldsReaderBase::ReadRecordWithComputedFields(test_model::RecordWithComputedFields& value) {
  if (unlikely(state_ != 0)) {
    ProtocolWithComputedFieldsReaderBaseInvalidState(0, state_);
  }

  ReadRecordWithComputedFieldsImpl(value);
  state_ = 2;
}

void ProtocolWithComputedFieldsReaderBase::Close() {
  if (unlikely(state_ != 2)) {
    ProtocolWithComputedFieldsReaderBaseInvalidState(2, state_);
  }

  CloseImpl();
}
void ProtocolWithComputedFieldsReaderBase::CopyTo(ProtocolWithComputedFieldsWriterBase& writer) {
  {
    test_model::RecordWithComputedFields value;
    ReadRecordWithComputedFields(value);
    writer.WriteRecordWithComputedFields(value);
  }
}

namespace {
void ProtocolWithKeywordStepsWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteInt() or EndInt()"; break;
  case 1: expected_method = "WriteFloat()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = end ? "EndInt()" : "WriteInt()"; break;
  case 1: attempted_method = "WriteFloat()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void ProtocolWithKeywordStepsReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadInt()";
    case 1: return "ReadFloat()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string ProtocolWithKeywordStepsWriterBase::schema_ = R"({"protocol":{"name":"ProtocolWithKeywordSteps","sequence":[{"name":"int","type":{"stream":{"items":"TestModel.RecordWithKeywordFields"}}},{"name":"float","type":"TestModel.EnumWithKeywordSymbols"}]},"types":[{"name":"ArrayWithKeywordDimensionNames","typeParameters":["INT16_MAX"],"type":{"array":{"items":"INT16_MAX","dimensions":[{"name":"while"},{"name":"do"}]}}},{"name":"EnumWithKeywordSymbols","values":[{"symbol":"try","value":2},{"symbol":"catch","value":1}]},{"name":"RecordWithKeywordFields","fields":[{"name":"int","type":"string"},{"name":"sizeof","type":{"name":"TestModel.ArrayWithKeywordDimensionNames","typeArguments":["int32"]}},{"name":"if","type":"TestModel.EnumWithKeywordSymbols"}]}]})";

void ProtocolWithKeywordStepsWriterBase::WriteInt(test_model::RecordWithKeywordFields const& value) {
  if (unlikely(state_ != 0)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntImpl(value);
}

void ProtocolWithKeywordStepsWriterBase::WriteInt(std::vector<test_model::RecordWithKeywordFields> const& values) {
  if (unlikely(state_ != 0)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(0, false, state_);
  }

  WriteIntImpl(values);
}

void ProtocolWithKeywordStepsWriterBase::EndInt() {
  if (unlikely(state_ != 0)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(0, true, state_);
  }

  EndIntImpl();
  state_ = 1;
}

// fallback implementation
void ProtocolWithKeywordStepsWriterBase::WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& values) {
  for (auto const& v : values) {
    WriteIntImpl(v);
  }
}

void ProtocolWithKeywordStepsWriterBase::WriteFloat(test_model::EnumWithKeywordSymbols const& value) {
  if (unlikely(state_ != 1)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(1, false, state_);
  }

  WriteFloatImpl(value);
  state_ = 2;
}

void ProtocolWithKeywordStepsWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    ProtocolWithKeywordStepsWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string ProtocolWithKeywordStepsReaderBase::schema_ = ProtocolWithKeywordStepsWriterBase::schema_;

bool ProtocolWithKeywordStepsReaderBase::ReadInt(test_model::RecordWithKeywordFields& value) {
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      return false;
    }
    ProtocolWithKeywordStepsReaderBaseInvalidState(0, state_);
  }

  bool result = ReadIntImpl(value);
  if (!result) {
    state_ = 2;
  }
  return result;
}

bool ProtocolWithKeywordStepsReaderBase::ReadInt(std::vector<test_model::RecordWithKeywordFields>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 0)) {
    if (state_ == 1) {
      state_ = 2;
      values.clear();
      return false;
    }
    ProtocolWithKeywordStepsReaderBaseInvalidState(0, state_);
  }

  if (!ReadIntImpl(values)) {state_ = 1;
  }
  return true;
}

// fallback implementation
bool ProtocolWithKeywordStepsReaderBase::ReadIntImpl(std::vector<test_model::RecordWithKeywordFields>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadIntImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void ProtocolWithKeywordStepsReaderBase::ReadFloat(test_model::EnumWithKeywordSymbols& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 1) {
      state_ = 2;
    } else {
      ProtocolWithKeywordStepsReaderBaseInvalidState(2, state_);
    }
  }

  ReadFloatImpl(value);
  state_ = 4;
}

void ProtocolWithKeywordStepsReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    ProtocolWithKeywordStepsReaderBaseInvalidState(4, state_);
  }

  CloseImpl();
}
void ProtocolWithKeywordStepsReaderBase::CopyTo(ProtocolWithKeywordStepsWriterBase& writer, size_t int_buffer_size) {
  if (int_buffer_size > 1) {
    std::vector<test_model::RecordWithKeywordFields> values;
    values.reserve(int_buffer_size);
    while(ReadInt(values)) {
      writer.WriteInt(values);
    }
    writer.EndInt();
  } else {
    test_model::RecordWithKeywordFields value;
    while(ReadInt(value)) {
      writer.WriteInt(value);
    }
    writer.EndInt();
  }
  {
    test_model::EnumWithKeywordSymbols value;
    ReadFloat(value);
    writer.WriteFloat(value);
  }
}
} // namespace test_model
