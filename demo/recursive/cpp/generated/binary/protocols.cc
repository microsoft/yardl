// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#include <cstddef>

#include "../yardl/detail/binary/coded_stream.h"
#include "../yardl/detail/binary/serializers.h"

namespace yardl::binary {
#ifndef _MSC_VER
// Values of offsetof() are only used if types are standard-layout.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

template <>
struct IsTriviallySerializable<sketch::BinaryTree> {
  using __T__ = sketch::BinaryTree;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    IsTriviallySerializable<decltype(__T__::left)>::value &&
    IsTriviallySerializable<decltype(__T__::right)>::value &&
    (sizeof(__T__) == (sizeof(__T__::value) + sizeof(__T__::left) + sizeof(__T__::right))) &&
    offsetof(__T__, value) < offsetof(__T__, left) && offsetof(__T__, left) < offsetof(__T__, right);
};

template <typename T>
struct IsTriviallySerializable<sketch::LinkedList<T>> {
  using __T__ = sketch::LinkedList<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    IsTriviallySerializable<decltype(__T__::next)>::value &&
    (sizeof(__T__) == (sizeof(__T__::value) + sizeof(__T__::next))) &&
    offsetof(__T__, value) < offsetof(__T__, next);
};

template <>
struct IsTriviallySerializable<sketch::File> {
  using __T__ = sketch::File;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::data)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::data))) &&
    offsetof(__T__, name) < offsetof(__T__, data);
};

template <>
struct IsTriviallySerializable<sketch::Directory> {
  using __T__ = sketch::Directory;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::entries)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::entries))) &&
    offsetof(__T__, name) < offsetof(__T__, entries);
};

#ifndef _MSC_VER
#pragma GCC diagnostic pop // #pragma GCC diagnostic ignored "-Winvalid-offsetof" 
#endif
} //namespace yardl::binary 

namespace {
template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}
} // namespace

namespace sketch::binary {
namespace {
[[maybe_unused]] void WriteBinaryTree(yardl::binary::CodedOutputStream& stream, sketch::BinaryTree const& value);

[[maybe_unused]] void ReadBinaryTree(yardl::binary::CodedInputStream& stream, sketch::BinaryTree& value);

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteLinkedList(yardl::binary::CodedOutputStream& stream, sketch::LinkedList<T> const& value);

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadLinkedList(yardl::binary::CodedInputStream& stream, sketch::LinkedList<T>& value);

[[maybe_unused]] void WriteDirectory(yardl::binary::CodedOutputStream& stream, sketch::Directory const& value);

[[maybe_unused]] void ReadDirectory(yardl::binary::CodedInputStream& stream, sketch::Directory& value);

[[maybe_unused]] void WriteBinaryTree(yardl::binary::CodedOutputStream& stream, sketch::BinaryTree const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::BinaryTree>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.value);
  yardl::binary::WritePointer<sketch::BinaryTree, sketch::binary::WriteBinaryTree>(stream, value.left);
  yardl::binary::WritePointer<sketch::BinaryTree, sketch::binary::WriteBinaryTree>(stream, value.right);
}

[[maybe_unused]] void ReadBinaryTree(yardl::binary::CodedInputStream& stream, sketch::BinaryTree& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::BinaryTree>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.value);
  yardl::binary::ReadPointer<sketch::BinaryTree, sketch::binary::ReadBinaryTree>(stream, value.left);
  yardl::binary::ReadPointer<sketch::BinaryTree, sketch::binary::ReadBinaryTree>(stream, value.right);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteLinkedList(yardl::binary::CodedOutputStream& stream, sketch::LinkedList<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::LinkedList<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteT(stream, value.value);
  yardl::binary::WritePointer<sketch::LinkedList<T>, sketch::binary::WriteLinkedList<T, WriteT>>(stream, value.next);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadLinkedList(yardl::binary::CodedInputStream& stream, sketch::LinkedList<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::LinkedList<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadT(stream, value.value);
  yardl::binary::ReadPointer<sketch::LinkedList<T>, sketch::binary::ReadLinkedList<T, ReadT>>(stream, value.next);
}

[[maybe_unused]] void WriteFile(yardl::binary::CodedOutputStream& stream, sketch::File const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::File>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteVector<uint8_t, yardl::binary::WriteInteger>(stream, value.data);
}

[[maybe_unused]] void ReadFile(yardl::binary::CodedInputStream& stream, sketch::File& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::File>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadVector<uint8_t, yardl::binary::ReadInteger>(stream, value.data);
}

[[maybe_unused]] void WriteDirectoryEntry(yardl::binary::CodedOutputStream& stream, sketch::DirectoryEntry const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::DirectoryEntry>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<sketch::File, sketch::binary::WriteFile, std::unique_ptr<sketch::Directory>, yardl::binary::WritePointer<sketch::Directory, sketch::binary::WriteDirectory>>(stream, value);
}

[[maybe_unused]] void ReadDirectoryEntry(yardl::binary::CodedInputStream& stream, sketch::DirectoryEntry& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::DirectoryEntry>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<sketch::File, sketch::binary::ReadFile, std::unique_ptr<sketch::Directory>, yardl::binary::ReadPointer<sketch::Directory, sketch::binary::ReadDirectory>>(stream, value);
}

[[maybe_unused]] void WriteDirectory(yardl::binary::CodedOutputStream& stream, sketch::Directory const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::Directory>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteVector<sketch::DirectoryEntry, sketch::binary::WriteDirectoryEntry>(stream, value.entries);
}

[[maybe_unused]] void ReadDirectory(yardl::binary::CodedInputStream& stream, sketch::Directory& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<sketch::Directory>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadVector<sketch::DirectoryEntry, sketch::binary::ReadDirectoryEntry>(stream, value.entries);
}

} // namespace

void MyProtocolWriter::WriteTreeImpl(sketch::BinaryTree const& value) {
  sketch::binary::WriteBinaryTree(stream_, value);
}

void MyProtocolWriter::WritePtreeImpl(std::unique_ptr<sketch::BinaryTree> const& value) {
  yardl::binary::WritePointer<sketch::BinaryTree, sketch::binary::WriteBinaryTree>(stream_, value);
}

void MyProtocolWriter::WriteListImpl(std::optional<sketch::LinkedList<std::string>> const& value) {
  yardl::binary::WriteOptional<sketch::LinkedList<std::string>, sketch::binary::WriteLinkedList<std::string, yardl::binary::WriteString>>(stream_, value);
}

void MyProtocolWriter::WriteCwdImpl(sketch::DirectoryEntry const& value) {
  yardl::binary::WriteBlock<sketch::DirectoryEntry, sketch::binary::WriteDirectoryEntry>(stream_, value);
}

void MyProtocolWriter::WriteCwdImpl(std::vector<sketch::DirectoryEntry> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<sketch::DirectoryEntry, sketch::binary::WriteDirectoryEntry>(stream_, values);
  }
}

void MyProtocolWriter::EndCwdImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MyProtocolWriter::Flush() {
  stream_.Flush();
}

void MyProtocolWriter::CloseImpl() {
  stream_.Flush();
}

void MyProtocolReader::ReadTreeImpl(sketch::BinaryTree& value) {
  sketch::binary::ReadBinaryTree(stream_, value);
}

void MyProtocolReader::ReadPtreeImpl(std::unique_ptr<sketch::BinaryTree>& value) {
  yardl::binary::ReadPointer<sketch::BinaryTree, sketch::binary::ReadBinaryTree>(stream_, value);
}

void MyProtocolReader::ReadListImpl(std::optional<sketch::LinkedList<std::string>>& value) {
  yardl::binary::ReadOptional<sketch::LinkedList<std::string>, sketch::binary::ReadLinkedList<std::string, yardl::binary::ReadString>>(stream_, value);
}

bool MyProtocolReader::ReadCwdImpl(sketch::DirectoryEntry& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<sketch::DirectoryEntry, sketch::binary::ReadDirectoryEntry>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MyProtocolReader::ReadCwdImpl(std::vector<sketch::DirectoryEntry>& values) {
  yardl::binary::ReadBlocksIntoVector<sketch::DirectoryEntry, sketch::binary::ReadDirectoryEntry>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void MyProtocolReader::CloseImpl() {
  stream_.VerifyFinished();
}

void MyProtocolIndexedWriter::WriteTreeImpl(sketch::BinaryTree const& value) {
  auto pos = stream_.Pos();
  step_index_.set_step_offset("Tree", pos);
  sketch::binary::WriteBinaryTree(stream_, value);
}

void MyProtocolIndexedWriter::WritePtreeImpl(std::unique_ptr<sketch::BinaryTree> const& value) {
  auto pos = stream_.Pos();
  step_index_.set_step_offset("Ptree", pos);
  yardl::binary::WritePointer<sketch::BinaryTree, sketch::binary::WriteBinaryTree>(stream_, value);
}

void MyProtocolIndexedWriter::WriteListImpl(std::optional<sketch::LinkedList<std::string>> const& value) {
  auto pos = stream_.Pos();
  step_index_.set_step_offset("List", pos);
  yardl::binary::WriteOptional<sketch::LinkedList<std::string>, sketch::binary::WriteLinkedList<std::string, yardl::binary::WriteString>>(stream_, value);
}

void MyProtocolIndexedWriter::WriteCwdImpl(sketch::DirectoryEntry const& value) {
  auto pos = stream_.Pos();
  step_index_.set_step_offset("Cwd", pos);
  size_t item_offset = 0;
  yardl::binary::WriteBlockAndSaveOffset<sketch::DirectoryEntry, sketch::binary::WriteDirectoryEntry>(stream_, value, item_offset);
  step_index_.add_stream_offset("Cwd", item_offset);
}

void MyProtocolIndexedWriter::WriteCwdImpl(std::vector<sketch::DirectoryEntry> const& values) {
  if (!values.empty()) {
    step_index_.set_step_offset("Cwd", stream_.Pos());
    std::vector<size_t> item_offsets;
    item_offsets.reserve(values.size());
    yardl::binary::WriteVectorAndSaveOffsets<sketch::DirectoryEntry, sketch::binary::WriteDirectoryEntry>(stream_, values, item_offsets);
    step_index_.add_stream_offsets("Cwd", item_offsets);
  }
}

void MyProtocolIndexedWriter::EndCwdImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MyProtocolIndexedWriter::Flush() {
  stream_.Flush();
}

void MyProtocolIndexedWriter::CloseImpl() {
  yardl::binary::WriteIndex(stream_, step_index_);

  stream_.Flush();
}

void MyProtocolIndexedReader::ReadTreeImpl(sketch::BinaryTree& value) {
  auto pos = step_index_.get_step_offset("Tree");
  stream_.Seek(pos);
  sketch::binary::ReadBinaryTree(stream_, value);
}

void MyProtocolIndexedReader::ReadPtreeImpl(std::unique_ptr<sketch::BinaryTree>& value) {
  auto pos = step_index_.get_step_offset("Ptree");
  stream_.Seek(pos);
  yardl::binary::ReadPointer<sketch::BinaryTree, sketch::binary::ReadBinaryTree>(stream_, value);
}

void MyProtocolIndexedReader::ReadListImpl(std::optional<sketch::LinkedList<std::string>>& value) {
  auto pos = step_index_.get_step_offset("List");
  stream_.Seek(pos);
  yardl::binary::ReadOptional<sketch::LinkedList<std::string>, sketch::binary::ReadLinkedList<std::string, yardl::binary::ReadString>>(stream_, value);
}

bool MyProtocolIndexedReader::ReadCwdImpl(sketch::DirectoryEntry& value, size_t idx) {
  size_t abs_offset = 0, items_remaining = 0;
  if (!step_index_.find_stream_item("Cwd", idx, abs_offset, items_remaining)) {
    return false;
  }
  stream_.Seek(abs_offset);
  current_block_remaining_ = items_remaining;
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<sketch::DirectoryEntry, sketch::binary::ReadDirectoryEntry>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MyProtocolIndexedReader::ReadCwdImpl(std::vector<sketch::DirectoryEntry>& values, size_t idx) {
  size_t abs_offset = 0, items_remaining = 0;
  if (!step_index_.find_stream_item("Cwd", idx, abs_offset, items_remaining)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  current_block_remaining_ = items_remaining;
  yardl::binary::ReadBlocksIntoVector<sketch::DirectoryEntry, sketch::binary::ReadDirectoryEntry>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void MyProtocolIndexedReader::CloseImpl() {
}

} // namespace sketch::binary

