// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package cpp

import (
	"bytes"
	"fmt"
	"path"

	"github.com/microsoft/yardl/tooling/internal/formatting"
	"github.com/microsoft/yardl/tooling/internal/iocommon"
	"github.com/microsoft/yardl/tooling/pkg/dsl"
	"github.com/microsoft/yardl/tooling/pkg/packaging"
)

func writeCMakeLists(env *dsl.Environment, options packaging.CppCodegenOptions) error {
	b := bytes.Buffer{}
	w := formatting.NewIndentedWriter(&b, "  ")

	objectLibraryName := fmt.Sprintf("%s_generated", formatting.ToSnakeCase(options.PackageInfo.Namespace))

	fmt.Fprintf(w, `# This file was generated by the "yardl" tool. DO NOT EDIT.

# To opt out of generating this file, set cpp.generateCMakeLists to false in the _package.yml file.

# To use the object library defined in this file, add the following to your CMakeLists.txt file:
# target_link_libraries(<your target> %s)
# add_subdirectory(<path to this directory>)

`, objectLibraryName)

	w.WriteStringln("if(NOT DEFINED CMAKE_CXX_STANDARD OR CMAKE_CXX_STANDARD LESS 20)")
	w.Indented(func() {
		w.WriteStringln("find_package(date REQUIRED)")
	})
	w.WriteString("endif()\n\n")

	w.WriteStringln("find_package(HDF5 REQUIRED)")
	w.WriteStringln("find_package(xtensor REQUIRED)")

	fmt.Fprintf(w, "add_library(%s OBJECT\n", objectLibraryName)
	w.Indented(func() {
		w.WriteStringln("protocols.cc")
		w.WriteStringln("binary/protocols.cc")
		w.WriteStringln("hdf5/protocols.cc")
		if options.InternalGenerateMocks {
			w.WriteStringln("mocks.cc")
		}
	})
	w.WriteString(")\n\n")

	fmt.Fprintf(w, "target_link_libraries(%s\n", objectLibraryName)
	w.Indented(func() {
		w.WriteStringln("PUBLIC hdf5")
		w.WriteStringln("PUBLIC hdf5_cpp")
	})
	w.WriteString(")\n")

	definitionsPath := path.Join(options.SourcesOutputDir, "CMakeLists.txt")
	return iocommon.WriteFileIfNeeded(definitionsPath, b.Bytes(), 0644)
}
