// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#include <cstddef>

#include "../yardl/detail/binary/coded_stream.h"
#include "../yardl/detail/binary/serializers.h"

namespace yardl::binary {
#ifndef _MSC_VER
// Values of offsetof() are only used if types are standard-layout.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

template <typename T1, typename T2>
struct IsTriviallySerializable<tuples::Tuple<T1, T2>> {
  using __T__ = tuples::Tuple<T1, T2>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v1)>::value &&
    IsTriviallySerializable<decltype(__T__::v2)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v1) + sizeof(__T__::v2))) &&
    offsetof(__T__, v1) < offsetof(__T__, v2);
};

template <>
struct IsTriviallySerializable<basic_types::RecordWithString> {
  using __T__ = basic_types::RecordWithString;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::i)>::value &&
    (sizeof(__T__) == (sizeof(__T__::i)));
};

template <>
struct IsTriviallySerializable<basic_types::RecordWithUnions> {
  using __T__ = basic_types::RecordWithUnions;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::null_or_int_or_string)>::value &&
    IsTriviallySerializable<decltype(__T__::date_or_datetime)>::value &&
    IsTriviallySerializable<decltype(__T__::null_or_fruits_or_days_of_week)>::value &&
    IsTriviallySerializable<decltype(__T__::record_or_int)>::value &&
    (sizeof(__T__) == (sizeof(__T__::null_or_int_or_string) + sizeof(__T__::date_or_datetime) + sizeof(__T__::null_or_fruits_or_days_of_week) + sizeof(__T__::record_or_int))) &&
    offsetof(__T__, null_or_int_or_string) < offsetof(__T__, date_or_datetime) && offsetof(__T__, date_or_datetime) < offsetof(__T__, null_or_fruits_or_days_of_week) && offsetof(__T__, null_or_fruits_or_days_of_week) < offsetof(__T__, record_or_int);
};

template <typename T0, typename T1>
struct IsTriviallySerializable<basic_types::GenericRecordWithComputedFields<T0, T1>> {
  using __T__ = basic_types::GenericRecordWithComputedFields<T0, T1>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::f1)>::value &&
    (sizeof(__T__) == (sizeof(__T__::f1)));
};

template <>
struct IsTriviallySerializable<test_model::SmallBenchmarkRecord> {
  using __T__ = test_model::SmallBenchmarkRecord;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::a)>::value &&
    IsTriviallySerializable<decltype(__T__::b)>::value &&
    IsTriviallySerializable<decltype(__T__::c)>::value &&
    (sizeof(__T__) == (sizeof(__T__::a) + sizeof(__T__::b) + sizeof(__T__::c))) &&
    offsetof(__T__, a) < offsetof(__T__, b) && offsetof(__T__, b) < offsetof(__T__, c);
};

template <>
struct IsTriviallySerializable<test_model::SimpleEncodingCounters> {
  using __T__ = test_model::SimpleEncodingCounters;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::e1)>::value &&
    IsTriviallySerializable<decltype(__T__::e2)>::value &&
    IsTriviallySerializable<decltype(__T__::slice)>::value &&
    IsTriviallySerializable<decltype(__T__::repetition)>::value &&
    (sizeof(__T__) == (sizeof(__T__::e1) + sizeof(__T__::e2) + sizeof(__T__::slice) + sizeof(__T__::repetition))) &&
    offsetof(__T__, e1) < offsetof(__T__, e2) && offsetof(__T__, e2) < offsetof(__T__, slice) && offsetof(__T__, slice) < offsetof(__T__, repetition);
};

template <>
struct IsTriviallySerializable<test_model::SimpleAcquisition> {
  using __T__ = test_model::SimpleAcquisition;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::flags)>::value &&
    IsTriviallySerializable<decltype(__T__::idx)>::value &&
    IsTriviallySerializable<decltype(__T__::data)>::value &&
    IsTriviallySerializable<decltype(__T__::trajectory)>::value &&
    (sizeof(__T__) == (sizeof(__T__::flags) + sizeof(__T__::idx) + sizeof(__T__::data) + sizeof(__T__::trajectory))) &&
    offsetof(__T__, flags) < offsetof(__T__, idx) && offsetof(__T__, idx) < offsetof(__T__, data) && offsetof(__T__, data) < offsetof(__T__, trajectory);
};

template <>
struct IsTriviallySerializable<test_model::SimpleRecord> {
  using __T__ = test_model::SimpleRecord;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::x)>::value &&
    IsTriviallySerializable<decltype(__T__::y)>::value &&
    IsTriviallySerializable<decltype(__T__::z)>::value &&
    (sizeof(__T__) == (sizeof(__T__::x) + sizeof(__T__::y) + sizeof(__T__::z))) &&
    offsetof(__T__, x) < offsetof(__T__, y) && offsetof(__T__, y) < offsetof(__T__, z);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithPrimitives> {
  using __T__ = test_model::RecordWithPrimitives;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::bool_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int8_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint8_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int16_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint16_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::size_field)>::value &&
    IsTriviallySerializable<decltype(__T__::float32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::float64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::complexfloat32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::complexfloat64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::date_field)>::value &&
    IsTriviallySerializable<decltype(__T__::time_field)>::value &&
    IsTriviallySerializable<decltype(__T__::datetime_field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::bool_field) + sizeof(__T__::int8_field) + sizeof(__T__::uint8_field) + sizeof(__T__::int16_field) + sizeof(__T__::uint16_field) + sizeof(__T__::int32_field) + sizeof(__T__::uint32_field) + sizeof(__T__::int64_field) + sizeof(__T__::uint64_field) + sizeof(__T__::size_field) + sizeof(__T__::float32_field) + sizeof(__T__::float64_field) + sizeof(__T__::complexfloat32_field) + sizeof(__T__::complexfloat64_field) + sizeof(__T__::date_field) + sizeof(__T__::time_field) + sizeof(__T__::datetime_field))) &&
    offsetof(__T__, bool_field) < offsetof(__T__, int8_field) && offsetof(__T__, int8_field) < offsetof(__T__, uint8_field) && offsetof(__T__, uint8_field) < offsetof(__T__, int16_field) && offsetof(__T__, int16_field) < offsetof(__T__, uint16_field) && offsetof(__T__, uint16_field) < offsetof(__T__, int32_field) && offsetof(__T__, int32_field) < offsetof(__T__, uint32_field) && offsetof(__T__, uint32_field) < offsetof(__T__, int64_field) && offsetof(__T__, int64_field) < offsetof(__T__, uint64_field) && offsetof(__T__, uint64_field) < offsetof(__T__, size_field) && offsetof(__T__, size_field) < offsetof(__T__, float32_field) && offsetof(__T__, float32_field) < offsetof(__T__, float64_field) && offsetof(__T__, float64_field) < offsetof(__T__, complexfloat32_field) && offsetof(__T__, complexfloat32_field) < offsetof(__T__, complexfloat64_field) && offsetof(__T__, complexfloat64_field) < offsetof(__T__, date_field) && offsetof(__T__, date_field) < offsetof(__T__, time_field) && offsetof(__T__, time_field) < offsetof(__T__, datetime_field);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithPrimitiveAliases> {
  using __T__ = test_model::RecordWithPrimitiveAliases;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::byte_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint_field)>::value &&
    IsTriviallySerializable<decltype(__T__::long_field)>::value &&
    IsTriviallySerializable<decltype(__T__::ulong_field)>::value &&
    IsTriviallySerializable<decltype(__T__::float_field)>::value &&
    IsTriviallySerializable<decltype(__T__::double_field)>::value &&
    IsTriviallySerializable<decltype(__T__::complexfloat_field)>::value &&
    IsTriviallySerializable<decltype(__T__::complexdouble_field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::byte_field) + sizeof(__T__::int_field) + sizeof(__T__::uint_field) + sizeof(__T__::long_field) + sizeof(__T__::ulong_field) + sizeof(__T__::float_field) + sizeof(__T__::double_field) + sizeof(__T__::complexfloat_field) + sizeof(__T__::complexdouble_field))) &&
    offsetof(__T__, byte_field) < offsetof(__T__, int_field) && offsetof(__T__, int_field) < offsetof(__T__, uint_field) && offsetof(__T__, uint_field) < offsetof(__T__, long_field) && offsetof(__T__, long_field) < offsetof(__T__, ulong_field) && offsetof(__T__, ulong_field) < offsetof(__T__, float_field) && offsetof(__T__, float_field) < offsetof(__T__, double_field) && offsetof(__T__, double_field) < offsetof(__T__, complexfloat_field) && offsetof(__T__, complexfloat_field) < offsetof(__T__, complexdouble_field);
};

template <>
struct IsTriviallySerializable<test_model::TupleWithRecords> {
  using __T__ = test_model::TupleWithRecords;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::a)>::value &&
    IsTriviallySerializable<decltype(__T__::b)>::value &&
    (sizeof(__T__) == (sizeof(__T__::a) + sizeof(__T__::b))) &&
    offsetof(__T__, a) < offsetof(__T__, b);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithVectors> {
  using __T__ = test_model::RecordWithVectors;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::default_vector)>::value &&
    IsTriviallySerializable<decltype(__T__::default_vector_fixed_length)>::value &&
    IsTriviallySerializable<decltype(__T__::vector_of_vectors)>::value &&
    (sizeof(__T__) == (sizeof(__T__::default_vector) + sizeof(__T__::default_vector_fixed_length) + sizeof(__T__::vector_of_vectors))) &&
    offsetof(__T__, default_vector) < offsetof(__T__, default_vector_fixed_length) && offsetof(__T__, default_vector_fixed_length) < offsetof(__T__, vector_of_vectors);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithVectorOfTimes> {
  using __T__ = test_model::RecordWithVectorOfTimes;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::times)>::value &&
    (sizeof(__T__) == (sizeof(__T__::times)));
};

template <>
struct IsTriviallySerializable<test_model::RecordWithArrays> {
  using __T__ = test_model::RecordWithArrays;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::default_array)>::value &&
    IsTriviallySerializable<decltype(__T__::default_array_with_empty_dimension)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_1_array)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_array)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_array_with_named_dimensions)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_fixed_array)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_fixed_array_with_named_dimensions)>::value &&
    IsTriviallySerializable<decltype(__T__::dynamic_array)>::value &&
    IsTriviallySerializable<decltype(__T__::array_of_vectors)>::value &&
    (sizeof(__T__) == (sizeof(__T__::default_array) + sizeof(__T__::default_array_with_empty_dimension) + sizeof(__T__::rank_1_array) + sizeof(__T__::rank_2_array) + sizeof(__T__::rank_2_array_with_named_dimensions) + sizeof(__T__::rank_2_fixed_array) + sizeof(__T__::rank_2_fixed_array_with_named_dimensions) + sizeof(__T__::dynamic_array) + sizeof(__T__::array_of_vectors))) &&
    offsetof(__T__, default_array) < offsetof(__T__, default_array_with_empty_dimension) && offsetof(__T__, default_array_with_empty_dimension) < offsetof(__T__, rank_1_array) && offsetof(__T__, rank_1_array) < offsetof(__T__, rank_2_array) && offsetof(__T__, rank_2_array) < offsetof(__T__, rank_2_array_with_named_dimensions) && offsetof(__T__, rank_2_array_with_named_dimensions) < offsetof(__T__, rank_2_fixed_array) && offsetof(__T__, rank_2_fixed_array) < offsetof(__T__, rank_2_fixed_array_with_named_dimensions) && offsetof(__T__, rank_2_fixed_array_with_named_dimensions) < offsetof(__T__, dynamic_array) && offsetof(__T__, dynamic_array) < offsetof(__T__, array_of_vectors);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithArraysSimpleSyntax> {
  using __T__ = test_model::RecordWithArraysSimpleSyntax;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::default_array)>::value &&
    IsTriviallySerializable<decltype(__T__::default_array_with_empty_dimension)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_1_array)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_array)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_array_with_named_dimensions)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_fixed_array)>::value &&
    IsTriviallySerializable<decltype(__T__::rank_2_fixed_array_with_named_dimensions)>::value &&
    IsTriviallySerializable<decltype(__T__::dynamic_array)>::value &&
    IsTriviallySerializable<decltype(__T__::array_of_vectors)>::value &&
    (sizeof(__T__) == (sizeof(__T__::default_array) + sizeof(__T__::default_array_with_empty_dimension) + sizeof(__T__::rank_1_array) + sizeof(__T__::rank_2_array) + sizeof(__T__::rank_2_array_with_named_dimensions) + sizeof(__T__::rank_2_fixed_array) + sizeof(__T__::rank_2_fixed_array_with_named_dimensions) + sizeof(__T__::dynamic_array) + sizeof(__T__::array_of_vectors))) &&
    offsetof(__T__, default_array) < offsetof(__T__, default_array_with_empty_dimension) && offsetof(__T__, default_array_with_empty_dimension) < offsetof(__T__, rank_1_array) && offsetof(__T__, rank_1_array) < offsetof(__T__, rank_2_array) && offsetof(__T__, rank_2_array) < offsetof(__T__, rank_2_array_with_named_dimensions) && offsetof(__T__, rank_2_array_with_named_dimensions) < offsetof(__T__, rank_2_fixed_array) && offsetof(__T__, rank_2_fixed_array) < offsetof(__T__, rank_2_fixed_array_with_named_dimensions) && offsetof(__T__, rank_2_fixed_array_with_named_dimensions) < offsetof(__T__, dynamic_array) && offsetof(__T__, dynamic_array) < offsetof(__T__, array_of_vectors);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithOptionalFields> {
  using __T__ = test_model::RecordWithOptionalFields;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::optional_int)>::value &&
    IsTriviallySerializable<decltype(__T__::optional_int_alternate_syntax)>::value &&
    IsTriviallySerializable<decltype(__T__::optional_time)>::value &&
    (sizeof(__T__) == (sizeof(__T__::optional_int) + sizeof(__T__::optional_int_alternate_syntax) + sizeof(__T__::optional_time))) &&
    offsetof(__T__, optional_int) < offsetof(__T__, optional_int_alternate_syntax) && offsetof(__T__, optional_int_alternate_syntax) < offsetof(__T__, optional_time);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithVlens> {
  using __T__ = test_model::RecordWithVlens;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::a)>::value &&
    IsTriviallySerializable<decltype(__T__::b)>::value &&
    IsTriviallySerializable<decltype(__T__::c)>::value &&
    (sizeof(__T__) == (sizeof(__T__::a) + sizeof(__T__::b) + sizeof(__T__::c))) &&
    offsetof(__T__, a) < offsetof(__T__, b) && offsetof(__T__, b) < offsetof(__T__, c);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithStrings> {
  using __T__ = test_model::RecordWithStrings;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::a)>::value &&
    IsTriviallySerializable<decltype(__T__::b)>::value &&
    (sizeof(__T__) == (sizeof(__T__::a) + sizeof(__T__::b))) &&
    offsetof(__T__, a) < offsetof(__T__, b);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithOptionalVector> {
  using __T__ = test_model::RecordWithOptionalVector;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::optional_vector)>::value &&
    (sizeof(__T__) == (sizeof(__T__::optional_vector)));
};

template <>
struct IsTriviallySerializable<test_model::RecordWithFixedVectors> {
  using __T__ = test_model::RecordWithFixedVectors;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::fixed_int_vector)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_simple_record_vector)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_record_with_vlens_vector)>::value &&
    (sizeof(__T__) == (sizeof(__T__::fixed_int_vector) + sizeof(__T__::fixed_simple_record_vector) + sizeof(__T__::fixed_record_with_vlens_vector))) &&
    offsetof(__T__, fixed_int_vector) < offsetof(__T__, fixed_simple_record_vector) && offsetof(__T__, fixed_simple_record_vector) < offsetof(__T__, fixed_record_with_vlens_vector);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithFixedArrays> {
  using __T__ = test_model::RecordWithFixedArrays;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::ints)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_simple_record_array)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_record_with_vlens_array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::ints) + sizeof(__T__::fixed_simple_record_array) + sizeof(__T__::fixed_record_with_vlens_array))) &&
    offsetof(__T__, ints) < offsetof(__T__, fixed_simple_record_array) && offsetof(__T__, fixed_simple_record_array) < offsetof(__T__, fixed_record_with_vlens_array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithNamedFixedArrays> {
  using __T__ = test_model::RecordWithNamedFixedArrays;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::ints)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_simple_record_array)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_record_with_vlens_array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::ints) + sizeof(__T__::fixed_simple_record_array) + sizeof(__T__::fixed_record_with_vlens_array))) &&
    offsetof(__T__, ints) < offsetof(__T__, fixed_simple_record_array) && offsetof(__T__, fixed_simple_record_array) < offsetof(__T__, fixed_record_with_vlens_array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithNDArrays> {
  using __T__ = test_model::RecordWithNDArrays;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::ints)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_simple_record_array)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_record_with_vlens_array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::ints) + sizeof(__T__::fixed_simple_record_array) + sizeof(__T__::fixed_record_with_vlens_array))) &&
    offsetof(__T__, ints) < offsetof(__T__, fixed_simple_record_array) && offsetof(__T__, fixed_simple_record_array) < offsetof(__T__, fixed_record_with_vlens_array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithNDArraysSingleDimension> {
  using __T__ = test_model::RecordWithNDArraysSingleDimension;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::ints)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_simple_record_array)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_record_with_vlens_array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::ints) + sizeof(__T__::fixed_simple_record_array) + sizeof(__T__::fixed_record_with_vlens_array))) &&
    offsetof(__T__, ints) < offsetof(__T__, fixed_simple_record_array) && offsetof(__T__, fixed_simple_record_array) < offsetof(__T__, fixed_record_with_vlens_array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithDynamicNDArrays> {
  using __T__ = test_model::RecordWithDynamicNDArrays;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::ints)>::value &&
    IsTriviallySerializable<decltype(__T__::simple_record_array)>::value &&
    IsTriviallySerializable<decltype(__T__::record_with_vlens_array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::ints) + sizeof(__T__::simple_record_array) + sizeof(__T__::record_with_vlens_array))) &&
    offsetof(__T__, ints) < offsetof(__T__, simple_record_array) && offsetof(__T__, simple_record_array) < offsetof(__T__, record_with_vlens_array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithFixedCollections> {
  using __T__ = test_model::RecordWithFixedCollections;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::fixed_vector)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::fixed_vector) + sizeof(__T__::fixed_array))) &&
    offsetof(__T__, fixed_vector) < offsetof(__T__, fixed_array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithVlenCollections> {
  using __T__ = test_model::RecordWithVlenCollections;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::vector)>::value &&
    IsTriviallySerializable<decltype(__T__::array)>::value &&
    (sizeof(__T__) == (sizeof(__T__::vector) + sizeof(__T__::array))) &&
    offsetof(__T__, vector) < offsetof(__T__, array);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithUnionsOfContainers> {
  using __T__ = test_model::RecordWithUnionsOfContainers;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::map_or_scalar)>::value &&
    IsTriviallySerializable<decltype(__T__::vector_or_scalar)>::value &&
    IsTriviallySerializable<decltype(__T__::array_or_scalar)>::value &&
    (sizeof(__T__) == (sizeof(__T__::map_or_scalar) + sizeof(__T__::vector_or_scalar) + sizeof(__T__::array_or_scalar))) &&
    offsetof(__T__, map_or_scalar) < offsetof(__T__, vector_or_scalar) && offsetof(__T__, vector_or_scalar) < offsetof(__T__, array_or_scalar);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithMaps> {
  using __T__ = test_model::RecordWithMaps;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::set_1)>::value &&
    IsTriviallySerializable<decltype(__T__::set_2)>::value &&
    (sizeof(__T__) == (sizeof(__T__::set_1) + sizeof(__T__::set_2))) &&
    offsetof(__T__, set_1) < offsetof(__T__, set_2);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithNoDefaultEnum> {
  using __T__ = test_model::RecordWithNoDefaultEnum;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::enum_field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::enum_field)));
};

template <>
struct IsTriviallySerializable<test_model::RecordWithEnums> {
  using __T__ = test_model::RecordWithEnums;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::enum_field)>::value &&
    IsTriviallySerializable<decltype(__T__::flags)>::value &&
    IsTriviallySerializable<decltype(__T__::flags_2)>::value &&
    IsTriviallySerializable<decltype(__T__::rec)>::value &&
    (sizeof(__T__) == (sizeof(__T__::enum_field) + sizeof(__T__::flags) + sizeof(__T__::flags_2) + sizeof(__T__::rec))) &&
    offsetof(__T__, enum_field) < offsetof(__T__, flags) && offsetof(__T__, flags) < offsetof(__T__, flags_2) && offsetof(__T__, flags_2) < offsetof(__T__, rec);
};

template <typename T1, typename T2>
struct IsTriviallySerializable<test_model::GenericRecord<T1, T2>> {
  using __T__ = test_model::GenericRecord<T1, T2>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::scalar_1)>::value &&
    IsTriviallySerializable<decltype(__T__::scalar_2)>::value &&
    IsTriviallySerializable<decltype(__T__::vector_1)>::value &&
    IsTriviallySerializable<decltype(__T__::image_2)>::value &&
    (sizeof(__T__) == (sizeof(__T__::scalar_1) + sizeof(__T__::scalar_2) + sizeof(__T__::vector_1) + sizeof(__T__::image_2))) &&
    offsetof(__T__, scalar_1) < offsetof(__T__, scalar_2) && offsetof(__T__, scalar_2) < offsetof(__T__, vector_1) && offsetof(__T__, vector_1) < offsetof(__T__, image_2);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithAliasedGenerics> {
  using __T__ = test_model::RecordWithAliasedGenerics;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::my_strings)>::value &&
    IsTriviallySerializable<decltype(__T__::aliased_strings)>::value &&
    (sizeof(__T__) == (sizeof(__T__::my_strings) + sizeof(__T__::aliased_strings))) &&
    offsetof(__T__, my_strings) < offsetof(__T__, aliased_strings);
};

template <typename T, typename U>
struct IsTriviallySerializable<test_model::RecordWithGenericVectorOfRecords<T, U>> {
  using __T__ = test_model::RecordWithGenericVectorOfRecords<T, U>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v)));
};

template <typename T>
struct IsTriviallySerializable<test_model::RecordWithOptionalGenericField<T>> {
  using __T__ = test_model::RecordWithOptionalGenericField<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v)));
};

template <typename T>
struct IsTriviallySerializable<test_model::RecordWithAliasedOptionalGenericField<T>> {
  using __T__ = test_model::RecordWithAliasedOptionalGenericField<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v)));
};

template <typename U, typename V>
struct IsTriviallySerializable<test_model::RecordWithOptionalGenericUnionField<U, V>> {
  using __T__ = test_model::RecordWithOptionalGenericUnionField<U, V>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v)));
};

template <typename U, typename V>
struct IsTriviallySerializable<test_model::RecordWithAliasedOptionalGenericUnionField<U, V>> {
  using __T__ = test_model::RecordWithAliasedOptionalGenericUnionField<U, V>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v)));
};

template <typename T>
struct IsTriviallySerializable<test_model::RecordWithGenericVectors<T>> {
  using __T__ = test_model::RecordWithGenericVectors<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::v)>::value &&
    IsTriviallySerializable<decltype(__T__::av)>::value &&
    (sizeof(__T__) == (sizeof(__T__::v) + sizeof(__T__::av))) &&
    offsetof(__T__, v) < offsetof(__T__, av);
};

template <typename T>
struct IsTriviallySerializable<test_model::RecordWithGenericFixedVectors<T>> {
  using __T__ = test_model::RecordWithGenericFixedVectors<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::fv)>::value &&
    IsTriviallySerializable<decltype(__T__::afv)>::value &&
    (sizeof(__T__) == (sizeof(__T__::fv) + sizeof(__T__::afv))) &&
    offsetof(__T__, fv) < offsetof(__T__, afv);
};

template <typename T>
struct IsTriviallySerializable<test_model::RecordWithGenericArrays<T>> {
  using __T__ = test_model::RecordWithGenericArrays<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::nd)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_nd)>::value &&
    IsTriviallySerializable<decltype(__T__::dynamic_nd)>::value &&
    IsTriviallySerializable<decltype(__T__::aliased_nd)>::value &&
    IsTriviallySerializable<decltype(__T__::aliased_fixed_nd)>::value &&
    IsTriviallySerializable<decltype(__T__::aliased_dynamic_nd)>::value &&
    (sizeof(__T__) == (sizeof(__T__::nd) + sizeof(__T__::fixed_nd) + sizeof(__T__::dynamic_nd) + sizeof(__T__::aliased_nd) + sizeof(__T__::aliased_fixed_nd) + sizeof(__T__::aliased_dynamic_nd))) &&
    offsetof(__T__, nd) < offsetof(__T__, fixed_nd) && offsetof(__T__, fixed_nd) < offsetof(__T__, dynamic_nd) && offsetof(__T__, dynamic_nd) < offsetof(__T__, aliased_nd) && offsetof(__T__, aliased_nd) < offsetof(__T__, aliased_fixed_nd) && offsetof(__T__, aliased_fixed_nd) < offsetof(__T__, aliased_dynamic_nd);
};

template <typename T, typename U>
struct IsTriviallySerializable<test_model::RecordWithGenericMaps<T, U>> {
  using __T__ = test_model::RecordWithGenericMaps<T, U>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::m)>::value &&
    IsTriviallySerializable<decltype(__T__::am)>::value &&
    (sizeof(__T__) == (sizeof(__T__::m) + sizeof(__T__::am))) &&
    offsetof(__T__, m) < offsetof(__T__, am);
};

template <typename A, typename B>
struct IsTriviallySerializable<test_model::RecordContainingGenericRecords<A, B>> {
  using __T__ = test_model::RecordContainingGenericRecords<A, B>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::g1)>::value &&
    IsTriviallySerializable<decltype(__T__::g1a)>::value &&
    IsTriviallySerializable<decltype(__T__::g2)>::value &&
    IsTriviallySerializable<decltype(__T__::g2a)>::value &&
    IsTriviallySerializable<decltype(__T__::g3)>::value &&
    IsTriviallySerializable<decltype(__T__::g3a)>::value &&
    IsTriviallySerializable<decltype(__T__::g4)>::value &&
    IsTriviallySerializable<decltype(__T__::g5)>::value &&
    IsTriviallySerializable<decltype(__T__::g6)>::value &&
    IsTriviallySerializable<decltype(__T__::g7)>::value &&
    (sizeof(__T__) == (sizeof(__T__::g1) + sizeof(__T__::g1a) + sizeof(__T__::g2) + sizeof(__T__::g2a) + sizeof(__T__::g3) + sizeof(__T__::g3a) + sizeof(__T__::g4) + sizeof(__T__::g5) + sizeof(__T__::g6) + sizeof(__T__::g7))) &&
    offsetof(__T__, g1) < offsetof(__T__, g1a) && offsetof(__T__, g1a) < offsetof(__T__, g2) && offsetof(__T__, g2) < offsetof(__T__, g2a) && offsetof(__T__, g2a) < offsetof(__T__, g3) && offsetof(__T__, g3) < offsetof(__T__, g3a) && offsetof(__T__, g3a) < offsetof(__T__, g4) && offsetof(__T__, g4) < offsetof(__T__, g5) && offsetof(__T__, g5) < offsetof(__T__, g6) && offsetof(__T__, g6) < offsetof(__T__, g7);
};

template <>
struct IsTriviallySerializable<test_model::RecordContainingNestedGenericRecords> {
  using __T__ = test_model::RecordContainingNestedGenericRecords;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::f1)>::value &&
    IsTriviallySerializable<decltype(__T__::f1a)>::value &&
    IsTriviallySerializable<decltype(__T__::f2)>::value &&
    IsTriviallySerializable<decltype(__T__::f2a)>::value &&
    IsTriviallySerializable<decltype(__T__::nested)>::value &&
    (sizeof(__T__) == (sizeof(__T__::f1) + sizeof(__T__::f1a) + sizeof(__T__::f2) + sizeof(__T__::f2a) + sizeof(__T__::nested))) &&
    offsetof(__T__, f1) < offsetof(__T__, f1a) && offsetof(__T__, f1a) < offsetof(__T__, f2) && offsetof(__T__, f2) < offsetof(__T__, f2a) && offsetof(__T__, f2a) < offsetof(__T__, nested);
};

template <>
struct IsTriviallySerializable<test_model::RecordContainingVectorsOfAliases> {
  using __T__ = test_model::RecordContainingVectorsOfAliases;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::strings)>::value &&
    IsTriviallySerializable<decltype(__T__::maps)>::value &&
    IsTriviallySerializable<decltype(__T__::arrays)>::value &&
    IsTriviallySerializable<decltype(__T__::tuples)>::value &&
    (sizeof(__T__) == (sizeof(__T__::strings) + sizeof(__T__::maps) + sizeof(__T__::arrays) + sizeof(__T__::tuples))) &&
    offsetof(__T__, strings) < offsetof(__T__, maps) && offsetof(__T__, maps) < offsetof(__T__, arrays) && offsetof(__T__, arrays) < offsetof(__T__, tuples);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithComputedFields> {
  using __T__ = test_model::RecordWithComputedFields;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::array_field)>::value &&
    IsTriviallySerializable<decltype(__T__::array_field_map_dimensions)>::value &&
    IsTriviallySerializable<decltype(__T__::dynamic_array_field)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_array_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int8_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint8_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int16_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint16_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::int64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::uint64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::size_field)>::value &&
    IsTriviallySerializable<decltype(__T__::float32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::float64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::complexfloat32_field)>::value &&
    IsTriviallySerializable<decltype(__T__::complexfloat64_field)>::value &&
    IsTriviallySerializable<decltype(__T__::string_field)>::value &&
    IsTriviallySerializable<decltype(__T__::tuple_field)>::value &&
    IsTriviallySerializable<decltype(__T__::vector_field)>::value &&
    IsTriviallySerializable<decltype(__T__::vector_of_vectors_field)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_vector_field)>::value &&
    IsTriviallySerializable<decltype(__T__::fixed_vector_of_vectors_field)>::value &&
    IsTriviallySerializable<decltype(__T__::optional_named_array)>::value &&
    IsTriviallySerializable<decltype(__T__::int_float_union)>::value &&
    IsTriviallySerializable<decltype(__T__::nullable_int_float_union)>::value &&
    IsTriviallySerializable<decltype(__T__::union_with_nested_generic_union)>::value &&
    IsTriviallySerializable<decltype(__T__::map_field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::array_field) + sizeof(__T__::array_field_map_dimensions) + sizeof(__T__::dynamic_array_field) + sizeof(__T__::fixed_array_field) + sizeof(__T__::int_field) + sizeof(__T__::int8_field) + sizeof(__T__::uint8_field) + sizeof(__T__::int16_field) + sizeof(__T__::uint16_field) + sizeof(__T__::uint32_field) + sizeof(__T__::int64_field) + sizeof(__T__::uint64_field) + sizeof(__T__::size_field) + sizeof(__T__::float32_field) + sizeof(__T__::float64_field) + sizeof(__T__::complexfloat32_field) + sizeof(__T__::complexfloat64_field) + sizeof(__T__::string_field) + sizeof(__T__::tuple_field) + sizeof(__T__::vector_field) + sizeof(__T__::vector_of_vectors_field) + sizeof(__T__::fixed_vector_field) + sizeof(__T__::fixed_vector_of_vectors_field) + sizeof(__T__::optional_named_array) + sizeof(__T__::int_float_union) + sizeof(__T__::nullable_int_float_union) + sizeof(__T__::union_with_nested_generic_union) + sizeof(__T__::map_field))) &&
    offsetof(__T__, array_field) < offsetof(__T__, array_field_map_dimensions) && offsetof(__T__, array_field_map_dimensions) < offsetof(__T__, dynamic_array_field) && offsetof(__T__, dynamic_array_field) < offsetof(__T__, fixed_array_field) && offsetof(__T__, fixed_array_field) < offsetof(__T__, int_field) && offsetof(__T__, int_field) < offsetof(__T__, int8_field) && offsetof(__T__, int8_field) < offsetof(__T__, uint8_field) && offsetof(__T__, uint8_field) < offsetof(__T__, int16_field) && offsetof(__T__, int16_field) < offsetof(__T__, uint16_field) && offsetof(__T__, uint16_field) < offsetof(__T__, uint32_field) && offsetof(__T__, uint32_field) < offsetof(__T__, int64_field) && offsetof(__T__, int64_field) < offsetof(__T__, uint64_field) && offsetof(__T__, uint64_field) < offsetof(__T__, size_field) && offsetof(__T__, size_field) < offsetof(__T__, float32_field) && offsetof(__T__, float32_field) < offsetof(__T__, float64_field) && offsetof(__T__, float64_field) < offsetof(__T__, complexfloat32_field) && offsetof(__T__, complexfloat32_field) < offsetof(__T__, complexfloat64_field) && offsetof(__T__, complexfloat64_field) < offsetof(__T__, string_field) && offsetof(__T__, string_field) < offsetof(__T__, tuple_field) && offsetof(__T__, tuple_field) < offsetof(__T__, vector_field) && offsetof(__T__, vector_field) < offsetof(__T__, vector_of_vectors_field) && offsetof(__T__, vector_of_vectors_field) < offsetof(__T__, fixed_vector_field) && offsetof(__T__, fixed_vector_field) < offsetof(__T__, fixed_vector_of_vectors_field) && offsetof(__T__, fixed_vector_of_vectors_field) < offsetof(__T__, optional_named_array) && offsetof(__T__, optional_named_array) < offsetof(__T__, int_float_union) && offsetof(__T__, int_float_union) < offsetof(__T__, nullable_int_float_union) && offsetof(__T__, nullable_int_float_union) < offsetof(__T__, union_with_nested_generic_union) && offsetof(__T__, union_with_nested_generic_union) < offsetof(__T__, map_field);
};

template <>
struct IsTriviallySerializable<test_model::RecordNotUsedInProtocol> {
  using __T__ = test_model::RecordNotUsedInProtocol;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::u1)>::value &&
    IsTriviallySerializable<decltype(__T__::u2)>::value &&
    (sizeof(__T__) == (sizeof(__T__::u1) + sizeof(__T__::u2))) &&
    offsetof(__T__, u1) < offsetof(__T__, u2);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithKeywordFields> {
  using __T__ = test_model::RecordWithKeywordFields;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::int_field)>::value &&
    IsTriviallySerializable<decltype(__T__::sizeof_field)>::value &&
    IsTriviallySerializable<decltype(__T__::if_field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::int_field) + sizeof(__T__::sizeof_field) + sizeof(__T__::if_field))) &&
    offsetof(__T__, int_field) < offsetof(__T__, sizeof_field) && offsetof(__T__, sizeof_field) < offsetof(__T__, if_field);
};

template <>
struct IsTriviallySerializable<test_model::RecordWithOptionalDate> {
  using __T__ = test_model::RecordWithOptionalDate;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::date_field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::date_field)));
};

#ifndef _MSC_VER
#pragma GCC diagnostic pop // #pragma GCC diagnostic ignored "-Winvalid-offsetof" 
#endif
} //namespace yardl::binary 

namespace {
template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1, T2> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  case 2: {
    T2 const& v = std::get<2>(value);
    WriteT2(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1, T2>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    case 2: {
      T2 v;
      ReadT2(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2, typename T3, yardl::binary::Writer<T3> WriteT3, typename T4, yardl::binary::Writer<T4> WriteT4>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1, T2, T3, T4> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  case 2: {
    T2 const& v = std::get<2>(value);
    WriteT2(stream, v);
    break;
  }
  case 3: {
    T3 const& v = std::get<3>(value);
    WriteT3(stream, v);
    break;
  }
  case 4: {
    T4 const& v = std::get<4>(value);
    WriteT4(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2, typename T3, yardl::binary::Reader<T3> ReadT3, typename T4, yardl::binary::Reader<T4> ReadT4>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1, T2, T3, T4>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    case 2: {
      T2 v;
      ReadT2(stream, v);
      value = std::move(v);
      break;
    }
    case 3: {
      T3 v;
      ReadT3(stream, v);
      value = std::move(v);
      break;
    }
    case 4: {
      T4 v;
      ReadT4(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}
} // namespace

namespace tuples::binary {
namespace {
template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteTuple(yardl::binary::CodedOutputStream& stream, tuples::Tuple<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<tuples::Tuple<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteT1(stream, value.v1);
  WriteT2(stream, value.v2);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadTuple(yardl::binary::CodedInputStream& stream, tuples::Tuple<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<tuples::Tuple<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadT1(stream, value.v1);
  ReadT2(stream, value.v2);
}

} // namespace

} // namespace tuples::binary

namespace basic_types::binary {
namespace {
template<typename K, yardl::binary::Writer<K> WriteK, typename V, yardl::binary::Writer<V> WriteV>
[[maybe_unused]] void WriteAliasedMap(yardl::binary::CodedOutputStream& stream, basic_types::AliasedMap<K, V> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::AliasedMap<K, V>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteMap<K, V, WriteK, WriteV>(stream, value);
}

template<typename K, yardl::binary::Reader<K> ReadK, typename V, yardl::binary::Reader<V> ReadV>
[[maybe_unused]] void ReadAliasedMap(yardl::binary::CodedInputStream& stream, basic_types::AliasedMap<K, V>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::AliasedMap<K, V>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadMap<K, V, ReadK, ReadV>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteMyTuple(yardl::binary::CodedOutputStream& stream, basic_types::MyTuple<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::MyTuple<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  tuples::binary::WriteTuple<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadMyTuple(yardl::binary::CodedInputStream& stream, basic_types::MyTuple<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::MyTuple<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  tuples::binary::ReadTuple<T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericUnion2(yardl::binary::CodedOutputStream& stream, basic_types::GenericUnion2<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericUnion2<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericUnion2(yardl::binary::CodedInputStream& stream, basic_types::GenericUnion2<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericUnion2<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericNullableUnion2(yardl::binary::CodedOutputStream& stream, basic_types::GenericNullableUnion2<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericNullableUnion2<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<std::monostate, yardl::binary::WriteMonostate, T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericNullableUnion2(yardl::binary::CodedInputStream& stream, basic_types::GenericNullableUnion2<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericNullableUnion2<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<std::monostate, yardl::binary::ReadMonostate, T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteGenericVector(yardl::binary::CodedOutputStream& stream, basic_types::GenericVector<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericVector<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<T, WriteT>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadGenericVector(yardl::binary::CodedInputStream& stream, basic_types::GenericVector<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericVector<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<T, ReadT>(stream, value);
}

[[maybe_unused]] void WriteRecordWithString(yardl::binary::CodedOutputStream& stream, basic_types::RecordWithString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::RecordWithString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.i);
}

[[maybe_unused]] void ReadRecordWithString(yardl::binary::CodedInputStream& stream, basic_types::RecordWithString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::RecordWithString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.i);
}

[[maybe_unused]] void WriteRecordWithUnions(yardl::binary::CodedOutputStream& stream, basic_types::RecordWithUnions const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::RecordWithUnions>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream, value.null_or_int_or_string);
  WriteUnion<yardl::Time, yardl::binary::WriteTime, yardl::DateTime, yardl::binary::WriteDateTime>(stream, value.date_or_datetime);
  basic_types::binary::WriteGenericNullableUnion2<basic_types::Fruits, yardl::binary::WriteEnum<basic_types::Fruits>, basic_types::DaysOfWeek, yardl::binary::WriteFlags<basic_types::DaysOfWeek>>(stream, value.null_or_fruits_or_days_of_week);
  WriteUnion<basic_types::RecordWithString, basic_types::binary::WriteRecordWithString, int32_t, yardl::binary::WriteInteger>(stream, value.record_or_int);
}

[[maybe_unused]] void ReadRecordWithUnions(yardl::binary::CodedInputStream& stream, basic_types::RecordWithUnions& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::RecordWithUnions>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream, value.null_or_int_or_string);
  ReadUnion<yardl::Time, yardl::binary::ReadTime, yardl::DateTime, yardl::binary::ReadDateTime>(stream, value.date_or_datetime);
  basic_types::binary::ReadGenericNullableUnion2<basic_types::Fruits, yardl::binary::ReadEnum<basic_types::Fruits>, basic_types::DaysOfWeek, yardl::binary::ReadFlags<basic_types::DaysOfWeek>>(stream, value.null_or_fruits_or_days_of_week);
  ReadUnion<basic_types::RecordWithString, basic_types::binary::ReadRecordWithString, int32_t, yardl::binary::ReadInteger>(stream, value.record_or_int);
}

template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1>
[[maybe_unused]] void WriteGenericRecordWithComputedFields(yardl::binary::CodedOutputStream& stream, basic_types::GenericRecordWithComputedFields<T0, T1> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericRecordWithComputedFields<T0, T1>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<T0, WriteT0, T1, WriteT1>(stream, value.f1);
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1>
[[maybe_unused]] void ReadGenericRecordWithComputedFields(yardl::binary::CodedInputStream& stream, basic_types::GenericRecordWithComputedFields<T0, T1>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<basic_types::GenericRecordWithComputedFields<T0, T1>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<T0, ReadT0, T1, ReadT1>(stream, value.f1);
}

} // namespace

} // namespace basic_types::binary

namespace image::binary {
namespace {
template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteImage(yardl::binary::CodedOutputStream& stream, image::Image<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<image::Image<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<T, WriteT, 2>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadImage(yardl::binary::CodedInputStream& stream, image::Image<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<image::Image<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<T, ReadT, 2>(stream, value);
}

[[maybe_unused]] void WriteFloatImage(yardl::binary::CodedOutputStream& stream, image::FloatImage const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<image::FloatImage>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  image::binary::WriteImage<float, yardl::binary::WriteFloatingPoint>(stream, value);
}

[[maybe_unused]] void ReadFloatImage(yardl::binary::CodedInputStream& stream, image::FloatImage& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<image::FloatImage>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  image::binary::ReadImage<float, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteIntImage(yardl::binary::CodedOutputStream& stream, image::IntImage const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<image::IntImage>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  image::binary::WriteImage<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadIntImage(yardl::binary::CodedInputStream& stream, image::IntImage& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<image::IntImage>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  image::binary::ReadImage<int32_t, yardl::binary::ReadInteger>(stream, value);
}

} // namespace

} // namespace image::binary

namespace test_model::binary {
namespace {
[[maybe_unused]] void WriteSmallBenchmarkRecord(yardl::binary::CodedOutputStream& stream, test_model::SmallBenchmarkRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SmallBenchmarkRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.a);
  yardl::binary::WriteFloatingPoint(stream, value.b);
  yardl::binary::WriteFloatingPoint(stream, value.c);
}

[[maybe_unused]] void ReadSmallBenchmarkRecord(yardl::binary::CodedInputStream& stream, test_model::SmallBenchmarkRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SmallBenchmarkRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.a);
  yardl::binary::ReadFloatingPoint(stream, value.b);
  yardl::binary::ReadFloatingPoint(stream, value.c);
}

[[maybe_unused]] void WriteSimpleEncodingCounters(yardl::binary::CodedOutputStream& stream, test_model::SimpleEncodingCounters const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleEncodingCounters>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.e1);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.e2);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.slice);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.repetition);
}

[[maybe_unused]] void ReadSimpleEncodingCounters(yardl::binary::CodedInputStream& stream, test_model::SimpleEncodingCounters& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleEncodingCounters>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.e1);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.e2);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.slice);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.repetition);
}

[[maybe_unused]] void WriteSimpleAcquisition(yardl::binary::CodedOutputStream& stream, test_model::SimpleAcquisition const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleAcquisition>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.flags);
  test_model::binary::WriteSimpleEncodingCounters(stream, value.idx);
  yardl::binary::WriteNDArray<std::complex<float>, yardl::binary::WriteFloatingPoint, 2>(stream, value.data);
  yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 2>(stream, value.trajectory);
}

[[maybe_unused]] void ReadSimpleAcquisition(yardl::binary::CodedInputStream& stream, test_model::SimpleAcquisition& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleAcquisition>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.flags);
  test_model::binary::ReadSimpleEncodingCounters(stream, value.idx);
  yardl::binary::ReadNDArray<std::complex<float>, yardl::binary::ReadFloatingPoint, 2>(stream, value.data);
  yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 2>(stream, value.trajectory);
}

[[maybe_unused]] void WriteSimpleRecord(yardl::binary::CodedOutputStream& stream, test_model::SimpleRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.x);
  yardl::binary::WriteInteger(stream, value.y);
  yardl::binary::WriteInteger(stream, value.z);
}

[[maybe_unused]] void ReadSimpleRecord(yardl::binary::CodedInputStream& stream, test_model::SimpleRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.x);
  yardl::binary::ReadInteger(stream, value.y);
  yardl::binary::ReadInteger(stream, value.z);
}

[[maybe_unused]] void WriteRecordWithPrimitives(yardl::binary::CodedOutputStream& stream, test_model::RecordWithPrimitives const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithPrimitives>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.bool_field);
  yardl::binary::WriteInteger(stream, value.int8_field);
  yardl::binary::WriteInteger(stream, value.uint8_field);
  yardl::binary::WriteInteger(stream, value.int16_field);
  yardl::binary::WriteInteger(stream, value.uint16_field);
  yardl::binary::WriteInteger(stream, value.int32_field);
  yardl::binary::WriteInteger(stream, value.uint32_field);
  yardl::binary::WriteInteger(stream, value.int64_field);
  yardl::binary::WriteInteger(stream, value.uint64_field);
  yardl::binary::WriteInteger(stream, value.size_field);
  yardl::binary::WriteFloatingPoint(stream, value.float32_field);
  yardl::binary::WriteFloatingPoint(stream, value.float64_field);
  yardl::binary::WriteFloatingPoint(stream, value.complexfloat32_field);
  yardl::binary::WriteFloatingPoint(stream, value.complexfloat64_field);
  yardl::binary::WriteDate(stream, value.date_field);
  yardl::binary::WriteTime(stream, value.time_field);
  yardl::binary::WriteDateTime(stream, value.datetime_field);
}

[[maybe_unused]] void ReadRecordWithPrimitives(yardl::binary::CodedInputStream& stream, test_model::RecordWithPrimitives& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithPrimitives>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.bool_field);
  yardl::binary::ReadInteger(stream, value.int8_field);
  yardl::binary::ReadInteger(stream, value.uint8_field);
  yardl::binary::ReadInteger(stream, value.int16_field);
  yardl::binary::ReadInteger(stream, value.uint16_field);
  yardl::binary::ReadInteger(stream, value.int32_field);
  yardl::binary::ReadInteger(stream, value.uint32_field);
  yardl::binary::ReadInteger(stream, value.int64_field);
  yardl::binary::ReadInteger(stream, value.uint64_field);
  yardl::binary::ReadInteger(stream, value.size_field);
  yardl::binary::ReadFloatingPoint(stream, value.float32_field);
  yardl::binary::ReadFloatingPoint(stream, value.float64_field);
  yardl::binary::ReadFloatingPoint(stream, value.complexfloat32_field);
  yardl::binary::ReadFloatingPoint(stream, value.complexfloat64_field);
  yardl::binary::ReadDate(stream, value.date_field);
  yardl::binary::ReadTime(stream, value.time_field);
  yardl::binary::ReadDateTime(stream, value.datetime_field);
}

[[maybe_unused]] void WriteRecordWithPrimitiveAliases(yardl::binary::CodedOutputStream& stream, test_model::RecordWithPrimitiveAliases const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithPrimitiveAliases>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.byte_field);
  yardl::binary::WriteInteger(stream, value.int_field);
  yardl::binary::WriteInteger(stream, value.uint_field);
  yardl::binary::WriteInteger(stream, value.long_field);
  yardl::binary::WriteInteger(stream, value.ulong_field);
  yardl::binary::WriteFloatingPoint(stream, value.float_field);
  yardl::binary::WriteFloatingPoint(stream, value.double_field);
  yardl::binary::WriteFloatingPoint(stream, value.complexfloat_field);
  yardl::binary::WriteFloatingPoint(stream, value.complexdouble_field);
}

[[maybe_unused]] void ReadRecordWithPrimitiveAliases(yardl::binary::CodedInputStream& stream, test_model::RecordWithPrimitiveAliases& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithPrimitiveAliases>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.byte_field);
  yardl::binary::ReadInteger(stream, value.int_field);
  yardl::binary::ReadInteger(stream, value.uint_field);
  yardl::binary::ReadInteger(stream, value.long_field);
  yardl::binary::ReadInteger(stream, value.ulong_field);
  yardl::binary::ReadFloatingPoint(stream, value.float_field);
  yardl::binary::ReadFloatingPoint(stream, value.double_field);
  yardl::binary::ReadFloatingPoint(stream, value.complexfloat_field);
  yardl::binary::ReadFloatingPoint(stream, value.complexdouble_field);
}

[[maybe_unused]] void WriteTupleWithRecords(yardl::binary::CodedOutputStream& stream, test_model::TupleWithRecords const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::TupleWithRecords>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteSimpleRecord(stream, value.a);
  test_model::binary::WriteSimpleRecord(stream, value.b);
}

[[maybe_unused]] void ReadTupleWithRecords(yardl::binary::CodedInputStream& stream, test_model::TupleWithRecords& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::TupleWithRecords>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadSimpleRecord(stream, value.a);
  test_model::binary::ReadSimpleRecord(stream, value.b);
}

[[maybe_unused]] void WriteRecordWithVectors(yardl::binary::CodedOutputStream& stream, test_model::RecordWithVectors const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVectors>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, value.default_vector);
  yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>(stream, value.default_vector_fixed_length);
  yardl::binary::WriteVector<std::array<int32_t, 2>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 2>>(stream, value.vector_of_vectors);
}

[[maybe_unused]] void ReadRecordWithVectors(yardl::binary::CodedInputStream& stream, test_model::RecordWithVectors& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVectors>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, value.default_vector);
  yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>(stream, value.default_vector_fixed_length);
  yardl::binary::ReadVector<std::array<int32_t, 2>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 2>>(stream, value.vector_of_vectors);
}

[[maybe_unused]] void WriteRecordWithVectorOfTimes(yardl::binary::CodedOutputStream& stream, test_model::RecordWithVectorOfTimes const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVectorOfTimes>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<yardl::Time, yardl::binary::WriteTime>(stream, value.times);
}

[[maybe_unused]] void ReadRecordWithVectorOfTimes(yardl::binary::CodedInputStream& stream, test_model::RecordWithVectorOfTimes& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVectorOfTimes>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<yardl::Time, yardl::binary::ReadTime>(stream, value.times);
}

[[maybe_unused]] void WriteRecordWithArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithArrays const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithArrays>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.default_array);
  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.default_array_with_empty_dimension);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 1>(stream, value.rank_1_array);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.rank_2_array);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.rank_2_array_with_named_dimensions);
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3, 4>(stream, value.rank_2_fixed_array);
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3, 4>(stream, value.rank_2_fixed_array_with_named_dimensions);
  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.dynamic_array);
  yardl::binary::WriteFixedNDArray<std::array<int32_t, 4>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 4>, 5>(stream, value.array_of_vectors);
}

[[maybe_unused]] void ReadRecordWithArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithArrays& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithArrays>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.default_array);
  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.default_array_with_empty_dimension);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 1>(stream, value.rank_1_array);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.rank_2_array);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.rank_2_array_with_named_dimensions);
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3, 4>(stream, value.rank_2_fixed_array);
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3, 4>(stream, value.rank_2_fixed_array_with_named_dimensions);
  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.dynamic_array);
  yardl::binary::ReadFixedNDArray<std::array<int32_t, 4>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 4>, 5>(stream, value.array_of_vectors);
}

[[maybe_unused]] void WriteRecordWithArraysSimpleSyntax(yardl::binary::CodedOutputStream& stream, test_model::RecordWithArraysSimpleSyntax const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithArraysSimpleSyntax>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.default_array);
  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.default_array_with_empty_dimension);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 1>(stream, value.rank_1_array);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.rank_2_array);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.rank_2_array_with_named_dimensions);
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3, 4>(stream, value.rank_2_fixed_array);
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3, 4>(stream, value.rank_2_fixed_array_with_named_dimensions);
  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.dynamic_array);
  yardl::binary::WriteFixedNDArray<std::array<int32_t, 4>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 4>, 5>(stream, value.array_of_vectors);
}

[[maybe_unused]] void ReadRecordWithArraysSimpleSyntax(yardl::binary::CodedInputStream& stream, test_model::RecordWithArraysSimpleSyntax& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithArraysSimpleSyntax>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.default_array);
  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.default_array_with_empty_dimension);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 1>(stream, value.rank_1_array);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.rank_2_array);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.rank_2_array_with_named_dimensions);
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3, 4>(stream, value.rank_2_fixed_array);
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3, 4>(stream, value.rank_2_fixed_array_with_named_dimensions);
  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.dynamic_array);
  yardl::binary::ReadFixedNDArray<std::array<int32_t, 4>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 4>, 5>(stream, value.array_of_vectors);
}

[[maybe_unused]] void WriteRecordWithOptionalFields(yardl::binary::CodedOutputStream& stream, test_model::RecordWithOptionalFields const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalFields>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream, value.optional_int);
  yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream, value.optional_int_alternate_syntax);
  yardl::binary::WriteOptional<yardl::Time, yardl::binary::WriteTime>(stream, value.optional_time);
}

[[maybe_unused]] void ReadRecordWithOptionalFields(yardl::binary::CodedInputStream& stream, test_model::RecordWithOptionalFields& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalFields>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream, value.optional_int);
  yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream, value.optional_int_alternate_syntax);
  yardl::binary::ReadOptional<yardl::Time, yardl::binary::ReadTime>(stream, value.optional_time);
}

[[maybe_unused]] void WriteRecordWithVlens(yardl::binary::CodedOutputStream& stream, test_model::RecordWithVlens const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVlens>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream, value.a);
  yardl::binary::WriteInteger(stream, value.b);
  yardl::binary::WriteInteger(stream, value.c);
}

[[maybe_unused]] void ReadRecordWithVlens(yardl::binary::CodedInputStream& stream, test_model::RecordWithVlens& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVlens>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream, value.a);
  yardl::binary::ReadInteger(stream, value.b);
  yardl::binary::ReadInteger(stream, value.c);
}

[[maybe_unused]] void WriteRecordWithStrings(yardl::binary::CodedOutputStream& stream, test_model::RecordWithStrings const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithStrings>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.a);
  yardl::binary::WriteString(stream, value.b);
}

[[maybe_unused]] void ReadRecordWithStrings(yardl::binary::CodedInputStream& stream, test_model::RecordWithStrings& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithStrings>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.a);
  yardl::binary::ReadString(stream, value.b);
}

[[maybe_unused]] void WriteRecordWithOptionalVector(yardl::binary::CodedOutputStream& stream, test_model::RecordWithOptionalVector const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalVector>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<std::vector<int32_t>, yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>>(stream, value.optional_vector);
}

[[maybe_unused]] void ReadRecordWithOptionalVector(yardl::binary::CodedInputStream& stream, test_model::RecordWithOptionalVector& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalVector>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<std::vector<int32_t>, yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>>(stream, value.optional_vector);
}

[[maybe_unused]] void WriteRecordWithFixedVectors(yardl::binary::CodedOutputStream& stream, test_model::RecordWithFixedVectors const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFixedVectors>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 5>(stream, value.fixed_int_vector);
  yardl::binary::WriteArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 3>(stream, value.fixed_simple_record_vector);
  yardl::binary::WriteArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2>(stream, value.fixed_record_with_vlens_vector);
}

[[maybe_unused]] void ReadRecordWithFixedVectors(yardl::binary::CodedInputStream& stream, test_model::RecordWithFixedVectors& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFixedVectors>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 5>(stream, value.fixed_int_vector);
  yardl::binary::ReadArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 3>(stream, value.fixed_simple_record_vector);
  yardl::binary::ReadArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2>(stream, value.fixed_record_with_vlens_vector);
}

[[maybe_unused]] void WriteRecordWithFixedArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithFixedArrays const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFixedArrays>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 2, 3>(stream, value.ints);
  yardl::binary::WriteFixedNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 3, 2>(stream, value.fixed_simple_record_array);
  yardl::binary::WriteFixedNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2, 2>(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void ReadRecordWithFixedArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithFixedArrays& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFixedArrays>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 2, 3>(stream, value.ints);
  yardl::binary::ReadFixedNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 3, 2>(stream, value.fixed_simple_record_array);
  yardl::binary::ReadFixedNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2, 2>(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void WriteIntArray(yardl::binary::CodedOutputStream& stream, test_model::IntArray const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::IntArray>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadIntArray(yardl::binary::CodedInputStream& stream, test_model::IntArray& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::IntArray>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteIntRank2Array(yardl::binary::CodedOutputStream& stream, test_model::IntRank2Array const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::IntRank2Array>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value);
}

[[maybe_unused]] void ReadIntRank2Array(yardl::binary::CodedInputStream& stream, test_model::IntRank2Array& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::IntRank2Array>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value);
}

[[maybe_unused]] void WriteIntFixedArray(yardl::binary::CodedOutputStream& stream, test_model::IntFixedArray const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::IntFixedArray>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 2, 3>(stream, value);
}

[[maybe_unused]] void ReadIntFixedArray(yardl::binary::CodedInputStream& stream, test_model::IntFixedArray& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::IntFixedArray>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 2, 3>(stream, value);
}

[[maybe_unused]] void WriteSimpleRecordFixedArray(yardl::binary::CodedOutputStream& stream, test_model::SimpleRecordFixedArray const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleRecordFixedArray>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 3, 2>(stream, value);
}

[[maybe_unused]] void ReadSimpleRecordFixedArray(yardl::binary::CodedInputStream& stream, test_model::SimpleRecordFixedArray& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::SimpleRecordFixedArray>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 3, 2>(stream, value);
}

[[maybe_unused]] void WriteRecordWithVlensFixedArray(yardl::binary::CodedOutputStream& stream, test_model::RecordWithVlensFixedArray const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVlensFixedArray>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2, 2>(stream, value);
}

[[maybe_unused]] void ReadRecordWithVlensFixedArray(yardl::binary::CodedInputStream& stream, test_model::RecordWithVlensFixedArray& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVlensFixedArray>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2, 2>(stream, value);
}

[[maybe_unused]] void WriteRecordWithNamedFixedArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithNamedFixedArrays const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNamedFixedArrays>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteIntFixedArray(stream, value.ints);
  test_model::binary::WriteSimpleRecordFixedArray(stream, value.fixed_simple_record_array);
  test_model::binary::WriteRecordWithVlensFixedArray(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void ReadRecordWithNamedFixedArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithNamedFixedArrays& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNamedFixedArrays>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadIntFixedArray(stream, value.ints);
  test_model::binary::ReadSimpleRecordFixedArray(stream, value.fixed_simple_record_array);
  test_model::binary::ReadRecordWithVlensFixedArray(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void WriteRecordWithNDArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithNDArrays const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNDArrays>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.ints);
  yardl::binary::WriteNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 2>(stream, value.fixed_simple_record_array);
  yardl::binary::WriteNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2>(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void ReadRecordWithNDArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithNDArrays& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNDArrays>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.ints);
  yardl::binary::ReadNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 2>(stream, value.fixed_simple_record_array);
  yardl::binary::ReadNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2>(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void WriteRecordWithNDArraysSingleDimension(yardl::binary::CodedOutputStream& stream, test_model::RecordWithNDArraysSingleDimension const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNDArraysSingleDimension>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 1>(stream, value.ints);
  yardl::binary::WriteNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 1>(stream, value.fixed_simple_record_array);
  yardl::binary::WriteNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 1>(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void ReadRecordWithNDArraysSingleDimension(yardl::binary::CodedInputStream& stream, test_model::RecordWithNDArraysSingleDimension& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNDArraysSingleDimension>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 1>(stream, value.ints);
  yardl::binary::ReadNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 1>(stream, value.fixed_simple_record_array);
  yardl::binary::ReadNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 1>(stream, value.fixed_record_with_vlens_array);
}

[[maybe_unused]] void WriteRecordWithDynamicNDArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithDynamicNDArrays const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithDynamicNDArrays>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteIntArray(stream, value.ints);
  yardl::binary::WriteDynamicNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream, value.simple_record_array);
  yardl::binary::WriteDynamicNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens>(stream, value.record_with_vlens_array);
}

[[maybe_unused]] void ReadRecordWithDynamicNDArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithDynamicNDArrays& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithDynamicNDArrays>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadIntArray(stream, value.ints);
  yardl::binary::ReadDynamicNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream, value.simple_record_array);
  yardl::binary::ReadDynamicNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens>(stream, value.record_with_vlens_array);
}

[[maybe_unused]] void WriteNamedFixedNDArray(yardl::binary::CodedOutputStream& stream, test_model::NamedFixedNDArray const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::NamedFixedNDArray>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 2, 4>(stream, value);
}

[[maybe_unused]] void ReadNamedFixedNDArray(yardl::binary::CodedInputStream& stream, test_model::NamedFixedNDArray& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::NamedFixedNDArray>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 2, 4>(stream, value);
}

[[maybe_unused]] void WriteRecordWithFixedCollections(yardl::binary::CodedOutputStream& stream, test_model::RecordWithFixedCollections const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFixedCollections>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>(stream, value.fixed_vector);
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 2, 3>(stream, value.fixed_array);
}

[[maybe_unused]] void ReadRecordWithFixedCollections(yardl::binary::CodedInputStream& stream, test_model::RecordWithFixedCollections& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFixedCollections>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>(stream, value.fixed_vector);
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 2, 3>(stream, value.fixed_array);
}

[[maybe_unused]] void WriteRecordWithVlenCollections(yardl::binary::CodedOutputStream& stream, test_model::RecordWithVlenCollections const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVlenCollections>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, value.vector);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.array);
}

[[maybe_unused]] void ReadRecordWithVlenCollections(yardl::binary::CodedInputStream& stream, test_model::RecordWithVlenCollections& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithVlenCollections>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, value.vector);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.array);
}

[[maybe_unused]] void WriteRecordWithUnionsOfContainers(yardl::binary::CodedOutputStream& stream, test_model::RecordWithUnionsOfContainers const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithUnionsOfContainers>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<std::unordered_map<std::string, int32_t>, yardl::binary::WriteMap<std::string, int32_t, yardl::binary::WriteString, yardl::binary::WriteInteger>, int32_t, yardl::binary::WriteInteger>(stream, value.map_or_scalar);
  WriteUnion<std::vector<int32_t>, yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>, int32_t, yardl::binary::WriteInteger>(stream, value.vector_or_scalar);
  WriteUnion<yardl::DynamicNDArray<int32_t>, yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>, int32_t, yardl::binary::WriteInteger>(stream, value.array_or_scalar);
}

[[maybe_unused]] void ReadRecordWithUnionsOfContainers(yardl::binary::CodedInputStream& stream, test_model::RecordWithUnionsOfContainers& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithUnionsOfContainers>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<std::unordered_map<std::string, int32_t>, yardl::binary::ReadMap<std::string, int32_t, yardl::binary::ReadString, yardl::binary::ReadInteger>, int32_t, yardl::binary::ReadInteger>(stream, value.map_or_scalar);
  ReadUnion<std::vector<int32_t>, yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>, int32_t, yardl::binary::ReadInteger>(stream, value.vector_or_scalar);
  ReadUnion<yardl::DynamicNDArray<int32_t>, yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>, int32_t, yardl::binary::ReadInteger>(stream, value.array_or_scalar);
}

[[maybe_unused]] void WriteNamedNDArray(yardl::binary::CodedOutputStream& stream, test_model::NamedNDArray const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::NamedNDArray>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value);
}

[[maybe_unused]] void ReadNamedNDArray(yardl::binary::CodedInputStream& stream, test_model::NamedNDArray& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::NamedNDArray>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value);
}

[[maybe_unused]] void WriteRecordWithMaps(yardl::binary::CodedOutputStream& stream, test_model::RecordWithMaps const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithMaps>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteMap<uint32_t, uint32_t, yardl::binary::WriteInteger, yardl::binary::WriteInteger>(stream, value.set_1);
  yardl::binary::WriteMap<int32_t, bool, yardl::binary::WriteInteger, yardl::binary::WriteInteger>(stream, value.set_2);
}

[[maybe_unused]] void ReadRecordWithMaps(yardl::binary::CodedInputStream& stream, test_model::RecordWithMaps& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithMaps>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadMap<uint32_t, uint32_t, yardl::binary::ReadInteger, yardl::binary::ReadInteger>(stream, value.set_1);
  yardl::binary::ReadMap<int32_t, bool, yardl::binary::ReadInteger, yardl::binary::ReadInteger>(stream, value.set_2);
}

[[maybe_unused]] void WriteFruits(yardl::binary::CodedOutputStream& stream, test_model::Fruits const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::Fruits>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteEnum<basic_types::Fruits>(stream, value);
}

[[maybe_unused]] void ReadFruits(yardl::binary::CodedInputStream& stream, test_model::Fruits& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::Fruits>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadEnum<basic_types::Fruits>(stream, value);
}

[[maybe_unused]] void WriteDaysOfWeek(yardl::binary::CodedOutputStream& stream, test_model::DaysOfWeek const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::DaysOfWeek>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFlags<basic_types::DaysOfWeek>(stream, value);
}

[[maybe_unused]] void ReadDaysOfWeek(yardl::binary::CodedInputStream& stream, test_model::DaysOfWeek& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::DaysOfWeek>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFlags<basic_types::DaysOfWeek>(stream, value);
}

[[maybe_unused]] void WriteTextFormat(yardl::binary::CodedOutputStream& stream, test_model::TextFormat const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::TextFormat>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFlags<basic_types::TextFormat>(stream, value);
}

[[maybe_unused]] void ReadTextFormat(yardl::binary::CodedInputStream& stream, test_model::TextFormat& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::TextFormat>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFlags<basic_types::TextFormat>(stream, value);
}

[[maybe_unused]] void WriteRecordWithNoDefaultEnum(yardl::binary::CodedOutputStream& stream, test_model::RecordWithNoDefaultEnum const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNoDefaultEnum>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteFruits(stream, value.enum_field);
}

[[maybe_unused]] void ReadRecordWithNoDefaultEnum(yardl::binary::CodedInputStream& stream, test_model::RecordWithNoDefaultEnum& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithNoDefaultEnum>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadFruits(stream, value.enum_field);
}

[[maybe_unused]] void WriteRecordWithEnums(yardl::binary::CodedOutputStream& stream, test_model::RecordWithEnums const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithEnums>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteFruits(stream, value.enum_field);
  test_model::binary::WriteDaysOfWeek(stream, value.flags);
  test_model::binary::WriteTextFormat(stream, value.flags_2);
  test_model::binary::WriteRecordWithNoDefaultEnum(stream, value.rec);
}

[[maybe_unused]] void ReadRecordWithEnums(yardl::binary::CodedInputStream& stream, test_model::RecordWithEnums& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithEnums>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadFruits(stream, value.enum_field);
  test_model::binary::ReadDaysOfWeek(stream, value.flags);
  test_model::binary::ReadTextFormat(stream, value.flags_2);
  test_model::binary::ReadRecordWithNoDefaultEnum(stream, value.rec);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteImage(yardl::binary::CodedOutputStream& stream, test_model::Image<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::Image<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  image::binary::WriteImage<T, WriteT>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadImage(yardl::binary::CodedInputStream& stream, test_model::Image<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::Image<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  image::binary::ReadImage<T, ReadT>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericRecord(yardl::binary::CodedOutputStream& stream, test_model::GenericRecord<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericRecord<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteT1(stream, value.scalar_1);
  WriteT2(stream, value.scalar_2);
  yardl::binary::WriteVector<T1, WriteT1>(stream, value.vector_1);
  test_model::binary::WriteImage<T2, WriteT2>(stream, value.image_2);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericRecord(yardl::binary::CodedInputStream& stream, test_model::GenericRecord<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericRecord<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadT1(stream, value.scalar_1);
  ReadT2(stream, value.scalar_2);
  yardl::binary::ReadVector<T1, ReadT1>(stream, value.vector_1);
  test_model::binary::ReadImage<T2, ReadT2>(stream, value.image_2);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteMyTuple(yardl::binary::CodedOutputStream& stream, test_model::MyTuple<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::MyTuple<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::WriteMyTuple<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadMyTuple(yardl::binary::CodedInputStream& stream, test_model::MyTuple<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::MyTuple<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::ReadMyTuple<T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteAliasedTuple(yardl::binary::CodedOutputStream& stream, test_model::AliasedTuple<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedTuple<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteMyTuple<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadAliasedTuple(yardl::binary::CodedInputStream& stream, test_model::AliasedTuple<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedTuple<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadMyTuple<T1, ReadT1, T2, ReadT2>(stream, value);
}

[[maybe_unused]] void WriteRecordWithAliasedGenerics(yardl::binary::CodedOutputStream& stream, test_model::RecordWithAliasedGenerics const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithAliasedGenerics>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteMyTuple<std::string, yardl::binary::WriteString, std::string, yardl::binary::WriteString>(stream, value.my_strings);
  test_model::binary::WriteAliasedTuple<std::string, yardl::binary::WriteString, std::string, yardl::binary::WriteString>(stream, value.aliased_strings);
}

[[maybe_unused]] void ReadRecordWithAliasedGenerics(yardl::binary::CodedInputStream& stream, test_model::RecordWithAliasedGenerics& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithAliasedGenerics>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadMyTuple<std::string, yardl::binary::ReadString, std::string, yardl::binary::ReadString>(stream, value.my_strings);
  test_model::binary::ReadAliasedTuple<std::string, yardl::binary::ReadString, std::string, yardl::binary::ReadString>(stream, value.aliased_strings);
}

[[maybe_unused]] void WriteAliasedString(yardl::binary::CodedOutputStream& stream, test_model::AliasedString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value);
}

[[maybe_unused]] void ReadAliasedString(yardl::binary::CodedInputStream& stream, test_model::AliasedString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value);
}

[[maybe_unused]] void WriteAliasedEnum(yardl::binary::CodedOutputStream& stream, test_model::AliasedEnum const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedEnum>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteFruits(stream, value);
}

[[maybe_unused]] void ReadAliasedEnum(yardl::binary::CodedInputStream& stream, test_model::AliasedEnum& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedEnum>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadFruits(stream, value);
}

[[maybe_unused]] void WriteAliasedSimpleRecord(yardl::binary::CodedOutputStream& stream, test_model::AliasedSimpleRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedSimpleRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteSimpleRecord(stream, value);
}

[[maybe_unused]] void ReadAliasedSimpleRecord(yardl::binary::CodedInputStream& stream, test_model::AliasedSimpleRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedSimpleRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadSimpleRecord(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteAliasedOpenGeneric(yardl::binary::CodedOutputStream& stream, test_model::AliasedOpenGeneric<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedOpenGeneric<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteAliasedTuple<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadAliasedOpenGeneric(yardl::binary::CodedInputStream& stream, test_model::AliasedOpenGeneric<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedOpenGeneric<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadAliasedTuple<T1, ReadT1, T2, ReadT2>(stream, value);
}

[[maybe_unused]] void WriteAliasedClosedGeneric(yardl::binary::CodedOutputStream& stream, test_model::AliasedClosedGeneric const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedClosedGeneric>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteAliasedTuple<test_model::AliasedString, test_model::binary::WriteAliasedString, test_model::AliasedEnum, test_model::binary::WriteAliasedEnum>(stream, value);
}

[[maybe_unused]] void ReadAliasedClosedGeneric(yardl::binary::CodedInputStream& stream, test_model::AliasedClosedGeneric& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedClosedGeneric>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadAliasedTuple<test_model::AliasedString, test_model::binary::ReadAliasedString, test_model::AliasedEnum, test_model::binary::ReadAliasedEnum>(stream, value);
}

[[maybe_unused]] void WriteAliasedOptional(yardl::binary::CodedOutputStream& stream, test_model::AliasedOptional const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedOptional>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadAliasedOptional(yardl::binary::CodedInputStream& stream, test_model::AliasedOptional& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedOptional>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedGenericOptional(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericOptional<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericOptional<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<T, WriteT>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedGenericOptional(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericOptional<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericOptional<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<T, ReadT>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT, typename U, yardl::binary::Writer<U> WriteU>
[[maybe_unused]] void WriteAliasedMultiGenericOptional(yardl::binary::CodedOutputStream& stream, test_model::AliasedMultiGenericOptional<T, U> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedMultiGenericOptional<T, U>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<std::monostate, yardl::binary::WriteMonostate, T, WriteT, U, WriteU>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT, typename U, yardl::binary::Reader<U> ReadU>
[[maybe_unused]] void ReadAliasedMultiGenericOptional(yardl::binary::CodedInputStream& stream, test_model::AliasedMultiGenericOptional<T, U>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedMultiGenericOptional<T, U>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<std::monostate, yardl::binary::ReadMonostate, T, ReadT, U, ReadU>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteAliasedGenericUnion2(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericUnion2<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericUnion2<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::WriteGenericUnion2<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadAliasedGenericUnion2(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericUnion2<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericUnion2<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::ReadGenericUnion2<T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedGenericVector(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericVector<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericVector<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::WriteGenericVector<T, WriteT>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedGenericVector(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericVector<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericVector<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::ReadGenericVector<T, ReadT>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedGenericFixedVector(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericFixedVector<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericFixedVector<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<T, WriteT, 3>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedGenericFixedVector(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericFixedVector<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericFixedVector<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<T, ReadT, 3>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedGenericRank2Array(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericRank2Array<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericRank2Array<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<T, WriteT, 2>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedGenericRank2Array(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericRank2Array<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericRank2Array<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<T, ReadT, 2>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedGenericFixedArray(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericFixedArray<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericFixedArray<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<T, WriteT, 16, 8>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedGenericFixedArray(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericFixedArray<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericFixedArray<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<T, ReadT, 16, 8>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedGenericDynamicArray(yardl::binary::CodedOutputStream& stream, test_model::AliasedGenericDynamicArray<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericDynamicArray<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteDynamicNDArray<T, WriteT>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedGenericDynamicArray(yardl::binary::CodedInputStream& stream, test_model::AliasedGenericDynamicArray<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedGenericDynamicArray<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadDynamicNDArray<T, ReadT>(stream, value);
}

template<typename K, yardl::binary::Writer<K> WriteK, typename V, yardl::binary::Writer<V> WriteV>
[[maybe_unused]] void WriteAliasedMap(yardl::binary::CodedOutputStream& stream, test_model::AliasedMap<K, V> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedMap<K, V>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::WriteAliasedMap<K, WriteK, V, WriteV>(stream, value);
}

template<typename K, yardl::binary::Reader<K> ReadK, typename V, yardl::binary::Reader<V> ReadV>
[[maybe_unused]] void ReadAliasedMap(yardl::binary::CodedInputStream& stream, test_model::AliasedMap<K, V>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedMap<K, V>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  basic_types::binary::ReadAliasedMap<K, ReadK, V, ReadV>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteVectorOfGenericRecords(yardl::binary::CodedOutputStream& stream, test_model::VectorOfGenericRecords<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::VectorOfGenericRecords<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<test_model::GenericRecord<T1, T2>, test_model::binary::WriteGenericRecord<T1, WriteT1, T2, WriteT2>>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadVectorOfGenericRecords(yardl::binary::CodedInputStream& stream, test_model::VectorOfGenericRecords<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::VectorOfGenericRecords<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<test_model::GenericRecord<T1, T2>, test_model::binary::ReadGenericRecord<T1, ReadT1, T2, ReadT2>>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteAliasedVectorOfGenericRecords(yardl::binary::CodedOutputStream& stream, test_model::AliasedVectorOfGenericRecords<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedVectorOfGenericRecords<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteAliasedGenericVector<test_model::GenericRecord<T1, T2>, test_model::binary::WriteGenericRecord<T1, WriteT1, T2, WriteT2>>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadAliasedVectorOfGenericRecords(yardl::binary::CodedInputStream& stream, test_model::AliasedVectorOfGenericRecords<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedVectorOfGenericRecords<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadAliasedGenericVector<test_model::GenericRecord<T1, T2>, test_model::binary::ReadGenericRecord<T1, ReadT1, T2, ReadT2>>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT, typename U, yardl::binary::Writer<U> WriteU>
[[maybe_unused]] void WriteRecordWithGenericVectorOfRecords(yardl::binary::CodedOutputStream& stream, test_model::RecordWithGenericVectorOfRecords<T, U> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericVectorOfRecords<T, U>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<test_model::VectorOfGenericRecords<T, U>, test_model::binary::WriteVectorOfGenericRecords<T, WriteT, U, WriteU>>(stream, value.v);
}

template<typename T, yardl::binary::Reader<T> ReadT, typename U, yardl::binary::Reader<U> ReadU>
[[maybe_unused]] void ReadRecordWithGenericVectorOfRecords(yardl::binary::CodedInputStream& stream, test_model::RecordWithGenericVectorOfRecords<T, U>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericVectorOfRecords<T, U>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<test_model::VectorOfGenericRecords<T, U>, test_model::binary::ReadVectorOfGenericRecords<T, ReadT, U, ReadU>>(stream, value.v);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteRecordWithOptionalGenericField(yardl::binary::CodedOutputStream& stream, test_model::RecordWithOptionalGenericField<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalGenericField<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<T, WriteT>(stream, value.v);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadRecordWithOptionalGenericField(yardl::binary::CodedInputStream& stream, test_model::RecordWithOptionalGenericField<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalGenericField<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<T, ReadT>(stream, value.v);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteRecordWithAliasedOptionalGenericField(yardl::binary::CodedOutputStream& stream, test_model::RecordWithAliasedOptionalGenericField<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithAliasedOptionalGenericField<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteAliasedGenericOptional<T, WriteT>(stream, value.v);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadRecordWithAliasedOptionalGenericField(yardl::binary::CodedInputStream& stream, test_model::RecordWithAliasedOptionalGenericField<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithAliasedOptionalGenericField<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadAliasedGenericOptional<T, ReadT>(stream, value.v);
}

template<typename U, yardl::binary::Writer<U> WriteU, typename V, yardl::binary::Writer<V> WriteV>
[[maybe_unused]] void WriteRecordWithOptionalGenericUnionField(yardl::binary::CodedOutputStream& stream, test_model::RecordWithOptionalGenericUnionField<U, V> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalGenericUnionField<U, V>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<std::monostate, yardl::binary::WriteMonostate, U, WriteU, V, WriteV>(stream, value.v);
}

template<typename U, yardl::binary::Reader<U> ReadU, typename V, yardl::binary::Reader<V> ReadV>
[[maybe_unused]] void ReadRecordWithOptionalGenericUnionField(yardl::binary::CodedInputStream& stream, test_model::RecordWithOptionalGenericUnionField<U, V>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalGenericUnionField<U, V>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<std::monostate, yardl::binary::ReadMonostate, U, ReadU, V, ReadV>(stream, value.v);
}

template<typename U, yardl::binary::Writer<U> WriteU, typename V, yardl::binary::Writer<V> WriteV>
[[maybe_unused]] void WriteRecordWithAliasedOptionalGenericUnionField(yardl::binary::CodedOutputStream& stream, test_model::RecordWithAliasedOptionalGenericUnionField<U, V> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithAliasedOptionalGenericUnionField<U, V>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteAliasedMultiGenericOptional<U, WriteU, V, WriteV>(stream, value.v);
}

template<typename U, yardl::binary::Reader<U> ReadU, typename V, yardl::binary::Reader<V> ReadV>
[[maybe_unused]] void ReadRecordWithAliasedOptionalGenericUnionField(yardl::binary::CodedInputStream& stream, test_model::RecordWithAliasedOptionalGenericUnionField<U, V>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithAliasedOptionalGenericUnionField<U, V>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadAliasedMultiGenericOptional<U, ReadU, V, ReadV>(stream, value.v);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteRecordWithGenericVectors(yardl::binary::CodedOutputStream& stream, test_model::RecordWithGenericVectors<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericVectors<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<T, WriteT>(stream, value.v);
  test_model::binary::WriteAliasedGenericVector<T, WriteT>(stream, value.av);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadRecordWithGenericVectors(yardl::binary::CodedInputStream& stream, test_model::RecordWithGenericVectors<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericVectors<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<T, ReadT>(stream, value.v);
  test_model::binary::ReadAliasedGenericVector<T, ReadT>(stream, value.av);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteRecordWithGenericFixedVectors(yardl::binary::CodedOutputStream& stream, test_model::RecordWithGenericFixedVectors<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericFixedVectors<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<T, WriteT, 3>(stream, value.fv);
  test_model::binary::WriteAliasedGenericFixedVector<T, WriteT>(stream, value.afv);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadRecordWithGenericFixedVectors(yardl::binary::CodedInputStream& stream, test_model::RecordWithGenericFixedVectors<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericFixedVectors<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<T, ReadT, 3>(stream, value.fv);
  test_model::binary::ReadAliasedGenericFixedVector<T, ReadT>(stream, value.afv);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteRecordWithGenericArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithGenericArrays<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericArrays<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<T, WriteT, 2>(stream, value.nd);
  yardl::binary::WriteFixedNDArray<T, WriteT, 16, 8>(stream, value.fixed_nd);
  yardl::binary::WriteDynamicNDArray<T, WriteT>(stream, value.dynamic_nd);
  test_model::binary::WriteAliasedGenericRank2Array<T, WriteT>(stream, value.aliased_nd);
  test_model::binary::WriteAliasedGenericFixedArray<T, WriteT>(stream, value.aliased_fixed_nd);
  test_model::binary::WriteAliasedGenericDynamicArray<T, WriteT>(stream, value.aliased_dynamic_nd);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadRecordWithGenericArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithGenericArrays<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericArrays<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<T, ReadT, 2>(stream, value.nd);
  yardl::binary::ReadFixedNDArray<T, ReadT, 16, 8>(stream, value.fixed_nd);
  yardl::binary::ReadDynamicNDArray<T, ReadT>(stream, value.dynamic_nd);
  test_model::binary::ReadAliasedGenericRank2Array<T, ReadT>(stream, value.aliased_nd);
  test_model::binary::ReadAliasedGenericFixedArray<T, ReadT>(stream, value.aliased_fixed_nd);
  test_model::binary::ReadAliasedGenericDynamicArray<T, ReadT>(stream, value.aliased_dynamic_nd);
}

template<typename T, yardl::binary::Writer<T> WriteT, typename U, yardl::binary::Writer<U> WriteU>
[[maybe_unused]] void WriteRecordWithGenericMaps(yardl::binary::CodedOutputStream& stream, test_model::RecordWithGenericMaps<T, U> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericMaps<T, U>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteMap<T, U, WriteT, WriteU>(stream, value.m);
  basic_types::binary::WriteAliasedMap<T, WriteT, U, WriteU>(stream, value.am);
}

template<typename T, yardl::binary::Reader<T> ReadT, typename U, yardl::binary::Reader<U> ReadU>
[[maybe_unused]] void ReadRecordWithGenericMaps(yardl::binary::CodedInputStream& stream, test_model::RecordWithGenericMaps<T, U>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithGenericMaps<T, U>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadMap<T, U, ReadT, ReadU>(stream, value.m);
  basic_types::binary::ReadAliasedMap<T, ReadT, U, ReadU>(stream, value.am);
}

template<typename A, yardl::binary::Writer<A> WriteA, typename B, yardl::binary::Writer<B> WriteB>
[[maybe_unused]] void WriteRecordContainingGenericRecords(yardl::binary::CodedOutputStream& stream, test_model::RecordContainingGenericRecords<A, B> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordContainingGenericRecords<A, B>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteRecordWithOptionalGenericField<A, WriteA>(stream, value.g1);
  test_model::binary::WriteRecordWithAliasedOptionalGenericField<A, WriteA>(stream, value.g1a);
  test_model::binary::WriteRecordWithOptionalGenericUnionField<A, WriteA, B, WriteB>(stream, value.g2);
  test_model::binary::WriteRecordWithAliasedOptionalGenericUnionField<A, WriteA, B, WriteB>(stream, value.g2a);
  test_model::binary::WriteMyTuple<A, WriteA, B, WriteB>(stream, value.g3);
  test_model::binary::WriteAliasedTuple<A, WriteA, B, WriteB>(stream, value.g3a);
  test_model::binary::WriteRecordWithGenericVectors<B, WriteB>(stream, value.g4);
  test_model::binary::WriteRecordWithGenericFixedVectors<B, WriteB>(stream, value.g5);
  test_model::binary::WriteRecordWithGenericArrays<B, WriteB>(stream, value.g6);
  test_model::binary::WriteRecordWithGenericMaps<A, WriteA, B, WriteB>(stream, value.g7);
}

template<typename A, yardl::binary::Reader<A> ReadA, typename B, yardl::binary::Reader<B> ReadB>
[[maybe_unused]] void ReadRecordContainingGenericRecords(yardl::binary::CodedInputStream& stream, test_model::RecordContainingGenericRecords<A, B>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordContainingGenericRecords<A, B>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadRecordWithOptionalGenericField<A, ReadA>(stream, value.g1);
  test_model::binary::ReadRecordWithAliasedOptionalGenericField<A, ReadA>(stream, value.g1a);
  test_model::binary::ReadRecordWithOptionalGenericUnionField<A, ReadA, B, ReadB>(stream, value.g2);
  test_model::binary::ReadRecordWithAliasedOptionalGenericUnionField<A, ReadA, B, ReadB>(stream, value.g2a);
  test_model::binary::ReadMyTuple<A, ReadA, B, ReadB>(stream, value.g3);
  test_model::binary::ReadAliasedTuple<A, ReadA, B, ReadB>(stream, value.g3a);
  test_model::binary::ReadRecordWithGenericVectors<B, ReadB>(stream, value.g4);
  test_model::binary::ReadRecordWithGenericFixedVectors<B, ReadB>(stream, value.g5);
  test_model::binary::ReadRecordWithGenericArrays<B, ReadB>(stream, value.g6);
  test_model::binary::ReadRecordWithGenericMaps<A, ReadA, B, ReadB>(stream, value.g7);
}

[[maybe_unused]] void WriteRecordContainingNestedGenericRecords(yardl::binary::CodedOutputStream& stream, test_model::RecordContainingNestedGenericRecords const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordContainingNestedGenericRecords>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteRecordWithOptionalGenericField<std::string, yardl::binary::WriteString>(stream, value.f1);
  test_model::binary::WriteRecordWithAliasedOptionalGenericField<std::string, yardl::binary::WriteString>(stream, value.f1a);
  test_model::binary::WriteRecordWithOptionalGenericUnionField<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream, value.f2);
  test_model::binary::WriteRecordWithAliasedOptionalGenericUnionField<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream, value.f2a);
  test_model::binary::WriteRecordContainingGenericRecords<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream, value.nested);
}

[[maybe_unused]] void ReadRecordContainingNestedGenericRecords(yardl::binary::CodedInputStream& stream, test_model::RecordContainingNestedGenericRecords& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordContainingNestedGenericRecords>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadRecordWithOptionalGenericField<std::string, yardl::binary::ReadString>(stream, value.f1);
  test_model::binary::ReadRecordWithAliasedOptionalGenericField<std::string, yardl::binary::ReadString>(stream, value.f1a);
  test_model::binary::ReadRecordWithOptionalGenericUnionField<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream, value.f2);
  test_model::binary::ReadRecordWithAliasedOptionalGenericUnionField<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream, value.f2a);
  test_model::binary::ReadRecordContainingGenericRecords<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream, value.nested);
}

[[maybe_unused]] void WriteRecordContainingVectorsOfAliases(yardl::binary::CodedOutputStream& stream, test_model::RecordContainingVectorsOfAliases const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordContainingVectorsOfAliases>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<test_model::AliasedString, test_model::binary::WriteAliasedString>(stream, value.strings);
  yardl::binary::WriteVector<test_model::AliasedMap<std::string, int32_t>, test_model::binary::WriteAliasedMap<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream, value.maps);
  yardl::binary::WriteVector<test_model::Image<float>, test_model::binary::WriteImage<float, yardl::binary::WriteFloatingPoint>>(stream, value.arrays);
  yardl::binary::WriteVector<test_model::MyTuple<int32_t, test_model::SimpleRecord>, test_model::binary::WriteMyTuple<int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>>(stream, value.tuples);
}

[[maybe_unused]] void ReadRecordContainingVectorsOfAliases(yardl::binary::CodedInputStream& stream, test_model::RecordContainingVectorsOfAliases& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordContainingVectorsOfAliases>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<test_model::AliasedString, test_model::binary::ReadAliasedString>(stream, value.strings);
  yardl::binary::ReadVector<test_model::AliasedMap<std::string, int32_t>, test_model::binary::ReadAliasedMap<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream, value.maps);
  yardl::binary::ReadVector<test_model::Image<float>, test_model::binary::ReadImage<float, yardl::binary::ReadFloatingPoint>>(stream, value.arrays);
  yardl::binary::ReadVector<test_model::MyTuple<int32_t, test_model::SimpleRecord>, test_model::binary::ReadMyTuple<int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>>(stream, value.tuples);
}

[[maybe_unused]] void WriteAliasedIntOrSimpleRecord(yardl::binary::CodedOutputStream& stream, test_model::AliasedIntOrSimpleRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedIntOrSimpleRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream, value);
}

[[maybe_unused]] void ReadAliasedIntOrSimpleRecord(yardl::binary::CodedInputStream& stream, test_model::AliasedIntOrSimpleRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedIntOrSimpleRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream, value);
}

[[maybe_unused]] void WriteAliasedIntOrAliasedSimpleRecord(yardl::binary::CodedOutputStream& stream, test_model::AliasedIntOrAliasedSimpleRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedIntOrAliasedSimpleRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<int32_t, yardl::binary::WriteInteger, test_model::AliasedSimpleRecord, test_model::binary::WriteAliasedSimpleRecord>(stream, value);
}

[[maybe_unused]] void ReadAliasedIntOrAliasedSimpleRecord(yardl::binary::CodedInputStream& stream, test_model::AliasedIntOrAliasedSimpleRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedIntOrAliasedSimpleRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<int32_t, yardl::binary::ReadInteger, test_model::AliasedSimpleRecord, test_model::binary::ReadAliasedSimpleRecord>(stream, value);
}

[[maybe_unused]] void WriteAliasedNullableIntSimpleRecord(yardl::binary::CodedOutputStream& stream, test_model::AliasedNullableIntSimpleRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedNullableIntSimpleRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream, value);
}

[[maybe_unused]] void ReadAliasedNullableIntSimpleRecord(yardl::binary::CodedInputStream& stream, test_model::AliasedNullableIntSimpleRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::AliasedNullableIntSimpleRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream, value);
}

[[maybe_unused]] void WriteRecordWithIntVectors(yardl::binary::CodedOutputStream& stream, test_model::RecordWithIntVectors const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithIntVectors>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteRecordWithGenericVectors<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadRecordWithIntVectors(yardl::binary::CodedInputStream& stream, test_model::RecordWithIntVectors& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithIntVectors>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadRecordWithGenericVectors<int32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteRecordWithFloatArrays(yardl::binary::CodedOutputStream& stream, test_model::RecordWithFloatArrays const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFloatArrays>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteRecordWithGenericArrays<float, yardl::binary::WriteFloatingPoint>(stream, value);
}

[[maybe_unused]] void ReadRecordWithFloatArrays(yardl::binary::CodedInputStream& stream, test_model::RecordWithFloatArrays& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithFloatArrays>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadRecordWithGenericArrays<float, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteUnionOfContainerRecords(yardl::binary::CodedOutputStream& stream, test_model::UnionOfContainerRecords const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::UnionOfContainerRecords>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<test_model::RecordWithIntVectors, test_model::binary::WriteRecordWithIntVectors, test_model::RecordWithFloatArrays, test_model::binary::WriteRecordWithFloatArrays>(stream, value);
}

[[maybe_unused]] void ReadUnionOfContainerRecords(yardl::binary::CodedInputStream& stream, test_model::UnionOfContainerRecords& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::UnionOfContainerRecords>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<test_model::RecordWithIntVectors, test_model::binary::ReadRecordWithIntVectors, test_model::RecordWithFloatArrays, test_model::binary::ReadRecordWithFloatArrays>(stream, value);
}

[[maybe_unused]] void WriteRecordWithComputedFields(yardl::binary::CodedOutputStream& stream, test_model::RecordWithComputedFields const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithComputedFields>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.array_field);
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value.array_field_map_dimensions);
  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream, value.dynamic_array_field);
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3, 4>(stream, value.fixed_array_field);
  yardl::binary::WriteInteger(stream, value.int_field);
  yardl::binary::WriteInteger(stream, value.int8_field);
  yardl::binary::WriteInteger(stream, value.uint8_field);
  yardl::binary::WriteInteger(stream, value.int16_field);
  yardl::binary::WriteInteger(stream, value.uint16_field);
  yardl::binary::WriteInteger(stream, value.uint32_field);
  yardl::binary::WriteInteger(stream, value.int64_field);
  yardl::binary::WriteInteger(stream, value.uint64_field);
  yardl::binary::WriteInteger(stream, value.size_field);
  yardl::binary::WriteFloatingPoint(stream, value.float32_field);
  yardl::binary::WriteFloatingPoint(stream, value.float64_field);
  yardl::binary::WriteFloatingPoint(stream, value.complexfloat32_field);
  yardl::binary::WriteFloatingPoint(stream, value.complexfloat64_field);
  yardl::binary::WriteString(stream, value.string_field);
  test_model::binary::WriteMyTuple<int32_t, yardl::binary::WriteInteger, int32_t, yardl::binary::WriteInteger>(stream, value.tuple_field);
  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, value.vector_field);
  yardl::binary::WriteVector<std::vector<int32_t>, yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>>(stream, value.vector_of_vectors_field);
  yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>(stream, value.fixed_vector_field);
  yardl::binary::WriteArray<std::array<int32_t, 3>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>, 2>(stream, value.fixed_vector_of_vectors_field);
  yardl::binary::WriteOptional<test_model::NamedNDArray, test_model::binary::WriteNamedNDArray>(stream, value.optional_named_array);
  WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>(stream, value.int_float_union);
  WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>(stream, value.nullable_int_float_union);
  WriteUnion<int32_t, yardl::binary::WriteInteger, basic_types::GenericRecordWithComputedFields<std::string, float>, basic_types::binary::WriteGenericRecordWithComputedFields<std::string, yardl::binary::WriteString, float, yardl::binary::WriteFloatingPoint>>(stream, value.union_with_nested_generic_union);
  yardl::binary::WriteMap<std::string, std::string, yardl::binary::WriteString, yardl::binary::WriteString>(stream, value.map_field);
}

[[maybe_unused]] void ReadRecordWithComputedFields(yardl::binary::CodedInputStream& stream, test_model::RecordWithComputedFields& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithComputedFields>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.array_field);
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value.array_field_map_dimensions);
  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream, value.dynamic_array_field);
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3, 4>(stream, value.fixed_array_field);
  yardl::binary::ReadInteger(stream, value.int_field);
  yardl::binary::ReadInteger(stream, value.int8_field);
  yardl::binary::ReadInteger(stream, value.uint8_field);
  yardl::binary::ReadInteger(stream, value.int16_field);
  yardl::binary::ReadInteger(stream, value.uint16_field);
  yardl::binary::ReadInteger(stream, value.uint32_field);
  yardl::binary::ReadInteger(stream, value.int64_field);
  yardl::binary::ReadInteger(stream, value.uint64_field);
  yardl::binary::ReadInteger(stream, value.size_field);
  yardl::binary::ReadFloatingPoint(stream, value.float32_field);
  yardl::binary::ReadFloatingPoint(stream, value.float64_field);
  yardl::binary::ReadFloatingPoint(stream, value.complexfloat32_field);
  yardl::binary::ReadFloatingPoint(stream, value.complexfloat64_field);
  yardl::binary::ReadString(stream, value.string_field);
  test_model::binary::ReadMyTuple<int32_t, yardl::binary::ReadInteger, int32_t, yardl::binary::ReadInteger>(stream, value.tuple_field);
  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, value.vector_field);
  yardl::binary::ReadVector<std::vector<int32_t>, yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>>(stream, value.vector_of_vectors_field);
  yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>(stream, value.fixed_vector_field);
  yardl::binary::ReadArray<std::array<int32_t, 3>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>, 2>(stream, value.fixed_vector_of_vectors_field);
  yardl::binary::ReadOptional<test_model::NamedNDArray, test_model::binary::ReadNamedNDArray>(stream, value.optional_named_array);
  ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>(stream, value.int_float_union);
  ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>(stream, value.nullable_int_float_union);
  ReadUnion<int32_t, yardl::binary::ReadInteger, basic_types::GenericRecordWithComputedFields<std::string, float>, basic_types::binary::ReadGenericRecordWithComputedFields<std::string, yardl::binary::ReadString, float, yardl::binary::ReadFloatingPoint>>(stream, value.union_with_nested_generic_union);
  yardl::binary::ReadMap<std::string, std::string, yardl::binary::ReadString, yardl::binary::ReadString>(stream, value.map_field);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteGenericUnionWithRepeatedTypeParameters(yardl::binary::CodedOutputStream& stream, test_model::GenericUnionWithRepeatedTypeParameters<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericUnionWithRepeatedTypeParameters<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<T, WriteT, std::vector<T>, yardl::binary::WriteVector<T, WriteT>, yardl::DynamicNDArray<T>, yardl::binary::WriteDynamicNDArray<T, WriteT>>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadGenericUnionWithRepeatedTypeParameters(yardl::binary::CodedInputStream& stream, test_model::GenericUnionWithRepeatedTypeParameters<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericUnionWithRepeatedTypeParameters<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<T, ReadT, std::vector<T>, yardl::binary::ReadVector<T, ReadT>, yardl::DynamicNDArray<T>, yardl::binary::ReadDynamicNDArray<T, ReadT>>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT, typename U, yardl::binary::Writer<U> WriteU, typename V, yardl::binary::Writer<V> WriteV>
[[maybe_unused]] void WriteGenericUnion3(yardl::binary::CodedOutputStream& stream, test_model::GenericUnion3<T, U, V> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericUnion3<T, U, V>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<T, WriteT, U, WriteU, V, WriteV>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT, typename U, yardl::binary::Reader<U> ReadU, typename V, yardl::binary::Reader<V> ReadV>
[[maybe_unused]] void ReadGenericUnion3(yardl::binary::CodedInputStream& stream, test_model::GenericUnion3<T, U, V>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericUnion3<T, U, V>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<T, ReadT, U, ReadU, V, ReadV>(stream, value);
}

template<typename U, yardl::binary::Writer<U> WriteU, typename V, yardl::binary::Writer<V> WriteV, typename W, yardl::binary::Writer<W> WriteW>
[[maybe_unused]] void WriteGenericUnion3Alternate(yardl::binary::CodedOutputStream& stream, test_model::GenericUnion3Alternate<U, V, W> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericUnion3Alternate<U, V, W>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<U, WriteU, V, WriteV, W, WriteW>(stream, value);
}

template<typename U, yardl::binary::Reader<U> ReadU, typename V, yardl::binary::Reader<V> ReadV, typename W, yardl::binary::Reader<W> ReadW>
[[maybe_unused]] void ReadGenericUnion3Alternate(yardl::binary::CodedInputStream& stream, test_model::GenericUnion3Alternate<U, V, W>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::GenericUnion3Alternate<U, V, W>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<U, ReadU, V, ReadV, W, ReadW>(stream, value);
}

[[maybe_unused]] void WriteRecordNotUsedInProtocol(yardl::binary::CodedOutputStream& stream, test_model::RecordNotUsedInProtocol const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordNotUsedInProtocol>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::WriteGenericUnion3<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream, value.u1);
  test_model::binary::WriteGenericUnion3Alternate<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream, value.u2);
}

[[maybe_unused]] void ReadRecordNotUsedInProtocol(yardl::binary::CodedInputStream& stream, test_model::RecordNotUsedInProtocol& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordNotUsedInProtocol>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  test_model::binary::ReadGenericUnion3<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream, value.u1);
  test_model::binary::ReadGenericUnion3Alternate<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream, value.u2);
}

[[maybe_unused]] void WriteArrayWithKeywordDimensionNames(yardl::binary::CodedOutputStream& stream, test_model::ArrayWithKeywordDimensionNames const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::ArrayWithKeywordDimensionNames>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream, value);
}

[[maybe_unused]] void ReadArrayWithKeywordDimensionNames(yardl::binary::CodedInputStream& stream, test_model::ArrayWithKeywordDimensionNames& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::ArrayWithKeywordDimensionNames>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream, value);
}

[[maybe_unused]] void WriteRecordWithKeywordFields(yardl::binary::CodedOutputStream& stream, test_model::RecordWithKeywordFields const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithKeywordFields>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.int_field);
  test_model::binary::WriteArrayWithKeywordDimensionNames(stream, value.sizeof_field);
  yardl::binary::WriteEnum<test_model::EnumWithKeywordSymbols>(stream, value.if_field);
}

[[maybe_unused]] void ReadRecordWithKeywordFields(yardl::binary::CodedInputStream& stream, test_model::RecordWithKeywordFields& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithKeywordFields>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.int_field);
  test_model::binary::ReadArrayWithKeywordDimensionNames(stream, value.sizeof_field);
  yardl::binary::ReadEnum<test_model::EnumWithKeywordSymbols>(stream, value.if_field);
}

[[maybe_unused]] void WriteRecordWithOptionalDate(yardl::binary::CodedOutputStream& stream, test_model::RecordWithOptionalDate const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalDate>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<yardl::Date, yardl::binary::WriteDate>(stream, value.date_field);
}

[[maybe_unused]] void ReadRecordWithOptionalDate(yardl::binary::CodedInputStream& stream, test_model::RecordWithOptionalDate& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<test_model::RecordWithOptionalDate>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<yardl::Date, yardl::binary::ReadDate>(stream, value.date_field);
}

} // namespace

void BenchmarkFloat256x256Writer::WriteFloat256x256Impl(yardl::FixedNDArray<float, 256, 256> const& value) {
  yardl::binary::WriteBlock<yardl::FixedNDArray<float, 256, 256>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 256, 256>>(stream_, value);
}

void BenchmarkFloat256x256Writer::WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<yardl::FixedNDArray<float, 256, 256>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 256, 256>>(stream_, values);
  }
}

void BenchmarkFloat256x256Writer::EndFloat256x256Impl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void BenchmarkFloat256x256Writer::Flush() {
  stream_.Flush();
}

void BenchmarkFloat256x256Writer::CloseImpl() {
  stream_.Flush();
}

bool BenchmarkFloat256x256Reader::ReadFloat256x256Impl(yardl::FixedNDArray<float, 256, 256>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<yardl::FixedNDArray<float, 256, 256>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 256, 256>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool BenchmarkFloat256x256Reader::ReadFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>>& values) {
  yardl::binary::ReadBlocksIntoVector<yardl::FixedNDArray<float, 256, 256>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 256, 256>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void BenchmarkFloat256x256Reader::CloseImpl() {
  stream_.VerifyFinished();
}

void BenchmarkInt256x256Writer::WriteInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256> const& value) {
  yardl::binary::WriteBlock<yardl::FixedNDArray<int32_t, 256, 256>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 256, 256>>(stream_, value);
}

void BenchmarkInt256x256Writer::WriteInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<yardl::FixedNDArray<int32_t, 256, 256>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 256, 256>>(stream_, values);
  }
}

void BenchmarkInt256x256Writer::EndInt256x256Impl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void BenchmarkInt256x256Writer::Flush() {
  stream_.Flush();
}

void BenchmarkInt256x256Writer::CloseImpl() {
  stream_.Flush();
}

bool BenchmarkInt256x256Reader::ReadInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<yardl::FixedNDArray<int32_t, 256, 256>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 256, 256>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool BenchmarkInt256x256Reader::ReadInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>>& values) {
  yardl::binary::ReadBlocksIntoVector<yardl::FixedNDArray<int32_t, 256, 256>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 256, 256>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void BenchmarkInt256x256Reader::CloseImpl() {
  stream_.VerifyFinished();
}

void BenchmarkFloatVlenWriter::WriteFloatArrayImpl(yardl::NDArray<float, 2> const& value) {
  yardl::binary::WriteBlock<yardl::NDArray<float, 2>, yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 2>>(stream_, value);
}

void BenchmarkFloatVlenWriter::WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<yardl::NDArray<float, 2>, yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 2>>(stream_, values);
  }
}

void BenchmarkFloatVlenWriter::EndFloatArrayImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void BenchmarkFloatVlenWriter::Flush() {
  stream_.Flush();
}

void BenchmarkFloatVlenWriter::CloseImpl() {
  stream_.Flush();
}

bool BenchmarkFloatVlenReader::ReadFloatArrayImpl(yardl::NDArray<float, 2>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<yardl::NDArray<float, 2>, yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 2>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool BenchmarkFloatVlenReader::ReadFloatArrayImpl(std::vector<yardl::NDArray<float, 2>>& values) {
  yardl::binary::ReadBlocksIntoVector<yardl::NDArray<float, 2>, yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 2>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void BenchmarkFloatVlenReader::CloseImpl() {
  stream_.VerifyFinished();
}

void BenchmarkSmallRecordWriter::WriteSmallRecordImpl(test_model::SmallBenchmarkRecord const& value) {
  yardl::binary::WriteBlock<test_model::SmallBenchmarkRecord, test_model::binary::WriteSmallBenchmarkRecord>(stream_, value);
}

void BenchmarkSmallRecordWriter::WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::SmallBenchmarkRecord, test_model::binary::WriteSmallBenchmarkRecord>(stream_, values);
  }
}

void BenchmarkSmallRecordWriter::EndSmallRecordImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void BenchmarkSmallRecordWriter::Flush() {
  stream_.Flush();
}

void BenchmarkSmallRecordWriter::CloseImpl() {
  stream_.Flush();
}

bool BenchmarkSmallRecordReader::ReadSmallRecordImpl(test_model::SmallBenchmarkRecord& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::SmallBenchmarkRecord, test_model::binary::ReadSmallBenchmarkRecord>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool BenchmarkSmallRecordReader::ReadSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::SmallBenchmarkRecord, test_model::binary::ReadSmallBenchmarkRecord>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void BenchmarkSmallRecordReader::CloseImpl() {
  stream_.VerifyFinished();
}

void BenchmarkSmallRecordWithOptionalsWriter::WriteSmallRecordImpl(test_model::SimpleEncodingCounters const& value) {
  yardl::binary::WriteBlock<test_model::SimpleEncodingCounters, test_model::binary::WriteSimpleEncodingCounters>(stream_, value);
}

void BenchmarkSmallRecordWithOptionalsWriter::WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::SimpleEncodingCounters, test_model::binary::WriteSimpleEncodingCounters>(stream_, values);
  }
}

void BenchmarkSmallRecordWithOptionalsWriter::EndSmallRecordImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void BenchmarkSmallRecordWithOptionalsWriter::Flush() {
  stream_.Flush();
}

void BenchmarkSmallRecordWithOptionalsWriter::CloseImpl() {
  stream_.Flush();
}

bool BenchmarkSmallRecordWithOptionalsReader::ReadSmallRecordImpl(test_model::SimpleEncodingCounters& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::SimpleEncodingCounters, test_model::binary::ReadSimpleEncodingCounters>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool BenchmarkSmallRecordWithOptionalsReader::ReadSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::SimpleEncodingCounters, test_model::binary::ReadSimpleEncodingCounters>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void BenchmarkSmallRecordWithOptionalsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void BenchmarkSimpleMrdWriter::WriteDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) {
  yardl::binary::WriteBlock<std::variant<test_model::SimpleAcquisition, image::Image<float>>, WriteUnion<test_model::SimpleAcquisition, test_model::binary::WriteSimpleAcquisition, image::Image<float>, image::binary::WriteImage<float, yardl::binary::WriteFloatingPoint>>>(stream_, value);
}

void BenchmarkSimpleMrdWriter::WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::variant<test_model::SimpleAcquisition, image::Image<float>>, WriteUnion<test_model::SimpleAcquisition, test_model::binary::WriteSimpleAcquisition, image::Image<float>, image::binary::WriteImage<float, yardl::binary::WriteFloatingPoint>>>(stream_, values);
  }
}

void BenchmarkSimpleMrdWriter::EndDataImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void BenchmarkSimpleMrdWriter::Flush() {
  stream_.Flush();
}

void BenchmarkSimpleMrdWriter::CloseImpl() {
  stream_.Flush();
}

bool BenchmarkSimpleMrdReader::ReadDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::variant<test_model::SimpleAcquisition, image::Image<float>>, ReadUnion<test_model::SimpleAcquisition, test_model::binary::ReadSimpleAcquisition, image::Image<float>, image::binary::ReadImage<float, yardl::binary::ReadFloatingPoint>>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool BenchmarkSimpleMrdReader::ReadDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::variant<test_model::SimpleAcquisition, image::Image<float>>, ReadUnion<test_model::SimpleAcquisition, test_model::binary::ReadSimpleAcquisition, image::Image<float>, image::binary::ReadImage<float, yardl::binary::ReadFloatingPoint>>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void BenchmarkSimpleMrdReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ScalarsWriter::WriteInt32Impl(int32_t const& value) {
  yardl::binary::WriteInteger(stream_, value);
}

void ScalarsWriter::WriteRecordImpl(test_model::RecordWithPrimitives const& value) {
  test_model::binary::WriteRecordWithPrimitives(stream_, value);
}

void ScalarsWriter::Flush() {
  stream_.Flush();
}

void ScalarsWriter::CloseImpl() {
  stream_.Flush();
}

void ScalarsReader::ReadInt32Impl(int32_t& value) {
  yardl::binary::ReadInteger(stream_, value);
}

void ScalarsReader::ReadRecordImpl(test_model::RecordWithPrimitives& value) {
  test_model::binary::ReadRecordWithPrimitives(stream_, value);
}

void ScalarsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ScalarOptionalsWriter::WriteOptionalIntImpl(std::optional<int32_t> const& value) {
  yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void ScalarOptionalsWriter::WriteOptionalRecordImpl(std::optional<test_model::SimpleRecord> const& value) {
  yardl::binary::WriteOptional<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream_, value);
}

void ScalarOptionalsWriter::WriteRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields const& value) {
  test_model::binary::WriteRecordWithOptionalFields(stream_, value);
}

void ScalarOptionalsWriter::WriteOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields> const& value) {
  yardl::binary::WriteOptional<test_model::RecordWithOptionalFields, test_model::binary::WriteRecordWithOptionalFields>(stream_, value);
}

void ScalarOptionalsWriter::Flush() {
  stream_.Flush();
}

void ScalarOptionalsWriter::CloseImpl() {
  stream_.Flush();
}

void ScalarOptionalsReader::ReadOptionalIntImpl(std::optional<int32_t>& value) {
  yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, value);
}

void ScalarOptionalsReader::ReadOptionalRecordImpl(std::optional<test_model::SimpleRecord>& value) {
  yardl::binary::ReadOptional<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream_, value);
}

void ScalarOptionalsReader::ReadRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields& value) {
  test_model::binary::ReadRecordWithOptionalFields(stream_, value);
}

void ScalarOptionalsReader::ReadOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields>& value) {
  yardl::binary::ReadOptional<test_model::RecordWithOptionalFields, test_model::binary::ReadRecordWithOptionalFields>(stream_, value);
}

void ScalarOptionalsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void NestedRecordsWriter::WriteTupleWithRecordsImpl(test_model::TupleWithRecords const& value) {
  test_model::binary::WriteTupleWithRecords(stream_, value);
}

void NestedRecordsWriter::Flush() {
  stream_.Flush();
}

void NestedRecordsWriter::CloseImpl() {
  stream_.Flush();
}

void NestedRecordsReader::ReadTupleWithRecordsImpl(test_model::TupleWithRecords& value) {
  test_model::binary::ReadTupleWithRecords(stream_, value);
}

void NestedRecordsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void VlensWriter::WriteIntVectorImpl(std::vector<int32_t> const& value) {
  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void VlensWriter::WriteComplexVectorImpl(std::vector<std::complex<float>> const& value) {
  yardl::binary::WriteVector<std::complex<float>, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void VlensWriter::WriteRecordWithVlensImpl(test_model::RecordWithVlens const& value) {
  test_model::binary::WriteRecordWithVlens(stream_, value);
}

void VlensWriter::WriteVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens> const& value) {
  yardl::binary::WriteVector<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens>(stream_, value);
}

void VlensWriter::Flush() {
  stream_.Flush();
}

void VlensWriter::CloseImpl() {
  stream_.Flush();
}

void VlensReader::ReadIntVectorImpl(std::vector<int32_t>& value) {
  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream_, value);
}

void VlensReader::ReadComplexVectorImpl(std::vector<std::complex<float>>& value) {
  yardl::binary::ReadVector<std::complex<float>, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void VlensReader::ReadRecordWithVlensImpl(test_model::RecordWithVlens& value) {
  test_model::binary::ReadRecordWithVlens(stream_, value);
}

void VlensReader::ReadVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens>& value) {
  yardl::binary::ReadVector<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens>(stream_, value);
}

void VlensReader::CloseImpl() {
  stream_.VerifyFinished();
}

void StringsWriter::WriteSingleStringImpl(std::string const& value) {
  yardl::binary::WriteString(stream_, value);
}

void StringsWriter::WriteRecWithStringImpl(test_model::RecordWithStrings const& value) {
  test_model::binary::WriteRecordWithStrings(stream_, value);
}

void StringsWriter::Flush() {
  stream_.Flush();
}

void StringsWriter::CloseImpl() {
  stream_.Flush();
}

void StringsReader::ReadSingleStringImpl(std::string& value) {
  yardl::binary::ReadString(stream_, value);
}

void StringsReader::ReadRecWithStringImpl(test_model::RecordWithStrings& value) {
  test_model::binary::ReadRecordWithStrings(stream_, value);
}

void StringsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void OptionalVectorsWriter::WriteRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector const& value) {
  test_model::binary::WriteRecordWithOptionalVector(stream_, value);
}

void OptionalVectorsWriter::Flush() {
  stream_.Flush();
}

void OptionalVectorsWriter::CloseImpl() {
  stream_.Flush();
}

void OptionalVectorsReader::ReadRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector& value) {
  test_model::binary::ReadRecordWithOptionalVector(stream_, value);
}

void OptionalVectorsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void FixedVectorsWriter::WriteFixedIntVectorImpl(std::array<int32_t, 5> const& value) {
  yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 5>(stream_, value);
}

void FixedVectorsWriter::WriteFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3> const& value) {
  yardl::binary::WriteArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 3>(stream_, value);
}

void FixedVectorsWriter::WriteFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2> const& value) {
  yardl::binary::WriteArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2>(stream_, value);
}

void FixedVectorsWriter::WriteRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors const& value) {
  test_model::binary::WriteRecordWithFixedVectors(stream_, value);
}

void FixedVectorsWriter::Flush() {
  stream_.Flush();
}

void FixedVectorsWriter::CloseImpl() {
  stream_.Flush();
}

void FixedVectorsReader::ReadFixedIntVectorImpl(std::array<int32_t, 5>& value) {
  yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 5>(stream_, value);
}

void FixedVectorsReader::ReadFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3>& value) {
  yardl::binary::ReadArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 3>(stream_, value);
}

void FixedVectorsReader::ReadFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2>& value) {
  yardl::binary::ReadArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2>(stream_, value);
}

void FixedVectorsReader::ReadRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors& value) {
  test_model::binary::ReadRecordWithFixedVectors(stream_, value);
}

void FixedVectorsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void StreamsWriter::WriteIntDataImpl(int32_t const& value) {
  yardl::binary::WriteBlock<int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void StreamsWriter::WriteIntDataImpl(std::vector<int32_t> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, values);
  }
}

void StreamsWriter::EndIntDataImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsWriter::WriteOptionalIntDataImpl(std::optional<int32_t> const& value) {
  yardl::binary::WriteBlock<std::optional<int32_t>, yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>>(stream_, value);
}

void StreamsWriter::WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::optional<int32_t>, yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>>(stream_, values);
  }
}

void StreamsWriter::EndOptionalIntDataImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsWriter::WriteRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector const& value) {
  yardl::binary::WriteBlock<test_model::RecordWithOptionalVector, test_model::binary::WriteRecordWithOptionalVector>(stream_, value);
}

void StreamsWriter::WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::RecordWithOptionalVector, test_model::binary::WriteRecordWithOptionalVector>(stream_, values);
  }
}

void StreamsWriter::EndRecordWithOptionalVectorDataImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsWriter::WriteFixedVectorImpl(std::array<int32_t, 3> const& value) {
  yardl::binary::WriteBlock<std::array<int32_t, 3>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>>(stream_, value);
}

void StreamsWriter::WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::array<int32_t, 3>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>>(stream_, values);
  }
}

void StreamsWriter::EndFixedVectorImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsWriter::Flush() {
  stream_.Flush();
}

void StreamsWriter::CloseImpl() {
  stream_.Flush();
}

bool StreamsReader::ReadIntDataImpl(int32_t& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsReader::ReadIntDataImpl(std::vector<int32_t>& values) {
  yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool StreamsReader::ReadOptionalIntDataImpl(std::optional<int32_t>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::optional<int32_t>, yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsReader::ReadOptionalIntDataImpl(std::vector<std::optional<int32_t>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::optional<int32_t>, yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool StreamsReader::ReadRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::RecordWithOptionalVector, test_model::binary::ReadRecordWithOptionalVector>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsReader::ReadRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::RecordWithOptionalVector, test_model::binary::ReadRecordWithOptionalVector>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool StreamsReader::ReadFixedVectorImpl(std::array<int32_t, 3>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::array<int32_t, 3>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsReader::ReadFixedVectorImpl(std::vector<std::array<int32_t, 3>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::array<int32_t, 3>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void StreamsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void FixedArraysWriter::WriteIntsImpl(yardl::FixedNDArray<int32_t, 2, 3> const& value) {
  yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 2, 3>(stream_, value);
}

void FixedArraysWriter::WriteFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) {
  yardl::binary::WriteFixedNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 3, 2>(stream_, value);
}

void FixedArraysWriter::WriteFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) {
  yardl::binary::WriteFixedNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2, 2>(stream_, value);
}

void FixedArraysWriter::WriteRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays const& value) {
  test_model::binary::WriteRecordWithFixedArrays(stream_, value);
}

void FixedArraysWriter::WriteNamedArrayImpl(test_model::NamedFixedNDArray const& value) {
  test_model::binary::WriteNamedFixedNDArray(stream_, value);
}

void FixedArraysWriter::Flush() {
  stream_.Flush();
}

void FixedArraysWriter::CloseImpl() {
  stream_.Flush();
}

void FixedArraysReader::ReadIntsImpl(yardl::FixedNDArray<int32_t, 2, 3>& value) {
  yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 2, 3>(stream_, value);
}

void FixedArraysReader::ReadFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value) {
  yardl::binary::ReadFixedNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 3, 2>(stream_, value);
}

void FixedArraysReader::ReadFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value) {
  yardl::binary::ReadFixedNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2, 2>(stream_, value);
}

void FixedArraysReader::ReadRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays& value) {
  test_model::binary::ReadRecordWithFixedArrays(stream_, value);
}

void FixedArraysReader::ReadNamedArrayImpl(test_model::NamedFixedNDArray& value) {
  test_model::binary::ReadNamedFixedNDArray(stream_, value);
}

void FixedArraysReader::CloseImpl() {
  stream_.VerifyFinished();
}

void SubarraysWriter::WriteDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) {
  yardl::binary::WriteDynamicNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3>>(stream_, value);
}

void SubarraysWriter::WriteDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) {
  yardl::binary::WriteDynamicNDArray<yardl::FixedNDArray<float, 3>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>>(stream_, value);
}

void SubarraysWriter::WriteKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) {
  yardl::binary::WriteNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3>, 1>(stream_, value);
}

void SubarraysWriter::WriteKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) {
  yardl::binary::WriteNDArray<yardl::FixedNDArray<float, 3>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>, 1>(stream_, value);
}

void SubarraysWriter::WriteFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) {
  yardl::binary::WriteFixedNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3>, 2>(stream_, value);
}

void SubarraysWriter::WriteFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) {
  yardl::binary::WriteFixedNDArray<yardl::FixedNDArray<float, 3>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>, 2>(stream_, value);
}

void SubarraysWriter::WriteNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) {
  yardl::binary::WriteDynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>, yardl::binary::WriteFixedNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3>, 2>>(stream_, value);
}

void SubarraysWriter::WriteDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) {
  yardl::binary::WriteDynamicNDArray<std::array<int32_t, 3>, yardl::binary::WriteArray<int32_t, yardl::binary::WriteInteger, 3>>(stream_, value);
}

void SubarraysWriter::WriteGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) {
  test_model::binary::WriteImage<yardl::FixedNDArray<int32_t, 3>, yardl::binary::WriteFixedNDArray<int32_t, yardl::binary::WriteInteger, 3>>(stream_, value);
}

void SubarraysWriter::Flush() {
  stream_.Flush();
}

void SubarraysWriter::CloseImpl() {
  stream_.Flush();
}

void SubarraysReader::ReadDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>>& value) {
  yardl::binary::ReadDynamicNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3>>(stream_, value);
}

void SubarraysReader::ReadDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>>& value) {
  yardl::binary::ReadDynamicNDArray<yardl::FixedNDArray<float, 3>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>>(stream_, value);
}

void SubarraysReader::ReadKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1>& value) {
  yardl::binary::ReadNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3>, 1>(stream_, value);
}

void SubarraysReader::ReadKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1>& value) {
  yardl::binary::ReadNDArray<yardl::FixedNDArray<float, 3>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>, 1>(stream_, value);
}

void SubarraysReader::ReadFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>& value) {
  yardl::binary::ReadFixedNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3>, 2>(stream_, value);
}

void SubarraysReader::ReadFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2>& value) {
  yardl::binary::ReadFixedNDArray<yardl::FixedNDArray<float, 3>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>, 2>(stream_, value);
}

void SubarraysReader::ReadNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>>& value) {
  yardl::binary::ReadDynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>, yardl::binary::ReadFixedNDArray<yardl::FixedNDArray<int32_t, 3>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3>, 2>>(stream_, value);
}

void SubarraysReader::ReadDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>>& value) {
  yardl::binary::ReadDynamicNDArray<std::array<int32_t, 3>, yardl::binary::ReadArray<int32_t, yardl::binary::ReadInteger, 3>>(stream_, value);
}

void SubarraysReader::ReadGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>>& value) {
  test_model::binary::ReadImage<yardl::FixedNDArray<int32_t, 3>, yardl::binary::ReadFixedNDArray<int32_t, yardl::binary::ReadInteger, 3>>(stream_, value);
}

void SubarraysReader::CloseImpl() {
  stream_.VerifyFinished();
}

void SubarraysInRecordsWriter::WriteWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) {
  yardl::binary::WriteDynamicNDArray<test_model::RecordWithFixedCollections, test_model::binary::WriteRecordWithFixedCollections>(stream_, value);
}

void SubarraysInRecordsWriter::WriteWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) {
  yardl::binary::WriteDynamicNDArray<test_model::RecordWithVlenCollections, test_model::binary::WriteRecordWithVlenCollections>(stream_, value);
}

void SubarraysInRecordsWriter::Flush() {
  stream_.Flush();
}

void SubarraysInRecordsWriter::CloseImpl() {
  stream_.Flush();
}

void SubarraysInRecordsReader::ReadWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections>& value) {
  yardl::binary::ReadDynamicNDArray<test_model::RecordWithFixedCollections, test_model::binary::ReadRecordWithFixedCollections>(stream_, value);
}

void SubarraysInRecordsReader::ReadWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections>& value) {
  yardl::binary::ReadDynamicNDArray<test_model::RecordWithVlenCollections, test_model::binary::ReadRecordWithVlenCollections>(stream_, value);
}

void SubarraysInRecordsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void NDArraysWriter::WriteIntsImpl(yardl::NDArray<int32_t, 2> const& value) {
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 2>(stream_, value);
}

void NDArraysWriter::WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2> const& value) {
  yardl::binary::WriteNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 2>(stream_, value);
}

void NDArraysWriter::WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) {
  yardl::binary::WriteNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 2>(stream_, value);
}

void NDArraysWriter::WriteRecordWithNDArraysImpl(test_model::RecordWithNDArrays const& value) {
  test_model::binary::WriteRecordWithNDArrays(stream_, value);
}

void NDArraysWriter::WriteNamedArrayImpl(test_model::NamedNDArray const& value) {
  test_model::binary::WriteNamedNDArray(stream_, value);
}

void NDArraysWriter::Flush() {
  stream_.Flush();
}

void NDArraysWriter::CloseImpl() {
  stream_.Flush();
}

void NDArraysReader::ReadIntsImpl(yardl::NDArray<int32_t, 2>& value) {
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 2>(stream_, value);
}

void NDArraysReader::ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2>& value) {
  yardl::binary::ReadNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 2>(stream_, value);
}

void NDArraysReader::ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2>& value) {
  yardl::binary::ReadNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 2>(stream_, value);
}

void NDArraysReader::ReadRecordWithNDArraysImpl(test_model::RecordWithNDArrays& value) {
  test_model::binary::ReadRecordWithNDArrays(stream_, value);
}

void NDArraysReader::ReadNamedArrayImpl(test_model::NamedNDArray& value) {
  test_model::binary::ReadNamedNDArray(stream_, value);
}

void NDArraysReader::CloseImpl() {
  stream_.VerifyFinished();
}

void NDArraysSingleDimensionWriter::WriteIntsImpl(yardl::NDArray<int32_t, 1> const& value) {
  yardl::binary::WriteNDArray<int32_t, yardl::binary::WriteInteger, 1>(stream_, value);
}

void NDArraysSingleDimensionWriter::WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1> const& value) {
  yardl::binary::WriteNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, 1>(stream_, value);
}

void NDArraysSingleDimensionWriter::WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) {
  yardl::binary::WriteNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens, 1>(stream_, value);
}

void NDArraysSingleDimensionWriter::WriteRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension const& value) {
  test_model::binary::WriteRecordWithNDArraysSingleDimension(stream_, value);
}

void NDArraysSingleDimensionWriter::Flush() {
  stream_.Flush();
}

void NDArraysSingleDimensionWriter::CloseImpl() {
  stream_.Flush();
}

void NDArraysSingleDimensionReader::ReadIntsImpl(yardl::NDArray<int32_t, 1>& value) {
  yardl::binary::ReadNDArray<int32_t, yardl::binary::ReadInteger, 1>(stream_, value);
}

void NDArraysSingleDimensionReader::ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1>& value) {
  yardl::binary::ReadNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, 1>(stream_, value);
}

void NDArraysSingleDimensionReader::ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1>& value) {
  yardl::binary::ReadNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens, 1>(stream_, value);
}

void NDArraysSingleDimensionReader::ReadRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension& value) {
  test_model::binary::ReadRecordWithNDArraysSingleDimension(stream_, value);
}

void NDArraysSingleDimensionReader::CloseImpl() {
  stream_.VerifyFinished();
}

void DynamicNDArraysWriter::WriteIntsImpl(yardl::DynamicNDArray<int32_t> const& value) {
  yardl::binary::WriteDynamicNDArray<int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void DynamicNDArraysWriter::WriteSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) {
  yardl::binary::WriteDynamicNDArray<test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream_, value);
}

void DynamicNDArraysWriter::WriteRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) {
  yardl::binary::WriteDynamicNDArray<test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens>(stream_, value);
}

void DynamicNDArraysWriter::WriteRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays const& value) {
  test_model::binary::WriteRecordWithDynamicNDArrays(stream_, value);
}

void DynamicNDArraysWriter::Flush() {
  stream_.Flush();
}

void DynamicNDArraysWriter::CloseImpl() {
  stream_.Flush();
}

void DynamicNDArraysReader::ReadIntsImpl(yardl::DynamicNDArray<int32_t>& value) {
  yardl::binary::ReadDynamicNDArray<int32_t, yardl::binary::ReadInteger>(stream_, value);
}

void DynamicNDArraysReader::ReadSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord>& value) {
  yardl::binary::ReadDynamicNDArray<test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream_, value);
}

void DynamicNDArraysReader::ReadRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens>& value) {
  yardl::binary::ReadDynamicNDArray<test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens>(stream_, value);
}

void DynamicNDArraysReader::ReadRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays& value) {
  test_model::binary::ReadRecordWithDynamicNDArrays(stream_, value);
}

void DynamicNDArraysReader::CloseImpl() {
  stream_.VerifyFinished();
}

void MultiDArraysWriter::WriteImagesImpl(yardl::NDArray<float, 4> const& value) {
  yardl::binary::WriteBlock<yardl::NDArray<float, 4>, yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 4>>(stream_, value);
}

void MultiDArraysWriter::WriteImagesImpl(std::vector<yardl::NDArray<float, 4>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<yardl::NDArray<float, 4>, yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 4>>(stream_, values);
  }
}

void MultiDArraysWriter::EndImagesImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MultiDArraysWriter::WriteFramesImpl(yardl::FixedNDArray<float, 1, 1, 64, 32> const& value) {
  yardl::binary::WriteBlock<yardl::FixedNDArray<float, 1, 1, 64, 32>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 1, 1, 64, 32>>(stream_, value);
}

void MultiDArraysWriter::WriteFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<yardl::FixedNDArray<float, 1, 1, 64, 32>, yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 1, 1, 64, 32>>(stream_, values);
  }
}

void MultiDArraysWriter::EndFramesImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MultiDArraysWriter::Flush() {
  stream_.Flush();
}

void MultiDArraysWriter::CloseImpl() {
  stream_.Flush();
}

bool MultiDArraysReader::ReadImagesImpl(yardl::NDArray<float, 4>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<yardl::NDArray<float, 4>, yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 4>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MultiDArraysReader::ReadImagesImpl(std::vector<yardl::NDArray<float, 4>>& values) {
  yardl::binary::ReadBlocksIntoVector<yardl::NDArray<float, 4>, yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 4>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool MultiDArraysReader::ReadFramesImpl(yardl::FixedNDArray<float, 1, 1, 64, 32>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<yardl::FixedNDArray<float, 1, 1, 64, 32>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 1, 1, 64, 32>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MultiDArraysReader::ReadFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>>& values) {
  yardl::binary::ReadBlocksIntoVector<yardl::FixedNDArray<float, 1, 1, 64, 32>, yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 1, 1, 64, 32>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void MultiDArraysReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ComplexArraysWriter::WriteFloatsImpl(yardl::DynamicNDArray<std::complex<float>> const& value) {
  yardl::binary::WriteDynamicNDArray<std::complex<float>, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void ComplexArraysWriter::WriteDoublesImpl(yardl::NDArray<std::complex<double>, 2> const& value) {
  yardl::binary::WriteNDArray<std::complex<double>, yardl::binary::WriteFloatingPoint, 2>(stream_, value);
}

void ComplexArraysWriter::Flush() {
  stream_.Flush();
}

void ComplexArraysWriter::CloseImpl() {
  stream_.Flush();
}

void ComplexArraysReader::ReadFloatsImpl(yardl::DynamicNDArray<std::complex<float>>& value) {
  yardl::binary::ReadDynamicNDArray<std::complex<float>, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void ComplexArraysReader::ReadDoublesImpl(yardl::NDArray<std::complex<double>, 2>& value) {
  yardl::binary::ReadNDArray<std::complex<double>, yardl::binary::ReadFloatingPoint, 2>(stream_, value);
}

void ComplexArraysReader::CloseImpl() {
  stream_.VerifyFinished();
}

void MapsWriter::WriteStringToIntImpl(std::unordered_map<std::string, int32_t> const& value) {
  yardl::binary::WriteMap<std::string, int32_t, yardl::binary::WriteString, yardl::binary::WriteInteger>(stream_, value);
}

void MapsWriter::WriteIntToStringImpl(std::unordered_map<int32_t, std::string> const& value) {
  yardl::binary::WriteMap<int32_t, std::string, yardl::binary::WriteInteger, yardl::binary::WriteString>(stream_, value);
}

void MapsWriter::WriteStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) {
  yardl::binary::WriteMap<std::string, std::variant<std::string, int32_t>, yardl::binary::WriteString, WriteUnion<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, value);
}

void MapsWriter::WriteAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t> const& value) {
  basic_types::binary::WriteAliasedMap<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void MapsWriter::WriteRecordsImpl(std::vector<test_model::RecordWithMaps> const& value) {
  yardl::binary::WriteVector<test_model::RecordWithMaps, test_model::binary::WriteRecordWithMaps>(stream_, value);
}

void MapsWriter::Flush() {
  stream_.Flush();
}

void MapsWriter::CloseImpl() {
  stream_.Flush();
}

void MapsReader::ReadStringToIntImpl(std::unordered_map<std::string, int32_t>& value) {
  yardl::binary::ReadMap<std::string, int32_t, yardl::binary::ReadString, yardl::binary::ReadInteger>(stream_, value);
}

void MapsReader::ReadIntToStringImpl(std::unordered_map<int32_t, std::string>& value) {
  yardl::binary::ReadMap<int32_t, std::string, yardl::binary::ReadInteger, yardl::binary::ReadString>(stream_, value);
}

void MapsReader::ReadStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value) {
  yardl::binary::ReadMap<std::string, std::variant<std::string, int32_t>, yardl::binary::ReadString, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, value);
}

void MapsReader::ReadAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t>& value) {
  basic_types::binary::ReadAliasedMap<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream_, value);
}

void MapsReader::ReadRecordsImpl(std::vector<test_model::RecordWithMaps>& value) {
  yardl::binary::ReadVector<test_model::RecordWithMaps, test_model::binary::ReadRecordWithMaps>(stream_, value);
}

void MapsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void UnionsWriter::WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  WriteUnion<int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream_, value);
}

void UnionsWriter::WriteIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens> const& value) {
  WriteUnion<int32_t, yardl::binary::WriteInteger, test_model::RecordWithVlens, test_model::binary::WriteRecordWithVlens>(stream_, value);
}

void UnionsWriter::WriteMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>(stream_, value);
}

void UnionsWriter::WriteRecordWithUnionsImpl(basic_types::RecordWithUnions const& value) {
  basic_types::binary::WriteRecordWithUnions(stream_, value);
}

void UnionsWriter::Flush() {
  stream_.Flush();
}

void UnionsWriter::CloseImpl() {
  stream_.Flush();
}

void UnionsReader::ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) {
  ReadUnion<int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream_, value);
}

void UnionsReader::ReadIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens>& value) {
  ReadUnion<int32_t, yardl::binary::ReadInteger, test_model::RecordWithVlens, test_model::binary::ReadRecordWithVlens>(stream_, value);
}

void UnionsReader::ReadMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>(stream_, value);
}

void UnionsReader::ReadRecordWithUnionsImpl(basic_types::RecordWithUnions& value) {
  basic_types::binary::ReadRecordWithUnions(stream_, value);
}

void UnionsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void StreamsOfUnionsWriter::WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) {
  yardl::binary::WriteBlock<std::variant<int32_t, test_model::SimpleRecord>, WriteUnion<int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>>(stream_, value);
}

void StreamsOfUnionsWriter::WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::variant<int32_t, test_model::SimpleRecord>, WriteUnion<int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>>(stream_, values);
  }
}

void StreamsOfUnionsWriter::EndIntOrSimpleRecordImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsOfUnionsWriter::WriteNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) {
  yardl::binary::WriteBlock<std::variant<std::monostate, int32_t, test_model::SimpleRecord>, WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>>(stream_, value);
}

void StreamsOfUnionsWriter::WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>, WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord>>(stream_, values);
  }
}

void StreamsOfUnionsWriter::EndNullableIntOrSimpleRecordImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsOfUnionsWriter::WriteManyCasesImpl(std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray> const& value) {
  yardl::binary::WriteBlock<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>, WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, test_model::NamedFixedNDArray, test_model::binary::WriteNamedFixedNDArray>>(stream_, value);
}

void StreamsOfUnionsWriter::WriteManyCasesImpl(std::vector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>, WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString, test_model::SimpleRecord, test_model::binary::WriteSimpleRecord, test_model::NamedFixedNDArray, test_model::binary::WriteNamedFixedNDArray>>(stream_, values);
  }
}

void StreamsOfUnionsWriter::EndManyCasesImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsOfUnionsWriter::Flush() {
  stream_.Flush();
}

void StreamsOfUnionsWriter::CloseImpl() {
  stream_.Flush();
}

bool StreamsOfUnionsReader::ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, test_model::SimpleRecord>, ReadUnion<int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsOfUnionsReader::ReadIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, test_model::SimpleRecord>, ReadUnion<int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool StreamsOfUnionsReader::ReadNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::variant<std::monostate, int32_t, test_model::SimpleRecord>, ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsOfUnionsReader::ReadNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>, ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool StreamsOfUnionsReader::ReadManyCasesImpl(std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>, ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, test_model::NamedFixedNDArray, test_model::binary::ReadNamedFixedNDArray>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsOfUnionsReader::ReadManyCasesImpl(std::vector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>, ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString, test_model::SimpleRecord, test_model::binary::ReadSimpleRecord, test_model::NamedFixedNDArray, test_model::binary::ReadNamedFixedNDArray>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void StreamsOfUnionsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void EnumsWriter::WriteSingleImpl(test_model::Fruits const& value) {
  test_model::binary::WriteFruits(stream_, value);
}

void EnumsWriter::WriteVecImpl(std::vector<test_model::Fruits> const& value) {
  yardl::binary::WriteVector<test_model::Fruits, test_model::binary::WriteFruits>(stream_, value);
}

void EnumsWriter::WriteSizeImpl(test_model::SizeBasedEnum const& value) {
  yardl::binary::WriteEnum<test_model::SizeBasedEnum>(stream_, value);
}

void EnumsWriter::WriteRecImpl(test_model::RecordWithEnums const& value) {
  test_model::binary::WriteRecordWithEnums(stream_, value);
}

void EnumsWriter::Flush() {
  stream_.Flush();
}

void EnumsWriter::CloseImpl() {
  stream_.Flush();
}

void EnumsReader::ReadSingleImpl(test_model::Fruits& value) {
  test_model::binary::ReadFruits(stream_, value);
}

void EnumsReader::ReadVecImpl(std::vector<test_model::Fruits>& value) {
  yardl::binary::ReadVector<test_model::Fruits, test_model::binary::ReadFruits>(stream_, value);
}

void EnumsReader::ReadSizeImpl(test_model::SizeBasedEnum& value) {
  yardl::binary::ReadEnum<test_model::SizeBasedEnum>(stream_, value);
}

void EnumsReader::ReadRecImpl(test_model::RecordWithEnums& value) {
  test_model::binary::ReadRecordWithEnums(stream_, value);
}

void EnumsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void FlagsWriter::WriteDaysImpl(test_model::DaysOfWeek const& value) {
  yardl::binary::WriteBlock<test_model::DaysOfWeek, test_model::binary::WriteDaysOfWeek>(stream_, value);
}

void FlagsWriter::WriteDaysImpl(std::vector<test_model::DaysOfWeek> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::DaysOfWeek, test_model::binary::WriteDaysOfWeek>(stream_, values);
  }
}

void FlagsWriter::EndDaysImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void FlagsWriter::WriteFormatsImpl(test_model::TextFormat const& value) {
  yardl::binary::WriteBlock<test_model::TextFormat, test_model::binary::WriteTextFormat>(stream_, value);
}

void FlagsWriter::WriteFormatsImpl(std::vector<test_model::TextFormat> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::TextFormat, test_model::binary::WriteTextFormat>(stream_, values);
  }
}

void FlagsWriter::EndFormatsImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void FlagsWriter::Flush() {
  stream_.Flush();
}

void FlagsWriter::CloseImpl() {
  stream_.Flush();
}

bool FlagsReader::ReadDaysImpl(test_model::DaysOfWeek& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::DaysOfWeek, test_model::binary::ReadDaysOfWeek>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool FlagsReader::ReadDaysImpl(std::vector<test_model::DaysOfWeek>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::DaysOfWeek, test_model::binary::ReadDaysOfWeek>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool FlagsReader::ReadFormatsImpl(test_model::TextFormat& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::TextFormat, test_model::binary::ReadTextFormat>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool FlagsReader::ReadFormatsImpl(std::vector<test_model::TextFormat>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::TextFormat, test_model::binary::ReadTextFormat>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void FlagsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void StateTestWriter::WriteAnIntImpl(int32_t const& value) {
  yardl::binary::WriteInteger(stream_, value);
}

void StateTestWriter::WriteAStreamImpl(int32_t const& value) {
  yardl::binary::WriteBlock<int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void StateTestWriter::WriteAStreamImpl(std::vector<int32_t> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, values);
  }
}

void StateTestWriter::EndAStreamImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StateTestWriter::WriteAnotherIntImpl(int32_t const& value) {
  yardl::binary::WriteInteger(stream_, value);
}

void StateTestWriter::Flush() {
  stream_.Flush();
}

void StateTestWriter::CloseImpl() {
  stream_.Flush();
}

void StateTestReader::ReadAnIntImpl(int32_t& value) {
  yardl::binary::ReadInteger(stream_, value);
}

bool StateTestReader::ReadAStreamImpl(int32_t& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StateTestReader::ReadAStreamImpl(std::vector<int32_t>& values) {
  yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void StateTestReader::ReadAnotherIntImpl(int32_t& value) {
  yardl::binary::ReadInteger(stream_, value);
}

void StateTestReader::CloseImpl() {
  stream_.VerifyFinished();
}

void SimpleGenericsWriter::WriteFloatImageImpl(image::FloatImage const& value) {
  image::binary::WriteFloatImage(stream_, value);
}

void SimpleGenericsWriter::WriteIntImageImpl(image::IntImage const& value) {
  image::binary::WriteIntImage(stream_, value);
}

void SimpleGenericsWriter::WriteIntImageAlternateSyntaxImpl(test_model::Image<int32_t> const& value) {
  test_model::binary::WriteImage<int32_t, yardl::binary::WriteInteger>(stream_, value);
}

void SimpleGenericsWriter::WriteStringImageImpl(test_model::Image<std::string> const& value) {
  test_model::binary::WriteImage<std::string, yardl::binary::WriteString>(stream_, value);
}

void SimpleGenericsWriter::WriteIntFloatTupleImpl(tuples::Tuple<int32_t, float> const& value) {
  tuples::binary::WriteTuple<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void SimpleGenericsWriter::WriteFloatFloatTupleImpl(tuples::Tuple<float, float> const& value) {
  tuples::binary::WriteTuple<float, yardl::binary::WriteFloatingPoint, float, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void SimpleGenericsWriter::WriteIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float> const& value) {
  tuples::binary::WriteTuple<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void SimpleGenericsWriter::WriteIntStringTupleImpl(tuples::Tuple<int32_t, std::string> const& value) {
  tuples::binary::WriteTuple<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
}

void SimpleGenericsWriter::WriteStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>> const& value) {
  yardl::binary::WriteBlock<std::variant<image::FloatImage, test_model::Image<double>>, WriteUnion<image::FloatImage, image::binary::WriteFloatImage, test_model::Image<double>, test_model::binary::WriteImage<double, yardl::binary::WriteFloatingPoint>>>(stream_, value);
}

void SimpleGenericsWriter::WriteStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<std::variant<image::FloatImage, test_model::Image<double>>, WriteUnion<image::FloatImage, image::binary::WriteFloatImage, test_model::Image<double>, test_model::binary::WriteImage<double, yardl::binary::WriteFloatingPoint>>>(stream_, values);
  }
}

void SimpleGenericsWriter::EndStreamOfTypeVariantsImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void SimpleGenericsWriter::Flush() {
  stream_.Flush();
}

void SimpleGenericsWriter::CloseImpl() {
  stream_.Flush();
}

void SimpleGenericsReader::ReadFloatImageImpl(image::FloatImage& value) {
  image::binary::ReadFloatImage(stream_, value);
}

void SimpleGenericsReader::ReadIntImageImpl(image::IntImage& value) {
  image::binary::ReadIntImage(stream_, value);
}

void SimpleGenericsReader::ReadIntImageAlternateSyntaxImpl(test_model::Image<int32_t>& value) {
  test_model::binary::ReadImage<int32_t, yardl::binary::ReadInteger>(stream_, value);
}

void SimpleGenericsReader::ReadStringImageImpl(test_model::Image<std::string>& value) {
  test_model::binary::ReadImage<std::string, yardl::binary::ReadString>(stream_, value);
}

void SimpleGenericsReader::ReadIntFloatTupleImpl(tuples::Tuple<int32_t, float>& value) {
  tuples::binary::ReadTuple<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void SimpleGenericsReader::ReadFloatFloatTupleImpl(tuples::Tuple<float, float>& value) {
  tuples::binary::ReadTuple<float, yardl::binary::ReadFloatingPoint, float, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void SimpleGenericsReader::ReadIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float>& value) {
  tuples::binary::ReadTuple<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void SimpleGenericsReader::ReadIntStringTupleImpl(tuples::Tuple<int32_t, std::string>& value) {
  tuples::binary::ReadTuple<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
}

bool SimpleGenericsReader::ReadStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<std::variant<image::FloatImage, test_model::Image<double>>, ReadUnion<image::FloatImage, image::binary::ReadFloatImage, test_model::Image<double>, test_model::binary::ReadImage<double, yardl::binary::ReadFloatingPoint>>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool SimpleGenericsReader::ReadStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>>& values) {
  yardl::binary::ReadBlocksIntoVector<std::variant<image::FloatImage, test_model::Image<double>>, ReadUnion<image::FloatImage, image::binary::ReadFloatImage, test_model::Image<double>, test_model::binary::ReadImage<double, yardl::binary::ReadFloatingPoint>>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void SimpleGenericsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void AdvancedGenericsWriter::WriteFloatImageImageImpl(test_model::Image<test_model::Image<float>> const& value) {
  test_model::binary::WriteImage<test_model::Image<float>, test_model::binary::WriteImage<float, yardl::binary::WriteFloatingPoint>>(stream_, value);
}

void AdvancedGenericsWriter::WriteGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string> const& value) {
  test_model::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
}

void AdvancedGenericsWriter::WriteTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  test_model::binary::WriteMyTuple<std::optional<int32_t>, yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>, std::optional<std::string>, yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>>(stream_, value);
}

void AdvancedGenericsWriter::WriteTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) {
  test_model::binary::WriteMyTuple<std::optional<int32_t>, yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>, std::optional<std::string>, yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>>(stream_, value);
}

void AdvancedGenericsWriter::WriteTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) {
  test_model::binary::WriteMyTuple<std::vector<int32_t>, yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>, std::vector<float>, yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>>(stream_, value);
}

void AdvancedGenericsWriter::Flush() {
  stream_.Flush();
}

void AdvancedGenericsWriter::CloseImpl() {
  stream_.Flush();
}

void AdvancedGenericsReader::ReadFloatImageImageImpl(test_model::Image<test_model::Image<float>>& value) {
  test_model::binary::ReadImage<test_model::Image<float>, test_model::binary::ReadImage<float, yardl::binary::ReadFloatingPoint>>(stream_, value);
}

void AdvancedGenericsReader::ReadGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string>& value) {
  test_model::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
}

void AdvancedGenericsReader::ReadTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  test_model::binary::ReadMyTuple<std::optional<int32_t>, yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>, std::optional<std::string>, yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>>(stream_, value);
}

void AdvancedGenericsReader::ReadTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) {
  test_model::binary::ReadMyTuple<std::optional<int32_t>, yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>, std::optional<std::string>, yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>>(stream_, value);
}

void AdvancedGenericsReader::ReadTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value) {
  test_model::binary::ReadMyTuple<std::vector<int32_t>, yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>, std::vector<float>, yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>>(stream_, value);
}

void AdvancedGenericsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void AliasesWriter::WriteAliasedStringImpl(test_model::AliasedString const& value) {
  test_model::binary::WriteAliasedString(stream_, value);
}

void AliasesWriter::WriteAliasedEnumImpl(test_model::AliasedEnum const& value) {
  test_model::binary::WriteAliasedEnum(stream_, value);
}

void AliasesWriter::WriteAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  test_model::binary::WriteAliasedOpenGeneric<test_model::AliasedString, test_model::binary::WriteAliasedString, test_model::AliasedEnum, test_model::binary::WriteAliasedEnum>(stream_, value);
}

void AliasesWriter::WriteAliasedClosedGenericImpl(test_model::AliasedClosedGeneric const& value) {
  test_model::binary::WriteAliasedClosedGeneric(stream_, value);
}

void AliasesWriter::WriteAliasedOptionalImpl(test_model::AliasedOptional const& value) {
  test_model::binary::WriteAliasedOptional(stream_, value);
}

void AliasesWriter::WriteAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float> const& value) {
  test_model::binary::WriteAliasedGenericOptional<float, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void AliasesWriter::WriteAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  test_model::binary::WriteAliasedGenericUnion2<test_model::AliasedString, test_model::binary::WriteAliasedString, test_model::AliasedEnum, test_model::binary::WriteAliasedEnum>(stream_, value);
}

void AliasesWriter::WriteAliasedGenericVectorImpl(test_model::AliasedGenericVector<float> const& value) {
  test_model::binary::WriteAliasedGenericVector<float, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void AliasesWriter::WriteAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float> const& value) {
  test_model::binary::WriteAliasedGenericFixedVector<float, yardl::binary::WriteFloatingPoint>(stream_, value);
}

void AliasesWriter::WriteStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) {
  yardl::binary::WriteBlock<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>, test_model::binary::WriteAliasedGenericUnion2<test_model::AliasedString, test_model::binary::WriteAliasedString, test_model::AliasedEnum, test_model::binary::WriteAliasedEnum>>(stream_, value);
}

void AliasesWriter::WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>, test_model::binary::WriteAliasedGenericUnion2<test_model::AliasedString, test_model::binary::WriteAliasedString, test_model::AliasedEnum, test_model::binary::WriteAliasedEnum>>(stream_, values);
  }
}

void AliasesWriter::EndStreamOfAliasedGenericUnion2Impl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void AliasesWriter::WriteVectorsImpl(std::vector<test_model::RecordContainingVectorsOfAliases> const& value) {
  yardl::binary::WriteVector<test_model::RecordContainingVectorsOfAliases, test_model::binary::WriteRecordContainingVectorsOfAliases>(stream_, value);
}

void AliasesWriter::Flush() {
  stream_.Flush();
}

void AliasesWriter::CloseImpl() {
  stream_.Flush();
}

void AliasesReader::ReadAliasedStringImpl(test_model::AliasedString& value) {
  test_model::binary::ReadAliasedString(stream_, value);
}

void AliasesReader::ReadAliasedEnumImpl(test_model::AliasedEnum& value) {
  test_model::binary::ReadAliasedEnum(stream_, value);
}

void AliasesReader::ReadAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value) {
  test_model::binary::ReadAliasedOpenGeneric<test_model::AliasedString, test_model::binary::ReadAliasedString, test_model::AliasedEnum, test_model::binary::ReadAliasedEnum>(stream_, value);
}

void AliasesReader::ReadAliasedClosedGenericImpl(test_model::AliasedClosedGeneric& value) {
  test_model::binary::ReadAliasedClosedGeneric(stream_, value);
}

void AliasesReader::ReadAliasedOptionalImpl(test_model::AliasedOptional& value) {
  test_model::binary::ReadAliasedOptional(stream_, value);
}

void AliasesReader::ReadAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float>& value) {
  test_model::binary::ReadAliasedGenericOptional<float, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void AliasesReader::ReadAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  test_model::binary::ReadAliasedGenericUnion2<test_model::AliasedString, test_model::binary::ReadAliasedString, test_model::AliasedEnum, test_model::binary::ReadAliasedEnum>(stream_, value);
}

void AliasesReader::ReadAliasedGenericVectorImpl(test_model::AliasedGenericVector<float>& value) {
  test_model::binary::ReadAliasedGenericVector<float, yardl::binary::ReadFloatingPoint>(stream_, value);
}

void AliasesReader::ReadAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float>& value) {
  test_model::binary::ReadAliasedGenericFixedVector<float, yardl::binary::ReadFloatingPoint>(stream_, value);
}

bool AliasesReader::ReadStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>, test_model::binary::ReadAliasedGenericUnion2<test_model::AliasedString, test_model::binary::ReadAliasedString, test_model::AliasedEnum, test_model::binary::ReadAliasedEnum>>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool AliasesReader::ReadStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>, test_model::binary::ReadAliasedGenericUnion2<test_model::AliasedString, test_model::binary::ReadAliasedString, test_model::AliasedEnum, test_model::binary::ReadAliasedEnum>>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void AliasesReader::ReadVectorsImpl(std::vector<test_model::RecordContainingVectorsOfAliases>& value) {
  yardl::binary::ReadVector<test_model::RecordContainingVectorsOfAliases, test_model::binary::ReadRecordContainingVectorsOfAliases>(stream_, value);
}

void AliasesReader::CloseImpl() {
  stream_.VerifyFinished();
}

void StreamsOfAliasedUnionsWriter::WriteIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord const& value) {
  yardl::binary::WriteBlock<test_model::AliasedIntOrSimpleRecord, test_model::binary::WriteAliasedIntOrSimpleRecord>(stream_, value);
}

void StreamsOfAliasedUnionsWriter::WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::AliasedIntOrSimpleRecord, test_model::binary::WriteAliasedIntOrSimpleRecord>(stream_, values);
  }
}

void StreamsOfAliasedUnionsWriter::EndIntOrSimpleRecordImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsOfAliasedUnionsWriter::WriteNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord const& value) {
  yardl::binary::WriteBlock<test_model::AliasedNullableIntSimpleRecord, test_model::binary::WriteAliasedNullableIntSimpleRecord>(stream_, value);
}

void StreamsOfAliasedUnionsWriter::WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::AliasedNullableIntSimpleRecord, test_model::binary::WriteAliasedNullableIntSimpleRecord>(stream_, values);
  }
}

void StreamsOfAliasedUnionsWriter::EndNullableIntOrSimpleRecordImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void StreamsOfAliasedUnionsWriter::Flush() {
  stream_.Flush();
}

void StreamsOfAliasedUnionsWriter::CloseImpl() {
  stream_.Flush();
}

bool StreamsOfAliasedUnionsReader::ReadIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::AliasedIntOrSimpleRecord, test_model::binary::ReadAliasedIntOrSimpleRecord>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsOfAliasedUnionsReader::ReadIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::AliasedIntOrSimpleRecord, test_model::binary::ReadAliasedIntOrSimpleRecord>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool StreamsOfAliasedUnionsReader::ReadNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::AliasedNullableIntSimpleRecord, test_model::binary::ReadAliasedNullableIntSimpleRecord>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool StreamsOfAliasedUnionsReader::ReadNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::AliasedNullableIntSimpleRecord, test_model::binary::ReadAliasedNullableIntSimpleRecord>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void StreamsOfAliasedUnionsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ProtocolWithComputedFieldsWriter::WriteRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields const& value) {
  test_model::binary::WriteRecordWithComputedFields(stream_, value);
}

void ProtocolWithComputedFieldsWriter::Flush() {
  stream_.Flush();
}

void ProtocolWithComputedFieldsWriter::CloseImpl() {
  stream_.Flush();
}

void ProtocolWithComputedFieldsReader::ReadRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields& value) {
  test_model::binary::ReadRecordWithComputedFields(stream_, value);
}

void ProtocolWithComputedFieldsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ProtocolWithKeywordStepsWriter::WriteIntImpl(test_model::RecordWithKeywordFields const& value) {
  yardl::binary::WriteBlock<test_model::RecordWithKeywordFields, test_model::binary::WriteRecordWithKeywordFields>(stream_, value);
}

void ProtocolWithKeywordStepsWriter::WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<test_model::RecordWithKeywordFields, test_model::binary::WriteRecordWithKeywordFields>(stream_, values);
  }
}

void ProtocolWithKeywordStepsWriter::EndIntImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void ProtocolWithKeywordStepsWriter::WriteFloatImpl(test_model::EnumWithKeywordSymbols const& value) {
  yardl::binary::WriteEnum<test_model::EnumWithKeywordSymbols>(stream_, value);
}

void ProtocolWithKeywordStepsWriter::Flush() {
  stream_.Flush();
}

void ProtocolWithKeywordStepsWriter::CloseImpl() {
  stream_.Flush();
}

bool ProtocolWithKeywordStepsReader::ReadIntImpl(test_model::RecordWithKeywordFields& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<test_model::RecordWithKeywordFields, test_model::binary::ReadRecordWithKeywordFields>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool ProtocolWithKeywordStepsReader::ReadIntImpl(std::vector<test_model::RecordWithKeywordFields>& values) {
  yardl::binary::ReadBlocksIntoVector<test_model::RecordWithKeywordFields, test_model::binary::ReadRecordWithKeywordFields>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void ProtocolWithKeywordStepsReader::ReadFloatImpl(test_model::EnumWithKeywordSymbols& value) {
  yardl::binary::ReadEnum<test_model::EnumWithKeywordSymbols>(stream_, value);
}

void ProtocolWithKeywordStepsReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ProtocolWithOptionalDateWriter::WriteRecordImpl(std::optional<test_model::RecordWithOptionalDate> const& value) {
  yardl::binary::WriteOptional<test_model::RecordWithOptionalDate, test_model::binary::WriteRecordWithOptionalDate>(stream_, value);
}

void ProtocolWithOptionalDateWriter::Flush() {
  stream_.Flush();
}

void ProtocolWithOptionalDateWriter::CloseImpl() {
  stream_.Flush();
}

void ProtocolWithOptionalDateReader::ReadRecordImpl(std::optional<test_model::RecordWithOptionalDate>& value) {
  yardl::binary::ReadOptional<test_model::RecordWithOptionalDate, test_model::binary::ReadRecordWithOptionalDate>(stream_, value);
}

void ProtocolWithOptionalDateReader::CloseImpl() {
  stream_.VerifyFinished();
}

} // namespace test_model::binary

