// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include "types.h"

namespace test_model {
enum class Version {
  Current
};
// Abstract writer for the BenchmarkFloat256x256 protocol.
class BenchmarkFloat256x256WriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `float256x256` stream, then call `EndFloat256x256() when done.`
  void WriteFloat256x256(yardl::FixedNDArray<float, 256, 256> const& value);

  // Ordinal 0.
  // Call this method to write many values to the `float256x256` stream, then call `EndFloat256x256()` when done.
  void WriteFloat256x256(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values);

  // Marks the end of the `float256x256` stream.
  void EndFloat256x256();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~BenchmarkFloat256x256WriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteFloat256x256Impl(yardl::FixedNDArray<float, 256, 256> const& value) = 0;
  virtual void WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& value);
  virtual void EndFloat256x256Impl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class BenchmarkFloat256x256ReaderBase;
};

// Abstract reader for the BenchmarkFloat256x256 protocol.
class BenchmarkFloat256x256ReaderBase {
  public:
  BenchmarkFloat256x256ReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadFloat256x256(yardl::FixedNDArray<float, 256, 256>& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadFloat256x256(std::vector<yardl::FixedNDArray<float, 256, 256>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(BenchmarkFloat256x256WriterBase& writer, size_t float256x256_buffer_size = 1);

  virtual ~BenchmarkFloat256x256ReaderBase() = default;

  protected:
  virtual bool ReadFloat256x256Impl(yardl::FixedNDArray<float, 256, 256>& value) = 0;
  virtual bool ReadFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the BenchmarkInt256x256 protocol.
class BenchmarkInt256x256WriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `int256x256` stream, then call `EndInt256x256() when done.`
  void WriteInt256x256(yardl::FixedNDArray<int32_t, 256, 256> const& value);

  // Ordinal 0.
  // Call this method to write many values to the `int256x256` stream, then call `EndInt256x256()` when done.
  void WriteInt256x256(std::vector<yardl::FixedNDArray<int32_t, 256, 256>> const& values);

  // Marks the end of the `int256x256` stream.
  void EndInt256x256();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~BenchmarkInt256x256WriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256> const& value) = 0;
  virtual void WriteInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>> const& value);
  virtual void EndInt256x256Impl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class BenchmarkInt256x256ReaderBase;
};

// Abstract reader for the BenchmarkInt256x256 protocol.
class BenchmarkInt256x256ReaderBase {
  public:
  BenchmarkInt256x256ReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadInt256x256(yardl::FixedNDArray<int32_t, 256, 256>& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadInt256x256(std::vector<yardl::FixedNDArray<int32_t, 256, 256>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(BenchmarkInt256x256WriterBase& writer, size_t int256x256_buffer_size = 1);

  virtual ~BenchmarkInt256x256ReaderBase() = default;

  protected:
  virtual bool ReadInt256x256Impl(yardl::FixedNDArray<int32_t, 256, 256>& value) = 0;
  virtual bool ReadInt256x256Impl(std::vector<yardl::FixedNDArray<int32_t, 256, 256>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the BenchmarkFloatVlen protocol.
class BenchmarkFloatVlenWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `floatArray` stream, then call `EndFloatArray() when done.`
  void WriteFloatArray(yardl::NDArray<float, 2> const& value);

  // Ordinal 0.
  // Call this method to write many values to the `floatArray` stream, then call `EndFloatArray()` when done.
  void WriteFloatArray(std::vector<yardl::NDArray<float, 2>> const& values);

  // Marks the end of the `floatArray` stream.
  void EndFloatArray();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~BenchmarkFloatVlenWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteFloatArrayImpl(yardl::NDArray<float, 2> const& value) = 0;
  virtual void WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& value);
  virtual void EndFloatArrayImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class BenchmarkFloatVlenReaderBase;
};

// Abstract reader for the BenchmarkFloatVlen protocol.
class BenchmarkFloatVlenReaderBase {
  public:
  BenchmarkFloatVlenReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadFloatArray(yardl::NDArray<float, 2>& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadFloatArray(std::vector<yardl::NDArray<float, 2>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(BenchmarkFloatVlenWriterBase& writer, size_t float_array_buffer_size = 1);

  virtual ~BenchmarkFloatVlenReaderBase() = default;

  protected:
  virtual bool ReadFloatArrayImpl(yardl::NDArray<float, 2>& value) = 0;
  virtual bool ReadFloatArrayImpl(std::vector<yardl::NDArray<float, 2>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the BenchmarkSmallRecord protocol.
class BenchmarkSmallRecordWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `smallRecord` stream, then call `EndSmallRecord() when done.`
  void WriteSmallRecord(test_model::SmallBenchmarkRecord const& value);

  // Ordinal 0.
  // Call this method to write many values to the `smallRecord` stream, then call `EndSmallRecord()` when done.
  void WriteSmallRecord(std::vector<test_model::SmallBenchmarkRecord> const& values);

  // Marks the end of the `smallRecord` stream.
  void EndSmallRecord();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~BenchmarkSmallRecordWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteSmallRecordImpl(test_model::SmallBenchmarkRecord const& value) = 0;
  virtual void WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& value);
  virtual void EndSmallRecordImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class BenchmarkSmallRecordReaderBase;
};

// Abstract reader for the BenchmarkSmallRecord protocol.
class BenchmarkSmallRecordReaderBase {
  public:
  BenchmarkSmallRecordReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadSmallRecord(test_model::SmallBenchmarkRecord& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadSmallRecord(std::vector<test_model::SmallBenchmarkRecord>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(BenchmarkSmallRecordWriterBase& writer, size_t small_record_buffer_size = 1);

  virtual ~BenchmarkSmallRecordReaderBase() = default;

  protected:
  virtual bool ReadSmallRecordImpl(test_model::SmallBenchmarkRecord& value) = 0;
  virtual bool ReadSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the BenchmarkSmallRecordWithOptionals protocol.
class BenchmarkSmallRecordWithOptionalsWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `smallRecord` stream, then call `EndSmallRecord() when done.`
  void WriteSmallRecord(test_model::SimpleEncodingCounters const& value);

  // Ordinal 0.
  // Call this method to write many values to the `smallRecord` stream, then call `EndSmallRecord()` when done.
  void WriteSmallRecord(std::vector<test_model::SimpleEncodingCounters> const& values);

  // Marks the end of the `smallRecord` stream.
  void EndSmallRecord();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~BenchmarkSmallRecordWithOptionalsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteSmallRecordImpl(test_model::SimpleEncodingCounters const& value) = 0;
  virtual void WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& value);
  virtual void EndSmallRecordImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class BenchmarkSmallRecordWithOptionalsReaderBase;
};

// Abstract reader for the BenchmarkSmallRecordWithOptionals protocol.
class BenchmarkSmallRecordWithOptionalsReaderBase {
  public:
  BenchmarkSmallRecordWithOptionalsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadSmallRecord(test_model::SimpleEncodingCounters& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadSmallRecord(std::vector<test_model::SimpleEncodingCounters>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(BenchmarkSmallRecordWithOptionalsWriterBase& writer, size_t small_record_buffer_size = 1);

  virtual ~BenchmarkSmallRecordWithOptionalsReaderBase() = default;

  protected:
  virtual bool ReadSmallRecordImpl(test_model::SimpleEncodingCounters& value) = 0;
  virtual bool ReadSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the BenchmarkSimpleMrd protocol.
class BenchmarkSimpleMrdWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `data` stream, then call `EndData() when done.`
  void WriteData(std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value);

  // Ordinal 0.
  // Call this method to write many values to the `data` stream, then call `EndData()` when done.
  void WriteData(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> const& values);

  // Marks the end of the `data` stream.
  void EndData();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~BenchmarkSimpleMrdWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>> const& value) = 0;
  virtual void WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>> const& value);
  virtual void EndDataImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class BenchmarkSimpleMrdReaderBase;
};

// Abstract reader for the BenchmarkSimpleMrd protocol.
class BenchmarkSimpleMrdReaderBase {
  public:
  BenchmarkSimpleMrdReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadData(std::variant<test_model::SimpleAcquisition, image::Image<float>>& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadData(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(BenchmarkSimpleMrdWriterBase& writer, size_t data_buffer_size = 1);

  virtual ~BenchmarkSimpleMrdReaderBase() = default;

  protected:
  virtual bool ReadDataImpl(std::variant<test_model::SimpleAcquisition, image::Image<float>>& value) = 0;
  virtual bool ReadDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, image::Image<float>>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Scalars protocol.
class ScalarsWriterBase {
  public:
  // Ordinal 0.
  void WriteInt32(int32_t const& value);

  // Ordinal 1.
  void WriteRecord(test_model::RecordWithPrimitives const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~ScalarsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteInt32Impl(int32_t const& value) = 0;
  virtual void WriteRecordImpl(test_model::RecordWithPrimitives const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class ScalarsReaderBase;
};

// Abstract reader for the Scalars protocol.
class ScalarsReaderBase {
  public:
  ScalarsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadInt32(int32_t& value);

  // Ordinal 1.
  void ReadRecord(test_model::RecordWithPrimitives& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(ScalarsWriterBase& writer);

  virtual ~ScalarsReaderBase() = default;

  protected:
  virtual void ReadInt32Impl(int32_t& value) = 0;
  virtual void ReadRecordImpl(test_model::RecordWithPrimitives& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the ScalarOptionals protocol.
class ScalarOptionalsWriterBase {
  public:
  // Ordinal 0.
  void WriteOptionalInt(std::optional<int32_t> const& value);

  // Ordinal 1.
  void WriteOptionalRecord(std::optional<test_model::SimpleRecord> const& value);

  // Ordinal 2.
  void WriteRecordWithOptionalFields(test_model::RecordWithOptionalFields const& value);

  // Ordinal 3.
  void WriteOptionalRecordWithOptionalFields(std::optional<test_model::RecordWithOptionalFields> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~ScalarOptionalsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteOptionalIntImpl(std::optional<int32_t> const& value) = 0;
  virtual void WriteOptionalRecordImpl(std::optional<test_model::SimpleRecord> const& value) = 0;
  virtual void WriteRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields const& value) = 0;
  virtual void WriteOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class ScalarOptionalsReaderBase;
};

// Abstract reader for the ScalarOptionals protocol.
class ScalarOptionalsReaderBase {
  public:
  ScalarOptionalsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadOptionalInt(std::optional<int32_t>& value);

  // Ordinal 1.
  void ReadOptionalRecord(std::optional<test_model::SimpleRecord>& value);

  // Ordinal 2.
  void ReadRecordWithOptionalFields(test_model::RecordWithOptionalFields& value);

  // Ordinal 3.
  void ReadOptionalRecordWithOptionalFields(std::optional<test_model::RecordWithOptionalFields>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(ScalarOptionalsWriterBase& writer);

  virtual ~ScalarOptionalsReaderBase() = default;

  protected:
  virtual void ReadOptionalIntImpl(std::optional<int32_t>& value) = 0;
  virtual void ReadOptionalRecordImpl(std::optional<test_model::SimpleRecord>& value) = 0;
  virtual void ReadRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields& value) = 0;
  virtual void ReadOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the NestedRecords protocol.
class NestedRecordsWriterBase {
  public:
  // Ordinal 0.
  void WriteTupleWithRecords(test_model::TupleWithRecords const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~NestedRecordsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteTupleWithRecordsImpl(test_model::TupleWithRecords const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class NestedRecordsReaderBase;
};

// Abstract reader for the NestedRecords protocol.
class NestedRecordsReaderBase {
  public:
  NestedRecordsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadTupleWithRecords(test_model::TupleWithRecords& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(NestedRecordsWriterBase& writer);

  virtual ~NestedRecordsReaderBase() = default;

  protected:
  virtual void ReadTupleWithRecordsImpl(test_model::TupleWithRecords& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Vlens protocol.
class VlensWriterBase {
  public:
  // Ordinal 0.
  void WriteIntVector(std::vector<int32_t> const& value);

  // Ordinal 1.
  void WriteComplexVector(std::vector<std::complex<float>> const& value);

  // Ordinal 2.
  void WriteRecordWithVlens(test_model::RecordWithVlens const& value);

  // Ordinal 3.
  void WriteVlenOfRecordWithVlens(std::vector<test_model::RecordWithVlens> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~VlensWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntVectorImpl(std::vector<int32_t> const& value) = 0;
  virtual void WriteComplexVectorImpl(std::vector<std::complex<float>> const& value) = 0;
  virtual void WriteRecordWithVlensImpl(test_model::RecordWithVlens const& value) = 0;
  virtual void WriteVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class VlensReaderBase;
};

// Abstract reader for the Vlens protocol.
class VlensReaderBase {
  public:
  VlensReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadIntVector(std::vector<int32_t>& value);

  // Ordinal 1.
  void ReadComplexVector(std::vector<std::complex<float>>& value);

  // Ordinal 2.
  void ReadRecordWithVlens(test_model::RecordWithVlens& value);

  // Ordinal 3.
  void ReadVlenOfRecordWithVlens(std::vector<test_model::RecordWithVlens>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(VlensWriterBase& writer);

  virtual ~VlensReaderBase() = default;

  protected:
  virtual void ReadIntVectorImpl(std::vector<int32_t>& value) = 0;
  virtual void ReadComplexVectorImpl(std::vector<std::complex<float>>& value) = 0;
  virtual void ReadRecordWithVlensImpl(test_model::RecordWithVlens& value) = 0;
  virtual void ReadVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Strings protocol.
class StringsWriterBase {
  public:
  // Ordinal 0.
  void WriteSingleString(std::string const& value);

  // Ordinal 1.
  void WriteRecWithString(test_model::RecordWithStrings const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~StringsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteSingleStringImpl(std::string const& value) = 0;
  virtual void WriteRecWithStringImpl(test_model::RecordWithStrings const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class StringsReaderBase;
};

// Abstract reader for the Strings protocol.
class StringsReaderBase {
  public:
  StringsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadSingleString(std::string& value);

  // Ordinal 1.
  void ReadRecWithString(test_model::RecordWithStrings& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(StringsWriterBase& writer);

  virtual ~StringsReaderBase() = default;

  protected:
  virtual void ReadSingleStringImpl(std::string& value) = 0;
  virtual void ReadRecWithStringImpl(test_model::RecordWithStrings& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the OptionalVectors protocol.
class OptionalVectorsWriterBase {
  public:
  // Ordinal 0.
  void WriteRecordWithOptionalVector(test_model::RecordWithOptionalVector const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~OptionalVectorsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class OptionalVectorsReaderBase;
};

// Abstract reader for the OptionalVectors protocol.
class OptionalVectorsReaderBase {
  public:
  OptionalVectorsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadRecordWithOptionalVector(test_model::RecordWithOptionalVector& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(OptionalVectorsWriterBase& writer);

  virtual ~OptionalVectorsReaderBase() = default;

  protected:
  virtual void ReadRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the FixedVectors protocol.
class FixedVectorsWriterBase {
  public:
  // Ordinal 0.
  void WriteFixedIntVector(std::array<int32_t, 5> const& value);

  // Ordinal 1.
  void WriteFixedSimpleRecordVector(std::array<test_model::SimpleRecord, 3> const& value);

  // Ordinal 2.
  void WriteFixedRecordWithVlensVector(std::array<test_model::RecordWithVlens, 2> const& value);

  // Ordinal 3.
  void WriteRecordWithFixedVectors(test_model::RecordWithFixedVectors const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~FixedVectorsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteFixedIntVectorImpl(std::array<int32_t, 5> const& value) = 0;
  virtual void WriteFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3> const& value) = 0;
  virtual void WriteFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2> const& value) = 0;
  virtual void WriteRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class FixedVectorsReaderBase;
};

// Abstract reader for the FixedVectors protocol.
class FixedVectorsReaderBase {
  public:
  FixedVectorsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadFixedIntVector(std::array<int32_t, 5>& value);

  // Ordinal 1.
  void ReadFixedSimpleRecordVector(std::array<test_model::SimpleRecord, 3>& value);

  // Ordinal 2.
  void ReadFixedRecordWithVlensVector(std::array<test_model::RecordWithVlens, 2>& value);

  // Ordinal 3.
  void ReadRecordWithFixedVectors(test_model::RecordWithFixedVectors& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(FixedVectorsWriterBase& writer);

  virtual ~FixedVectorsReaderBase() = default;

  protected:
  virtual void ReadFixedIntVectorImpl(std::array<int32_t, 5>& value) = 0;
  virtual void ReadFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3>& value) = 0;
  virtual void ReadFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2>& value) = 0;
  virtual void ReadRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Streams protocol.
class StreamsWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `intData` stream, then call `EndIntData() when done.`
  void WriteIntData(int32_t const& value);

  // Ordinal 0.
  // Call this method to write many values to the `intData` stream, then call `EndIntData()` when done.
  void WriteIntData(std::vector<int32_t> const& values);

  // Marks the end of the `intData` stream.
  void EndIntData();

  // Ordinal 1.
  // Call this method for each element of the `optionalIntData` stream, then call `EndOptionalIntData() when done.`
  void WriteOptionalIntData(std::optional<int32_t> const& value);

  // Ordinal 1.
  // Call this method to write many values to the `optionalIntData` stream, then call `EndOptionalIntData()` when done.
  void WriteOptionalIntData(std::vector<std::optional<int32_t>> const& values);

  // Marks the end of the `optionalIntData` stream.
  void EndOptionalIntData();

  // Ordinal 2.
  // Call this method for each element of the `recordWithOptionalVectorData` stream, then call `EndRecordWithOptionalVectorData() when done.`
  void WriteRecordWithOptionalVectorData(test_model::RecordWithOptionalVector const& value);

  // Ordinal 2.
  // Call this method to write many values to the `recordWithOptionalVectorData` stream, then call `EndRecordWithOptionalVectorData()` when done.
  void WriteRecordWithOptionalVectorData(std::vector<test_model::RecordWithOptionalVector> const& values);

  // Marks the end of the `recordWithOptionalVectorData` stream.
  void EndRecordWithOptionalVectorData();

  // Ordinal 3.
  // Call this method for each element of the `fixedVector` stream, then call `EndFixedVector() when done.`
  void WriteFixedVector(std::array<int32_t, 3> const& value);

  // Ordinal 3.
  // Call this method to write many values to the `fixedVector` stream, then call `EndFixedVector()` when done.
  void WriteFixedVector(std::vector<std::array<int32_t, 3>> const& values);

  // Marks the end of the `fixedVector` stream.
  void EndFixedVector();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~StreamsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntDataImpl(int32_t const& value) = 0;
  virtual void WriteIntDataImpl(std::vector<int32_t> const& value);
  virtual void EndIntDataImpl() = 0;
  virtual void WriteOptionalIntDataImpl(std::optional<int32_t> const& value) = 0;
  virtual void WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& value);
  virtual void EndOptionalIntDataImpl() = 0;
  virtual void WriteRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector const& value) = 0;
  virtual void WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& value);
  virtual void EndRecordWithOptionalVectorDataImpl() = 0;
  virtual void WriteFixedVectorImpl(std::array<int32_t, 3> const& value) = 0;
  virtual void WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& value);
  virtual void EndFixedVectorImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class StreamsReaderBase;
};

// Abstract reader for the Streams protocol.
class StreamsReaderBase {
  public:
  StreamsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadIntData(int32_t& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadIntData(std::vector<int32_t>& values);

  // Ordinal 1.
  [[nodiscard]] bool ReadOptionalIntData(std::optional<int32_t>& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadOptionalIntData(std::vector<std::optional<int32_t>>& values);

  // Ordinal 2.
  [[nodiscard]] bool ReadRecordWithOptionalVectorData(test_model::RecordWithOptionalVector& value);

  // Ordinal 2.
  [[nodiscard]] bool ReadRecordWithOptionalVectorData(std::vector<test_model::RecordWithOptionalVector>& values);

  // Ordinal 3.
  [[nodiscard]] bool ReadFixedVector(std::array<int32_t, 3>& value);

  // Ordinal 3.
  [[nodiscard]] bool ReadFixedVector(std::vector<std::array<int32_t, 3>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(StreamsWriterBase& writer, size_t int_data_buffer_size = 1, size_t optional_int_data_buffer_size = 1, size_t record_with_optional_vector_data_buffer_size = 1, size_t fixed_vector_buffer_size = 1);

  virtual ~StreamsReaderBase() = default;

  protected:
  virtual bool ReadIntDataImpl(int32_t& value) = 0;
  virtual bool ReadIntDataImpl(std::vector<int32_t>& values);
  virtual bool ReadOptionalIntDataImpl(std::optional<int32_t>& value) = 0;
  virtual bool ReadOptionalIntDataImpl(std::vector<std::optional<int32_t>>& values);
  virtual bool ReadRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector& value) = 0;
  virtual bool ReadRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector>& values);
  virtual bool ReadFixedVectorImpl(std::array<int32_t, 3>& value) = 0;
  virtual bool ReadFixedVectorImpl(std::vector<std::array<int32_t, 3>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the FixedArrays protocol.
class FixedArraysWriterBase {
  public:
  // Ordinal 0.
  void WriteInts(yardl::FixedNDArray<int32_t, 2, 3> const& value);

  // Ordinal 1.
  void WriteFixedSimpleRecordArray(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value);

  // Ordinal 2.
  void WriteFixedRecordWithVlensArray(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value);

  // Ordinal 3.
  void WriteRecordWithFixedArrays(test_model::RecordWithFixedArrays const& value);

  // Ordinal 4.
  void WriteNamedArray(test_model::NamedFixedNDArray const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~FixedArraysWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntsImpl(yardl::FixedNDArray<int32_t, 2, 3> const& value) = 0;
  virtual void WriteFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) = 0;
  virtual void WriteFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) = 0;
  virtual void WriteRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays const& value) = 0;
  virtual void WriteNamedArrayImpl(test_model::NamedFixedNDArray const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class FixedArraysReaderBase;
};

// Abstract reader for the FixedArrays protocol.
class FixedArraysReaderBase {
  public:
  FixedArraysReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadInts(yardl::FixedNDArray<int32_t, 2, 3>& value);

  // Ordinal 1.
  void ReadFixedSimpleRecordArray(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value);

  // Ordinal 2.
  void ReadFixedRecordWithVlensArray(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value);

  // Ordinal 3.
  void ReadRecordWithFixedArrays(test_model::RecordWithFixedArrays& value);

  // Ordinal 4.
  void ReadNamedArray(test_model::NamedFixedNDArray& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(FixedArraysWriterBase& writer);

  virtual ~FixedArraysReaderBase() = default;

  protected:
  virtual void ReadIntsImpl(yardl::FixedNDArray<int32_t, 2, 3>& value) = 0;
  virtual void ReadFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value) = 0;
  virtual void ReadFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value) = 0;
  virtual void ReadRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays& value) = 0;
  virtual void ReadNamedArrayImpl(test_model::NamedFixedNDArray& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Subarrays protocol.
class SubarraysWriterBase {
  public:
  // Ordinal 0.
  void WriteDynamicWithFixedIntSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value);

  // Ordinal 1.
  void WriteDynamicWithFixedFloatSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value);

  // Ordinal 2.
  void WriteKnownDimCountWithFixedIntSubarray(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value);

  // Ordinal 3.
  void WriteKnownDimCountWithFixedFloatSubarray(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value);

  // Ordinal 4.
  void WriteFixedWithFixedIntSubarray(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value);

  // Ordinal 5.
  void WriteFixedWithFixedFloatSubarray(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value);

  // Ordinal 6.
  void WriteNestedSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value);

  // Ordinal 7.
  void WriteDynamicWithFixedVectorSubarray(yardl::DynamicNDArray<std::array<int32_t, 3>> const& value);

  // Ordinal 8.
  void WriteGenericSubarray(test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~SubarraysWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>> const& value) = 0;
  virtual void WriteDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>> const& value) = 0;
  virtual void WriteKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1> const& value) = 0;
  virtual void WriteKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1> const& value) = 0;
  virtual void WriteFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2> const& value) = 0;
  virtual void WriteFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2> const& value) = 0;
  virtual void WriteNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>> const& value) = 0;
  virtual void WriteDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>> const& value) = 0;
  virtual void WriteGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class SubarraysReaderBase;
};

// Abstract reader for the Subarrays protocol.
class SubarraysReaderBase {
  public:
  SubarraysReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadDynamicWithFixedIntSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>>& value);

  // Ordinal 1.
  void ReadDynamicWithFixedFloatSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>>& value);

  // Ordinal 2.
  void ReadKnownDimCountWithFixedIntSubarray(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1>& value);

  // Ordinal 3.
  void ReadKnownDimCountWithFixedFloatSubarray(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1>& value);

  // Ordinal 4.
  void ReadFixedWithFixedIntSubarray(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>& value);

  // Ordinal 5.
  void ReadFixedWithFixedFloatSubarray(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2>& value);

  // Ordinal 6.
  void ReadNestedSubarray(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>>& value);

  // Ordinal 7.
  void ReadDynamicWithFixedVectorSubarray(yardl::DynamicNDArray<std::array<int32_t, 3>>& value);

  // Ordinal 8.
  void ReadGenericSubarray(test_model::Image<yardl::FixedNDArray<int32_t, 3>>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(SubarraysWriterBase& writer);

  virtual ~SubarraysReaderBase() = default;

  protected:
  virtual void ReadDynamicWithFixedIntSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<int32_t, 3>>& value) = 0;
  virtual void ReadDynamicWithFixedFloatSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<float, 3>>& value) = 0;
  virtual void ReadKnownDimCountWithFixedIntSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<int32_t, 3>, 1>& value) = 0;
  virtual void ReadKnownDimCountWithFixedFloatSubarrayImpl(yardl::NDArray<yardl::FixedNDArray<float, 3>, 1>& value) = 0;
  virtual void ReadFixedWithFixedIntSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>& value) = 0;
  virtual void ReadFixedWithFixedFloatSubarrayImpl(yardl::FixedNDArray<yardl::FixedNDArray<float, 3>, 2>& value) = 0;
  virtual void ReadNestedSubarrayImpl(yardl::DynamicNDArray<yardl::FixedNDArray<yardl::FixedNDArray<int32_t, 3>, 2>>& value) = 0;
  virtual void ReadDynamicWithFixedVectorSubarrayImpl(yardl::DynamicNDArray<std::array<int32_t, 3>>& value) = 0;
  virtual void ReadGenericSubarrayImpl(test_model::Image<yardl::FixedNDArray<int32_t, 3>>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the SubarraysInRecords protocol.
class SubarraysInRecordsWriterBase {
  public:
  // Ordinal 0.
  void WriteWithFixedSubarrays(yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value);

  // Ordinal 1.
  void WriteWithVlenSubarrays(yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~SubarraysInRecordsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections> const& value) = 0;
  virtual void WriteWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class SubarraysInRecordsReaderBase;
};

// Abstract reader for the SubarraysInRecords protocol.
class SubarraysInRecordsReaderBase {
  public:
  SubarraysInRecordsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadWithFixedSubarrays(yardl::DynamicNDArray<test_model::RecordWithFixedCollections>& value);

  // Ordinal 1.
  void ReadWithVlenSubarrays(yardl::DynamicNDArray<test_model::RecordWithVlenCollections>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(SubarraysInRecordsWriterBase& writer);

  virtual ~SubarraysInRecordsReaderBase() = default;

  protected:
  virtual void ReadWithFixedSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithFixedCollections>& value) = 0;
  virtual void ReadWithVlenSubarraysImpl(yardl::DynamicNDArray<test_model::RecordWithVlenCollections>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the NDArrays protocol.
class NDArraysWriterBase {
  public:
  // Ordinal 0.
  void WriteInts(yardl::NDArray<int32_t, 2> const& value);

  // Ordinal 1.
  void WriteSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 2> const& value);

  // Ordinal 2.
  void WriteRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 2> const& value);

  // Ordinal 3.
  void WriteRecordWithNDArrays(test_model::RecordWithNDArrays const& value);

  // Ordinal 4.
  void WriteNamedArray(test_model::NamedNDArray const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~NDArraysWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntsImpl(yardl::NDArray<int32_t, 2> const& value) = 0;
  virtual void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2> const& value) = 0;
  virtual void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) = 0;
  virtual void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArrays const& value) = 0;
  virtual void WriteNamedArrayImpl(test_model::NamedNDArray const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class NDArraysReaderBase;
};

// Abstract reader for the NDArrays protocol.
class NDArraysReaderBase {
  public:
  NDArraysReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadInts(yardl::NDArray<int32_t, 2>& value);

  // Ordinal 1.
  void ReadSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 2>& value);

  // Ordinal 2.
  void ReadRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 2>& value);

  // Ordinal 3.
  void ReadRecordWithNDArrays(test_model::RecordWithNDArrays& value);

  // Ordinal 4.
  void ReadNamedArray(test_model::NamedNDArray& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(NDArraysWriterBase& writer);

  virtual ~NDArraysReaderBase() = default;

  protected:
  virtual void ReadIntsImpl(yardl::NDArray<int32_t, 2>& value) = 0;
  virtual void ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2>& value) = 0;
  virtual void ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2>& value) = 0;
  virtual void ReadRecordWithNDArraysImpl(test_model::RecordWithNDArrays& value) = 0;
  virtual void ReadNamedArrayImpl(test_model::NamedNDArray& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the NDArraysSingleDimension protocol.
class NDArraysSingleDimensionWriterBase {
  public:
  // Ordinal 0.
  void WriteInts(yardl::NDArray<int32_t, 1> const& value);

  // Ordinal 1.
  void WriteSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 1> const& value);

  // Ordinal 2.
  void WriteRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 1> const& value);

  // Ordinal 3.
  void WriteRecordWithNDArrays(test_model::RecordWithNDArraysSingleDimension const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~NDArraysSingleDimensionWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntsImpl(yardl::NDArray<int32_t, 1> const& value) = 0;
  virtual void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1> const& value) = 0;
  virtual void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) = 0;
  virtual void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class NDArraysSingleDimensionReaderBase;
};

// Abstract reader for the NDArraysSingleDimension protocol.
class NDArraysSingleDimensionReaderBase {
  public:
  NDArraysSingleDimensionReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadInts(yardl::NDArray<int32_t, 1>& value);

  // Ordinal 1.
  void ReadSimpleRecordArray(yardl::NDArray<test_model::SimpleRecord, 1>& value);

  // Ordinal 2.
  void ReadRecordWithVlensArray(yardl::NDArray<test_model::RecordWithVlens, 1>& value);

  // Ordinal 3.
  void ReadRecordWithNDArrays(test_model::RecordWithNDArraysSingleDimension& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(NDArraysSingleDimensionWriterBase& writer);

  virtual ~NDArraysSingleDimensionReaderBase() = default;

  protected:
  virtual void ReadIntsImpl(yardl::NDArray<int32_t, 1>& value) = 0;
  virtual void ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1>& value) = 0;
  virtual void ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1>& value) = 0;
  virtual void ReadRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the DynamicNDArrays protocol.
class DynamicNDArraysWriterBase {
  public:
  // Ordinal 0.
  void WriteInts(yardl::DynamicNDArray<int32_t> const& value);

  // Ordinal 1.
  void WriteSimpleRecordArray(yardl::DynamicNDArray<test_model::SimpleRecord> const& value);

  // Ordinal 2.
  void WriteRecordWithVlensArray(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value);

  // Ordinal 3.
  void WriteRecordWithDynamicNDArrays(test_model::RecordWithDynamicNDArrays const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~DynamicNDArraysWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntsImpl(yardl::DynamicNDArray<int32_t> const& value) = 0;
  virtual void WriteSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) = 0;
  virtual void WriteRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) = 0;
  virtual void WriteRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class DynamicNDArraysReaderBase;
};

// Abstract reader for the DynamicNDArrays protocol.
class DynamicNDArraysReaderBase {
  public:
  DynamicNDArraysReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadInts(yardl::DynamicNDArray<int32_t>& value);

  // Ordinal 1.
  void ReadSimpleRecordArray(yardl::DynamicNDArray<test_model::SimpleRecord>& value);

  // Ordinal 2.
  void ReadRecordWithVlensArray(yardl::DynamicNDArray<test_model::RecordWithVlens>& value);

  // Ordinal 3.
  void ReadRecordWithDynamicNDArrays(test_model::RecordWithDynamicNDArrays& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(DynamicNDArraysWriterBase& writer);

  virtual ~DynamicNDArraysReaderBase() = default;

  protected:
  virtual void ReadIntsImpl(yardl::DynamicNDArray<int32_t>& value) = 0;
  virtual void ReadSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord>& value) = 0;
  virtual void ReadRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens>& value) = 0;
  virtual void ReadRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the MultiDArrays protocol.
class MultiDArraysWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `images` stream, then call `EndImages() when done.`
  void WriteImages(yardl::NDArray<float, 4> const& value);

  // Ordinal 0.
  // Call this method to write many values to the `images` stream, then call `EndImages()` when done.
  void WriteImages(std::vector<yardl::NDArray<float, 4>> const& values);

  // Marks the end of the `images` stream.
  void EndImages();

  // Ordinal 1.
  // Call this method for each element of the `frames` stream, then call `EndFrames() when done.`
  void WriteFrames(yardl::FixedNDArray<float, 1, 1, 64, 32> const& value);

  // Ordinal 1.
  // Call this method to write many values to the `frames` stream, then call `EndFrames()` when done.
  void WriteFrames(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> const& values);

  // Marks the end of the `frames` stream.
  void EndFrames();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~MultiDArraysWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteImagesImpl(yardl::NDArray<float, 4> const& value) = 0;
  virtual void WriteImagesImpl(std::vector<yardl::NDArray<float, 4>> const& value);
  virtual void EndImagesImpl() = 0;
  virtual void WriteFramesImpl(yardl::FixedNDArray<float, 1, 1, 64, 32> const& value) = 0;
  virtual void WriteFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>> const& value);
  virtual void EndFramesImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class MultiDArraysReaderBase;
};

// Abstract reader for the MultiDArrays protocol.
class MultiDArraysReaderBase {
  public:
  MultiDArraysReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadImages(yardl::NDArray<float, 4>& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadImages(std::vector<yardl::NDArray<float, 4>>& values);

  // Ordinal 1.
  [[nodiscard]] bool ReadFrames(yardl::FixedNDArray<float, 1, 1, 64, 32>& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadFrames(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(MultiDArraysWriterBase& writer, size_t images_buffer_size = 1, size_t frames_buffer_size = 1);

  virtual ~MultiDArraysReaderBase() = default;

  protected:
  virtual bool ReadImagesImpl(yardl::NDArray<float, 4>& value) = 0;
  virtual bool ReadImagesImpl(std::vector<yardl::NDArray<float, 4>>& values);
  virtual bool ReadFramesImpl(yardl::FixedNDArray<float, 1, 1, 64, 32>& value) = 0;
  virtual bool ReadFramesImpl(std::vector<yardl::FixedNDArray<float, 1, 1, 64, 32>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the ComplexArrays protocol.
class ComplexArraysWriterBase {
  public:
  // Ordinal 0.
  void WriteFloats(yardl::DynamicNDArray<std::complex<float>> const& value);

  // Ordinal 1.
  void WriteDoubles(yardl::NDArray<std::complex<double>, 2> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~ComplexArraysWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteFloatsImpl(yardl::DynamicNDArray<std::complex<float>> const& value) = 0;
  virtual void WriteDoublesImpl(yardl::NDArray<std::complex<double>, 2> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class ComplexArraysReaderBase;
};

// Abstract reader for the ComplexArrays protocol.
class ComplexArraysReaderBase {
  public:
  ComplexArraysReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadFloats(yardl::DynamicNDArray<std::complex<float>>& value);

  // Ordinal 1.
  void ReadDoubles(yardl::NDArray<std::complex<double>, 2>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(ComplexArraysWriterBase& writer);

  virtual ~ComplexArraysReaderBase() = default;

  protected:
  virtual void ReadFloatsImpl(yardl::DynamicNDArray<std::complex<float>>& value) = 0;
  virtual void ReadDoublesImpl(yardl::NDArray<std::complex<double>, 2>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Maps protocol.
class MapsWriterBase {
  public:
  // Ordinal 0.
  void WriteStringToInt(std::unordered_map<std::string, int32_t> const& value);

  // Ordinal 1.
  void WriteIntToString(std::unordered_map<int32_t, std::string> const& value);

  // Ordinal 2.
  void WriteStringToUnion(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value);

  // Ordinal 3.
  void WriteAliasedGeneric(basic_types::AliasedMap<std::string, int32_t> const& value);

  // Ordinal 4.
  void WriteRecords(std::vector<test_model::RecordWithMaps> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~MapsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteStringToIntImpl(std::unordered_map<std::string, int32_t> const& value) = 0;
  virtual void WriteIntToStringImpl(std::unordered_map<int32_t, std::string> const& value) = 0;
  virtual void WriteStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) = 0;
  virtual void WriteAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t> const& value) = 0;
  virtual void WriteRecordsImpl(std::vector<test_model::RecordWithMaps> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class MapsReaderBase;
};

// Abstract reader for the Maps protocol.
class MapsReaderBase {
  public:
  MapsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadStringToInt(std::unordered_map<std::string, int32_t>& value);

  // Ordinal 1.
  void ReadIntToString(std::unordered_map<int32_t, std::string>& value);

  // Ordinal 2.
  void ReadStringToUnion(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value);

  // Ordinal 3.
  void ReadAliasedGeneric(basic_types::AliasedMap<std::string, int32_t>& value);

  // Ordinal 4.
  void ReadRecords(std::vector<test_model::RecordWithMaps>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(MapsWriterBase& writer);

  virtual ~MapsReaderBase() = default;

  protected:
  virtual void ReadStringToIntImpl(std::unordered_map<std::string, int32_t>& value) = 0;
  virtual void ReadIntToStringImpl(std::unordered_map<int32_t, std::string>& value) = 0;
  virtual void ReadStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value) = 0;
  virtual void ReadAliasedGenericImpl(basic_types::AliasedMap<std::string, int32_t>& value) = 0;
  virtual void ReadRecordsImpl(std::vector<test_model::RecordWithMaps>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Unions protocol.
class UnionsWriterBase {
  public:
  // Ordinal 0.
  void WriteIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord> const& value);

  // Ordinal 1.
  void WriteIntOrRecordWithVlens(std::variant<int32_t, test_model::RecordWithVlens> const& value);

  // Ordinal 2.
  void WriteMonosotateOrIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value);

  // Ordinal 3.
  void WriteVectorOfUnions(std::vector<std::variant<std::string, int32_t>> const& value);

  // Ordinal 4.
  void WriteRecordWithUnions(basic_types::RecordWithUnions const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~UnionsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) = 0;
  virtual void WriteIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens> const& value) = 0;
  virtual void WriteMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) = 0;
  virtual void WriteVectorOfUnionsImpl(std::vector<std::variant<std::string, int32_t>> const& value) = 0;
  virtual void WriteRecordWithUnionsImpl(basic_types::RecordWithUnions const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class UnionsReaderBase;
};

// Abstract reader for the Unions protocol.
class UnionsReaderBase {
  public:
  UnionsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord>& value);

  // Ordinal 1.
  void ReadIntOrRecordWithVlens(std::variant<int32_t, test_model::RecordWithVlens>& value);

  // Ordinal 2.
  void ReadMonosotateOrIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value);

  // Ordinal 3.
  void ReadVectorOfUnions(std::vector<std::variant<std::string, int32_t>>& value);

  // Ordinal 4.
  void ReadRecordWithUnions(basic_types::RecordWithUnions& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(UnionsWriterBase& writer);

  virtual ~UnionsReaderBase() = default;

  protected:
  virtual void ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) = 0;
  virtual void ReadIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens>& value) = 0;
  virtual void ReadMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) = 0;
  virtual void ReadVectorOfUnionsImpl(std::vector<std::variant<std::string, int32_t>>& value) = 0;
  virtual void ReadRecordWithUnionsImpl(basic_types::RecordWithUnions& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the StreamsOfUnions protocol.
class StreamsOfUnionsWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `intOrSimpleRecord` stream, then call `EndIntOrSimpleRecord() when done.`
  void WriteIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord> const& value);

  // Ordinal 0.
  // Call this method to write many values to the `intOrSimpleRecord` stream, then call `EndIntOrSimpleRecord()` when done.
  void WriteIntOrSimpleRecord(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values);

  // Marks the end of the `intOrSimpleRecord` stream.
  void EndIntOrSimpleRecord();

  // Ordinal 1.
  // Call this method for each element of the `nullableIntOrSimpleRecord` stream, then call `EndNullableIntOrSimpleRecord() when done.`
  void WriteNullableIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value);

  // Ordinal 1.
  // Call this method to write many values to the `nullableIntOrSimpleRecord` stream, then call `EndNullableIntOrSimpleRecord()` when done.
  void WriteNullableIntOrSimpleRecord(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values);

  // Marks the end of the `nullableIntOrSimpleRecord` stream.
  void EndNullableIntOrSimpleRecord();

  // Ordinal 2.
  // Call this method for each element of the `manyCases` stream, then call `EndManyCases() when done.`
  void WriteManyCases(std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray> const& value);

  // Ordinal 2.
  // Call this method to write many values to the `manyCases` stream, then call `EndManyCases()` when done.
  void WriteManyCases(std::vector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>> const& values);

  // Marks the end of the `manyCases` stream.
  void EndManyCases();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~StreamsOfUnionsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) = 0;
  virtual void WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& value);
  virtual void EndIntOrSimpleRecordImpl() = 0;
  virtual void WriteNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) = 0;
  virtual void WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& value);
  virtual void EndNullableIntOrSimpleRecordImpl() = 0;
  virtual void WriteManyCasesImpl(std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray> const& value) = 0;
  virtual void WriteManyCasesImpl(std::vector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>> const& value);
  virtual void EndManyCasesImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class StreamsOfUnionsReaderBase;
};

// Abstract reader for the StreamsOfUnions protocol.
class StreamsOfUnionsReaderBase {
  public:
  StreamsOfUnionsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadIntOrSimpleRecord(std::variant<int32_t, test_model::SimpleRecord>& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadIntOrSimpleRecord(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values);

  // Ordinal 1.
  [[nodiscard]] bool ReadNullableIntOrSimpleRecord(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadNullableIntOrSimpleRecord(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values);

  // Ordinal 2.
  [[nodiscard]] bool ReadManyCases(std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>& value);

  // Ordinal 2.
  [[nodiscard]] bool ReadManyCases(std::vector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(StreamsOfUnionsWriterBase& writer, size_t int_or_simple_record_buffer_size = 1, size_t nullable_int_or_simple_record_buffer_size = 1, size_t many_cases_buffer_size = 1);

  virtual ~StreamsOfUnionsReaderBase() = default;

  protected:
  virtual bool ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) = 0;
  virtual bool ReadIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values);
  virtual bool ReadNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) = 0;
  virtual bool ReadNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values);
  virtual bool ReadManyCasesImpl(std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>& value) = 0;
  virtual bool ReadManyCasesImpl(std::vector<std::variant<int32_t, float, std::string, test_model::SimpleRecord, test_model::NamedFixedNDArray>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Enums protocol.
class EnumsWriterBase {
  public:
  // Ordinal 0.
  void WriteSingle(test_model::Fruits const& value);

  // Ordinal 1.
  void WriteVec(std::vector<test_model::Fruits> const& value);

  // Ordinal 2.
  void WriteSize(test_model::SizeBasedEnum const& value);

  // Ordinal 3.
  void WriteRec(test_model::RecordWithEnums const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~EnumsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteSingleImpl(test_model::Fruits const& value) = 0;
  virtual void WriteVecImpl(std::vector<test_model::Fruits> const& value) = 0;
  virtual void WriteSizeImpl(test_model::SizeBasedEnum const& value) = 0;
  virtual void WriteRecImpl(test_model::RecordWithEnums const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class EnumsReaderBase;
};

// Abstract reader for the Enums protocol.
class EnumsReaderBase {
  public:
  EnumsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadSingle(test_model::Fruits& value);

  // Ordinal 1.
  void ReadVec(std::vector<test_model::Fruits>& value);

  // Ordinal 2.
  void ReadSize(test_model::SizeBasedEnum& value);

  // Ordinal 3.
  void ReadRec(test_model::RecordWithEnums& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(EnumsWriterBase& writer);

  virtual ~EnumsReaderBase() = default;

  protected:
  virtual void ReadSingleImpl(test_model::Fruits& value) = 0;
  virtual void ReadVecImpl(std::vector<test_model::Fruits>& value) = 0;
  virtual void ReadSizeImpl(test_model::SizeBasedEnum& value) = 0;
  virtual void ReadRecImpl(test_model::RecordWithEnums& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Flags protocol.
class FlagsWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `days` stream, then call `EndDays() when done.`
  void WriteDays(test_model::DaysOfWeek const& value);

  // Ordinal 0.
  // Call this method to write many values to the `days` stream, then call `EndDays()` when done.
  void WriteDays(std::vector<test_model::DaysOfWeek> const& values);

  // Marks the end of the `days` stream.
  void EndDays();

  // Ordinal 1.
  // Call this method for each element of the `formats` stream, then call `EndFormats() when done.`
  void WriteFormats(test_model::TextFormat const& value);

  // Ordinal 1.
  // Call this method to write many values to the `formats` stream, then call `EndFormats()` when done.
  void WriteFormats(std::vector<test_model::TextFormat> const& values);

  // Marks the end of the `formats` stream.
  void EndFormats();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~FlagsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteDaysImpl(test_model::DaysOfWeek const& value) = 0;
  virtual void WriteDaysImpl(std::vector<test_model::DaysOfWeek> const& value);
  virtual void EndDaysImpl() = 0;
  virtual void WriteFormatsImpl(test_model::TextFormat const& value) = 0;
  virtual void WriteFormatsImpl(std::vector<test_model::TextFormat> const& value);
  virtual void EndFormatsImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class FlagsReaderBase;
};

// Abstract reader for the Flags protocol.
class FlagsReaderBase {
  public:
  FlagsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadDays(test_model::DaysOfWeek& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadDays(std::vector<test_model::DaysOfWeek>& values);

  // Ordinal 1.
  [[nodiscard]] bool ReadFormats(test_model::TextFormat& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadFormats(std::vector<test_model::TextFormat>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(FlagsWriterBase& writer, size_t days_buffer_size = 1, size_t formats_buffer_size = 1);

  virtual ~FlagsReaderBase() = default;

  protected:
  virtual bool ReadDaysImpl(test_model::DaysOfWeek& value) = 0;
  virtual bool ReadDaysImpl(std::vector<test_model::DaysOfWeek>& values);
  virtual bool ReadFormatsImpl(test_model::TextFormat& value) = 0;
  virtual bool ReadFormatsImpl(std::vector<test_model::TextFormat>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the StateTest protocol.
class StateTestWriterBase {
  public:
  // Ordinal 0.
  void WriteAnInt(int32_t const& value);

  // Ordinal 1.
  // Call this method for each element of the `aStream` stream, then call `EndAStream() when done.`
  void WriteAStream(int32_t const& value);

  // Ordinal 1.
  // Call this method to write many values to the `aStream` stream, then call `EndAStream()` when done.
  void WriteAStream(std::vector<int32_t> const& values);

  // Marks the end of the `aStream` stream.
  void EndAStream();

  // Ordinal 2.
  void WriteAnotherInt(int32_t const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~StateTestWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteAnIntImpl(int32_t const& value) = 0;
  virtual void WriteAStreamImpl(int32_t const& value) = 0;
  virtual void WriteAStreamImpl(std::vector<int32_t> const& value);
  virtual void EndAStreamImpl() = 0;
  virtual void WriteAnotherIntImpl(int32_t const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class StateTestReaderBase;
};

// Abstract reader for the StateTest protocol.
class StateTestReaderBase {
  public:
  StateTestReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadAnInt(int32_t& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadAStream(int32_t& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadAStream(std::vector<int32_t>& values);

  // Ordinal 2.
  void ReadAnotherInt(int32_t& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(StateTestWriterBase& writer, size_t a_stream_buffer_size = 1);

  virtual ~StateTestReaderBase() = default;

  protected:
  virtual void ReadAnIntImpl(int32_t& value) = 0;
  virtual bool ReadAStreamImpl(int32_t& value) = 0;
  virtual bool ReadAStreamImpl(std::vector<int32_t>& values);
  virtual void ReadAnotherIntImpl(int32_t& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the SimpleGenerics protocol.
class SimpleGenericsWriterBase {
  public:
  // Ordinal 0.
  void WriteFloatImage(image::FloatImage const& value);

  // Ordinal 1.
  void WriteIntImage(image::IntImage const& value);

  // Ordinal 2.
  void WriteIntImageAlternateSyntax(test_model::Image<int32_t> const& value);

  // Ordinal 3.
  void WriteStringImage(test_model::Image<std::string> const& value);

  // Ordinal 4.
  void WriteIntFloatTuple(tuples::Tuple<int32_t, float> const& value);

  // Ordinal 5.
  void WriteFloatFloatTuple(tuples::Tuple<float, float> const& value);

  // Ordinal 6.
  void WriteIntFloatTupleAlternateSyntax(tuples::Tuple<int32_t, float> const& value);

  // Ordinal 7.
  void WriteIntStringTuple(tuples::Tuple<int32_t, std::string> const& value);

  // Ordinal 8.
  // Call this method for each element of the `streamOfTypeVariants` stream, then call `EndStreamOfTypeVariants() when done.`
  void WriteStreamOfTypeVariants(std::variant<image::FloatImage, test_model::Image<double>> const& value);

  // Ordinal 8.
  // Call this method to write many values to the `streamOfTypeVariants` stream, then call `EndStreamOfTypeVariants()` when done.
  void WriteStreamOfTypeVariants(std::vector<std::variant<image::FloatImage, test_model::Image<double>>> const& values);

  // Marks the end of the `streamOfTypeVariants` stream.
  void EndStreamOfTypeVariants();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~SimpleGenericsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteFloatImageImpl(image::FloatImage const& value) = 0;
  virtual void WriteIntImageImpl(image::IntImage const& value) = 0;
  virtual void WriteIntImageAlternateSyntaxImpl(test_model::Image<int32_t> const& value) = 0;
  virtual void WriteStringImageImpl(test_model::Image<std::string> const& value) = 0;
  virtual void WriteIntFloatTupleImpl(tuples::Tuple<int32_t, float> const& value) = 0;
  virtual void WriteFloatFloatTupleImpl(tuples::Tuple<float, float> const& value) = 0;
  virtual void WriteIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float> const& value) = 0;
  virtual void WriteIntStringTupleImpl(tuples::Tuple<int32_t, std::string> const& value) = 0;
  virtual void WriteStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>> const& value) = 0;
  virtual void WriteStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>> const& value);
  virtual void EndStreamOfTypeVariantsImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class SimpleGenericsReaderBase;
};

// Abstract reader for the SimpleGenerics protocol.
class SimpleGenericsReaderBase {
  public:
  SimpleGenericsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadFloatImage(image::FloatImage& value);

  // Ordinal 1.
  void ReadIntImage(image::IntImage& value);

  // Ordinal 2.
  void ReadIntImageAlternateSyntax(test_model::Image<int32_t>& value);

  // Ordinal 3.
  void ReadStringImage(test_model::Image<std::string>& value);

  // Ordinal 4.
  void ReadIntFloatTuple(tuples::Tuple<int32_t, float>& value);

  // Ordinal 5.
  void ReadFloatFloatTuple(tuples::Tuple<float, float>& value);

  // Ordinal 6.
  void ReadIntFloatTupleAlternateSyntax(tuples::Tuple<int32_t, float>& value);

  // Ordinal 7.
  void ReadIntStringTuple(tuples::Tuple<int32_t, std::string>& value);

  // Ordinal 8.
  [[nodiscard]] bool ReadStreamOfTypeVariants(std::variant<image::FloatImage, test_model::Image<double>>& value);

  // Ordinal 8.
  [[nodiscard]] bool ReadStreamOfTypeVariants(std::vector<std::variant<image::FloatImage, test_model::Image<double>>>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(SimpleGenericsWriterBase& writer, size_t stream_of_type_variants_buffer_size = 1);

  virtual ~SimpleGenericsReaderBase() = default;

  protected:
  virtual void ReadFloatImageImpl(image::FloatImage& value) = 0;
  virtual void ReadIntImageImpl(image::IntImage& value) = 0;
  virtual void ReadIntImageAlternateSyntaxImpl(test_model::Image<int32_t>& value) = 0;
  virtual void ReadStringImageImpl(test_model::Image<std::string>& value) = 0;
  virtual void ReadIntFloatTupleImpl(tuples::Tuple<int32_t, float>& value) = 0;
  virtual void ReadFloatFloatTupleImpl(tuples::Tuple<float, float>& value) = 0;
  virtual void ReadIntFloatTupleAlternateSyntaxImpl(tuples::Tuple<int32_t, float>& value) = 0;
  virtual void ReadIntStringTupleImpl(tuples::Tuple<int32_t, std::string>& value) = 0;
  virtual bool ReadStreamOfTypeVariantsImpl(std::variant<image::FloatImage, test_model::Image<double>>& value) = 0;
  virtual bool ReadStreamOfTypeVariantsImpl(std::vector<std::variant<image::FloatImage, test_model::Image<double>>>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the AdvancedGenerics protocol.
class AdvancedGenericsWriterBase {
  public:
  // Ordinal 0.
  void WriteFloatImageImage(test_model::Image<test_model::Image<float>> const& value);

  // Ordinal 1.
  void WriteGenericRecord1(test_model::GenericRecord<int32_t, std::string> const& value);

  // Ordinal 2.
  void WriteTupleOfOptionals(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value);

  // Ordinal 3.
  void WriteTupleOfOptionalsAlternateSyntax(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value);

  // Ordinal 4.
  void WriteTupleOfVectors(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~AdvancedGenericsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteFloatImageImageImpl(test_model::Image<test_model::Image<float>> const& value) = 0;
  virtual void WriteGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string> const& value) = 0;
  virtual void WriteTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) = 0;
  virtual void WriteTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) = 0;
  virtual void WriteTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class AdvancedGenericsReaderBase;
};

// Abstract reader for the AdvancedGenerics protocol.
class AdvancedGenericsReaderBase {
  public:
  AdvancedGenericsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadFloatImageImage(test_model::Image<test_model::Image<float>>& value);

  // Ordinal 1.
  void ReadGenericRecord1(test_model::GenericRecord<int32_t, std::string>& value);

  // Ordinal 2.
  void ReadTupleOfOptionals(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value);

  // Ordinal 3.
  void ReadTupleOfOptionalsAlternateSyntax(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value);

  // Ordinal 4.
  void ReadTupleOfVectors(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(AdvancedGenericsWriterBase& writer);

  virtual ~AdvancedGenericsReaderBase() = default;

  protected:
  virtual void ReadFloatImageImageImpl(test_model::Image<test_model::Image<float>>& value) = 0;
  virtual void ReadGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string>& value) = 0;
  virtual void ReadTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) = 0;
  virtual void ReadTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) = 0;
  virtual void ReadTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the Aliases protocol.
class AliasesWriterBase {
  public:
  // Ordinal 0.
  void WriteAliasedString(test_model::AliasedString const& value);

  // Ordinal 1.
  void WriteAliasedEnum(test_model::AliasedEnum const& value);

  // Ordinal 2.
  void WriteAliasedOpenGeneric(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value);

  // Ordinal 3.
  void WriteAliasedClosedGeneric(test_model::AliasedClosedGeneric const& value);

  // Ordinal 4.
  void WriteAliasedOptional(test_model::AliasedOptional const& value);

  // Ordinal 5.
  void WriteAliasedGenericOptional(test_model::AliasedGenericOptional<float> const& value);

  // Ordinal 6.
  void WriteAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value);

  // Ordinal 7.
  void WriteAliasedGenericVector(test_model::AliasedGenericVector<float> const& value);

  // Ordinal 8.
  void WriteAliasedGenericFixedVector(test_model::AliasedGenericFixedVector<float> const& value);

  // Ordinal 9.
  // Call this method for each element of the `streamOfAliasedGenericUnion2` stream, then call `EndStreamOfAliasedGenericUnion2() when done.`
  void WriteStreamOfAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value);

  // Ordinal 9.
  // Call this method to write many values to the `streamOfAliasedGenericUnion2` stream, then call `EndStreamOfAliasedGenericUnion2()` when done.
  void WriteStreamOfAliasedGenericUnion2(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values);

  // Marks the end of the `streamOfAliasedGenericUnion2` stream.
  void EndStreamOfAliasedGenericUnion2();

  // Ordinal 10.
  void WriteVectors(std::vector<test_model::RecordContainingVectorsOfAliases> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~AliasesWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteAliasedStringImpl(test_model::AliasedString const& value) = 0;
  virtual void WriteAliasedEnumImpl(test_model::AliasedEnum const& value) = 0;
  virtual void WriteAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) = 0;
  virtual void WriteAliasedClosedGenericImpl(test_model::AliasedClosedGeneric const& value) = 0;
  virtual void WriteAliasedOptionalImpl(test_model::AliasedOptional const& value) = 0;
  virtual void WriteAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float> const& value) = 0;
  virtual void WriteAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) = 0;
  virtual void WriteAliasedGenericVectorImpl(test_model::AliasedGenericVector<float> const& value) = 0;
  virtual void WriteAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float> const& value) = 0;
  virtual void WriteStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) = 0;
  virtual void WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& value);
  virtual void EndStreamOfAliasedGenericUnion2Impl() = 0;
  virtual void WriteVectorsImpl(std::vector<test_model::RecordContainingVectorsOfAliases> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class AliasesReaderBase;
};

// Abstract reader for the Aliases protocol.
class AliasesReaderBase {
  public:
  AliasesReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadAliasedString(test_model::AliasedString& value);

  // Ordinal 1.
  void ReadAliasedEnum(test_model::AliasedEnum& value);

  // Ordinal 2.
  void ReadAliasedOpenGeneric(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value);

  // Ordinal 3.
  void ReadAliasedClosedGeneric(test_model::AliasedClosedGeneric& value);

  // Ordinal 4.
  void ReadAliasedOptional(test_model::AliasedOptional& value);

  // Ordinal 5.
  void ReadAliasedGenericOptional(test_model::AliasedGenericOptional<float>& value);

  // Ordinal 6.
  void ReadAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value);

  // Ordinal 7.
  void ReadAliasedGenericVector(test_model::AliasedGenericVector<float>& value);

  // Ordinal 8.
  void ReadAliasedGenericFixedVector(test_model::AliasedGenericFixedVector<float>& value);

  // Ordinal 9.
  [[nodiscard]] bool ReadStreamOfAliasedGenericUnion2(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value);

  // Ordinal 9.
  [[nodiscard]] bool ReadStreamOfAliasedGenericUnion2(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values);

  // Ordinal 10.
  void ReadVectors(std::vector<test_model::RecordContainingVectorsOfAliases>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(AliasesWriterBase& writer, size_t stream_of_aliased_generic_union_2_buffer_size = 1);

  virtual ~AliasesReaderBase() = default;

  protected:
  virtual void ReadAliasedStringImpl(test_model::AliasedString& value) = 0;
  virtual void ReadAliasedEnumImpl(test_model::AliasedEnum& value) = 0;
  virtual void ReadAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value) = 0;
  virtual void ReadAliasedClosedGenericImpl(test_model::AliasedClosedGeneric& value) = 0;
  virtual void ReadAliasedOptionalImpl(test_model::AliasedOptional& value) = 0;
  virtual void ReadAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float>& value) = 0;
  virtual void ReadAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) = 0;
  virtual void ReadAliasedGenericVectorImpl(test_model::AliasedGenericVector<float>& value) = 0;
  virtual void ReadAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float>& value) = 0;
  virtual bool ReadStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) = 0;
  virtual bool ReadStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values);
  virtual void ReadVectorsImpl(std::vector<test_model::RecordContainingVectorsOfAliases>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the StreamsOfAliasedUnions protocol.
class StreamsOfAliasedUnionsWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `intOrSimpleRecord` stream, then call `EndIntOrSimpleRecord() when done.`
  void WriteIntOrSimpleRecord(test_model::AliasedIntOrSimpleRecord const& value);

  // Ordinal 0.
  // Call this method to write many values to the `intOrSimpleRecord` stream, then call `EndIntOrSimpleRecord()` when done.
  void WriteIntOrSimpleRecord(std::vector<test_model::AliasedIntOrSimpleRecord> const& values);

  // Marks the end of the `intOrSimpleRecord` stream.
  void EndIntOrSimpleRecord();

  // Ordinal 1.
  // Call this method for each element of the `nullableIntOrSimpleRecord` stream, then call `EndNullableIntOrSimpleRecord() when done.`
  void WriteNullableIntOrSimpleRecord(test_model::AliasedNullableIntSimpleRecord const& value);

  // Ordinal 1.
  // Call this method to write many values to the `nullableIntOrSimpleRecord` stream, then call `EndNullableIntOrSimpleRecord()` when done.
  void WriteNullableIntOrSimpleRecord(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values);

  // Marks the end of the `nullableIntOrSimpleRecord` stream.
  void EndNullableIntOrSimpleRecord();

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~StreamsOfAliasedUnionsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord const& value) = 0;
  virtual void WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& value);
  virtual void EndIntOrSimpleRecordImpl() = 0;
  virtual void WriteNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord const& value) = 0;
  virtual void WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& value);
  virtual void EndNullableIntOrSimpleRecordImpl() = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class StreamsOfAliasedUnionsReaderBase;
};

// Abstract reader for the StreamsOfAliasedUnions protocol.
class StreamsOfAliasedUnionsReaderBase {
  public:
  StreamsOfAliasedUnionsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadIntOrSimpleRecord(test_model::AliasedIntOrSimpleRecord& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadIntOrSimpleRecord(std::vector<test_model::AliasedIntOrSimpleRecord>& values);

  // Ordinal 1.
  [[nodiscard]] bool ReadNullableIntOrSimpleRecord(test_model::AliasedNullableIntSimpleRecord& value);

  // Ordinal 1.
  [[nodiscard]] bool ReadNullableIntOrSimpleRecord(std::vector<test_model::AliasedNullableIntSimpleRecord>& values);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(StreamsOfAliasedUnionsWriterBase& writer, size_t int_or_simple_record_buffer_size = 1, size_t nullable_int_or_simple_record_buffer_size = 1);

  virtual ~StreamsOfAliasedUnionsReaderBase() = default;

  protected:
  virtual bool ReadIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord& value) = 0;
  virtual bool ReadIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord>& values);
  virtual bool ReadNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord& value) = 0;
  virtual bool ReadNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord>& values);
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the ProtocolWithComputedFields protocol.
class ProtocolWithComputedFieldsWriterBase {
  public:
  // Ordinal 0.
  void WriteRecordWithComputedFields(test_model::RecordWithComputedFields const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~ProtocolWithComputedFieldsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class ProtocolWithComputedFieldsReaderBase;
};

// Abstract reader for the ProtocolWithComputedFields protocol.
class ProtocolWithComputedFieldsReaderBase {
  public:
  ProtocolWithComputedFieldsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadRecordWithComputedFields(test_model::RecordWithComputedFields& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(ProtocolWithComputedFieldsWriterBase& writer);

  virtual ~ProtocolWithComputedFieldsReaderBase() = default;

  protected:
  virtual void ReadRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the ProtocolWithKeywordSteps protocol.
class ProtocolWithKeywordStepsWriterBase {
  public:
  // Ordinal 0.
  // Call this method for each element of the `int` stream, then call `EndInt() when done.`
  void WriteInt(test_model::RecordWithKeywordFields const& value);

  // Ordinal 0.
  // Call this method to write many values to the `int` stream, then call `EndInt()` when done.
  void WriteInt(std::vector<test_model::RecordWithKeywordFields> const& values);

  // Marks the end of the `int` stream.
  void EndInt();

  // Ordinal 1.
  void WriteFloat(test_model::EnumWithKeywordSymbols const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~ProtocolWithKeywordStepsWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteIntImpl(test_model::RecordWithKeywordFields const& value) = 0;
  virtual void WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& value);
  virtual void EndIntImpl() = 0;
  virtual void WriteFloatImpl(test_model::EnumWithKeywordSymbols const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class ProtocolWithKeywordStepsReaderBase;
};

// Abstract reader for the ProtocolWithKeywordSteps protocol.
class ProtocolWithKeywordStepsReaderBase {
  public:
  ProtocolWithKeywordStepsReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  [[nodiscard]] bool ReadInt(test_model::RecordWithKeywordFields& value);

  // Ordinal 0.
  [[nodiscard]] bool ReadInt(std::vector<test_model::RecordWithKeywordFields>& values);

  // Ordinal 1.
  void ReadFloat(test_model::EnumWithKeywordSymbols& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(ProtocolWithKeywordStepsWriterBase& writer, size_t int_buffer_size = 1);

  virtual ~ProtocolWithKeywordStepsReaderBase() = default;

  protected:
  virtual bool ReadIntImpl(test_model::RecordWithKeywordFields& value) = 0;
  virtual bool ReadIntImpl(std::vector<test_model::RecordWithKeywordFields>& values);
  virtual void ReadFloatImpl(test_model::EnumWithKeywordSymbols& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};

// Abstract writer for the ProtocolWithOptionalDate protocol.
class ProtocolWithOptionalDateWriterBase {
  public:
  // Ordinal 0.
  void WriteRecord(std::optional<test_model::RecordWithOptionalDate> const& value);

  // Optionaly close this writer before destructing. Validates that all steps were completed.
  void Close();

  virtual ~ProtocolWithOptionalDateWriterBase() = default;

  // Flushes all buffered data.
  virtual void Flush() {}

  protected:
  virtual void WriteRecordImpl(std::optional<test_model::RecordWithOptionalDate> const& value) = 0;
  virtual void CloseImpl() {}

  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static std::string SchemaFromVersion(Version version);

  private:
  uint8_t state_ = 0;

  friend class ProtocolWithOptionalDateReaderBase;
};

// Abstract reader for the ProtocolWithOptionalDate protocol.
class ProtocolWithOptionalDateReaderBase {
  public:
  ProtocolWithOptionalDateReaderBase(bool skip_completed_check = false): skip_completed_check_(skip_completed_check) {}

  // Ordinal 0.
  void ReadRecord(std::optional<test_model::RecordWithOptionalDate>& value);

  // Optionaly close this writer before destructing. Validates that all steps were completely read.
  void Close();

  void CopyTo(ProtocolWithOptionalDateWriterBase& writer);

  virtual ~ProtocolWithOptionalDateReaderBase() = default;

  protected:
  virtual void ReadRecordImpl(std::optional<test_model::RecordWithOptionalDate>& value) = 0;
  virtual void CloseImpl() {}
  static std::string schema_;

  static std::vector<std::string> previous_schemas_;

  static Version VersionFromSchema(const std::string& schema);

  bool skip_completed_check_;

  private:
  uint8_t state_ = 0;
};
} // namespace test_model
