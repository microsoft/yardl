# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedClass=false

import collections.abc
import datetime
import typing
import numpy as np
import numpy.typing as npt

from . import *
from . import _binary
from . import yardl_types as yardl

T = typing.TypeVar('T')

class _MyRecDescriptor(_binary.RecordDescriptor[MyRec[T]]):
    def __init__(self, t_descriptor: _binary.TypeDescriptor[T]) -> None:
        super().__init__([("f1", _binary.int8_descriptor), ("f2", t_descriptor), ("f3", _binary.EnumDescriptor(_binary.uint8_descriptor))])

    def write(self, stream: _binary.CodedOutputStream, value: MyRec[T]) -> None:
        self._write(stream, value.f1, value.f2, value.f3)


class _PointDescriptor(_binary.RecordDescriptor[Point[T]]):
    def __init__(self, t_descriptor: _binary.TypeDescriptor[T]) -> None:
        super().__init__([("x", t_descriptor), ("y", t_descriptor)])

    def write(self, stream: _binary.CodedOutputStream, value: Point[T]) -> None:
        self._write(stream, value.x, value.y)


class _MyStructDescriptor(_binary.RecordDescriptor[MyStruct[T]]):
    def __init__(self, t_descriptor: _binary.TypeDescriptor[T]) -> None:
        super().__init__([("points", _binary.FixedNDArrayDescriptor(_PointDescriptor(t_descriptor), (2,)))])

    def write(self, stream: _binary.CodedOutputStream, value: MyStruct[T]) -> None:
        self._write(stream, value.points)


class BinaryP1Writer(P1WriterBase, _binary.BinaryProtocolWriter):
    """Binary writer for the P1 protocol."""

    def __init__(self, stream: typing.BinaryIO | str) -> None:
        P1WriterBase.__init__(self)
        _binary.BinaryProtocolWriter.__init__(self, stream, P1WriterBase.schema)

    def _write_an_int(self, value: yardl.UInt32) -> None:
        _binary.uint32_descriptor.write(self._stream, value)

    def _write_a_stream(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        _binary.StreamDescriptor(_binary.int32_descriptor).write(self._stream, value)

    def _write_optional(self, value: yardl.Int32 | None) -> None:
        _binary.OptionalDescriptor(_binary.int32_descriptor).write(self._stream, value)

    def _write_union(self, value: yardl.Int32 | yardl.UInt32 | None) -> None:
        _binary.UnionDescriptor([(None.__class__, _binary.none_descriptor), (yardl.Int32, _binary.int32_descriptor), (yardl.UInt32, _binary.uint32_descriptor)]).write(self._stream, value)

    def _write_date(self, value: yardl.Date) -> None:
        _binary.date_descriptor.write(self._stream, value)

    def _write_flag(self, value: MyFlags) -> None:
        _binary.EnumDescriptor(_binary.uint8_descriptor).write(self._stream, value)

    def _write_vec(self, value: list[yardl.Int32]) -> None:
        _binary.FixedVectorDescriptor(_binary.int32_descriptor, 3).write(self._stream, value)

    def _write_arr(self, value: npt.NDArray[np.uint32]) -> None:
        _binary.DynamicNDArrayDescriptor(_binary.uint32_descriptor).write(self._stream, value)

    def _write_map(self, value: dict[str, yardl.Int32]) -> None:
        _binary.MapDescriptor(_binary.string_descriptor, _binary.int32_descriptor).write(self._stream, value)

    def _write_point(self, value: Point[yardl.Int32]) -> None:
        _PointDescriptor(_binary.int32_descriptor).write(self._stream, value)

    def _write_points(self, value: list[Point[yardl.Int32]]) -> None:
        _binary.FixedVectorDescriptor(_PointDescriptor(_binary.int32_descriptor), 2).write(self._stream, value)

    def _write_gen_rec(self, value: npt.NDArray[np.void]) -> None:
        _binary.FixedNDArrayDescriptor(_MyRecDescriptor(_binary.float32_descriptor), (1,)).write(self._stream, value)

    def _write_myint(self, value: MyInt) -> None:
        _binary.UnionDescriptor([(yardl.Int32, _binary.int32_descriptor), (yardl.Float32, _binary.float32_descriptor)]).write(self._stream, value)

    def _write_image(self, value: Image[yardl.Int32]) -> None:
        _binary.VectorDescriptor(_binary.int32_descriptor).write(self._stream, value)

    def _write_intimage(self, value: IntImage) -> None:
        _binary.VectorDescriptor(_binary.float32_descriptor).write(self._stream, value)

    def _write_complicated_arr(self, value: npt.NDArray[np.void]) -> None:
        _binary.DynamicNDArrayDescriptor(_MyStructDescriptor(_binary.int32_descriptor)).write(self._stream, value)


class BinaryP1Reader(P1ReaderBase):
    """Binary writer for the P1 protocol."""

    def _read_an_int(self) -> yardl.UInt32:
        raise NotImplementedError()

    def _read_a_stream(self) -> collections.abc.Iterable[yardl.Int32]:
        raise NotImplementedError()

    def _read_optional(self) -> yardl.Int32 | None:
        raise NotImplementedError()

    def _read_union(self) -> yardl.Int32 | yardl.UInt32 | None:
        raise NotImplementedError()

    def _read_date(self) -> yardl.Date:
        raise NotImplementedError()

    def _read_flag(self) -> MyFlags:
        raise NotImplementedError()

    def _read_vec(self) -> list[yardl.Int32]:
        raise NotImplementedError()

    def _read_arr(self) -> npt.NDArray[np.uint32]:
        raise NotImplementedError()

    def _read_map(self) -> dict[str, yardl.Int32]:
        raise NotImplementedError()

    def _read_point(self) -> Point[yardl.Int32]:
        raise NotImplementedError()

    def _read_points(self) -> list[Point[yardl.Int32]]:
        raise NotImplementedError()

    def _read_gen_rec(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

    def _read_myint(self) -> MyInt:
        raise NotImplementedError()

    def _read_image(self) -> Image[yardl.Int32]:
        raise NotImplementedError()

    def _read_intimage(self) -> IntImage:
        raise NotImplementedError()

    def _read_complicated_arr(self) -> npt.NDArray[np.void]:
        raise NotImplementedError()

