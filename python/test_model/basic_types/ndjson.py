# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedClass=false
# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import collections.abc
import io
import typing

import numpy as np
import numpy.typing as npt

from .types import *

from .. import _ndjson
from .. import yardl_types as yardl

fruits_name_to_value_map = {
    "apple": Fruits.APPLE,
    "banana": Fruits.BANANA,
    "pear": Fruits.PEAR,
}
fruits_value_to_name_map = {v: n for n, v in fruits_name_to_value_map.items()}

days_of_week_name_to_value_map = {
    "monday": DaysOfWeek.MONDAY,
    "tuesday": DaysOfWeek.TUESDAY,
    "wednesday": DaysOfWeek.WEDNESDAY,
    "thursday": DaysOfWeek.THURSDAY,
    "friday": DaysOfWeek.FRIDAY,
    "saturday": DaysOfWeek.SATURDAY,
    "sunday": DaysOfWeek.SUNDAY,
}
days_of_week_value_to_name_map = {v: n for n, v in days_of_week_name_to_value_map.items()}

text_format_name_to_value_map = {
    "regular": TextFormat.REGULAR,
    "bold": TextFormat.BOLD,
    "italic": TextFormat.ITALIC,
    "underline": TextFormat.UNDERLINE,
    "strikethrough": TextFormat.STRIKETHROUGH,
}
text_format_value_to_name_map = {v: n for n, v in text_format_name_to_value_map.items()}

class RecordWithUnionsConverter(_ndjson.JsonConverter[RecordWithUnions, np.void]):
    def __init__(self) -> None:
        self._null_or_int_or_string_converter = _ndjson.UnionConverter(Int32OrString, [None, (Int32OrString.Int32, _ndjson.int32_converter, [int, float]), (Int32OrString.String, _ndjson.string_converter, [str])], True)
        self._date_or_datetime_converter = _ndjson.UnionConverter(TimeOrDatetime, [(TimeOrDatetime.Time, _ndjson.time_converter, [int, float]), (TimeOrDatetime.Datetime, _ndjson.datetime_converter, [int, float])], False)
        super().__init__(np.dtype([
            ("null_or_int_or_string", self._null_or_int_or_string_converter.overall_dtype()),
            ("date_or_datetime", self._date_or_datetime_converter.overall_dtype()),
        ]))

    def to_json(self, value: RecordWithUnions) -> object:
        if not isinstance(value, RecordWithUnions): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'RecordWithUnions' instance")
        json_object = {}

        if value.null_or_int_or_string is not None:
            json_object["nullOrIntOrString"] = self._null_or_int_or_string_converter.to_json(value.null_or_int_or_string)
        json_object["dateOrDatetime"] = self._date_or_datetime_converter.to_json(value.date_or_datetime)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        if (field_val := value["null_or_int_or_string"]) is not None:
            json_object["nullOrIntOrString"] = self._null_or_int_or_string_converter.numpy_to_json(field_val)
        json_object["dateOrDatetime"] = self._date_or_datetime_converter.numpy_to_json(value["date_or_datetime"])
        return json_object

    def from_json(self, json_object: object) -> RecordWithUnions:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return RecordWithUnions(
            null_or_int_or_string=self._null_or_int_or_string_converter.from_json(json_object.get("nullOrIntOrString")),
            date_or_datetime=self._date_or_datetime_converter.from_json(json_object["dateOrDatetime"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._null_or_int_or_string_converter.from_json_to_numpy(json_object.get("nullOrIntOrString")),
            self._date_or_datetime_converter.from_json_to_numpy(json_object["dateOrDatetime"]),
        ) # type:ignore 


class GenericRecordWithComputedFieldsConverter(typing.Generic[T0, T0_NP, T1, T1_NP], _ndjson.JsonConverter[GenericRecordWithComputedFields[T0, T1], np.void]):
    def __init__(self, t0_converter: _ndjson.JsonConverter[T0, T0_NP], t1_converter: _ndjson.JsonConverter[T1, T1_NP]) -> None:
        self._f1_converter = _ndjson.UnionConverter(T0OrT1, [(T0OrT1[T0, T1].T0, t0_converter, [dict]), (T0OrT1[T0, T1].T1, t1_converter, [dict])], False)
        super().__init__(np.dtype([
            ("f1", self._f1_converter.overall_dtype()),
        ]))

    def to_json(self, value: GenericRecordWithComputedFields[T0, T1]) -> object:
        if not isinstance(value, GenericRecordWithComputedFields): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'GenericRecordWithComputedFields[T0, T1]' instance")
        json_object = {}

        json_object["f1"] = self._f1_converter.to_json(value.f1)
        return json_object

    def numpy_to_json(self, value: np.void) -> object:
        if not isinstance(value, np.void): # pyright: ignore [reportUnnecessaryIsInstance]
            raise TypeError("Expected 'np.void' instance")
        json_object = {}

        json_object["f1"] = self._f1_converter.numpy_to_json(value["f1"])
        return json_object

    def from_json(self, json_object: object) -> GenericRecordWithComputedFields[T0, T1]:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return GenericRecordWithComputedFields[T0, T1](
            f1=self._f1_converter.from_json(json_object["f1"],),
        )

    def from_json_to_numpy(self, json_object: object) -> np.void:
        if not isinstance(json_object, dict):
            raise TypeError("Expected 'dict' instance")
        return (
            self._f1_converter.from_json_to_numpy(json_object["f1"]),
        ) # type:ignore 


