// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "../yardl/detail/ndjson/serializers.h"
#include "protocols.h"

namespace evo_test {
using ordered_json = nlohmann::ordered_json;

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Header const& value);
[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Header& value);

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Sample const& value);
[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Sample& value);

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Signature const& value);
[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Signature& value);

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Footer const& value);
[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Footer& value);

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::NewRecord const& value);
[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::NewRecord& value);

} // namespace evo_test

NLOHMANN_JSON_NAMESPACE_BEGIN

template <>
struct adl_serializer<std::variant<std::string, int64_t>> {
  [[maybe_unused]] static void to_json(ordered_json& j, std::variant<std::string, int64_t> const& value) {
    std::visit([&j](auto const& v) {j = v;}, value);
  }

  [[maybe_unused]] static void from_json(ordered_json const& j, std::variant<std::string, int64_t>& value) {
    if ((j.is_string())) {
      value = j.get<std::string>();
      return;
    }
    if ((j.is_number())) {
      value = j.get<int64_t>();
      return;
    }
    throw std::runtime_error("Invalid union value");
  }
};

NLOHMANN_JSON_NAMESPACE_END

namespace evo_test {
using ordered_json = nlohmann::ordered_json;

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Header const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.subject)) {
    j.push_back({"subject", value.subject});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.meta)) {
    j.push_back({"meta", value.meta});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.weight)) {
    j.push_back({"weight", value.weight});
  }
}

[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Header& value) {
  if (auto it = j.find("subject"); it != j.end()) {
    it->get_to(value.subject);
  }
  if (auto it = j.find("meta"); it != j.end()) {
    it->get_to(value.meta);
  }
  if (auto it = j.find("weight"); it != j.end()) {
    it->get_to(value.weight);
  }
}

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Sample const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.timestamp)) {
    j.push_back({"timestamp", value.timestamp});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
}

[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Sample& value) {
  if (auto it = j.find("timestamp"); it != j.end()) {
    it->get_to(value.timestamp);
  }
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
}

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Signature const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.email)) {
    j.push_back({"email", value.email});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.number)) {
    j.push_back({"number", value.number});
  }
}

[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Signature& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("email"); it != j.end()) {
    it->get_to(value.email);
  }
  if (auto it = j.find("number"); it != j.end()) {
    it->get_to(value.number);
  }
}

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::Footer const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.signature)) {
    j.push_back({"signature", value.signature});
  }
}

[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::Footer& value) {
  if (auto it = j.find("signature"); it != j.end()) {
    it->get_to(value.signature);
  }
}

[[maybe_unused]] static void to_json(ordered_json& j, evo_test::NewRecord const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.stuff)) {
    j.push_back({"stuff", value.stuff});
  }
}

[[maybe_unused]] static void from_json(ordered_json const& j, evo_test::NewRecord& value) {
  if (auto it = j.find("stuff"); it != j.end()) {
    it->get_to(value.stuff);
  }
}

} // namespace evo_test

namespace evo_test::ndjson {
void MyProtocolWriter::WriteHeaderImpl(evo_test::Header const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "header", json_value);}

void MyProtocolWriter::WriteIdImpl(std::string const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "id", json_value);}

void MyProtocolWriter::WriteSamplesImpl(evo_test::Sample const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "samples", json_value);}

void MyProtocolWriter::WriteFooterImpl(std::optional<evo_test::Footer> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "footer", json_value);}

void MyProtocolWriter::Flush() {
  stream_.flush();
}

void MyProtocolWriter::CloseImpl() {
  stream_.flush();
}

void MyProtocolReader::ReadHeaderImpl(evo_test::Header& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "header", true, unused_step_, value);
}

void MyProtocolReader::ReadIdImpl(std::string& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "id", true, unused_step_, value);
}

bool MyProtocolReader::ReadSamplesImpl(evo_test::Sample& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "samples", false, unused_step_, value);
}

void MyProtocolReader::ReadFooterImpl(std::optional<evo_test::Footer>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "footer", true, unused_step_, value);
}

void MyProtocolReader::CloseImpl() {
  VerifyFinished();
}

void NewProtocolWriter::WriteCalibrationImpl(std::vector<double> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "calibration", json_value);}

void NewProtocolWriter::WriteDataImpl(evo_test::NewRecord const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "data", json_value);}

void NewProtocolWriter::Flush() {
  stream_.flush();
}

void NewProtocolWriter::CloseImpl() {
  stream_.flush();
}

void NewProtocolReader::ReadCalibrationImpl(std::vector<double>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "calibration", true, unused_step_, value);
}

bool NewProtocolReader::ReadDataImpl(evo_test::NewRecord& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "data", false, unused_step_, value);
}

void NewProtocolReader::CloseImpl() {
  VerifyFinished();
}

} // namespace evo_test::ndjson

