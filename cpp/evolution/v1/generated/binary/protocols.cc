// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#include <cstddef>

#include "../yardl/detail/binary/coded_stream.h"
#include "../yardl/detail/binary/serializers.h"

namespace yardl::binary {
#ifndef _MSC_VER
// Values of offsetof() are only used if types are standard-layout.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

template <>
struct IsTriviallySerializable<evo_test::UnchangedRecord> {
  using __T__ = evo_test::UnchangedRecord;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::age)>::value &&
    IsTriviallySerializable<decltype(__T__::meta)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::age) + sizeof(__T__::meta))) &&
    offsetof(__T__, name) < offsetof(__T__, age) && offsetof(__T__, age) < offsetof(__T__, meta);
};

template <>
struct IsTriviallySerializable<evo_test::RecordWithChanges> {
  using __T__ = evo_test::RecordWithChanges;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::float_to_double)>::value &&
    IsTriviallySerializable<decltype(__T__::unchanged_record)>::value &&
    IsTriviallySerializable<decltype(__T__::int_to_long)>::value &&
    IsTriviallySerializable<decltype(__T__::optional_long_to_string)>::value &&
    (sizeof(__T__) == (sizeof(__T__::float_to_double) + sizeof(__T__::unchanged_record) + sizeof(__T__::int_to_long) + sizeof(__T__::optional_long_to_string))) &&
    offsetof(__T__, float_to_double) < offsetof(__T__, unchanged_record) && offsetof(__T__, unchanged_record) < offsetof(__T__, int_to_long) && offsetof(__T__, int_to_long) < offsetof(__T__, optional_long_to_string);
};

template <>
struct IsTriviallySerializable<evo_test::DeprecatedRecord> {
  using __T__ = evo_test::DeprecatedRecord;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::s)>::value &&
    IsTriviallySerializable<decltype(__T__::i)>::value &&
    (sizeof(__T__) == (sizeof(__T__::s) + sizeof(__T__::i))) &&
    offsetof(__T__, s) < offsetof(__T__, i);
};

template <>
struct IsTriviallySerializable<evo_test::RZ> {
  using __T__ = evo_test::RZ;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::subject)>::value &&
    (sizeof(__T__) == (sizeof(__T__::subject)));
};

template <>
struct IsTriviallySerializable<evo_test::UnusedButChangedRecord> {
  using __T__ = evo_test::UnusedButChangedRecord;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::age)>::value &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    (sizeof(__T__) == (sizeof(__T__::age) + sizeof(__T__::name))) &&
    offsetof(__T__, age) < offsetof(__T__, name);
};

template <typename T1, typename T2>
struct IsTriviallySerializable<evo_test::GenericRecord<T1, T2>> {
  using __T__ = evo_test::GenericRecord<T1, T2>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::field_2)>::value &&
    IsTriviallySerializable<decltype(__T__::field_1)>::value &&
    IsTriviallySerializable<decltype(__T__::added)>::value &&
    (sizeof(__T__) == (sizeof(__T__::field_2) + sizeof(__T__::field_1) + sizeof(__T__::added))) &&
    offsetof(__T__, field_2) < offsetof(__T__, field_1) && offsetof(__T__, field_1) < offsetof(__T__, added);
};

template <typename T>
struct IsTriviallySerializable<evo_test::GenericParentRecord<T>> {
  using __T__ = evo_test::GenericParentRecord<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::record)>::value &&
    IsTriviallySerializable<decltype(__T__::record_of_union)>::value &&
    IsTriviallySerializable<decltype(__T__::union_of_record)>::value &&
    (sizeof(__T__) == (sizeof(__T__::record) + sizeof(__T__::record_of_union) + sizeof(__T__::union_of_record))) &&
    offsetof(__T__, record) < offsetof(__T__, record_of_union) && offsetof(__T__, record_of_union) < offsetof(__T__, union_of_record);
};

template <typename T2>
struct IsTriviallySerializable<evo_test::OldUnchangedGeneric<T2>> {
  using __T__ = evo_test::OldUnchangedGeneric<T2>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::field)>::value &&
    (sizeof(__T__) == (sizeof(__T__::field)));
};

template <typename Y, typename Z>
struct IsTriviallySerializable<evo_test::OldChangedGeneric<Y, Z>> {
  using __T__ = evo_test::OldChangedGeneric<Y, Z>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::y)>::value &&
    IsTriviallySerializable<decltype(__T__::z)>::value &&
    (sizeof(__T__) == (sizeof(__T__::y) + sizeof(__T__::z))) &&
    offsetof(__T__, y) < offsetof(__T__, z);
};

#ifndef _MSC_VER
#pragma GCC diagnostic pop // #pragma GCC diagnostic ignored "-Winvalid-offsetof" 
#endif
} //namespace yardl::binary 

namespace {
template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1, T2> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  case 2: {
    T2 const& v = std::get<2>(value);
    WriteT2(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1, T2>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    case 2: {
      T2 v;
      ReadT2(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2, typename T3, yardl::binary::Writer<T3> WriteT3>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1, T2, T3> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  case 2: {
    T2 const& v = std::get<2>(value);
    WriteT2(stream, v);
    break;
  }
  case 3: {
    T3 const& v = std::get<3>(value);
    WriteT3(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2, typename T3, yardl::binary::Reader<T3> ReadT3>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1, T2, T3>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    case 2: {
      T2 v;
      ReadT2(stream, v);
      value = std::move(v);
      break;
    }
    case 3: {
      T3 v;
      ReadT3(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}
} // namespace

namespace evo_test::binary {
namespace {
[[maybe_unused]] void WriteAliasedInt(yardl::binary::CodedOutputStream& stream, evo_test::AliasedInt const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedInt>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value);
}

[[maybe_unused]] void ReadAliasedInt(yardl::binary::CodedInputStream& stream, evo_test::AliasedInt& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedInt>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value);
}

[[maybe_unused]] void WriteAliasedString(yardl::binary::CodedOutputStream& stream, evo_test::AliasedString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value);
}

[[maybe_unused]] void ReadAliasedString(yardl::binary::CodedInputStream& stream, evo_test::AliasedString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value);
}

[[maybe_unused]] void WriteAliasedLongToString(yardl::binary::CodedOutputStream& stream, evo_test::AliasedLongToString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedLongToString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value);
}

[[maybe_unused]] void ReadAliasedLongToString(yardl::binary::CodedInputStream& stream, evo_test::AliasedLongToString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedLongToString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value);
}

[[maybe_unused]] void WriteUnchangedRecord(yardl::binary::CodedOutputStream& stream, evo_test::UnchangedRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::UnchangedRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteInteger(stream, value.age);
  yardl::binary::WriteMap<std::string, double, yardl::binary::WriteString, yardl::binary::WriteFloatingPoint>(stream, value.meta);
}

[[maybe_unused]] void ReadUnchangedRecord(yardl::binary::CodedInputStream& stream, evo_test::UnchangedRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::UnchangedRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadInteger(stream, value.age);
  yardl::binary::ReadMap<std::string, double, yardl::binary::ReadString, yardl::binary::ReadFloatingPoint>(stream, value.meta);
}

[[maybe_unused]] void WriteRecordWithChanges(yardl::binary::CodedOutputStream& stream, evo_test::RecordWithChanges const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RecordWithChanges>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.float_to_double);
  evo_test::binary::WriteUnchangedRecord(stream, value.unchanged_record);
  yardl::binary::WriteInteger(stream, value.int_to_long);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.optional_long_to_string);
}

[[maybe_unused]] void ReadRecordWithChanges(yardl::binary::CodedInputStream& stream, evo_test::RecordWithChanges& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RecordWithChanges>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.float_to_double);
  evo_test::binary::ReadUnchangedRecord(stream, value.unchanged_record);
  yardl::binary::ReadInteger(stream, value.int_to_long);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.optional_long_to_string);
}

[[maybe_unused]] void WriteAliasedRecordWithChanges(yardl::binary::CodedOutputStream& stream, evo_test::AliasedRecordWithChanges const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedRecordWithChanges>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteRecordWithChanges(stream, value);
}

[[maybe_unused]] void ReadAliasedRecordWithChanges(yardl::binary::CodedInputStream& stream, evo_test::AliasedRecordWithChanges& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedRecordWithChanges>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadRecordWithChanges(stream, value);
}

[[maybe_unused]] void WriteAliasOfAliasedRecordWithChanges(yardl::binary::CodedOutputStream& stream, evo_test::AliasOfAliasedRecordWithChanges const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasOfAliasedRecordWithChanges>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteAliasedRecordWithChanges(stream, value);
}

[[maybe_unused]] void ReadAliasOfAliasedRecordWithChanges(yardl::binary::CodedInputStream& stream, evo_test::AliasOfAliasedRecordWithChanges& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasOfAliasedRecordWithChanges>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadAliasedRecordWithChanges(stream, value);
}

[[maybe_unused]] void WriteAliasedOptionalRecord(yardl::binary::CodedOutputStream& stream, evo_test::AliasedOptionalRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOptionalRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream, value);
}

[[maybe_unused]] void ReadAliasedOptionalRecord(yardl::binary::CodedInputStream& stream, evo_test::AliasedOptionalRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOptionalRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream, value);
}

[[maybe_unused]] void WriteAliasedOptionalString(yardl::binary::CodedOutputStream& stream, evo_test::AliasedOptionalString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOptionalString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value);
}

[[maybe_unused]] void ReadAliasedOptionalString(yardl::binary::CodedInputStream& stream, evo_test::AliasedOptionalString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOptionalString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value);
}

[[maybe_unused]] void WriteAliasedRecordOrInt(yardl::binary::CodedOutputStream& stream, evo_test::AliasedRecordOrInt const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedRecordOrInt>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadAliasedRecordOrInt(yardl::binary::CodedInputStream& stream, evo_test::AliasedRecordOrInt& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedRecordOrInt>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, int32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteAliasedRecordOrString(yardl::binary::CodedOutputStream& stream, evo_test::AliasedRecordOrString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedRecordOrString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream, value);
}

[[maybe_unused]] void ReadAliasedRecordOrString(yardl::binary::CodedInputStream& stream, evo_test::AliasedRecordOrString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedRecordOrString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream, value);
}

[[maybe_unused]] void WriteDeprecatedRecord(yardl::binary::CodedOutputStream& stream, evo_test::DeprecatedRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::DeprecatedRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.s);
  yardl::binary::WriteInteger(stream, value.i);
}

[[maybe_unused]] void ReadDeprecatedRecord(yardl::binary::CodedInputStream& stream, evo_test::DeprecatedRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::DeprecatedRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.s);
  yardl::binary::ReadInteger(stream, value.i);
}

[[maybe_unused]] void WriteRenamedRecord(yardl::binary::CodedOutputStream& stream, evo_test::RenamedRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RenamedRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteDeprecatedRecord(stream, value);
}

[[maybe_unused]] void ReadRenamedRecord(yardl::binary::CodedInputStream& stream, evo_test::RenamedRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RenamedRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadDeprecatedRecord(stream, value);
}

[[maybe_unused]] void WriteStreamItem(yardl::binary::CodedOutputStream& stream, evo_test::StreamItem const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::StreamItem>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, evo_test::RenamedRecord, evo_test::binary::WriteRenamedRecord>(stream, value);
}

[[maybe_unused]] void ReadStreamItem(yardl::binary::CodedInputStream& stream, evo_test::StreamItem& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::StreamItem>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, evo_test::RenamedRecord, evo_test::binary::ReadRenamedRecord>(stream, value);
}

[[maybe_unused]] void WriteRZ(yardl::binary::CodedOutputStream& stream, evo_test::RZ const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RZ>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.subject);
}

[[maybe_unused]] void ReadRZ(yardl::binary::CodedInputStream& stream, evo_test::RZ& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RZ>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.subject);
}

[[maybe_unused]] void WriteRY(yardl::binary::CodedOutputStream& stream, evo_test::RY const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RY>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteRZ(stream, value);
}

[[maybe_unused]] void ReadRY(yardl::binary::CodedInputStream& stream, evo_test::RY& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RY>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadRZ(stream, value);
}

[[maybe_unused]] void WriteRNew(yardl::binary::CodedOutputStream& stream, evo_test::RNew const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RNew>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteRY(stream, value);
}

[[maybe_unused]] void ReadRNew(yardl::binary::CodedInputStream& stream, evo_test::RNew& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RNew>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadRY(stream, value);
}

[[maybe_unused]] void WriteRLink(yardl::binary::CodedOutputStream& stream, evo_test::RLink const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RLink>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteRNew(stream, value);
}

[[maybe_unused]] void ReadRLink(yardl::binary::CodedInputStream& stream, evo_test::RLink& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RLink>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadRNew(stream, value);
}

[[maybe_unused]] void WriteRX(yardl::binary::CodedOutputStream& stream, evo_test::RX const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RX>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteRLink(stream, value);
}

[[maybe_unused]] void ReadRX(yardl::binary::CodedInputStream& stream, evo_test::RX& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RX>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadRLink(stream, value);
}

[[maybe_unused]] void WriteRUnion(yardl::binary::CodedOutputStream& stream, evo_test::RUnion const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RUnion>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<evo_test::RX, evo_test::binary::WriteRX, std::string, yardl::binary::WriteString>(stream, value);
}

[[maybe_unused]] void ReadRUnion(yardl::binary::CodedInputStream& stream, evo_test::RUnion& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::RUnion>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<evo_test::RX, evo_test::binary::ReadRX, std::string, yardl::binary::ReadString>(stream, value);
}

[[maybe_unused]] void WriteUnusedButChangedRecord(yardl::binary::CodedOutputStream& stream, evo_test::UnusedButChangedRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::UnusedButChangedRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.age);
  yardl::binary::WriteString(stream, value.name);
}

[[maybe_unused]] void ReadUnusedButChangedRecord(yardl::binary::CodedInputStream& stream, evo_test::UnusedButChangedRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::UnusedButChangedRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.age);
  yardl::binary::ReadString(stream, value.name);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericRecord(yardl::binary::CodedOutputStream& stream, evo_test::GenericRecord<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericRecord<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteT2(stream, value.field_2);
  WriteT1(stream, value.field_1);
  yardl::binary::WriteOptional<bool, yardl::binary::WriteInteger>(stream, value.added);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericRecord(yardl::binary::CodedInputStream& stream, evo_test::GenericRecord<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericRecord<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadT2(stream, value.field_2);
  ReadT1(stream, value.field_1);
  yardl::binary::ReadOptional<bool, yardl::binary::ReadInteger>(stream, value.added);
}

template<typename A, yardl::binary::Writer<A> WriteA, typename B, yardl::binary::Writer<B> WriteB>
[[maybe_unused]] void WriteAliasedOpenGenericRecord(yardl::binary::CodedOutputStream& stream, evo_test::AliasedOpenGenericRecord<A, B> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOpenGenericRecord<A, B>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteGenericRecord<A, WriteA, B, WriteB>(stream, value);
}

template<typename A, yardl::binary::Reader<A> ReadA, typename B, yardl::binary::Reader<B> ReadB>
[[maybe_unused]] void ReadAliasedOpenGenericRecord(yardl::binary::CodedInputStream& stream, evo_test::AliasedOpenGenericRecord<A, B>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOpenGenericRecord<A, B>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadGenericRecord<A, ReadA, B, ReadB>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedHalfClosedGenericRecord(yardl::binary::CodedOutputStream& stream, evo_test::AliasedHalfClosedGenericRecord<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedHalfClosedGenericRecord<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteAliasedOpenGenericRecord<T, WriteT, std::string, yardl::binary::WriteString>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedHalfClosedGenericRecord(yardl::binary::CodedInputStream& stream, evo_test::AliasedHalfClosedGenericRecord<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedHalfClosedGenericRecord<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadAliasedOpenGenericRecord<T, ReadT, std::string, yardl::binary::ReadString>(stream, value);
}

template<typename X, yardl::binary::Writer<X> WriteX, typename Y, yardl::binary::Writer<Y> WriteY>
[[maybe_unused]] void WriteGenericUnion2(yardl::binary::CodedOutputStream& stream, evo_test::GenericUnion2<X, Y> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericUnion2<X, Y>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<X, WriteX, Y, WriteY>(stream, value);
}

template<typename X, yardl::binary::Reader<X> ReadX, typename Y, yardl::binary::Reader<Y> ReadY>
[[maybe_unused]] void ReadGenericUnion2(yardl::binary::CodedInputStream& stream, evo_test::GenericUnion2<X, Y>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericUnion2<X, Y>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<X, ReadX, Y, ReadY>(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericUnion(yardl::binary::CodedOutputStream& stream, evo_test::GenericUnion<T1, T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericUnion<T1, T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteGenericUnion2<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericUnion(yardl::binary::CodedInputStream& stream, evo_test::GenericUnion<T1, T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericUnion<T1, T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadGenericUnion2<T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename A, yardl::binary::Writer<A> WriteA, typename B, yardl::binary::Writer<B> WriteB>
[[maybe_unused]] void WriteAliasedOpenGenericUnion(yardl::binary::CodedOutputStream& stream, evo_test::AliasedOpenGenericUnion<A, B> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOpenGenericUnion<A, B>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteGenericUnion<A, WriteA, B, WriteB>(stream, value);
}

template<typename A, yardl::binary::Reader<A> ReadA, typename B, yardl::binary::Reader<B> ReadB>
[[maybe_unused]] void ReadAliasedOpenGenericUnion(yardl::binary::CodedInputStream& stream, evo_test::AliasedOpenGenericUnion<A, B>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedOpenGenericUnion<A, B>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadGenericUnion<A, ReadA, B, ReadB>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedHalfClosedGenericUnion(yardl::binary::CodedOutputStream& stream, evo_test::AliasedHalfClosedGenericUnion<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedHalfClosedGenericUnion<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteAliasedOpenGenericUnion<T, WriteT, float, yardl::binary::WriteFloatingPoint>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedHalfClosedGenericUnion(yardl::binary::CodedInputStream& stream, evo_test::AliasedHalfClosedGenericUnion<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedHalfClosedGenericUnion<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadAliasedOpenGenericUnion<T, ReadT, float, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteAliasedClosedGenericUnion(yardl::binary::CodedOutputStream& stream, evo_test::AliasedClosedGenericUnion const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedClosedGenericUnion>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteAliasedHalfClosedGenericUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream, value);
}

[[maybe_unused]] void ReadAliasedClosedGenericUnion(yardl::binary::CodedInputStream& stream, evo_test::AliasedClosedGenericUnion& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedClosedGenericUnion>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadAliasedHalfClosedGenericUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteGenericParentRecord(yardl::binary::CodedOutputStream& stream, evo_test::GenericParentRecord<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericParentRecord<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteAliasedHalfClosedGenericRecord<T, WriteT>(stream, value.record);
  evo_test::binary::WriteAliasedOpenGenericRecord<evo_test::AliasedOpenGenericUnion<T, float>, evo_test::binary::WriteAliasedOpenGenericUnion<T, WriteT, float, yardl::binary::WriteFloatingPoint>, std::string, yardl::binary::WriteString>(stream, value.record_of_union);
  evo_test::binary::WriteAliasedClosedGenericUnion(stream, value.union_of_record);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadGenericParentRecord(yardl::binary::CodedInputStream& stream, evo_test::GenericParentRecord<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericParentRecord<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadAliasedHalfClosedGenericRecord<T, ReadT>(stream, value.record);
  evo_test::binary::ReadAliasedOpenGenericRecord<evo_test::AliasedOpenGenericUnion<T, float>, evo_test::binary::ReadAliasedOpenGenericUnion<T, ReadT, float, yardl::binary::ReadFloatingPoint>, std::string, yardl::binary::ReadString>(stream, value.record_of_union);
  evo_test::binary::ReadAliasedClosedGenericUnion(stream, value.union_of_record);
}

template<typename T, yardl::binary::Writer<T> WriteT, typename U, yardl::binary::Writer<U> WriteU>
[[maybe_unused]] void WriteGenericUnionReversed(yardl::binary::CodedOutputStream& stream, evo_test::GenericUnionReversed<T, U> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericUnionReversed<T, U>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteGenericUnion2<U, WriteU, T, WriteT>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT, typename U, yardl::binary::Reader<U> ReadU>
[[maybe_unused]] void ReadGenericUnionReversed(yardl::binary::CodedInputStream& stream, evo_test::GenericUnionReversed<T, U>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericUnionReversed<T, U>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadGenericUnion2<U, ReadU, T, ReadT>(stream, value);
}

[[maybe_unused]] void WriteAliasedClosedGenericRecord(yardl::binary::CodedOutputStream& stream, evo_test::AliasedClosedGenericRecord const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedClosedGenericRecord>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteAliasedHalfClosedGenericRecord<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadAliasedClosedGenericRecord(yardl::binary::CodedInputStream& stream, evo_test::AliasedClosedGenericRecord& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedClosedGenericRecord>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadAliasedHalfClosedGenericRecord<int32_t, yardl::binary::ReadInteger>(stream, value);
}

template<typename X, yardl::binary::Writer<X> WriteX, typename Y, yardl::binary::Writer<Y> WriteY>
[[maybe_unused]] void WriteGenericRecordReversed(yardl::binary::CodedOutputStream& stream, evo_test::GenericRecordReversed<X, Y> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericRecordReversed<X, Y>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteGenericRecord<Y, WriteY, X, WriteX>(stream, value);
}

template<typename X, yardl::binary::Reader<X> ReadX, typename Y, yardl::binary::Reader<Y> ReadY>
[[maybe_unused]] void ReadGenericRecordReversed(yardl::binary::CodedInputStream& stream, evo_test::GenericRecordReversed<X, Y>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::GenericRecordReversed<X, Y>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadGenericRecord<Y, ReadY, X, ReadX>(stream, value);
}

[[maybe_unused]] void WriteAliasedGenericRecordOrString(yardl::binary::CodedOutputStream& stream, evo_test::AliasedGenericRecordOrString const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedGenericRecordOrString>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, std::string, yardl::binary::WriteString>(stream, value);
}

[[maybe_unused]] void ReadAliasedGenericRecordOrString(yardl::binary::CodedInputStream& stream, evo_test::AliasedGenericRecordOrString& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedGenericRecordOrString>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, std::string, yardl::binary::ReadString>(stream, value);
}

template<typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteOldUnchangedGeneric(yardl::binary::CodedOutputStream& stream, evo_test::OldUnchangedGeneric<T2> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::OldUnchangedGeneric<T2>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteT2(stream, value.field);
}

template<typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadOldUnchangedGeneric(yardl::binary::CodedInputStream& stream, evo_test::OldUnchangedGeneric<T2>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::OldUnchangedGeneric<T2>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadT2(stream, value.field);
}

template<typename A, yardl::binary::Writer<A> WriteA>
[[maybe_unused]] void WriteUnchangedGeneric(yardl::binary::CodedOutputStream& stream, evo_test::UnchangedGeneric<A> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::UnchangedGeneric<A>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteOldUnchangedGeneric<A, WriteA>(stream, value);
}

template<typename A, yardl::binary::Reader<A> ReadA>
[[maybe_unused]] void ReadUnchangedGeneric(yardl::binary::CodedInputStream& stream, evo_test::UnchangedGeneric<A>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::UnchangedGeneric<A>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadOldUnchangedGeneric<A, ReadA>(stream, value);
}

[[maybe_unused]] void WriteUnchanged(yardl::binary::CodedOutputStream& stream, evo_test::Unchanged const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::Unchanged>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteUnchangedGeneric<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadUnchanged(yardl::binary::CodedInputStream& stream, evo_test::Unchanged& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::Unchanged>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadUnchangedGeneric<int32_t, yardl::binary::ReadInteger>(stream, value);
}

template<typename Y, yardl::binary::Writer<Y> WriteY, typename Z, yardl::binary::Writer<Z> WriteZ>
[[maybe_unused]] void WriteOldChangedGeneric(yardl::binary::CodedOutputStream& stream, evo_test::OldChangedGeneric<Y, Z> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::OldChangedGeneric<Y, Z>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<Y, WriteY>(stream, value.y);
  yardl::binary::WriteOptional<evo_test::OldUnchangedGeneric<Z>, evo_test::binary::WriteOldUnchangedGeneric<Z, WriteZ>>(stream, value.z);
}

template<typename Y, yardl::binary::Reader<Y> ReadY, typename Z, yardl::binary::Reader<Z> ReadZ>
[[maybe_unused]] void ReadOldChangedGeneric(yardl::binary::CodedInputStream& stream, evo_test::OldChangedGeneric<Y, Z>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::OldChangedGeneric<Y, Z>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<Y, ReadY>(stream, value.y);
  yardl::binary::ReadOptional<evo_test::OldUnchangedGeneric<Z>, evo_test::binary::ReadOldUnchangedGeneric<Z, ReadZ>>(stream, value.z);
}

template<typename I, yardl::binary::Writer<I> WriteI, typename J, yardl::binary::Writer<J> WriteJ>
[[maybe_unused]] void WriteChangedGeneric(yardl::binary::CodedOutputStream& stream, evo_test::ChangedGeneric<I, J> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::ChangedGeneric<I, J>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteOldChangedGeneric<I, WriteI, J, WriteJ>(stream, value);
}

template<typename I, yardl::binary::Reader<I> ReadI, typename J, yardl::binary::Reader<J> ReadJ>
[[maybe_unused]] void ReadChangedGeneric(yardl::binary::CodedInputStream& stream, evo_test::ChangedGeneric<I, J>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::ChangedGeneric<I, J>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadOldChangedGeneric<I, ReadI, J, ReadJ>(stream, value);
}

[[maybe_unused]] void WriteChanged(yardl::binary::CodedOutputStream& stream, evo_test::Changed const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::Changed>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::WriteChangedGeneric<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadChanged(yardl::binary::CodedInputStream& stream, evo_test::Changed& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::Changed>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  evo_test::binary::ReadChangedGeneric<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteAliasedEnum(yardl::binary::CodedOutputStream& stream, evo_test::AliasedEnum const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedEnum>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteEnum<evo_test::GrowingEnum>(stream, value);
}

[[maybe_unused]] void ReadAliasedEnum(yardl::binary::CodedInputStream& stream, evo_test::AliasedEnum& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<evo_test::AliasedEnum>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadEnum<evo_test::GrowingEnum>(stream, value);
}

[[maybe_unused]] void WriteAliasedLongToString_v0(yardl::binary::CodedOutputStream& stream, evo_test::AliasedLongToString const& value) {
  int64_t aliased_long_to_string_v0 = {};
  try {
    aliased_long_to_string_v0 = std::stol(value);
  } catch (...) {
    throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
  }
  yardl::binary::WriteInteger(stream, aliased_long_to_string_v0);
}

[[maybe_unused]] void ReadAliasedLongToString_v0(yardl::binary::CodedInputStream& stream, evo_test::AliasedLongToString& value) {
  int64_t aliased_long_to_string_v0 = {};
  yardl::binary::ReadInteger(stream, aliased_long_to_string_v0);
  value = std::to_string(aliased_long_to_string_v0);
}

[[maybe_unused]] void WriteUnchangedRecord_v0(yardl::binary::CodedOutputStream& stream, evo_test::UnchangedRecord const& value) {
  evo_test::binary::WriteUnchangedRecord(stream, value);
}

[[maybe_unused]] void ReadUnchangedRecord_v0(yardl::binary::CodedInputStream& stream, evo_test::UnchangedRecord& value) {
  evo_test::binary::ReadUnchangedRecord(stream, value);
}

[[maybe_unused]] void WriteRecordWithChanges_v0(yardl::binary::CodedOutputStream& stream, evo_test::RecordWithChanges const& value) {
  float deprecated_float = {};
  yardl::binary::WriteFloatingPoint(stream, deprecated_float);
  int32_t int_to_long = {};
  if (value.int_to_long > std::numeric_limits<int32_t>::max() || value.int_to_long < std::numeric_limits<int32_t>::lowest()) {
    throw std::runtime_error("Numeric overflow detected while converting 'int64' to 'int32'");
  }
  int_to_long = static_cast<int32_t>(value.int_to_long);
  yardl::binary::WriteInteger(stream, int_to_long);
  std::vector<int32_t> deprecated_vector = {};
  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, deprecated_vector);
  float float_to_double = {};
  if (value.float_to_double > std::numeric_limits<float>::max() || value.float_to_double < std::numeric_limits<float>::lowest()) {
    throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'float32'");
  }
  float_to_double = static_cast<float>(value.float_to_double);
  yardl::binary::WriteFloatingPoint(stream, float_to_double);
  yardl::FixedNDArray<uint8_t, 7> deprecated_array = {};
  yardl::binary::WriteFixedNDArray<uint8_t, yardl::binary::WriteInteger, 7>(stream, deprecated_array);
  std::optional<int64_t> optional_long_to_string = {};
  if (value.optional_long_to_string.has_value()) {
    try {
      optional_long_to_string = std::stol(value.optional_long_to_string.value());
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value.optional_long_to_string.value() + "\" to number");
    }
  }
  yardl::binary::WriteOptional<int64_t, yardl::binary::WriteInteger>(stream, optional_long_to_string);
  std::unordered_map<std::string, std::vector<int32_t>> deprecated_map = {};
  yardl::binary::WriteMap<std::string, std::vector<int32_t>, yardl::binary::WriteString, yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>>(stream, deprecated_map);
  evo_test::binary::WriteUnchangedRecord_v0(stream, value.unchanged_record);
}

[[maybe_unused]] void ReadRecordWithChanges_v0(yardl::binary::CodedInputStream& stream, evo_test::RecordWithChanges& value) {
  float deprecated_float = {};
  yardl::binary::ReadFloatingPoint(stream, deprecated_float);
  int32_t int_to_long = {};
  yardl::binary::ReadInteger(stream, int_to_long);
  value.int_to_long = static_cast<int64_t>(int_to_long);
  std::vector<int32_t> deprecated_vector = {};
  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, deprecated_vector);
  float float_to_double = {};
  yardl::binary::ReadFloatingPoint(stream, float_to_double);
  value.float_to_double = static_cast<double>(float_to_double);
  yardl::FixedNDArray<uint8_t, 7> deprecated_array = {};
  yardl::binary::ReadFixedNDArray<uint8_t, yardl::binary::ReadInteger, 7>(stream, deprecated_array);
  std::optional<int64_t> optional_long_to_string = {};
  yardl::binary::ReadOptional<int64_t, yardl::binary::ReadInteger>(stream, optional_long_to_string);
  if (optional_long_to_string.has_value()) {
    value.optional_long_to_string = std::to_string(optional_long_to_string.value());
  }
  std::unordered_map<std::string, std::vector<int32_t>> deprecated_map = {};
  yardl::binary::ReadMap<std::string, std::vector<int32_t>, yardl::binary::ReadString, yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>>(stream, deprecated_map);
  evo_test::binary::ReadUnchangedRecord_v0(stream, value.unchanged_record);
}

[[maybe_unused]] void WriteAliasedRecordWithChanges_v0(yardl::binary::CodedOutputStream& stream, evo_test::AliasedRecordWithChanges const& value) {
  evo_test::binary::WriteRecordWithChanges_v0(stream, value);
}

[[maybe_unused]] void ReadAliasedRecordWithChanges_v0(yardl::binary::CodedInputStream& stream, evo_test::AliasedRecordWithChanges& value) {
  evo_test::binary::ReadRecordWithChanges_v0(stream, value);
}

[[maybe_unused]] void WriteRenamedRecord_v0(yardl::binary::CodedOutputStream& stream, evo_test::DeprecatedRecord const& value) {
  yardl::binary::WriteInteger(stream, value.i);
  yardl::binary::WriteString(stream, value.s);
}

[[maybe_unused]] void ReadRenamedRecord_v0(yardl::binary::CodedInputStream& stream, evo_test::DeprecatedRecord& value) {
  yardl::binary::ReadInteger(stream, value.i);
  yardl::binary::ReadString(stream, value.s);
}

[[maybe_unused]] void WriteStreamItem_v0(yardl::binary::CodedOutputStream& stream, evo_test::StreamItem const& value) {
  evo_test::RecordWithChanges_v0 stream_item_v0 = {};
  if (value.index() == 0) {
    stream_item_v0 = std::get<0>(value);
  }
  evo_test::binary::WriteRecordWithChanges_v0(stream, stream_item_v0);
}

[[maybe_unused]] void ReadStreamItem_v0(yardl::binary::CodedInputStream& stream, evo_test::StreamItem& value) {
  evo_test::RecordWithChanges_v0 stream_item_v0 = {};
  evo_test::binary::ReadRecordWithChanges_v0(stream, stream_item_v0);
  value = stream_item_v0;
}

[[maybe_unused]] void WriteRC_v0(yardl::binary::CodedOutputStream& stream, evo_test::RZ const& value) {
  std::string subject = {};
  subject = std::to_string(value.subject);
  yardl::binary::WriteString(stream, subject);
}

[[maybe_unused]] void ReadRC_v0(yardl::binary::CodedInputStream& stream, evo_test::RZ& value) {
  std::string subject = {};
  yardl::binary::ReadString(stream, subject);
  try {
    value.subject = std::stoi(subject);
  } catch (...) {
    throw std::runtime_error("Unable to convert string \"" + subject + "\" to number");
  }
}

[[maybe_unused]] void WriteRB_v0(yardl::binary::CodedOutputStream& stream, evo_test::RZ const& value) {
  evo_test::binary::WriteRC_v0(stream, value);
}

[[maybe_unused]] void ReadRB_v0(yardl::binary::CodedInputStream& stream, evo_test::RZ& value) {
  evo_test::binary::ReadRC_v0(stream, value);
}

[[maybe_unused]] void WriteRA_v0(yardl::binary::CodedOutputStream& stream, evo_test::RZ const& value) {
  evo_test::binary::WriteRB_v0(stream, value);
}

[[maybe_unused]] void ReadRA_v0(yardl::binary::CodedInputStream& stream, evo_test::RZ& value) {
  evo_test::binary::ReadRB_v0(stream, value);
}

[[maybe_unused]] void WriteRLink_v0(yardl::binary::CodedOutputStream& stream, evo_test::RLink const& value) {
  evo_test::binary::WriteRA_v0(stream, value);
}

[[maybe_unused]] void ReadRLink_v0(yardl::binary::CodedInputStream& stream, evo_test::RLink& value) {
  evo_test::binary::ReadRA_v0(stream, value);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericRecord_v0(yardl::binary::CodedOutputStream& stream, evo_test::GenericRecord<T1, T2> const& value) {
  std::optional<bool> removed = {};
  yardl::binary::WriteOptional<bool, yardl::binary::WriteInteger>(stream, removed);
  WriteT1(stream, value.field_1);
  WriteT2(stream, value.field_2);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericRecord_v0(yardl::binary::CodedInputStream& stream, evo_test::GenericRecord<T1, T2>& value) {
  std::optional<bool> removed = {};
  yardl::binary::ReadOptional<bool, yardl::binary::ReadInteger>(stream, removed);
  ReadT1(stream, value.field_1);
  ReadT2(stream, value.field_2);
}

template<typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteGenericUnion_v0(yardl::binary::CodedOutputStream& stream, evo_test::GenericUnion<T1, T2> const& value) {
  evo_test::binary::WriteGenericUnion<T1, WriteT1, T2, WriteT2>(stream, value);
}

template<typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadGenericUnion_v0(yardl::binary::CodedInputStream& stream, evo_test::GenericUnion<T1, T2>& value) {
  evo_test::binary::ReadGenericUnion<T1, ReadT1, T2, ReadT2>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteGenericParentRecord_v0(yardl::binary::CodedOutputStream& stream, evo_test::GenericParentRecord<T> const& value) {
  evo_test::binary::WriteGenericRecord_v0<T, WriteT, std::string, yardl::binary::WriteString>(stream, value.record);
  evo_test::binary::WriteGenericRecord_v0<evo_test::GenericUnion_v0<T, float>, evo_test::binary::WriteGenericUnion_v0<T, WriteT, float, yardl::binary::WriteFloatingPoint>, std::string, yardl::binary::WriteString>(stream, value.record_of_union);
  evo_test::binary::WriteGenericUnion_v0<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, float, yardl::binary::WriteFloatingPoint>(stream, value.union_of_record);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadGenericParentRecord_v0(yardl::binary::CodedInputStream& stream, evo_test::GenericParentRecord<T>& value) {
  evo_test::binary::ReadGenericRecord_v0<T, ReadT, std::string, yardl::binary::ReadString>(stream, value.record);
  evo_test::binary::ReadGenericRecord_v0<evo_test::GenericUnion_v0<T, float>, evo_test::binary::ReadGenericUnion_v0<T, ReadT, float, yardl::binary::ReadFloatingPoint>, std::string, yardl::binary::ReadString>(stream, value.record_of_union);
  evo_test::binary::ReadGenericUnion_v0<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, float, yardl::binary::ReadFloatingPoint>(stream, value.union_of_record);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedHalfClosedGenericUnion_v0(yardl::binary::CodedOutputStream& stream, evo_test::GenericUnion<T, float> const& value) {
  evo_test::binary::WriteGenericUnion<T, WriteT, float, yardl::binary::WriteFloatingPoint>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedHalfClosedGenericUnion_v0(yardl::binary::CodedInputStream& stream, evo_test::GenericUnion<T, float>& value) {
  evo_test::binary::ReadGenericUnion<T, ReadT, float, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteAliasedClosedGenericUnion_v0(yardl::binary::CodedOutputStream& stream, evo_test::AliasedClosedGenericUnion const& value) {
  evo_test::binary::WriteAliasedHalfClosedGenericUnion_v0<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream, value);
}

[[maybe_unused]] void ReadAliasedClosedGenericUnion_v0(yardl::binary::CodedInputStream& stream, evo_test::AliasedClosedGenericUnion& value) {
  evo_test::binary::ReadAliasedHalfClosedGenericUnion_v0<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteAliasedHalfClosedGenericRecord_v0(yardl::binary::CodedOutputStream& stream, evo_test::AliasedHalfClosedGenericRecord<T> const& value) {
  evo_test::binary::WriteGenericRecord_v0<T, WriteT, std::string, yardl::binary::WriteString>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadAliasedHalfClosedGenericRecord_v0(yardl::binary::CodedInputStream& stream, evo_test::AliasedHalfClosedGenericRecord<T>& value) {
  evo_test::binary::ReadGenericRecord_v0<T, ReadT, std::string, yardl::binary::ReadString>(stream, value);
}

template<typename T2, yardl::binary::Writer<T2> WriteT2>
[[maybe_unused]] void WriteUnchangedGeneric_v0(yardl::binary::CodedOutputStream& stream, evo_test::OldUnchangedGeneric<T2> const& value) {
  evo_test::binary::WriteOldUnchangedGeneric<T2, WriteT2>(stream, value);
}

template<typename T2, yardl::binary::Reader<T2> ReadT2>
[[maybe_unused]] void ReadUnchangedGeneric_v0(yardl::binary::CodedInputStream& stream, evo_test::OldUnchangedGeneric<T2>& value) {
  evo_test::binary::ReadOldUnchangedGeneric<T2, ReadT2>(stream, value);
}

template<typename Y, yardl::binary::Writer<Y> WriteY, typename Z, yardl::binary::Writer<Z> WriteZ>
[[maybe_unused]] void WriteChangedGeneric_v0(yardl::binary::CodedOutputStream& stream, evo_test::OldChangedGeneric<Y, Z> const& value) {
  Y y = {};
  if (value.y.has_value()) {
    y = value.y.value();
  }
  WriteY(stream, y);
  evo_test::UnchangedGeneric_v0<Z> z = {};
  if (value.z.has_value()) {
    z = value.z.value();
  }
  evo_test::binary::WriteUnchangedGeneric_v0<Z, WriteZ>(stream, z);
}

template<typename Y, yardl::binary::Reader<Y> ReadY, typename Z, yardl::binary::Reader<Z> ReadZ>
[[maybe_unused]] void ReadChangedGeneric_v0(yardl::binary::CodedInputStream& stream, evo_test::OldChangedGeneric<Y, Z>& value) {
  Y y = {};
  ReadY(stream, y);
  value.y = y;
  evo_test::UnchangedGeneric_v0<Z> z = {};
  evo_test::binary::ReadUnchangedGeneric_v0<Z, ReadZ>(stream, z);
  value.z = z;
}

} // namespace

void ProtocolWithChangesWriter::WriteInt8ToIntImpl(int32_t const& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_int = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'int32' to 'int8'");
    }
    int8_to_int = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_int);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteInt8ToLongImpl(int64_t const& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_long = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'int64' to 'int8'");
    }
    int8_to_long = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_long);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteInt8ToUintImpl(uint32_t const& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_uint = {};
    if (value > std::numeric_limits<int8_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint32' to 'int8'");
    }
    int8_to_uint = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_uint);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteInt8ToUlongImpl(uint64_t const& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_ulong = {};
    if (value > std::numeric_limits<int8_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint64' to 'int8'");
    }
    int8_to_ulong = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_ulong);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteInt8ToFloatImpl(float const& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_float = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'int8'");
    }
    int8_to_float = static_cast<int8_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int8_to_float);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteInt8ToDoubleImpl(double const& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_double = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'int8'");
    }
    int8_to_double = static_cast<int8_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int8_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToUintImpl(uint32_t const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_uint = {};
    if (value > std::numeric_limits<int32_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint32' to 'int32'");
    }
    int_to_uint = static_cast<int32_t>(value);
    yardl::binary::WriteInteger(stream_, int_to_uint);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToLongImpl(int64_t const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_long = {};
    if (value > std::numeric_limits<int32_t>::max() || value < std::numeric_limits<int32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'int64' to 'int32'");
    }
    int_to_long = static_cast<int32_t>(value);
    yardl::binary::WriteInteger(stream_, int_to_long);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToFloatImpl(float const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_float = {};
    if (value > std::numeric_limits<int32_t>::max() || value < std::numeric_limits<int32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'int32'");
    }
    int_to_float = static_cast<int32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int_to_float);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToDoubleImpl(double const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_double = {};
    if (value > std::numeric_limits<int32_t>::max() || value < std::numeric_limits<int32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'int32'");
    }
    int_to_double = static_cast<int32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUintToUlongImpl(uint64_t const& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_ulong = {};
    if (value > std::numeric_limits<uint32_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint64' to 'uint32'");
    }
    uint_to_ulong = static_cast<uint32_t>(value);
    yardl::binary::WriteInteger(stream_, uint_to_ulong);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUintToFloatImpl(float const& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_float = {};
    if (value > std::numeric_limits<uint32_t>::max() || value < std::numeric_limits<uint32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'uint32'");
    }
    uint_to_float = static_cast<uint32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, uint_to_float);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUintToDoubleImpl(double const& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_double = {};
    if (value > std::numeric_limits<uint32_t>::max() || value < std::numeric_limits<uint32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'uint32'");
    }
    uint_to_double = static_cast<uint32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, uint_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteFloatToDoubleImpl(double const& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_double = {};
    if (value > std::numeric_limits<float>::max() || value < std::numeric_limits<float>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'float32'");
    }
    float_to_double = static_cast<float>(value);
    yardl::binary::WriteFloatingPoint(stream_, float_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteComplexFloatToComplexDoubleImpl(std::complex<double> const& value) {
  switch (version_) {
  case Version::v0: {
    std::complex<float> complex_float_to_complex_double = {};
    if (std::real(value) > std::numeric_limits<std::complex<float>::value_type>::max() || std::real(value) < std::numeric_limits<std::complex<float>::value_type>::lowest()) {
      throw std::runtime_error("Real part overflow detected while converting 'complexfloat64' to 'complexfloat32'");
    }
    if (std::imag(value) > std::numeric_limits<std::complex<float>::value_type>::max() || std::imag(value) < std::numeric_limits<std::complex<float>::value_type>::lowest()) {
      throw std::runtime_error("Imaginary part overflow detected while converting 'complexfloat64' to 'complexfloat32'");
    }
    complex_float_to_complex_double = std::complex<float>(value);
    yardl::binary::WriteFloatingPoint(stream_, complex_float_to_complex_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToStringImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_string = {};
    try {
      int_to_string = std::stoi(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, int_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUintToStringImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_string = {};
    try {
      uint_to_string = std::stoul(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, uint_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteLongToStringImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    int64_t long_to_string = {};
    try {
      long_to_string = std::stol(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, long_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUlongToStringImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    uint64_t ulong_to_string = {};
    try {
      ulong_to_string = std::stoul(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, ulong_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteFloatToStringImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_string = {};
    try {
      float_to_string = std::stof(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteFloatingPoint(stream_, float_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteDoubleToStringImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    double double_to_string = {};
    try {
      double_to_string = std::stod(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteFloatingPoint(stream_, double_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToOptionalImpl(std::optional<int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_optional = {};
    if (value.has_value()) {
      int_to_optional = value.value();
    }
    yardl::binary::WriteInteger(stream_, int_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteFloatToOptionalImpl(std::optional<float> const& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_optional = {};
    if (value.has_value()) {
      float_to_optional = value.value();
    }
    yardl::binary::WriteFloatingPoint(stream_, float_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStringToOptionalImpl(std::optional<std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::string string_to_optional = {};
    if (value.has_value()) {
      string_to_optional = value.value();
    }
    yardl::binary::WriteString(stream_, string_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToUnionImpl(std::variant<int32_t, bool> const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union = {};
    if (value.index() == 0) {
      int_to_union = std::get<0>(value);
    }
    yardl::binary::WriteInteger(stream_, int_to_union);
    break;
  }
  default:
    WriteUnion<int32_t, yardl::binary::WriteInteger, bool, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteFloatToUnionImpl(std::variant<float, bool> const& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_union = {};
    if (value.index() == 0) {
      float_to_union = std::get<0>(value);
    }
    yardl::binary::WriteFloatingPoint(stream_, float_to_union);
    break;
  }
  default:
    WriteUnion<float, yardl::binary::WriteFloatingPoint, bool, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStringToUnionImpl(std::variant<std::string, bool> const& value) {
  switch (version_) {
  case Version::v0: {
    std::string string_to_union = {};
    if (value.index() == 0) {
      string_to_union = std::get<0>(value);
    }
    yardl::binary::WriteString(stream_, string_to_union);
    break;
  }
  default:
    WriteUnion<std::string, yardl::binary::WriteString, bool, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalIntToFloatImpl(std::optional<float> const& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_float = {};
    if (value.has_value()) {
      if (value.value() > std::numeric_limits<int32_t>::max() || value.value() < std::numeric_limits<int32_t>::lowest()) {
        throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'int32'");
      }
      optional_int_to_float = static_cast<int32_t>(std::round(value.value()));
    }
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, optional_int_to_float);
    break;
  }
  default:
    yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalFloatToStringImpl(std::optional<std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<float> optional_float_to_string = {};
    if (value.has_value()) {
      try {
        optional_float_to_string = std::stof(value.value());
      } catch (...) {
        throw std::runtime_error("Unable to convert string \"" + value.value() + "\" to number");
      }
    }
    yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream_, optional_float_to_string);
    break;
  }
  default:
    yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAliasedLongToStringImpl(evo_test::AliasedLongToString const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedLongToString_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedLongToString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStringToAliasedStringImpl(evo_test::AliasedString const& value) {
  evo_test::binary::WriteAliasedString(stream_, value);
}

void ProtocolWithChangesWriter::WriteStringToAliasedIntImpl(evo_test::AliasedInt const& value) {
  switch (version_) {
  case Version::v0: {
    std::string string_to_aliased_int = {};
    string_to_aliased_int = std::to_string(value);
    yardl::binary::WriteString(stream_, string_to_aliased_int);
    break;
  }
  default:
    evo_test::binary::WriteAliasedInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteEnumToAliasedEnumImpl(evo_test::AliasedEnum const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteEnum<evo_test::GrowingEnum_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedEnum(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalIntToUnionImpl(std::variant<std::monostate, int32_t, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_union = {};
    if (value.index() == 1) {
      optional_int_to_union = std::get<1>(value);
    }
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, optional_int_to_union);
    break;
  }
  default:
    WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalRecordToUnionImpl(std::variant<std::monostate, evo_test::RecordWithChanges, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<evo_test::RecordWithChanges_v0> optional_record_to_union = {};
    if (value.index() == 1) {
      optional_record_to_union = std::get<1>(value);
    }
    yardl::binary::WriteOptional<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, optional_record_to_union);
    break;
  }
  default:
    WriteUnion<std::monostate, yardl::binary::WriteMonostate, evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordWithChangesImpl(evo_test::RecordWithChanges const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAliasedRecordWithChangesImpl(evo_test::AliasedRecordWithChanges const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToRenamedRecordImpl(evo_test::RenamedRecord const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRenamedRecord_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRenamedRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToAliasedRecordImpl(evo_test::AliasedRecordWithChanges const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToAliasedAliasImpl(evo_test::AliasOfAliasedRecordWithChanges const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasOfAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamIntToStringToFloatImpl(std::string const& value) {
  switch (version_) {
  case Version::v0: {
    int32_t stream_int_to_string_to_float = {};
    try {
      stream_int_to_string_to_float = std::stoi(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteBlock<int32_t, yardl::binary::WriteInteger>(stream_, stream_int_to_string_to_float);
    break;
  }
  default:
    yardl::binary::WriteBlock<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamIntToStringToFloatImpl(std::vector<std::string> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      std::vector<int32_t> stream_int_to_string_to_float = {};
      stream_int_to_string_to_float.resize(values.size());
      for (size_t i = 0; i < values.size(); i++) {
        int32_t item = {};
        try {
          item = std::stoi(values[i]);
        } catch (...) {
          throw std::runtime_error("Unable to convert string \"" + values[i] + "\" to number");
        }
        stream_int_to_string_to_float[i] = item;
      }
      yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, stream_int_to_string_to_float);
      break;
    }
    default:
      yardl::binary::WriteVector<std::string, yardl::binary::WriteString>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndStreamIntToStringToFloatImpl() {
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteVectorIntToStringToFloatImpl(std::vector<std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> vector_int_to_string_to_float = {};
    vector_int_to_string_to_float.resize(value.size());
    for (size_t i = 0; i < value.size(); i++) {
      int32_t item = {};
      try {
        item = std::stoi(value[i]);
      } catch (...) {
        throw std::runtime_error("Unable to convert string \"" + value[i] + "\" to number");
      }
      vector_int_to_string_to_float[i] = item;
    }
    yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, vector_int_to_string_to_float);
    break;
  }
  default:
    yardl::binary::WriteVector<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntFloatUnionReorderedImpl(std::variant<float, int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, float> int_float_union_reordered = {};
    switch (value.index()) {
      case 0: {
        int_float_union_reordered = std::get<0>(value);
        break;
      }
      case 1: {
        int_float_union_reordered = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>(stream_, int_float_union_reordered);
    break;
  }
  default:
    WriteUnion<float, yardl::binary::WriteFloatingPoint, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteVectorUnionReorderedImpl(std::vector<std::variant<float, int32_t>> const& value) {
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, float>> vector_union_reordered = {};
    vector_union_reordered.resize(value.size());
    for (size_t i = 0; i < value.size(); i++) {
      std::variant<int32_t, float> item = {};
      switch (value[i].index()) {
        case 0: {
          item = std::get<0>(value[i]);
          break;
        }
        case 1: {
          item = std::get<1>(value[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      vector_union_reordered[i] = item;
    }
    yardl::binary::WriteVector<std::variant<int32_t, float>, WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>>(stream_, vector_union_reordered);
    break;
  }
  default:
    yardl::binary::WriteVector<std::variant<float, int32_t>, WriteUnion<float, yardl::binary::WriteFloatingPoint, int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamUnionReorderedImpl(std::variant<std::string, int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, std::string> stream_union_reordered = {};
    switch (value.index()) {
      case 0: {
        stream_union_reordered = std::get<0>(value);
        break;
      }
      case 1: {
        stream_union_reordered = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    yardl::binary::WriteBlock<std::variant<int32_t, std::string>, WriteUnion<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, stream_union_reordered);
    break;
  }
  default:
    yardl::binary::WriteBlock<std::variant<std::string, int32_t>, WriteUnion<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamUnionReorderedImpl(std::vector<std::variant<std::string, int32_t>> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      std::vector<std::variant<int32_t, std::string>> stream_union_reordered = {};
      stream_union_reordered.resize(values.size());
      for (size_t i = 0; i < values.size(); i++) {
        std::variant<int32_t, std::string> item = {};
        switch (values[i].index()) {
          case 0: {
            item = std::get<0>(values[i]);
            break;
          }
          case 1: {
            item = std::get<1>(values[i]);
            break;
          }
          default: throw std::runtime_error("Invalid union index.");
        }
        stream_union_reordered[i] = item;
      }
      yardl::binary::WriteVector<std::variant<int32_t, std::string>, WriteUnion<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, stream_union_reordered);
      break;
    }
    default:
      yardl::binary::WriteVector<std::variant<std::string, int32_t>, WriteUnion<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndStreamUnionReorderedImpl() {
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToUnionStreamImpl(int32_t const& value) {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteBlock<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteIntToUnionStreamImpl(std::vector<int32_t> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      break;
    }
    default:
      yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndIntToUnionStreamImpl() {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionStreamTypeChangeImpl(std::variant<int32_t, bool> const& value) {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteBlock<std::variant<int32_t, bool>, WriteUnion<int32_t, yardl::binary::WriteInteger, bool, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionStreamTypeChangeImpl(std::vector<std::variant<int32_t, bool>> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      break;
    }
    default:
      yardl::binary::WriteVector<std::variant<int32_t, bool>, WriteUnion<int32_t, yardl::binary::WriteInteger, bool, yardl::binary::WriteInteger>>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndUnionStreamTypeChangeImpl() {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamOfAliasTypeChangeImpl(evo_test::StreamItem const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlock<evo_test::StreamItem_v0, evo_test::binary::WriteStreamItem_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteBlock<evo_test::StreamItem, evo_test::binary::WriteStreamItem>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamOfAliasTypeChangeImpl(std::vector<evo_test::StreamItem> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVector<evo_test::StreamItem_v0, evo_test::binary::WriteStreamItem_v0>(stream_, values);
      break;
    }
    default:
      yardl::binary::WriteVector<evo_test::StreamItem, evo_test::binary::WriteStreamItem>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndStreamOfAliasTypeChangeImpl() {
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRlinkImpl(evo_test::RLink const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRlinkRXImpl(evo_test::RX const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRlinkRYImpl(evo_test::RY const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRlinkRZImpl(evo_test::RZ const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRaRLinkImpl(evo_test::RLink const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRaRXImpl(evo_test::RX const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRaRYImpl(evo_test::RY const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRaRZImpl(evo_test::RZ const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRbRLinkImpl(evo_test::RLink const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRbRXImpl(evo_test::RX const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRbRYImpl(evo_test::RY const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRbRZImpl(evo_test::RZ const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRcRLinkImpl(evo_test::RLink const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRcRXImpl(evo_test::RX const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRcRYImpl(evo_test::RY const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRcRZImpl(evo_test::RZ const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRlinkRNewImpl(evo_test::RNew const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRaRNewImpl(evo_test::RNew const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRbRNewImpl(evo_test::RNew const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRcRNewImpl(evo_test::RNew const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRlinkRUnionImpl(evo_test::RUnion const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rlink_r_union = {};
    if (value.index() == 0) {
      rlink_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, rlink_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRaRUnionImpl(evo_test::RUnion const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 ra_r_union = {};
    if (value.index() == 0) {
      ra_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, ra_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRbRUnionImpl(evo_test::RUnion const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rb_r_union = {};
    if (value.index() == 0) {
      rb_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, rb_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRcRUnionImpl(evo_test::RUnion const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rc_r_union = {};
    if (value.index() == 0) {
      rc_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, rc_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalRecordWithChangesImpl(std::optional<evo_test::RecordWithChanges> const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteOptional<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAliasedOptionalRecordWithChangesImpl(std::optional<evo_test::AliasedRecordWithChanges> const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteOptional<evo_test::AliasedRecordWithChanges_v0, evo_test::binary::WriteAliasedRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::AliasedRecordWithChanges, evo_test::binary::WriteAliasedRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionRecordWithChangesImpl(std::variant<evo_test::RecordWithChanges, int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_record_with_changes = {};
    switch (value.index()) {
      case 0: {
        union_record_with_changes = std::get<0>(value);
        break;
      }
      case 1: {
        union_record_with_changes = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger>(stream_, union_record_with_changes);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionWithSameTypesetImpl(std::variant<float, evo_test::RecordWithChanges, std::string, int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_same_typeset = {};
    switch (value.index()) {
      case 0: {
        union_with_same_typeset = std::get<0>(value);
        break;
      }
      case 1: {
        union_with_same_typeset = std::get<1>(value);
        break;
      }
      case 2: {
        union_with_same_typeset = std::get<2>(value);
        break;
      }
      case 3: {
        union_with_same_typeset = std::get<3>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream_, union_with_same_typeset);
    break;
  }
  default:
    WriteUnion<float, yardl::binary::WriteFloatingPoint, evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionWithTypesAddedImpl(std::variant<evo_test::RecordWithChanges, int32_t, float, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, float> union_with_types_added = {};
    switch (value.index()) {
      case 0: {
        union_with_types_added = std::get<0>(value);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges: RecordWithChanges_v0 | float32'");
        break;
      }
      case 2: {
        union_with_types_added = std::get<2>(value);
        break;
      }
      case 3: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[3] + "' incompatible with target union type 'RecordWithChanges: RecordWithChanges_v0 | float32'");
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, float, yardl::binary::WriteFloatingPoint>(stream_, union_with_types_added);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionWithTypesRemovedImpl(std::variant<evo_test::RecordWithChanges, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_types_removed = {};
    switch (value.index()) {
      case 0: {
        union_with_types_removed = std::get<0>(value);
        break;
      }
      case 1: {
        union_with_types_removed = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream_, union_with_types_removed);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToOptionalImpl(std::optional<evo_test::RecordWithChanges> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_optional = {};
    if (value.has_value()) {
      record_to_optional = value.value();
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToAliasedOptionalImpl(evo_test::AliasedOptionalRecord const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_optional = {};
    if (value.has_value()) {
      record_to_aliased_optional = value.value();
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_aliased_optional);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToUnionImpl(std::variant<evo_test::RecordWithChanges, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_union = {};
    if (value.index() == 0) {
      record_to_union = std::get<0>(value);
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_union);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteRecordToAliasedUnionImpl(evo_test::AliasedRecordOrString const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_union = {};
    if (value.index() == 0) {
      record_to_aliased_union = std::get<0>(value);
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_aliased_union);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionToAliasedUnionImpl(evo_test::AliasedRecordOrInt const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union = {};
    switch (value.index()) {
      case 0: {
        union_to_aliased_union = std::get<0>(value);
        break;
      }
      case 1: {
        union_to_aliased_union = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger>(stream_, union_to_aliased_union);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordOrInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteUnionToAliasedUnionWithChangesImpl(evo_test::AliasedRecordOrString const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union_with_changes = {};
    switch (value.index()) {
      case 0: {
        union_to_aliased_union_with_changes = std::get<0>(value);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "string"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges: RecordWithChanges_v0 | int32'");
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger>(stream_, union_to_aliased_union_with_changes);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalToAliasedOptionalImpl(evo_test::AliasedOptionalRecord const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteOptional<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteOptionalToAliasedOptionalWithChangesImpl(evo_test::AliasedOptionalString const& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_to_aliased_optional_with_changes = {};
    if (value.has_value()) {
      try {
        optional_to_aliased_optional_with_changes = std::stoi(value.value());
      } catch (...) {
        throw std::runtime_error("Unable to convert string \"" + value.value() + "\" to number");
      }
    }
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, optional_to_aliased_optional_with_changes);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOptionalString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordImpl(evo_test::GenericRecord<int32_t, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordToOpenAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOpenGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordToClosedAliasImpl(evo_test::AliasedClosedGenericRecord const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedClosedGenericRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordToHalfClosedAliasImpl(evo_test::AliasedHalfClosedGenericRecord<int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedHalfClosedGenericRecord<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAliasedGenericRecordToAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedHalfClosedGenericRecord_v0<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOpenGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordToReversedImpl(evo_test::GenericRecordReversed<std::string, int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericRecordReversed<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteClosedGenericRecordToUnionImpl(std::variant<evo_test::GenericRecord<int32_t, std::string>, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> closed_generic_record_to_union = {};
    if (value.index() == 0) {
      closed_generic_record_to_union = std::get<0>(value);
    }
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, closed_generic_record_to_union);
    break;
  }
  default:
    WriteUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordToAliasedUnionImpl(evo_test::AliasedGenericRecordOrString const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> generic_record_to_aliased_union = {};
    if (value.index() == 0) {
      generic_record_to_aliased_union = std::get<0>(value);
    }
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, generic_record_to_aliased_union);
    break;
  }
  default:
    evo_test::binary::WriteAliasedGenericRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericUnionToReversedImpl(evo_test::GenericUnionReversed<float, evo_test::GenericRecord<int32_t, std::string>> const& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::GenericRecord_v0<int32_t, std::string>, float> generic_union_to_reversed = {};
    switch (value.index()) {
      case 0: {
        generic_union_to_reversed = std::get<0>(value);
        break;
      }
      case 1: {
        generic_union_to_reversed = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, float, yardl::binary::WriteFloatingPoint>(stream_, generic_union_to_reversed);
    break;
  }
  default:
    evo_test::binary::WriteGenericUnionReversed<float, yardl::binary::WriteFloatingPoint, evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericUnionOfChangedRecordImpl(evo_test::GenericUnion<evo_test::GenericRecord<int32_t, std::string>, float> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedClosedGenericUnion_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, float, yardl::binary::WriteFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericParentRecordImpl(evo_test::GenericParentRecord<int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericParentRecord_v0<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericParentRecord<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericNestedRecordsImpl(evo_test::GenericRecord<evo_test::Unchanged, evo_test::Changed> const& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<evo_test::UnchangedGeneric_v0<int32_t>, evo_test::binary::WriteUnchangedGeneric_v0<int32_t, yardl::binary::WriteInteger>, evo_test::ChangedGeneric_v0<std::string, int32_t>, evo_test::binary::WriteChangedGeneric_v0<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericRecord<evo_test::Unchanged, evo_test::binary::WriteUnchanged, evo_test::Changed, evo_test::binary::WriteChanged>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordStreamImpl(evo_test::AliasedClosedGenericRecord const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlock<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteBlock<evo_test::AliasedClosedGenericRecord, evo_test::binary::WriteAliasedClosedGenericRecord>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericRecordStreamImpl(std::vector<evo_test::AliasedClosedGenericRecord> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVector<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, values);
      break;
    }
    default:
      yardl::binary::WriteVector<evo_test::AliasedClosedGenericRecord, evo_test::binary::WriteAliasedClosedGenericRecord>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndGenericRecordStreamImpl() {
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericParentRecordStreamImpl(evo_test::GenericParentRecord<int32_t> const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlock<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::WriteGenericParentRecord_v0<int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteBlock<evo_test::GenericParentRecord<int32_t>, evo_test::binary::WriteGenericParentRecord<int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteGenericParentRecordStreamImpl(std::vector<evo_test::GenericParentRecord<int32_t>> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVector<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::WriteGenericParentRecord_v0<int32_t, yardl::binary::WriteInteger>>(stream_, values);
      break;
    }
    default:
      yardl::binary::WriteVector<evo_test::GenericParentRecord<int32_t>, evo_test::binary::WriteGenericParentRecord<int32_t, yardl::binary::WriteInteger>>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndGenericParentRecordStreamImpl() {
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteVectorRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges> const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteVector<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteVector<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamedRecordWithChangesImpl(evo_test::RecordWithChanges const& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlock<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteBlock<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteStreamedRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVector<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, values);
      break;
    }
    default:
      yardl::binary::WriteVector<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndStreamedRecordWithChangesImpl() {
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAddedOptionalImpl(std::optional<evo_test::RecordWithChanges> const& value) {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAddedMapImpl(std::unordered_map<std::string, std::string> const& value) {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteMap<std::string, std::string, yardl::binary::WriteString, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAddedRecordStreamImpl(evo_test::RecordWithChanges const& value) {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteBlock<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesWriter::WriteAddedRecordStreamImpl(std::vector<evo_test::RecordWithChanges> const& values) {
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      break;
    }
    default:
      yardl::binary::WriteVector<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, values);
      break;
    }
  }
}

void ProtocolWithChangesWriter::EndAddedRecordStreamImpl() {
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesWriter::Flush() {
  stream_.Flush();
}

void ProtocolWithChangesWriter::CloseImpl() {
  stream_.Flush();
}

void ProtocolWithChangesReader::ReadInt8ToIntImpl(int32_t& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_int = {};
    yardl::binary::ReadInteger(stream_, int8_to_int);
    value = static_cast<int32_t>(int8_to_int);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadInt8ToLongImpl(int64_t& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_long = {};
    yardl::binary::ReadInteger(stream_, int8_to_long);
    value = static_cast<int64_t>(int8_to_long);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadInt8ToUintImpl(uint32_t& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_uint = {};
    yardl::binary::ReadInteger(stream_, int8_to_uint);
    if (int8_to_uint < 0) {
      throw std::runtime_error("Numeric overflow detected while converting 'int8' to 'uint32'");
    }
    value = static_cast<uint32_t>(int8_to_uint);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadInt8ToUlongImpl(uint64_t& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_ulong = {};
    yardl::binary::ReadInteger(stream_, int8_to_ulong);
    if (int8_to_ulong < 0) {
      throw std::runtime_error("Numeric overflow detected while converting 'int8' to 'uint64'");
    }
    value = static_cast<uint64_t>(int8_to_ulong);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadInt8ToFloatImpl(float& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_float = {};
    yardl::binary::ReadInteger(stream_, int8_to_float);
    value = static_cast<float>(int8_to_float);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadInt8ToDoubleImpl(double& value) {
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_double = {};
    yardl::binary::ReadInteger(stream_, int8_to_double);
    value = static_cast<double>(int8_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToUintImpl(uint32_t& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_uint = {};
    yardl::binary::ReadInteger(stream_, int_to_uint);
    if (int_to_uint < 0) {
      throw std::runtime_error("Numeric overflow detected while converting 'int32' to 'uint32'");
    }
    value = static_cast<uint32_t>(int_to_uint);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToLongImpl(int64_t& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_long = {};
    yardl::binary::ReadInteger(stream_, int_to_long);
    value = static_cast<int64_t>(int_to_long);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToFloatImpl(float& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_float = {};
    yardl::binary::ReadInteger(stream_, int_to_float);
    value = static_cast<float>(int_to_float);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToDoubleImpl(double& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_double = {};
    yardl::binary::ReadInteger(stream_, int_to_double);
    value = static_cast<double>(int_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUintToUlongImpl(uint64_t& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_ulong = {};
    yardl::binary::ReadInteger(stream_, uint_to_ulong);
    value = static_cast<uint64_t>(uint_to_ulong);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUintToFloatImpl(float& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_float = {};
    yardl::binary::ReadInteger(stream_, uint_to_float);
    value = static_cast<float>(uint_to_float);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUintToDoubleImpl(double& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_double = {};
    yardl::binary::ReadInteger(stream_, uint_to_double);
    value = static_cast<double>(uint_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadFloatToDoubleImpl(double& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_double = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_double);
    value = static_cast<double>(float_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadComplexFloatToComplexDoubleImpl(std::complex<double>& value) {
  switch (version_) {
  case Version::v0: {
    std::complex<float> complex_float_to_complex_double = {};
    yardl::binary::ReadFloatingPoint(stream_, complex_float_to_complex_double);
    value = std::complex<double>(complex_float_to_complex_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToStringImpl(std::string& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_string = {};
    yardl::binary::ReadInteger(stream_, int_to_string);
    value = std::to_string(int_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUintToStringImpl(std::string& value) {
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_string = {};
    yardl::binary::ReadInteger(stream_, uint_to_string);
    value = std::to_string(uint_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadLongToStringImpl(std::string& value) {
  switch (version_) {
  case Version::v0: {
    int64_t long_to_string = {};
    yardl::binary::ReadInteger(stream_, long_to_string);
    value = std::to_string(long_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUlongToStringImpl(std::string& value) {
  switch (version_) {
  case Version::v0: {
    uint64_t ulong_to_string = {};
    yardl::binary::ReadInteger(stream_, ulong_to_string);
    value = std::to_string(ulong_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadFloatToStringImpl(std::string& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_string = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_string);
    value = std::to_string(float_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadDoubleToStringImpl(std::string& value) {
  switch (version_) {
  case Version::v0: {
    double double_to_string = {};
    yardl::binary::ReadFloatingPoint(stream_, double_to_string);
    value = std::to_string(double_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToOptionalImpl(std::optional<int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_optional = {};
    yardl::binary::ReadInteger(stream_, int_to_optional);
    value = int_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadFloatToOptionalImpl(std::optional<float>& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_optional = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_optional);
    value = float_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadStringToOptionalImpl(std::optional<std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::string string_to_optional = {};
    yardl::binary::ReadString(stream_, string_to_optional);
    value = string_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntToUnionImpl(std::variant<int32_t, bool>& value) {
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union = {};
    yardl::binary::ReadInteger(stream_, int_to_union);
    value = int_to_union;
    break;
  }
  default:
    ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadFloatToUnionImpl(std::variant<float, bool>& value) {
  switch (version_) {
  case Version::v0: {
    float float_to_union = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_union);
    value = float_to_union;
    break;
  }
  default:
    ReadUnion<float, yardl::binary::ReadFloatingPoint, bool, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadStringToUnionImpl(std::variant<std::string, bool>& value) {
  switch (version_) {
  case Version::v0: {
    std::string string_to_union = {};
    yardl::binary::ReadString(stream_, string_to_union);
    value = string_to_union;
    break;
  }
  default:
    ReadUnion<std::string, yardl::binary::ReadString, bool, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalIntToFloatImpl(std::optional<float>& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_float = {};
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, optional_int_to_float);
    if (optional_int_to_float.has_value()) {
      value = static_cast<float>(optional_int_to_float.value());
    }
    break;
  }
  default:
    yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalFloatToStringImpl(std::optional<std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<float> optional_float_to_string = {};
    yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream_, optional_float_to_string);
    if (optional_float_to_string.has_value()) {
      value = std::to_string(optional_float_to_string.value());
    }
    break;
  }
  default:
    yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadAliasedLongToStringImpl(evo_test::AliasedLongToString& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedLongToString_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedLongToString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadStringToAliasedStringImpl(evo_test::AliasedString& value) {
  evo_test::binary::ReadAliasedString(stream_, value);
}

void ProtocolWithChangesReader::ReadStringToAliasedIntImpl(evo_test::AliasedInt& value) {
  switch (version_) {
  case Version::v0: {
    std::string string_to_aliased_int = {};
    yardl::binary::ReadString(stream_, string_to_aliased_int);
    try {
      value = std::stoi(string_to_aliased_int);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + string_to_aliased_int + "\" to number");
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadEnumToAliasedEnumImpl(evo_test::AliasedEnum& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadEnum<evo_test::GrowingEnum_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedEnum(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalIntToUnionImpl(std::variant<std::monostate, int32_t, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_union = {};
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, optional_int_to_union);
    if (optional_int_to_union.has_value()) {
      value = optional_int_to_union.value();
    } else {
      value = std::monostate{};
    }
    break;
  }
  default:
    ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalRecordToUnionImpl(std::variant<std::monostate, evo_test::RecordWithChanges, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<evo_test::RecordWithChanges_v0> optional_record_to_union = {};
    yardl::binary::ReadOptional<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, optional_record_to_union);
    if (optional_record_to_union.has_value()) {
      value = optional_record_to_union.value();
    } else {
      value = std::monostate{};
    }
    break;
  }
  default:
    ReadUnion<std::monostate, yardl::binary::ReadMonostate, evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordWithChangesImpl(evo_test::RecordWithChanges& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadAliasedRecordWithChangesImpl(evo_test::AliasedRecordWithChanges& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToRenamedRecordImpl(evo_test::RenamedRecord& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRenamedRecord_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRenamedRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToAliasedRecordImpl(evo_test::AliasedRecordWithChanges& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToAliasedAliasImpl(evo_test::AliasOfAliasedRecordWithChanges& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasOfAliasedRecordWithChanges(stream_, value);
    break;
  }
}

bool ProtocolWithChangesReader::ReadStreamIntToStringToFloatImpl(std::string& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    int32_t stream_int_to_string_to_float = {};
    read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, stream_int_to_string_to_float);
    if (read_block_successful) {
      value = std::to_string(stream_int_to_string_to_float);
    }
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::string, yardl::binary::ReadString>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadStreamIntToStringToFloatImpl(std::vector<std::string>& values) {
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> stream_int_to_string_to_float = {};
    stream_int_to_string_to_float.reserve(values.capacity());
    yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, stream_int_to_string_to_float);
    values.resize(stream_int_to_string_to_float.size());
    for (size_t i = 0; i < stream_int_to_string_to_float.size(); i++) {
      std::string item = {};
      item = std::to_string(stream_int_to_string_to_float[i]);
      values[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::string, yardl::binary::ReadString>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

void ProtocolWithChangesReader::ReadVectorIntToStringToFloatImpl(std::vector<std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> vector_int_to_string_to_float = {};
    yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream_, vector_int_to_string_to_float);
    value.resize(vector_int_to_string_to_float.size());
    for (size_t i = 0; i < vector_int_to_string_to_float.size(); i++) {
      std::string item = {};
      item = std::to_string(vector_int_to_string_to_float[i]);
      value[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadVector<std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadIntFloatUnionReorderedImpl(std::variant<float, int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, float> int_float_union_reordered = {};
    ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>(stream_, int_float_union_reordered);
    switch (int_float_union_reordered.index()) {
      case 0: {
        value = std::get<0>(int_float_union_reordered);
        break;
      }
      case 1: {
        value = std::get<1>(int_float_union_reordered);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<float, yardl::binary::ReadFloatingPoint, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadVectorUnionReorderedImpl(std::vector<std::variant<float, int32_t>>& value) {
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, float>> vector_union_reordered = {};
    yardl::binary::ReadVector<std::variant<int32_t, float>, ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>>(stream_, vector_union_reordered);
    value.resize(vector_union_reordered.size());
    for (size_t i = 0; i < vector_union_reordered.size(); i++) {
      std::variant<float, int32_t> item = {};
      switch (vector_union_reordered[i].index()) {
        case 0: {
          item = std::get<0>(vector_union_reordered[i]);
          break;
        }
        case 1: {
          item = std::get<1>(vector_union_reordered[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      value[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadVector<std::variant<float, int32_t>, ReadUnion<float, yardl::binary::ReadFloatingPoint, int32_t, yardl::binary::ReadInteger>>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesReader::ReadStreamUnionReorderedImpl(std::variant<std::string, int32_t>& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, std::string> stream_union_reordered = {};
    read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, std::string>, ReadUnion<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, stream_union_reordered);
    if (read_block_successful) {
      switch (stream_union_reordered.index()) {
        case 0: {
          value = std::get<0>(stream_union_reordered);
          break;
        }
        case 1: {
          value = std::get<1>(stream_union_reordered);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
    }
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::variant<std::string, int32_t>, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadStreamUnionReorderedImpl(std::vector<std::variant<std::string, int32_t>>& values) {
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, std::string>> stream_union_reordered = {};
    stream_union_reordered.reserve(values.capacity());
    yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, std::string>, ReadUnion<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, stream_union_reordered);
    values.resize(stream_union_reordered.size());
    for (size_t i = 0; i < stream_union_reordered.size(); i++) {
      std::variant<std::string, int32_t> item = {};
      switch (stream_union_reordered[i].index()) {
        case 0: {
          item = std::get<0>(stream_union_reordered[i]);
          break;
        }
        case 1: {
          item = std::get<1>(stream_union_reordered[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      values[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::variant<std::string, int32_t>, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesReader::ReadIntToUnionStreamImpl(int32_t& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union_stream = {};
    value = std::move(int_to_union_stream);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadIntToUnionStreamImpl(std::vector<int32_t>& values) {
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesReader::ReadUnionStreamTypeChangeImpl(std::variant<int32_t, bool>& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, bool> union_stream_type_change = {};
    value = std::move(union_stream_type_change);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, bool>, ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadUnionStreamTypeChangeImpl(std::vector<std::variant<int32_t, bool>>& values) {
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, bool>, ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesReader::ReadStreamOfAliasTypeChangeImpl(evo_test::StreamItem& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::StreamItem_v0, evo_test::binary::ReadStreamItem_v0>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::StreamItem, evo_test::binary::ReadStreamItem>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadStreamOfAliasTypeChangeImpl(std::vector<evo_test::StreamItem>& values) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::StreamItem_v0, evo_test::binary::ReadStreamItem_v0>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::StreamItem, evo_test::binary::ReadStreamItem>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

void ProtocolWithChangesReader::ReadRlinkImpl(evo_test::RLink& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRlinkRXImpl(evo_test::RX& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRlinkRYImpl(evo_test::RY& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRlinkRZImpl(evo_test::RZ& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRaRLinkImpl(evo_test::RLink& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRaRXImpl(evo_test::RX& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRaRYImpl(evo_test::RY& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRaRZImpl(evo_test::RZ& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRbRLinkImpl(evo_test::RLink& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRbRXImpl(evo_test::RX& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRbRYImpl(evo_test::RY& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRbRZImpl(evo_test::RZ& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRcRLinkImpl(evo_test::RLink& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRcRXImpl(evo_test::RX& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRcRYImpl(evo_test::RY& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRcRZImpl(evo_test::RZ& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRlinkRNewImpl(evo_test::RNew& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRaRNewImpl(evo_test::RNew& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRbRNewImpl(evo_test::RNew& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRcRNewImpl(evo_test::RNew& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRlinkRUnionImpl(evo_test::RUnion& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rlink_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, rlink_r_union);
    value = rlink_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRaRUnionImpl(evo_test::RUnion& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 ra_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, ra_r_union);
    value = ra_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRbRUnionImpl(evo_test::RUnion& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rb_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, rb_r_union);
    value = rb_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRcRUnionImpl(evo_test::RUnion& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rc_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, rc_r_union);
    value = rc_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalRecordWithChangesImpl(std::optional<evo_test::RecordWithChanges>& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadOptional<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadAliasedOptionalRecordWithChangesImpl(std::optional<evo_test::AliasedRecordWithChanges>& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadOptional<evo_test::AliasedRecordWithChanges_v0, evo_test::binary::ReadAliasedRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::AliasedRecordWithChanges, evo_test::binary::ReadAliasedRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUnionRecordWithChangesImpl(std::variant<evo_test::RecordWithChanges, int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_record_with_changes = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger>(stream_, union_record_with_changes);
    switch (union_record_with_changes.index()) {
      case 0: {
        value = std::get<0>(union_record_with_changes);
        break;
      }
      case 1: {
        value = std::get<1>(union_record_with_changes);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUnionWithSameTypesetImpl(std::variant<float, evo_test::RecordWithChanges, std::string, int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_same_typeset = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream_, union_with_same_typeset);
    switch (union_with_same_typeset.index()) {
      case 0: {
        value = std::get<0>(union_with_same_typeset);
        break;
      }
      case 1: {
        value = std::get<1>(union_with_same_typeset);
        break;
      }
      case 2: {
        value = std::get<2>(union_with_same_typeset);
        break;
      }
      case 3: {
        value = std::get<3>(union_with_same_typeset);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<float, yardl::binary::ReadFloatingPoint, evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUnionWithTypesAddedImpl(std::variant<evo_test::RecordWithChanges, int32_t, float, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, float> union_with_types_added = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, float, yardl::binary::ReadFloatingPoint>(stream_, union_with_types_added);
    switch (union_with_types_added.index()) {
      case 0: {
        value = std::get<0>(union_with_types_added);
        break;
      }
      case 1: {
        value = std::get<1>(union_with_types_added);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUnionWithTypesRemovedImpl(std::variant<evo_test::RecordWithChanges, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_types_removed = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream_, union_with_types_removed);
    switch (union_with_types_removed.index()) {
      case 0: {
        value = std::get<0>(union_with_types_removed);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges | string'");
        break;
      }
      case 2: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[2] + "' incompatible with target union type 'RecordWithChanges | string'");
        break;
      }
      case 3: {
        value = std::get<3>(union_with_types_removed);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToOptionalImpl(std::optional<evo_test::RecordWithChanges>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_optional = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_optional);
    value = record_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToAliasedOptionalImpl(evo_test::AliasedOptionalRecord& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_optional = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_aliased_optional);
    value = record_to_aliased_optional;
    break;
  }
  default:
    evo_test::binary::ReadAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToUnionImpl(std::variant<evo_test::RecordWithChanges, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_union = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_union);
    value = record_to_union;
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadRecordToAliasedUnionImpl(evo_test::AliasedRecordOrString& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_union = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_aliased_union);
    value = record_to_aliased_union;
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUnionToAliasedUnionImpl(evo_test::AliasedRecordOrInt& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger>(stream_, union_to_aliased_union);
    switch (union_to_aliased_union.index()) {
      case 0: {
        value = std::get<0>(union_to_aliased_union);
        break;
      }
      case 1: {
        value = std::get<1>(union_to_aliased_union);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordOrInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadUnionToAliasedUnionWithChangesImpl(evo_test::AliasedRecordOrString& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union_with_changes = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger>(stream_, union_to_aliased_union_with_changes);
    switch (union_to_aliased_union_with_changes.index()) {
      case 0: {
        value = std::get<0>(union_to_aliased_union_with_changes);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges | string'");
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalToAliasedOptionalImpl(evo_test::AliasedOptionalRecord& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadOptional<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadOptionalToAliasedOptionalWithChangesImpl(evo_test::AliasedOptionalString& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_to_aliased_optional_with_changes = {};
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, optional_to_aliased_optional_with_changes);
    if (optional_to_aliased_optional_with_changes.has_value()) {
      value = std::to_string(optional_to_aliased_optional_with_changes.value());
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedOptionalString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericRecordImpl(evo_test::GenericRecord<int32_t, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericRecordToOpenAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedOpenGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericRecordToClosedAliasImpl(evo_test::AliasedClosedGenericRecord& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedClosedGenericRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericRecordToHalfClosedAliasImpl(evo_test::AliasedHalfClosedGenericRecord<int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedHalfClosedGenericRecord<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadAliasedGenericRecordToAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedHalfClosedGenericRecord_v0<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedOpenGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericRecordToReversedImpl(evo_test::GenericRecordReversed<std::string, int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericRecordReversed<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadClosedGenericRecordToUnionImpl(std::variant<evo_test::GenericRecord<int32_t, std::string>, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> closed_generic_record_to_union = {};
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, closed_generic_record_to_union);
    value = closed_generic_record_to_union;
    break;
  }
  default:
    ReadUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericRecordToAliasedUnionImpl(evo_test::AliasedGenericRecordOrString& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> generic_record_to_aliased_union = {};
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, generic_record_to_aliased_union);
    value = generic_record_to_aliased_union;
    break;
  }
  default:
    evo_test::binary::ReadAliasedGenericRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericUnionToReversedImpl(evo_test::GenericUnionReversed<float, evo_test::GenericRecord<int32_t, std::string>>& value) {
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::GenericRecord_v0<int32_t, std::string>, float> generic_union_to_reversed = {};
    ReadUnion<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, float, yardl::binary::ReadFloatingPoint>(stream_, generic_union_to_reversed);
    switch (generic_union_to_reversed.index()) {
      case 0: {
        value = std::get<0>(generic_union_to_reversed);
        break;
      }
      case 1: {
        value = std::get<1>(generic_union_to_reversed);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    evo_test::binary::ReadGenericUnionReversed<float, yardl::binary::ReadFloatingPoint, evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericUnionOfChangedRecordImpl(evo_test::GenericUnion<evo_test::GenericRecord<int32_t, std::string>, float>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedClosedGenericUnion_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, float, yardl::binary::ReadFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericParentRecordImpl(evo_test::GenericParentRecord<int32_t>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadGenericNestedRecordsImpl(evo_test::GenericRecord<evo_test::Unchanged, evo_test::Changed>& value) {
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<evo_test::UnchangedGeneric_v0<int32_t>, evo_test::binary::ReadUnchangedGeneric_v0<int32_t, yardl::binary::ReadInteger>, evo_test::ChangedGeneric_v0<std::string, int32_t>, evo_test::binary::ReadChangedGeneric_v0<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericRecord<evo_test::Unchanged, evo_test::binary::ReadUnchanged, evo_test::Changed, evo_test::binary::ReadChanged>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesReader::ReadGenericRecordStreamImpl(evo_test::AliasedClosedGenericRecord& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::AliasedClosedGenericRecord, evo_test::binary::ReadAliasedClosedGenericRecord>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadGenericRecordStreamImpl(std::vector<evo_test::AliasedClosedGenericRecord>& values) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::AliasedClosedGenericRecord, evo_test::binary::ReadAliasedClosedGenericRecord>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesReader::ReadGenericParentRecordStreamImpl(evo_test::GenericParentRecord<int32_t>& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericParentRecord<int32_t>, evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadGenericParentRecordStreamImpl(std::vector<evo_test::GenericParentRecord<int32_t>>& values) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericParentRecord<int32_t>, evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

void ProtocolWithChangesReader::ReadVectorRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges>& value) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadVector<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::ReadVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesReader::ReadStreamedRecordWithChangesImpl(evo_test::RecordWithChanges& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadStreamedRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges>& values) {
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

void ProtocolWithChangesReader::ReadAddedOptionalImpl(std::optional<evo_test::RecordWithChanges>& value) {
  switch (version_) {
  case Version::v0: {
    std::optional<evo_test::RecordWithChanges> added_optional = {};
    value = std::move(added_optional);
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesReader::ReadAddedMapImpl(std::unordered_map<std::string, std::string>& value) {
  switch (version_) {
  case Version::v0: {
    std::unordered_map<std::string, std::string> added_map = {};
    value = std::move(added_map);
    break;
  }
  default:
    yardl::binary::ReadMap<std::string, std::string, yardl::binary::ReadString, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesReader::ReadAddedRecordStreamImpl(evo_test::RecordWithChanges& value) {
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges added_record_stream = {};
    value = std::move(added_record_stream);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesReader::ReadAddedRecordStreamImpl(std::vector<evo_test::RecordWithChanges>& values) {
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

void ProtocolWithChangesReader::CloseImpl() {
  stream_.VerifyFinished();
}

void ProtocolWithChangesIndexedWriter::WriteInt8ToIntImpl(int32_t const& value) {
  step_index_.set_step_offset("Int8ToInt", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_int = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'int32' to 'int8'");
    }
    int8_to_int = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_int);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteInt8ToLongImpl(int64_t const& value) {
  step_index_.set_step_offset("Int8ToLong", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_long = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'int64' to 'int8'");
    }
    int8_to_long = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_long);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteInt8ToUintImpl(uint32_t const& value) {
  step_index_.set_step_offset("Int8ToUint", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_uint = {};
    if (value > std::numeric_limits<int8_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint32' to 'int8'");
    }
    int8_to_uint = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_uint);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteInt8ToUlongImpl(uint64_t const& value) {
  step_index_.set_step_offset("Int8ToUlong", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_ulong = {};
    if (value > std::numeric_limits<int8_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint64' to 'int8'");
    }
    int8_to_ulong = static_cast<int8_t>(value);
    yardl::binary::WriteInteger(stream_, int8_to_ulong);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteInt8ToFloatImpl(float const& value) {
  step_index_.set_step_offset("Int8ToFloat", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_float = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'int8'");
    }
    int8_to_float = static_cast<int8_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int8_to_float);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteInt8ToDoubleImpl(double const& value) {
  step_index_.set_step_offset("Int8ToDouble", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_double = {};
    if (value > std::numeric_limits<int8_t>::max() || value < std::numeric_limits<int8_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'int8'");
    }
    int8_to_double = static_cast<int8_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int8_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToUintImpl(uint32_t const& value) {
  step_index_.set_step_offset("IntToUint", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_uint = {};
    if (value > std::numeric_limits<int32_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint32' to 'int32'");
    }
    int_to_uint = static_cast<int32_t>(value);
    yardl::binary::WriteInteger(stream_, int_to_uint);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToLongImpl(int64_t const& value) {
  step_index_.set_step_offset("IntToLong", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_long = {};
    if (value > std::numeric_limits<int32_t>::max() || value < std::numeric_limits<int32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'int64' to 'int32'");
    }
    int_to_long = static_cast<int32_t>(value);
    yardl::binary::WriteInteger(stream_, int_to_long);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToFloatImpl(float const& value) {
  step_index_.set_step_offset("IntToFloat", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_float = {};
    if (value > std::numeric_limits<int32_t>::max() || value < std::numeric_limits<int32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'int32'");
    }
    int_to_float = static_cast<int32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int_to_float);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToDoubleImpl(double const& value) {
  step_index_.set_step_offset("IntToDouble", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_double = {};
    if (value > std::numeric_limits<int32_t>::max() || value < std::numeric_limits<int32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'int32'");
    }
    int_to_double = static_cast<int32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, int_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUintToUlongImpl(uint64_t const& value) {
  step_index_.set_step_offset("UintToUlong", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_ulong = {};
    if (value > std::numeric_limits<uint32_t>::max()) {
      throw std::runtime_error("Numeric overflow detected while converting 'uint64' to 'uint32'");
    }
    uint_to_ulong = static_cast<uint32_t>(value);
    yardl::binary::WriteInteger(stream_, uint_to_ulong);
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUintToFloatImpl(float const& value) {
  step_index_.set_step_offset("UintToFloat", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_float = {};
    if (value > std::numeric_limits<uint32_t>::max() || value < std::numeric_limits<uint32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'uint32'");
    }
    uint_to_float = static_cast<uint32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, uint_to_float);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUintToDoubleImpl(double const& value) {
  step_index_.set_step_offset("UintToDouble", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_double = {};
    if (value > std::numeric_limits<uint32_t>::max() || value < std::numeric_limits<uint32_t>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'uint32'");
    }
    uint_to_double = static_cast<uint32_t>(std::round(value));
    yardl::binary::WriteInteger(stream_, uint_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteFloatToDoubleImpl(double const& value) {
  step_index_.set_step_offset("FloatToDouble", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    float float_to_double = {};
    if (value > std::numeric_limits<float>::max() || value < std::numeric_limits<float>::lowest()) {
      throw std::runtime_error("Numeric overflow detected while converting 'float64' to 'float32'");
    }
    float_to_double = static_cast<float>(value);
    yardl::binary::WriteFloatingPoint(stream_, float_to_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteComplexFloatToComplexDoubleImpl(std::complex<double> const& value) {
  step_index_.set_step_offset("ComplexFloatToComplexDouble", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::complex<float> complex_float_to_complex_double = {};
    if (std::real(value) > std::numeric_limits<std::complex<float>::value_type>::max() || std::real(value) < std::numeric_limits<std::complex<float>::value_type>::lowest()) {
      throw std::runtime_error("Real part overflow detected while converting 'complexfloat64' to 'complexfloat32'");
    }
    if (std::imag(value) > std::numeric_limits<std::complex<float>::value_type>::max() || std::imag(value) < std::numeric_limits<std::complex<float>::value_type>::lowest()) {
      throw std::runtime_error("Imaginary part overflow detected while converting 'complexfloat64' to 'complexfloat32'");
    }
    complex_float_to_complex_double = std::complex<float>(value);
    yardl::binary::WriteFloatingPoint(stream_, complex_float_to_complex_double);
    break;
  }
  default:
    yardl::binary::WriteFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToStringImpl(std::string const& value) {
  step_index_.set_step_offset("IntToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_string = {};
    try {
      int_to_string = std::stoi(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, int_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUintToStringImpl(std::string const& value) {
  step_index_.set_step_offset("UintToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_string = {};
    try {
      uint_to_string = std::stoul(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, uint_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteLongToStringImpl(std::string const& value) {
  step_index_.set_step_offset("LongToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int64_t long_to_string = {};
    try {
      long_to_string = std::stol(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, long_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUlongToStringImpl(std::string const& value) {
  step_index_.set_step_offset("UlongToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    uint64_t ulong_to_string = {};
    try {
      ulong_to_string = std::stoul(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteInteger(stream_, ulong_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteFloatToStringImpl(std::string const& value) {
  step_index_.set_step_offset("FloatToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    float float_to_string = {};
    try {
      float_to_string = std::stof(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteFloatingPoint(stream_, float_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteDoubleToStringImpl(std::string const& value) {
  step_index_.set_step_offset("DoubleToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    double double_to_string = {};
    try {
      double_to_string = std::stod(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteFloatingPoint(stream_, double_to_string);
    break;
  }
  default:
    yardl::binary::WriteString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToOptionalImpl(std::optional<int32_t> const& value) {
  step_index_.set_step_offset("IntToOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_optional = {};
    if (value.has_value()) {
      int_to_optional = value.value();
    }
    yardl::binary::WriteInteger(stream_, int_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteFloatToOptionalImpl(std::optional<float> const& value) {
  step_index_.set_step_offset("FloatToOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    float float_to_optional = {};
    if (value.has_value()) {
      float_to_optional = value.value();
    }
    yardl::binary::WriteFloatingPoint(stream_, float_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStringToOptionalImpl(std::optional<std::string> const& value) {
  step_index_.set_step_offset("StringToOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::string string_to_optional = {};
    if (value.has_value()) {
      string_to_optional = value.value();
    }
    yardl::binary::WriteString(stream_, string_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToUnionImpl(std::variant<int32_t, bool> const& value) {
  step_index_.set_step_offset("IntToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union = {};
    if (value.index() == 0) {
      int_to_union = std::get<0>(value);
    }
    yardl::binary::WriteInteger(stream_, int_to_union);
    break;
  }
  default:
    WriteUnion<int32_t, yardl::binary::WriteInteger, bool, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteFloatToUnionImpl(std::variant<float, bool> const& value) {
  step_index_.set_step_offset("FloatToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    float float_to_union = {};
    if (value.index() == 0) {
      float_to_union = std::get<0>(value);
    }
    yardl::binary::WriteFloatingPoint(stream_, float_to_union);
    break;
  }
  default:
    WriteUnion<float, yardl::binary::WriteFloatingPoint, bool, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStringToUnionImpl(std::variant<std::string, bool> const& value) {
  step_index_.set_step_offset("StringToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::string string_to_union = {};
    if (value.index() == 0) {
      string_to_union = std::get<0>(value);
    }
    yardl::binary::WriteString(stream_, string_to_union);
    break;
  }
  default:
    WriteUnion<std::string, yardl::binary::WriteString, bool, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalIntToFloatImpl(std::optional<float> const& value) {
  step_index_.set_step_offset("OptionalIntToFloat", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_float = {};
    if (value.has_value()) {
      if (value.value() > std::numeric_limits<int32_t>::max() || value.value() < std::numeric_limits<int32_t>::lowest()) {
        throw std::runtime_error("Numeric overflow detected while converting 'float32' to 'int32'");
      }
      optional_int_to_float = static_cast<int32_t>(std::round(value.value()));
    }
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, optional_int_to_float);
    break;
  }
  default:
    yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalFloatToStringImpl(std::optional<std::string> const& value) {
  step_index_.set_step_offset("OptionalFloatToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::optional<float> optional_float_to_string = {};
    if (value.has_value()) {
      try {
        optional_float_to_string = std::stof(value.value());
      } catch (...) {
        throw std::runtime_error("Unable to convert string \"" + value.value() + "\" to number");
      }
    }
    yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream_, optional_float_to_string);
    break;
  }
  default:
    yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAliasedLongToStringImpl(evo_test::AliasedLongToString const& value) {
  step_index_.set_step_offset("AliasedLongToString", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedLongToString_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedLongToString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStringToAliasedStringImpl(evo_test::AliasedString const& value) {
  step_index_.set_step_offset("StringToAliasedString", stream_.Pos());
  evo_test::binary::WriteAliasedString(stream_, value);
}

void ProtocolWithChangesIndexedWriter::WriteStringToAliasedIntImpl(evo_test::AliasedInt const& value) {
  step_index_.set_step_offset("StringToAliasedInt", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::string string_to_aliased_int = {};
    string_to_aliased_int = std::to_string(value);
    yardl::binary::WriteString(stream_, string_to_aliased_int);
    break;
  }
  default:
    evo_test::binary::WriteAliasedInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteEnumToAliasedEnumImpl(evo_test::AliasedEnum const& value) {
  step_index_.set_step_offset("EnumToAliasedEnum", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteEnum<evo_test::GrowingEnum_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedEnum(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalIntToUnionImpl(std::variant<std::monostate, int32_t, std::string> const& value) {
  step_index_.set_step_offset("OptionalIntToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_union = {};
    if (value.index() == 1) {
      optional_int_to_union = std::get<1>(value);
    }
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, optional_int_to_union);
    break;
  }
  default:
    WriteUnion<std::monostate, yardl::binary::WriteMonostate, int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalRecordToUnionImpl(std::variant<std::monostate, evo_test::RecordWithChanges, std::string> const& value) {
  step_index_.set_step_offset("OptionalRecordToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::optional<evo_test::RecordWithChanges_v0> optional_record_to_union = {};
    if (value.index() == 1) {
      optional_record_to_union = std::get<1>(value);
    }
    yardl::binary::WriteOptional<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, optional_record_to_union);
    break;
  }
  default:
    WriteUnion<std::monostate, yardl::binary::WriteMonostate, evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordWithChangesImpl(evo_test::RecordWithChanges const& value) {
  step_index_.set_step_offset("RecordWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAliasedRecordWithChangesImpl(evo_test::AliasedRecordWithChanges const& value) {
  step_index_.set_step_offset("AliasedRecordWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToRenamedRecordImpl(evo_test::RenamedRecord const& value) {
  step_index_.set_step_offset("RecordToRenamedRecord", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRenamedRecord_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRenamedRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToAliasedRecordImpl(evo_test::AliasedRecordWithChanges const& value) {
  step_index_.set_step_offset("RecordToAliasedRecord", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToAliasedAliasImpl(evo_test::AliasOfAliasedRecordWithChanges const& value) {
  step_index_.set_step_offset("RecordToAliasedAlias", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasOfAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStreamIntToStringToFloatImpl(std::string const& value) {
  step_index_.set_step_offset("StreamIntToStringToFloat", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    int32_t stream_int_to_string_to_float = {};
    try {
      stream_int_to_string_to_float = std::stoi(value);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + value + "\" to number");
    }
    yardl::binary::WriteBlockAndSaveOffset<int32_t, yardl::binary::WriteInteger>(stream_, stream_int_to_string_to_float, item_offset);
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<std::string, yardl::binary::WriteString>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("StreamIntToStringToFloat", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteStreamIntToStringToFloatImpl(std::vector<std::string> const& values) {
  step_index_.set_step_offset("StreamIntToStringToFloat", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      std::vector<int32_t> stream_int_to_string_to_float = {};
      stream_int_to_string_to_float.resize(values.size());
      for (size_t i = 0; i < values.size(); i++) {
        int32_t item = {};
        try {
          item = std::stoi(values[i]);
        } catch (...) {
          throw std::runtime_error("Unable to convert string \"" + values[i] + "\" to number");
        }
        stream_int_to_string_to_float[i] = item;
      }
      yardl::binary::WriteVectorAndSaveOffsets<int32_t, yardl::binary::WriteInteger>(stream_, stream_int_to_string_to_float, item_offsets);
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<std::string, yardl::binary::WriteString>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("StreamIntToStringToFloat", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndStreamIntToStringToFloatImpl() {
  step_index_.set_step_offset("StreamIntToStringToFloat", stream_.Pos());
  step_index_.add_stream_offsets("StreamIntToStringToFloat", std::vector<size_t>{});
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteVectorIntToStringToFloatImpl(std::vector<std::string> const& value) {
  step_index_.set_step_offset("VectorIntToStringToFloat", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> vector_int_to_string_to_float = {};
    vector_int_to_string_to_float.resize(value.size());
    for (size_t i = 0; i < value.size(); i++) {
      int32_t item = {};
      try {
        item = std::stoi(value[i]);
      } catch (...) {
        throw std::runtime_error("Unable to convert string \"" + value[i] + "\" to number");
      }
      vector_int_to_string_to_float[i] = item;
    }
    yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream_, vector_int_to_string_to_float);
    break;
  }
  default:
    yardl::binary::WriteVector<std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntFloatUnionReorderedImpl(std::variant<float, int32_t> const& value) {
  step_index_.set_step_offset("IntFloatUnionReordered", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, float> int_float_union_reordered = {};
    switch (value.index()) {
      case 0: {
        int_float_union_reordered = std::get<0>(value);
        break;
      }
      case 1: {
        int_float_union_reordered = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>(stream_, int_float_union_reordered);
    break;
  }
  default:
    WriteUnion<float, yardl::binary::WriteFloatingPoint, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteVectorUnionReorderedImpl(std::vector<std::variant<float, int32_t>> const& value) {
  step_index_.set_step_offset("VectorUnionReordered", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, float>> vector_union_reordered = {};
    vector_union_reordered.resize(value.size());
    for (size_t i = 0; i < value.size(); i++) {
      std::variant<int32_t, float> item = {};
      switch (value[i].index()) {
        case 0: {
          item = std::get<0>(value[i]);
          break;
        }
        case 1: {
          item = std::get<1>(value[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      vector_union_reordered[i] = item;
    }
    yardl::binary::WriteVector<std::variant<int32_t, float>, WriteUnion<int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint>>(stream_, vector_union_reordered);
    break;
  }
  default:
    yardl::binary::WriteVector<std::variant<float, int32_t>, WriteUnion<float, yardl::binary::WriteFloatingPoint, int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStreamUnionReorderedImpl(std::variant<std::string, int32_t> const& value) {
  step_index_.set_step_offset("StreamUnionReordered", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, std::string> stream_union_reordered = {};
    switch (value.index()) {
      case 0: {
        stream_union_reordered = std::get<0>(value);
        break;
      }
      case 1: {
        stream_union_reordered = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    yardl::binary::WriteBlockAndSaveOffset<std::variant<int32_t, std::string>, WriteUnion<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, stream_union_reordered, item_offset);
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<std::variant<std::string, int32_t>, WriteUnion<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("StreamUnionReordered", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteStreamUnionReorderedImpl(std::vector<std::variant<std::string, int32_t>> const& values) {
  step_index_.set_step_offset("StreamUnionReordered", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      std::vector<std::variant<int32_t, std::string>> stream_union_reordered = {};
      stream_union_reordered.resize(values.size());
      for (size_t i = 0; i < values.size(); i++) {
        std::variant<int32_t, std::string> item = {};
        switch (values[i].index()) {
          case 0: {
            item = std::get<0>(values[i]);
            break;
          }
          case 1: {
            item = std::get<1>(values[i]);
            break;
          }
          default: throw std::runtime_error("Invalid union index.");
        }
        stream_union_reordered[i] = item;
      }
      yardl::binary::WriteVectorAndSaveOffsets<std::variant<int32_t, std::string>, WriteUnion<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, stream_union_reordered, item_offsets);
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<std::variant<std::string, int32_t>, WriteUnion<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("StreamUnionReordered", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndStreamUnionReorderedImpl() {
  step_index_.set_step_offset("StreamUnionReordered", stream_.Pos());
  step_index_.add_stream_offsets("StreamUnionReordered", std::vector<size_t>{});
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteIntToUnionStreamImpl(int32_t const& value) {
  step_index_.set_step_offset("IntToUnionStream", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<int32_t, yardl::binary::WriteInteger>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("IntToUnionStream", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteIntToUnionStreamImpl(std::vector<int32_t> const& values) {
  step_index_.set_step_offset("IntToUnionStream", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<int32_t, yardl::binary::WriteInteger>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("IntToUnionStream", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndIntToUnionStreamImpl() {
  step_index_.set_step_offset("IntToUnionStream", stream_.Pos());
  step_index_.add_stream_offsets("IntToUnionStream", std::vector<size_t>{});
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionStreamTypeChangeImpl(std::variant<int32_t, bool> const& value) {
  step_index_.set_step_offset("UnionStreamTypeChange", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<std::variant<int32_t, bool>, WriteUnion<int32_t, yardl::binary::WriteInteger, bool, yardl::binary::WriteInteger>>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("UnionStreamTypeChange", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteUnionStreamTypeChangeImpl(std::vector<std::variant<int32_t, bool>> const& values) {
  step_index_.set_step_offset("UnionStreamTypeChange", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<std::variant<int32_t, bool>, WriteUnion<int32_t, yardl::binary::WriteInteger, bool, yardl::binary::WriteInteger>>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("UnionStreamTypeChange", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndUnionStreamTypeChangeImpl() {
  step_index_.set_step_offset("UnionStreamTypeChange", stream_.Pos());
  step_index_.add_stream_offsets("UnionStreamTypeChange", std::vector<size_t>{});
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStreamOfAliasTypeChangeImpl(evo_test::StreamItem const& value) {
  step_index_.set_step_offset("StreamOfAliasTypeChange", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlockAndSaveOffset<evo_test::StreamItem_v0, evo_test::binary::WriteStreamItem_v0>(stream_, value, item_offset);
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<evo_test::StreamItem, evo_test::binary::WriteStreamItem>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("StreamOfAliasTypeChange", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteStreamOfAliasTypeChangeImpl(std::vector<evo_test::StreamItem> const& values) {
  step_index_.set_step_offset("StreamOfAliasTypeChange", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::StreamItem_v0, evo_test::binary::WriteStreamItem_v0>(stream_, values, item_offsets);
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::StreamItem, evo_test::binary::WriteStreamItem>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("StreamOfAliasTypeChange", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndStreamOfAliasTypeChangeImpl() {
  step_index_.set_step_offset("StreamOfAliasTypeChange", stream_.Pos());
  step_index_.add_stream_offsets("StreamOfAliasTypeChange", std::vector<size_t>{});
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRlinkImpl(evo_test::RLink const& value) {
  step_index_.set_step_offset("Rlink", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRlinkRXImpl(evo_test::RX const& value) {
  step_index_.set_step_offset("RlinkRX", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRlinkRYImpl(evo_test::RY const& value) {
  step_index_.set_step_offset("RlinkRY", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRlinkRZImpl(evo_test::RZ const& value) {
  step_index_.set_step_offset("RlinkRZ", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRaRLinkImpl(evo_test::RLink const& value) {
  step_index_.set_step_offset("RaRLink", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRaRXImpl(evo_test::RX const& value) {
  step_index_.set_step_offset("RaRX", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRaRYImpl(evo_test::RY const& value) {
  step_index_.set_step_offset("RaRY", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRaRZImpl(evo_test::RZ const& value) {
  step_index_.set_step_offset("RaRZ", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRbRLinkImpl(evo_test::RLink const& value) {
  step_index_.set_step_offset("RbRLink", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRbRXImpl(evo_test::RX const& value) {
  step_index_.set_step_offset("RbRX", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRbRYImpl(evo_test::RY const& value) {
  step_index_.set_step_offset("RbRY", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRbRZImpl(evo_test::RZ const& value) {
  step_index_.set_step_offset("RbRZ", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRcRLinkImpl(evo_test::RLink const& value) {
  step_index_.set_step_offset("RcRLink", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRcRXImpl(evo_test::RX const& value) {
  step_index_.set_step_offset("RcRX", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRcRYImpl(evo_test::RY const& value) {
  step_index_.set_step_offset("RcRY", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRcRZImpl(evo_test::RZ const& value) {
  step_index_.set_step_offset("RcRZ", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRlinkRNewImpl(evo_test::RNew const& value) {
  step_index_.set_step_offset("RlinkRNew", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRaRNewImpl(evo_test::RNew const& value) {
  step_index_.set_step_offset("RaRNew", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRbRNewImpl(evo_test::RNew const& value) {
  step_index_.set_step_offset("RbRNew", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRcRNewImpl(evo_test::RNew const& value) {
  step_index_.set_step_offset("RcRNew", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRlinkRUnionImpl(evo_test::RUnion const& value) {
  step_index_.set_step_offset("RlinkRUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rlink_r_union = {};
    if (value.index() == 0) {
      rlink_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, rlink_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRaRUnionImpl(evo_test::RUnion const& value) {
  step_index_.set_step_offset("RaRUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 ra_r_union = {};
    if (value.index() == 0) {
      ra_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, ra_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRbRUnionImpl(evo_test::RUnion const& value) {
  step_index_.set_step_offset("RbRUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rb_r_union = {};
    if (value.index() == 0) {
      rb_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, rb_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRcRUnionImpl(evo_test::RUnion const& value) {
  step_index_.set_step_offset("RcRUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rc_r_union = {};
    if (value.index() == 0) {
      rc_r_union = std::get<0>(value);
    }
    evo_test::binary::WriteRC_v0(stream_, rc_r_union);
    break;
  }
  default:
    evo_test::binary::WriteRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalRecordWithChangesImpl(std::optional<evo_test::RecordWithChanges> const& value) {
  step_index_.set_step_offset("OptionalRecordWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteOptional<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAliasedOptionalRecordWithChangesImpl(std::optional<evo_test::AliasedRecordWithChanges> const& value) {
  step_index_.set_step_offset("AliasedOptionalRecordWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteOptional<evo_test::AliasedRecordWithChanges_v0, evo_test::binary::WriteAliasedRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::AliasedRecordWithChanges, evo_test::binary::WriteAliasedRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionRecordWithChangesImpl(std::variant<evo_test::RecordWithChanges, int32_t> const& value) {
  step_index_.set_step_offset("UnionRecordWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_record_with_changes = {};
    switch (value.index()) {
      case 0: {
        union_record_with_changes = std::get<0>(value);
        break;
      }
      case 1: {
        union_record_with_changes = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger>(stream_, union_record_with_changes);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionWithSameTypesetImpl(std::variant<float, evo_test::RecordWithChanges, std::string, int32_t> const& value) {
  step_index_.set_step_offset("UnionWithSameTypeset", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_same_typeset = {};
    switch (value.index()) {
      case 0: {
        union_with_same_typeset = std::get<0>(value);
        break;
      }
      case 1: {
        union_with_same_typeset = std::get<1>(value);
        break;
      }
      case 2: {
        union_with_same_typeset = std::get<2>(value);
        break;
      }
      case 3: {
        union_with_same_typeset = std::get<3>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream_, union_with_same_typeset);
    break;
  }
  default:
    WriteUnion<float, yardl::binary::WriteFloatingPoint, evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionWithTypesAddedImpl(std::variant<evo_test::RecordWithChanges, int32_t, float, std::string> const& value) {
  step_index_.set_step_offset("UnionWithTypesAdded", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, float> union_with_types_added = {};
    switch (value.index()) {
      case 0: {
        union_with_types_added = std::get<0>(value);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges: RecordWithChanges_v0 | float32'");
        break;
      }
      case 2: {
        union_with_types_added = std::get<2>(value);
        break;
      }
      case 3: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[3] + "' incompatible with target union type 'RecordWithChanges: RecordWithChanges_v0 | float32'");
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, float, yardl::binary::WriteFloatingPoint>(stream_, union_with_types_added);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionWithTypesRemovedImpl(std::variant<evo_test::RecordWithChanges, std::string> const& value) {
  step_index_.set_step_offset("UnionWithTypesRemoved", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_types_removed = {};
    switch (value.index()) {
      case 0: {
        union_with_types_removed = std::get<0>(value);
        break;
      }
      case 1: {
        union_with_types_removed = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger, float, yardl::binary::WriteFloatingPoint, std::string, yardl::binary::WriteString>(stream_, union_with_types_removed);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToOptionalImpl(std::optional<evo_test::RecordWithChanges> const& value) {
  step_index_.set_step_offset("RecordToOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_optional = {};
    if (value.has_value()) {
      record_to_optional = value.value();
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_optional);
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToAliasedOptionalImpl(evo_test::AliasedOptionalRecord const& value) {
  step_index_.set_step_offset("RecordToAliasedOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_optional = {};
    if (value.has_value()) {
      record_to_aliased_optional = value.value();
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_aliased_optional);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToUnionImpl(std::variant<evo_test::RecordWithChanges, std::string> const& value) {
  step_index_.set_step_offset("RecordToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_union = {};
    if (value.index() == 0) {
      record_to_union = std::get<0>(value);
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_union);
    break;
  }
  default:
    WriteUnion<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteRecordToAliasedUnionImpl(evo_test::AliasedRecordOrString const& value) {
  step_index_.set_step_offset("RecordToAliasedUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_union = {};
    if (value.index() == 0) {
      record_to_aliased_union = std::get<0>(value);
    }
    evo_test::binary::WriteRecordWithChanges_v0(stream_, record_to_aliased_union);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionToAliasedUnionImpl(evo_test::AliasedRecordOrInt const& value) {
  step_index_.set_step_offset("UnionToAliasedUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union = {};
    switch (value.index()) {
      case 0: {
        union_to_aliased_union = std::get<0>(value);
        break;
      }
      case 1: {
        union_to_aliased_union = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger>(stream_, union_to_aliased_union);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordOrInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteUnionToAliasedUnionWithChangesImpl(evo_test::AliasedRecordOrString const& value) {
  step_index_.set_step_offset("UnionToAliasedUnionWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union_with_changes = {};
    switch (value.index()) {
      case 0: {
        union_to_aliased_union_with_changes = std::get<0>(value);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "string"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges: RecordWithChanges_v0 | int32'");
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0, int32_t, yardl::binary::WriteInteger>(stream_, union_to_aliased_union_with_changes);
    break;
  }
  default:
    evo_test::binary::WriteAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalToAliasedOptionalImpl(evo_test::AliasedOptionalRecord const& value) {
  step_index_.set_step_offset("OptionalToAliasedOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteOptional<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteOptionalToAliasedOptionalWithChangesImpl(evo_test::AliasedOptionalString const& value) {
  step_index_.set_step_offset("OptionalToAliasedOptionalWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_to_aliased_optional_with_changes = {};
    if (value.has_value()) {
      try {
        optional_to_aliased_optional_with_changes = std::stoi(value.value());
      } catch (...) {
        throw std::runtime_error("Unable to convert string \"" + value.value() + "\" to number");
      }
    }
    yardl::binary::WriteOptional<int32_t, yardl::binary::WriteInteger>(stream_, optional_to_aliased_optional_with_changes);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOptionalString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordImpl(evo_test::GenericRecord<int32_t, std::string> const& value) {
  step_index_.set_step_offset("GenericRecord", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordToOpenAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string> const& value) {
  step_index_.set_step_offset("GenericRecordToOpenAlias", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOpenGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordToClosedAliasImpl(evo_test::AliasedClosedGenericRecord const& value) {
  step_index_.set_step_offset("GenericRecordToClosedAlias", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedClosedGenericRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordToHalfClosedAliasImpl(evo_test::AliasedHalfClosedGenericRecord<int32_t> const& value) {
  step_index_.set_step_offset("GenericRecordToHalfClosedAlias", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedHalfClosedGenericRecord<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAliasedGenericRecordToAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string> const& value) {
  step_index_.set_step_offset("AliasedGenericRecordToAlias", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedHalfClosedGenericRecord_v0<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteAliasedOpenGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordToReversedImpl(evo_test::GenericRecordReversed<std::string, int32_t> const& value) {
  step_index_.set_step_offset("GenericRecordToReversed", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericRecordReversed<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteClosedGenericRecordToUnionImpl(std::variant<evo_test::GenericRecord<int32_t, std::string>, std::string> const& value) {
  step_index_.set_step_offset("ClosedGenericRecordToUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> closed_generic_record_to_union = {};
    if (value.index() == 0) {
      closed_generic_record_to_union = std::get<0>(value);
    }
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, closed_generic_record_to_union);
    break;
  }
  default:
    WriteUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, std::string, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordToAliasedUnionImpl(evo_test::AliasedGenericRecordOrString const& value) {
  step_index_.set_step_offset("GenericRecordToAliasedUnion", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> generic_record_to_aliased_union = {};
    if (value.index() == 0) {
      generic_record_to_aliased_union = std::get<0>(value);
    }
    evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>(stream_, generic_record_to_aliased_union);
    break;
  }
  default:
    evo_test::binary::WriteAliasedGenericRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericUnionToReversedImpl(evo_test::GenericUnionReversed<float, evo_test::GenericRecord<int32_t, std::string>> const& value) {
  step_index_.set_step_offset("GenericUnionToReversed", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::GenericRecord_v0<int32_t, std::string>, float> generic_union_to_reversed = {};
    switch (value.index()) {
      case 0: {
        generic_union_to_reversed = std::get<0>(value);
        break;
      }
      case 1: {
        generic_union_to_reversed = std::get<1>(value);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    WriteUnion<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, float, yardl::binary::WriteFloatingPoint>(stream_, generic_union_to_reversed);
    break;
  }
  default:
    evo_test::binary::WriteGenericUnionReversed<float, yardl::binary::WriteFloatingPoint, evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericUnionOfChangedRecordImpl(evo_test::GenericUnion<evo_test::GenericRecord<int32_t, std::string>, float> const& value) {
  step_index_.set_step_offset("GenericUnionOfChangedRecord", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteAliasedClosedGenericUnion_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::WriteGenericRecord<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>, float, yardl::binary::WriteFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericParentRecordImpl(evo_test::GenericParentRecord<int32_t> const& value) {
  step_index_.set_step_offset("GenericParentRecord", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericParentRecord_v0<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericParentRecord<int32_t, yardl::binary::WriteInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericNestedRecordsImpl(evo_test::GenericRecord<evo_test::Unchanged, evo_test::Changed> const& value) {
  step_index_.set_step_offset("GenericNestedRecords", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    evo_test::binary::WriteGenericRecord_v0<evo_test::UnchangedGeneric_v0<int32_t>, evo_test::binary::WriteUnchangedGeneric_v0<int32_t, yardl::binary::WriteInteger>, evo_test::ChangedGeneric_v0<std::string, int32_t>, evo_test::binary::WriteChangedGeneric_v0<std::string, yardl::binary::WriteString, int32_t, yardl::binary::WriteInteger>>(stream_, value);
    break;
  }
  default:
    evo_test::binary::WriteGenericRecord<evo_test::Unchanged, evo_test::binary::WriteUnchanged, evo_test::Changed, evo_test::binary::WriteChanged>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordStreamImpl(evo_test::AliasedClosedGenericRecord const& value) {
  step_index_.set_step_offset("GenericRecordStream", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlockAndSaveOffset<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, value, item_offset);
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<evo_test::AliasedClosedGenericRecord, evo_test::binary::WriteAliasedClosedGenericRecord>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("GenericRecordStream", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteGenericRecordStreamImpl(std::vector<evo_test::AliasedClosedGenericRecord> const& values) {
  step_index_.set_step_offset("GenericRecordStream", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::WriteGenericRecord_v0<int32_t, yardl::binary::WriteInteger, std::string, yardl::binary::WriteString>>(stream_, values, item_offsets);
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::AliasedClosedGenericRecord, evo_test::binary::WriteAliasedClosedGenericRecord>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("GenericRecordStream", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndGenericRecordStreamImpl() {
  step_index_.set_step_offset("GenericRecordStream", stream_.Pos());
  step_index_.add_stream_offsets("GenericRecordStream", std::vector<size_t>{});
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteGenericParentRecordStreamImpl(evo_test::GenericParentRecord<int32_t> const& value) {
  step_index_.set_step_offset("GenericParentRecordStream", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlockAndSaveOffset<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::WriteGenericParentRecord_v0<int32_t, yardl::binary::WriteInteger>>(stream_, value, item_offset);
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<evo_test::GenericParentRecord<int32_t>, evo_test::binary::WriteGenericParentRecord<int32_t, yardl::binary::WriteInteger>>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("GenericParentRecordStream", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteGenericParentRecordStreamImpl(std::vector<evo_test::GenericParentRecord<int32_t>> const& values) {
  step_index_.set_step_offset("GenericParentRecordStream", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::WriteGenericParentRecord_v0<int32_t, yardl::binary::WriteInteger>>(stream_, values, item_offsets);
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::GenericParentRecord<int32_t>, evo_test::binary::WriteGenericParentRecord<int32_t, yardl::binary::WriteInteger>>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("GenericParentRecordStream", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndGenericParentRecordStreamImpl() {
  step_index_.set_step_offset("GenericParentRecordStream", stream_.Pos());
  step_index_.add_stream_offsets("GenericParentRecordStream", std::vector<size_t>{});
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteVectorRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges> const& value) {
  step_index_.set_step_offset("VectorRecordWithChanges", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteVector<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::WriteVector<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteStreamedRecordWithChangesImpl(evo_test::RecordWithChanges const& value) {
  step_index_.set_step_offset("StreamedRecordWithChanges", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    yardl::binary::WriteBlockAndSaveOffset<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, value, item_offset);
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("StreamedRecordWithChanges", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteStreamedRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges> const& values) {
  step_index_.set_step_offset("StreamedRecordWithChanges", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::RecordWithChanges_v0, evo_test::binary::WriteRecordWithChanges_v0>(stream_, values, item_offsets);
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("StreamedRecordWithChanges", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndStreamedRecordWithChangesImpl() {
  step_index_.set_step_offset("StreamedRecordWithChanges", stream_.Pos());
  step_index_.add_stream_offsets("StreamedRecordWithChanges", std::vector<size_t>{});
  switch (version_) {
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAddedOptionalImpl(std::optional<evo_test::RecordWithChanges> const& value) {
  step_index_.set_step_offset("AddedOptional", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteOptional<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAddedMapImpl(std::unordered_map<std::string, std::string> const& value) {
  step_index_.set_step_offset("AddedMap", stream_.Pos());
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteMap<std::string, std::string, yardl::binary::WriteString, yardl::binary::WriteString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::WriteAddedRecordStreamImpl(evo_test::RecordWithChanges const& value) {
  step_index_.set_step_offset("AddedRecordStream", stream_.Pos());
  size_t item_offset = 0;
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteBlockAndSaveOffset<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, value, item_offset);
    break;
  }
  step_index_.add_stream_offset("AddedRecordStream", item_offset);
}

void ProtocolWithChangesIndexedWriter::WriteAddedRecordStreamImpl(std::vector<evo_test::RecordWithChanges> const& values) {
  step_index_.set_step_offset("AddedRecordStream", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    switch (version_) {
    case Version::v0: {
      break;
    }
    default:
      yardl::binary::WriteVectorAndSaveOffsets<evo_test::RecordWithChanges, evo_test::binary::WriteRecordWithChanges>(stream_, values, item_offsets);
      break;
    }
  }
  step_index_.add_stream_offsets("AddedRecordStream", item_offsets);
}

void ProtocolWithChangesIndexedWriter::EndAddedRecordStreamImpl() {
  step_index_.set_step_offset("AddedRecordStream", stream_.Pos());
  step_index_.add_stream_offsets("AddedRecordStream", std::vector<size_t>{});
  switch (version_) {
  case Version::v0: {
    break;
  }
  default:
    yardl::binary::WriteInteger(stream_, 0U);
    break;
  }
}

void ProtocolWithChangesIndexedWriter::Flush() {
  stream_.Flush();
}

void ProtocolWithChangesIndexedWriter::CloseImpl() {
  yardl::binary::WriteIndex(stream_, step_index_);
  stream_.Flush();
}

void ProtocolWithChangesIndexedReader::ReadInt8ToIntImpl(int32_t& value) {
  auto pos = step_index_.get_step_offset("Int8ToInt");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_int = {};
    yardl::binary::ReadInteger(stream_, int8_to_int);
    value = static_cast<int32_t>(int8_to_int);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadInt8ToLongImpl(int64_t& value) {
  auto pos = step_index_.get_step_offset("Int8ToLong");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_long = {};
    yardl::binary::ReadInteger(stream_, int8_to_long);
    value = static_cast<int64_t>(int8_to_long);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadInt8ToUintImpl(uint32_t& value) {
  auto pos = step_index_.get_step_offset("Int8ToUint");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_uint = {};
    yardl::binary::ReadInteger(stream_, int8_to_uint);
    if (int8_to_uint < 0) {
      throw std::runtime_error("Numeric overflow detected while converting 'int8' to 'uint32'");
    }
    value = static_cast<uint32_t>(int8_to_uint);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadInt8ToUlongImpl(uint64_t& value) {
  auto pos = step_index_.get_step_offset("Int8ToUlong");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_ulong = {};
    yardl::binary::ReadInteger(stream_, int8_to_ulong);
    if (int8_to_ulong < 0) {
      throw std::runtime_error("Numeric overflow detected while converting 'int8' to 'uint64'");
    }
    value = static_cast<uint64_t>(int8_to_ulong);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadInt8ToFloatImpl(float& value) {
  auto pos = step_index_.get_step_offset("Int8ToFloat");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_float = {};
    yardl::binary::ReadInteger(stream_, int8_to_float);
    value = static_cast<float>(int8_to_float);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadInt8ToDoubleImpl(double& value) {
  auto pos = step_index_.get_step_offset("Int8ToDouble");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int8_t int8_to_double = {};
    yardl::binary::ReadInteger(stream_, int8_to_double);
    value = static_cast<double>(int8_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToUintImpl(uint32_t& value) {
  auto pos = step_index_.get_step_offset("IntToUint");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_uint = {};
    yardl::binary::ReadInteger(stream_, int_to_uint);
    if (int_to_uint < 0) {
      throw std::runtime_error("Numeric overflow detected while converting 'int32' to 'uint32'");
    }
    value = static_cast<uint32_t>(int_to_uint);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToLongImpl(int64_t& value) {
  auto pos = step_index_.get_step_offset("IntToLong");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_long = {};
    yardl::binary::ReadInteger(stream_, int_to_long);
    value = static_cast<int64_t>(int_to_long);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToFloatImpl(float& value) {
  auto pos = step_index_.get_step_offset("IntToFloat");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_float = {};
    yardl::binary::ReadInteger(stream_, int_to_float);
    value = static_cast<float>(int_to_float);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToDoubleImpl(double& value) {
  auto pos = step_index_.get_step_offset("IntToDouble");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_double = {};
    yardl::binary::ReadInteger(stream_, int_to_double);
    value = static_cast<double>(int_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUintToUlongImpl(uint64_t& value) {
  auto pos = step_index_.get_step_offset("UintToUlong");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_ulong = {};
    yardl::binary::ReadInteger(stream_, uint_to_ulong);
    value = static_cast<uint64_t>(uint_to_ulong);
    break;
  }
  default:
    yardl::binary::ReadInteger(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUintToFloatImpl(float& value) {
  auto pos = step_index_.get_step_offset("UintToFloat");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_float = {};
    yardl::binary::ReadInteger(stream_, uint_to_float);
    value = static_cast<float>(uint_to_float);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUintToDoubleImpl(double& value) {
  auto pos = step_index_.get_step_offset("UintToDouble");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_double = {};
    yardl::binary::ReadInteger(stream_, uint_to_double);
    value = static_cast<double>(uint_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadFloatToDoubleImpl(double& value) {
  auto pos = step_index_.get_step_offset("FloatToDouble");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    float float_to_double = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_double);
    value = static_cast<double>(float_to_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadComplexFloatToComplexDoubleImpl(std::complex<double>& value) {
  auto pos = step_index_.get_step_offset("ComplexFloatToComplexDouble");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::complex<float> complex_float_to_complex_double = {};
    yardl::binary::ReadFloatingPoint(stream_, complex_float_to_complex_double);
    value = std::complex<double>(complex_float_to_complex_double);
    break;
  }
  default:
    yardl::binary::ReadFloatingPoint(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToStringImpl(std::string& value) {
  auto pos = step_index_.get_step_offset("IntToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_string = {};
    yardl::binary::ReadInteger(stream_, int_to_string);
    value = std::to_string(int_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUintToStringImpl(std::string& value) {
  auto pos = step_index_.get_step_offset("UintToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    uint32_t uint_to_string = {};
    yardl::binary::ReadInteger(stream_, uint_to_string);
    value = std::to_string(uint_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadLongToStringImpl(std::string& value) {
  auto pos = step_index_.get_step_offset("LongToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int64_t long_to_string = {};
    yardl::binary::ReadInteger(stream_, long_to_string);
    value = std::to_string(long_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUlongToStringImpl(std::string& value) {
  auto pos = step_index_.get_step_offset("UlongToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    uint64_t ulong_to_string = {};
    yardl::binary::ReadInteger(stream_, ulong_to_string);
    value = std::to_string(ulong_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadFloatToStringImpl(std::string& value) {
  auto pos = step_index_.get_step_offset("FloatToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    float float_to_string = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_string);
    value = std::to_string(float_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadDoubleToStringImpl(std::string& value) {
  auto pos = step_index_.get_step_offset("DoubleToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    double double_to_string = {};
    yardl::binary::ReadFloatingPoint(stream_, double_to_string);
    value = std::to_string(double_to_string);
    break;
  }
  default:
    yardl::binary::ReadString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToOptionalImpl(std::optional<int32_t>& value) {
  auto pos = step_index_.get_step_offset("IntToOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_optional = {};
    yardl::binary::ReadInteger(stream_, int_to_optional);
    value = int_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadFloatToOptionalImpl(std::optional<float>& value) {
  auto pos = step_index_.get_step_offset("FloatToOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    float float_to_optional = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_optional);
    value = float_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadStringToOptionalImpl(std::optional<std::string>& value) {
  auto pos = step_index_.get_step_offset("StringToOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::string string_to_optional = {};
    yardl::binary::ReadString(stream_, string_to_optional);
    value = string_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntToUnionImpl(std::variant<int32_t, bool>& value) {
  auto pos = step_index_.get_step_offset("IntToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union = {};
    yardl::binary::ReadInteger(stream_, int_to_union);
    value = int_to_union;
    break;
  }
  default:
    ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadFloatToUnionImpl(std::variant<float, bool>& value) {
  auto pos = step_index_.get_step_offset("FloatToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    float float_to_union = {};
    yardl::binary::ReadFloatingPoint(stream_, float_to_union);
    value = float_to_union;
    break;
  }
  default:
    ReadUnion<float, yardl::binary::ReadFloatingPoint, bool, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadStringToUnionImpl(std::variant<std::string, bool>& value) {
  auto pos = step_index_.get_step_offset("StringToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::string string_to_union = {};
    yardl::binary::ReadString(stream_, string_to_union);
    value = string_to_union;
    break;
  }
  default:
    ReadUnion<std::string, yardl::binary::ReadString, bool, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalIntToFloatImpl(std::optional<float>& value) {
  auto pos = step_index_.get_step_offset("OptionalIntToFloat");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_float = {};
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, optional_int_to_float);
    if (optional_int_to_float.has_value()) {
      value = static_cast<float>(optional_int_to_float.value());
    }
    break;
  }
  default:
    yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalFloatToStringImpl(std::optional<std::string>& value) {
  auto pos = step_index_.get_step_offset("OptionalFloatToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::optional<float> optional_float_to_string = {};
    yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream_, optional_float_to_string);
    if (optional_float_to_string.has_value()) {
      value = std::to_string(optional_float_to_string.value());
    }
    break;
  }
  default:
    yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadAliasedLongToStringImpl(evo_test::AliasedLongToString& value) {
  auto pos = step_index_.get_step_offset("AliasedLongToString");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedLongToString_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedLongToString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadStringToAliasedStringImpl(evo_test::AliasedString& value) {
  auto pos = step_index_.get_step_offset("StringToAliasedString");
  stream_.Seek(pos);
  evo_test::binary::ReadAliasedString(stream_, value);
}

void ProtocolWithChangesIndexedReader::ReadStringToAliasedIntImpl(evo_test::AliasedInt& value) {
  auto pos = step_index_.get_step_offset("StringToAliasedInt");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::string string_to_aliased_int = {};
    yardl::binary::ReadString(stream_, string_to_aliased_int);
    try {
      value = std::stoi(string_to_aliased_int);
    } catch (...) {
      throw std::runtime_error("Unable to convert string \"" + string_to_aliased_int + "\" to number");
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadEnumToAliasedEnumImpl(evo_test::AliasedEnum& value) {
  auto pos = step_index_.get_step_offset("EnumToAliasedEnum");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadEnum<evo_test::GrowingEnum_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedEnum(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalIntToUnionImpl(std::variant<std::monostate, int32_t, std::string>& value) {
  auto pos = step_index_.get_step_offset("OptionalIntToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_int_to_union = {};
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, optional_int_to_union);
    if (optional_int_to_union.has_value()) {
      value = optional_int_to_union.value();
    } else {
      value = std::monostate{};
    }
    break;
  }
  default:
    ReadUnion<std::monostate, yardl::binary::ReadMonostate, int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalRecordToUnionImpl(std::variant<std::monostate, evo_test::RecordWithChanges, std::string>& value) {
  auto pos = step_index_.get_step_offset("OptionalRecordToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::optional<evo_test::RecordWithChanges_v0> optional_record_to_union = {};
    yardl::binary::ReadOptional<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, optional_record_to_union);
    if (optional_record_to_union.has_value()) {
      value = optional_record_to_union.value();
    } else {
      value = std::monostate{};
    }
    break;
  }
  default:
    ReadUnion<std::monostate, yardl::binary::ReadMonostate, evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordWithChangesImpl(evo_test::RecordWithChanges& value) {
  auto pos = step_index_.get_step_offset("RecordWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadAliasedRecordWithChangesImpl(evo_test::AliasedRecordWithChanges& value) {
  auto pos = step_index_.get_step_offset("AliasedRecordWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToRenamedRecordImpl(evo_test::RenamedRecord& value) {
  auto pos = step_index_.get_step_offset("RecordToRenamedRecord");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRenamedRecord_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRenamedRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToAliasedRecordImpl(evo_test::AliasedRecordWithChanges& value) {
  auto pos = step_index_.get_step_offset("RecordToAliasedRecord");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordWithChanges(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToAliasedAliasImpl(evo_test::AliasOfAliasedRecordWithChanges& value) {
  auto pos = step_index_.get_step_offset("RecordToAliasedAlias");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRecordWithChanges_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasOfAliasedRecordWithChanges(stream_, value);
    break;
  }
}

bool ProtocolWithChangesIndexedReader::ReadStreamIntToStringToFloatImpl(std::string& value) {
  if (!step_index_.offset_within_stream("StreamIntToStringToFloat", "VectorIntToStringToFloat", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamIntToStringToFloat"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    int32_t stream_int_to_string_to_float = {};
    read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, stream_int_to_string_to_float);
    if (read_block_successful) {
      value = std::to_string(stream_int_to_string_to_float);
    }
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::string, yardl::binary::ReadString>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamIntToStringToFloatImpl(std::vector<std::string>& values) {
  if (!step_index_.offset_within_stream("StreamIntToStringToFloat", "VectorIntToStringToFloat", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamIntToStringToFloat"));
  }
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> stream_int_to_string_to_float = {};
    stream_int_to_string_to_float.reserve(values.capacity());
    yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, stream_int_to_string_to_float);
    values.resize(stream_int_to_string_to_float.size());
    for (size_t i = 0; i < stream_int_to_string_to_float.size(); i++) {
      std::string item = {};
      item = std::to_string(stream_int_to_string_to_float[i]);
      values[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::string, yardl::binary::ReadString>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadStreamIntToStringToFloatImpl(std::string& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamIntToStringToFloat", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    int32_t stream_int_to_string_to_float = {};
    read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, stream_int_to_string_to_float);
    if (read_block_successful) {
      value = std::to_string(stream_int_to_string_to_float);
    }
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::string, yardl::binary::ReadString>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamIntToStringToFloatImpl(std::vector<std::string>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamIntToStringToFloat", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> stream_int_to_string_to_float = {};
    stream_int_to_string_to_float.reserve(values.capacity());
    yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, stream_int_to_string_to_float);
    values.resize(stream_int_to_string_to_float.size());
    for (size_t i = 0; i < stream_int_to_string_to_float.size(); i++) {
      std::string item = {};
      item = std::to_string(stream_int_to_string_to_float[i]);
      values[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::string, yardl::binary::ReadString>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountStreamIntToStringToFloatImpl() {
  return step_index_.get_stream_count("StreamIntToStringToFloat");
}

void ProtocolWithChangesIndexedReader::ReadVectorIntToStringToFloatImpl(std::vector<std::string>& value) {
  auto pos = step_index_.get_step_offset("VectorIntToStringToFloat");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::vector<int32_t> vector_int_to_string_to_float = {};
    yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream_, vector_int_to_string_to_float);
    value.resize(vector_int_to_string_to_float.size());
    for (size_t i = 0; i < vector_int_to_string_to_float.size(); i++) {
      std::string item = {};
      item = std::to_string(vector_int_to_string_to_float[i]);
      value[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadVector<std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadIntFloatUnionReorderedImpl(std::variant<float, int32_t>& value) {
  auto pos = step_index_.get_step_offset("IntFloatUnionReordered");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, float> int_float_union_reordered = {};
    ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>(stream_, int_float_union_reordered);
    switch (int_float_union_reordered.index()) {
      case 0: {
        value = std::get<0>(int_float_union_reordered);
        break;
      }
      case 1: {
        value = std::get<1>(int_float_union_reordered);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<float, yardl::binary::ReadFloatingPoint, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadVectorUnionReorderedImpl(std::vector<std::variant<float, int32_t>>& value) {
  auto pos = step_index_.get_step_offset("VectorUnionReordered");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, float>> vector_union_reordered = {};
    yardl::binary::ReadVector<std::variant<int32_t, float>, ReadUnion<int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint>>(stream_, vector_union_reordered);
    value.resize(vector_union_reordered.size());
    for (size_t i = 0; i < vector_union_reordered.size(); i++) {
      std::variant<float, int32_t> item = {};
      switch (vector_union_reordered[i].index()) {
        case 0: {
          item = std::get<0>(vector_union_reordered[i]);
          break;
        }
        case 1: {
          item = std::get<1>(vector_union_reordered[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      value[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadVector<std::variant<float, int32_t>, ReadUnion<float, yardl::binary::ReadFloatingPoint, int32_t, yardl::binary::ReadInteger>>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesIndexedReader::ReadStreamUnionReorderedImpl(std::variant<std::string, int32_t>& value) {
  if (!step_index_.offset_within_stream("StreamUnionReordered", "IntToUnionStream", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamUnionReordered"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, std::string> stream_union_reordered = {};
    read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, std::string>, ReadUnion<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, stream_union_reordered);
    if (read_block_successful) {
      switch (stream_union_reordered.index()) {
        case 0: {
          value = std::get<0>(stream_union_reordered);
          break;
        }
        case 1: {
          value = std::get<1>(stream_union_reordered);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
    }
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::variant<std::string, int32_t>, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamUnionReorderedImpl(std::vector<std::variant<std::string, int32_t>>& values) {
  if (!step_index_.offset_within_stream("StreamUnionReordered", "IntToUnionStream", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamUnionReordered"));
  }
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, std::string>> stream_union_reordered = {};
    stream_union_reordered.reserve(values.capacity());
    yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, std::string>, ReadUnion<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, stream_union_reordered);
    values.resize(stream_union_reordered.size());
    for (size_t i = 0; i < stream_union_reordered.size(); i++) {
      std::variant<std::string, int32_t> item = {};
      switch (stream_union_reordered[i].index()) {
        case 0: {
          item = std::get<0>(stream_union_reordered[i]);
          break;
        }
        case 1: {
          item = std::get<1>(stream_union_reordered[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      values[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::variant<std::string, int32_t>, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadStreamUnionReorderedImpl(std::variant<std::string, int32_t>& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamUnionReordered", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, std::string> stream_union_reordered = {};
    read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, std::string>, ReadUnion<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, stream_union_reordered);
    if (read_block_successful) {
      switch (stream_union_reordered.index()) {
        case 0: {
          value = std::get<0>(stream_union_reordered);
          break;
        }
        case 1: {
          value = std::get<1>(stream_union_reordered);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
    }
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::variant<std::string, int32_t>, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamUnionReorderedImpl(std::vector<std::variant<std::string, int32_t>>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamUnionReordered", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    std::vector<std::variant<int32_t, std::string>> stream_union_reordered = {};
    stream_union_reordered.reserve(values.capacity());
    yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, std::string>, ReadUnion<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, stream_union_reordered);
    values.resize(stream_union_reordered.size());
    for (size_t i = 0; i < stream_union_reordered.size(); i++) {
      std::variant<std::string, int32_t> item = {};
      switch (stream_union_reordered[i].index()) {
        case 0: {
          item = std::get<0>(stream_union_reordered[i]);
          break;
        }
        case 1: {
          item = std::get<1>(stream_union_reordered[i]);
          break;
        }
        default: throw std::runtime_error("Invalid union index.");
      }
      values[i] = item;
    }
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::variant<std::string, int32_t>, ReadUnion<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountStreamUnionReorderedImpl() {
  return step_index_.get_stream_count("StreamUnionReordered");
}

bool ProtocolWithChangesIndexedReader::ReadIntToUnionStreamImpl(int32_t& value) {
  if (!step_index_.offset_within_stream("IntToUnionStream", "UnionStreamTypeChange", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("IntToUnionStream"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union_stream = {};
    value = std::move(int_to_union_stream);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadIntToUnionStreamImpl(std::vector<int32_t>& values) {
  if (!step_index_.offset_within_stream("IntToUnionStream", "UnionStreamTypeChange", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("IntToUnionStream"));
  }
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadIntToUnionStreamImpl(int32_t& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("IntToUnionStream", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    int32_t int_to_union_stream = {};
    value = std::move(int_to_union_stream);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadIntToUnionStreamImpl(std::vector<int32_t>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("IntToUnionStream", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<int32_t, yardl::binary::ReadInteger>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountIntToUnionStreamImpl() {
  return step_index_.get_stream_count("IntToUnionStream");
}

bool ProtocolWithChangesIndexedReader::ReadUnionStreamTypeChangeImpl(std::variant<int32_t, bool>& value) {
  if (!step_index_.offset_within_stream("UnionStreamTypeChange", "StreamOfAliasTypeChange", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("UnionStreamTypeChange"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, bool> union_stream_type_change = {};
    value = std::move(union_stream_type_change);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, bool>, ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadUnionStreamTypeChangeImpl(std::vector<std::variant<int32_t, bool>>& values) {
  if (!step_index_.offset_within_stream("UnionStreamTypeChange", "StreamOfAliasTypeChange", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("UnionStreamTypeChange"));
  }
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, bool>, ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadUnionStreamTypeChangeImpl(std::variant<int32_t, bool>& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("UnionStreamTypeChange", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    std::variant<int32_t, bool> union_stream_type_change = {};
    value = std::move(union_stream_type_change);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<std::variant<int32_t, bool>, ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadUnionStreamTypeChangeImpl(std::vector<std::variant<int32_t, bool>>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("UnionStreamTypeChange", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<std::variant<int32_t, bool>, ReadUnion<int32_t, yardl::binary::ReadInteger, bool, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountUnionStreamTypeChangeImpl() {
  return step_index_.get_stream_count("UnionStreamTypeChange");
}

bool ProtocolWithChangesIndexedReader::ReadStreamOfAliasTypeChangeImpl(evo_test::StreamItem& value) {
  if (!step_index_.offset_within_stream("StreamOfAliasTypeChange", "Rlink", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamOfAliasTypeChange"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::StreamItem_v0, evo_test::binary::ReadStreamItem_v0>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::StreamItem, evo_test::binary::ReadStreamItem>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamOfAliasTypeChangeImpl(std::vector<evo_test::StreamItem>& values) {
  if (!step_index_.offset_within_stream("StreamOfAliasTypeChange", "Rlink", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamOfAliasTypeChange"));
  }
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::StreamItem_v0, evo_test::binary::ReadStreamItem_v0>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::StreamItem, evo_test::binary::ReadStreamItem>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadStreamOfAliasTypeChangeImpl(evo_test::StreamItem& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamOfAliasTypeChange", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::StreamItem_v0, evo_test::binary::ReadStreamItem_v0>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::StreamItem, evo_test::binary::ReadStreamItem>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamOfAliasTypeChangeImpl(std::vector<evo_test::StreamItem>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamOfAliasTypeChange", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::StreamItem_v0, evo_test::binary::ReadStreamItem_v0>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::StreamItem, evo_test::binary::ReadStreamItem>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountStreamOfAliasTypeChangeImpl() {
  return step_index_.get_stream_count("StreamOfAliasTypeChange");
}

void ProtocolWithChangesIndexedReader::ReadRlinkImpl(evo_test::RLink& value) {
  auto pos = step_index_.get_step_offset("Rlink");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRlinkRXImpl(evo_test::RX& value) {
  auto pos = step_index_.get_step_offset("RlinkRX");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRlinkRYImpl(evo_test::RY& value) {
  auto pos = step_index_.get_step_offset("RlinkRY");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRlinkRZImpl(evo_test::RZ& value) {
  auto pos = step_index_.get_step_offset("RlinkRZ");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRaRLinkImpl(evo_test::RLink& value) {
  auto pos = step_index_.get_step_offset("RaRLink");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRaRXImpl(evo_test::RX& value) {
  auto pos = step_index_.get_step_offset("RaRX");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRaRYImpl(evo_test::RY& value) {
  auto pos = step_index_.get_step_offset("RaRY");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRaRZImpl(evo_test::RZ& value) {
  auto pos = step_index_.get_step_offset("RaRZ");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRbRLinkImpl(evo_test::RLink& value) {
  auto pos = step_index_.get_step_offset("RbRLink");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRbRXImpl(evo_test::RX& value) {
  auto pos = step_index_.get_step_offset("RbRX");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRbRYImpl(evo_test::RY& value) {
  auto pos = step_index_.get_step_offset("RbRY");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRbRZImpl(evo_test::RZ& value) {
  auto pos = step_index_.get_step_offset("RbRZ");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRcRLinkImpl(evo_test::RLink& value) {
  auto pos = step_index_.get_step_offset("RcRLink");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRLink(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRcRXImpl(evo_test::RX& value) {
  auto pos = step_index_.get_step_offset("RcRX");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRX(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRcRYImpl(evo_test::RY& value) {
  auto pos = step_index_.get_step_offset("RcRY");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRY(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRcRZImpl(evo_test::RZ& value) {
  auto pos = step_index_.get_step_offset("RcRZ");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRZ(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRlinkRNewImpl(evo_test::RNew& value) {
  auto pos = step_index_.get_step_offset("RlinkRNew");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRLink_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRaRNewImpl(evo_test::RNew& value) {
  auto pos = step_index_.get_step_offset("RaRNew");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRA_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRbRNewImpl(evo_test::RNew& value) {
  auto pos = step_index_.get_step_offset("RbRNew");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRB_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRcRNewImpl(evo_test::RNew& value) {
  auto pos = step_index_.get_step_offset("RcRNew");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadRC_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadRNew(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRlinkRUnionImpl(evo_test::RUnion& value) {
  auto pos = step_index_.get_step_offset("RlinkRUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rlink_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, rlink_r_union);
    value = rlink_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRaRUnionImpl(evo_test::RUnion& value) {
  auto pos = step_index_.get_step_offset("RaRUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 ra_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, ra_r_union);
    value = ra_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRbRUnionImpl(evo_test::RUnion& value) {
  auto pos = step_index_.get_step_offset("RbRUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rb_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, rb_r_union);
    value = rb_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRcRUnionImpl(evo_test::RUnion& value) {
  auto pos = step_index_.get_step_offset("RcRUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RC_v0 rc_r_union = {};
    evo_test::binary::ReadRC_v0(stream_, rc_r_union);
    value = rc_r_union;
    break;
  }
  default:
    evo_test::binary::ReadRUnion(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalRecordWithChangesImpl(std::optional<evo_test::RecordWithChanges>& value) {
  auto pos = step_index_.get_step_offset("OptionalRecordWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadOptional<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadAliasedOptionalRecordWithChangesImpl(std::optional<evo_test::AliasedRecordWithChanges>& value) {
  auto pos = step_index_.get_step_offset("AliasedOptionalRecordWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadOptional<evo_test::AliasedRecordWithChanges_v0, evo_test::binary::ReadAliasedRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::AliasedRecordWithChanges, evo_test::binary::ReadAliasedRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUnionRecordWithChangesImpl(std::variant<evo_test::RecordWithChanges, int32_t>& value) {
  auto pos = step_index_.get_step_offset("UnionRecordWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_record_with_changes = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger>(stream_, union_record_with_changes);
    switch (union_record_with_changes.index()) {
      case 0: {
        value = std::get<0>(union_record_with_changes);
        break;
      }
      case 1: {
        value = std::get<1>(union_record_with_changes);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUnionWithSameTypesetImpl(std::variant<float, evo_test::RecordWithChanges, std::string, int32_t>& value) {
  auto pos = step_index_.get_step_offset("UnionWithSameTypeset");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_same_typeset = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream_, union_with_same_typeset);
    switch (union_with_same_typeset.index()) {
      case 0: {
        value = std::get<0>(union_with_same_typeset);
        break;
      }
      case 1: {
        value = std::get<1>(union_with_same_typeset);
        break;
      }
      case 2: {
        value = std::get<2>(union_with_same_typeset);
        break;
      }
      case 3: {
        value = std::get<3>(union_with_same_typeset);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<float, yardl::binary::ReadFloatingPoint, evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUnionWithTypesAddedImpl(std::variant<evo_test::RecordWithChanges, int32_t, float, std::string>& value) {
  auto pos = step_index_.get_step_offset("UnionWithTypesAdded");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, float> union_with_types_added = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, float, yardl::binary::ReadFloatingPoint>(stream_, union_with_types_added);
    switch (union_with_types_added.index()) {
      case 0: {
        value = std::get<0>(union_with_types_added);
        break;
      }
      case 1: {
        value = std::get<1>(union_with_types_added);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUnionWithTypesRemovedImpl(std::variant<evo_test::RecordWithChanges, std::string>& value) {
  auto pos = step_index_.get_step_offset("UnionWithTypesRemoved");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t, float, std::string> union_with_types_removed = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger, float, yardl::binary::ReadFloatingPoint, std::string, yardl::binary::ReadString>(stream_, union_with_types_removed);
    switch (union_with_types_removed.index()) {
      case 0: {
        value = std::get<0>(union_with_types_removed);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges | string'");
        break;
      }
      case 2: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32", "float32", "string"};
        throw std::runtime_error("Source type '" + source_types[2] + "' incompatible with target union type 'RecordWithChanges | string'");
        break;
      }
      case 3: {
        value = std::get<3>(union_with_types_removed);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToOptionalImpl(std::optional<evo_test::RecordWithChanges>& value) {
  auto pos = step_index_.get_step_offset("RecordToOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_optional = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_optional);
    value = record_to_optional;
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToAliasedOptionalImpl(evo_test::AliasedOptionalRecord& value) {
  auto pos = step_index_.get_step_offset("RecordToAliasedOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_optional = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_aliased_optional);
    value = record_to_aliased_optional;
    break;
  }
  default:
    evo_test::binary::ReadAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToUnionImpl(std::variant<evo_test::RecordWithChanges, std::string>& value) {
  auto pos = step_index_.get_step_offset("RecordToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_union = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_union);
    value = record_to_union;
    break;
  }
  default:
    ReadUnion<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadRecordToAliasedUnionImpl(evo_test::AliasedRecordOrString& value) {
  auto pos = step_index_.get_step_offset("RecordToAliasedUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges_v0 record_to_aliased_union = {};
    evo_test::binary::ReadRecordWithChanges_v0(stream_, record_to_aliased_union);
    value = record_to_aliased_union;
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUnionToAliasedUnionImpl(evo_test::AliasedRecordOrInt& value) {
  auto pos = step_index_.get_step_offset("UnionToAliasedUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger>(stream_, union_to_aliased_union);
    switch (union_to_aliased_union.index()) {
      case 0: {
        value = std::get<0>(union_to_aliased_union);
        break;
      }
      case 1: {
        value = std::get<1>(union_to_aliased_union);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordOrInt(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadUnionToAliasedUnionWithChangesImpl(evo_test::AliasedRecordOrString& value) {
  auto pos = step_index_.get_step_offset("UnionToAliasedUnionWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::RecordWithChanges_v0, int32_t> union_to_aliased_union_with_changes = {};
    ReadUnion<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0, int32_t, yardl::binary::ReadInteger>(stream_, union_to_aliased_union_with_changes);
    switch (union_to_aliased_union_with_changes.index()) {
      case 0: {
        value = std::get<0>(union_to_aliased_union_with_changes);
        break;
      }
      case 1: {
        std::vector<std::string> source_types = {"EvoTest.RecordWithChanges", "int32"};
        throw std::runtime_error("Source type '" + source_types[1] + "' incompatible with target union type 'RecordWithChanges | string'");
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalToAliasedOptionalImpl(evo_test::AliasedOptionalRecord& value) {
  auto pos = step_index_.get_step_offset("OptionalToAliasedOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadOptional<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedOptionalRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadOptionalToAliasedOptionalWithChangesImpl(evo_test::AliasedOptionalString& value) {
  auto pos = step_index_.get_step_offset("OptionalToAliasedOptionalWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::optional<int32_t> optional_to_aliased_optional_with_changes = {};
    yardl::binary::ReadOptional<int32_t, yardl::binary::ReadInteger>(stream_, optional_to_aliased_optional_with_changes);
    if (optional_to_aliased_optional_with_changes.has_value()) {
      value = std::to_string(optional_to_aliased_optional_with_changes.value());
    }
    break;
  }
  default:
    evo_test::binary::ReadAliasedOptionalString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericRecordImpl(evo_test::GenericRecord<int32_t, std::string>& value) {
  auto pos = step_index_.get_step_offset("GenericRecord");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericRecordToOpenAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string>& value) {
  auto pos = step_index_.get_step_offset("GenericRecordToOpenAlias");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedOpenGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericRecordToClosedAliasImpl(evo_test::AliasedClosedGenericRecord& value) {
  auto pos = step_index_.get_step_offset("GenericRecordToClosedAlias");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedClosedGenericRecord(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericRecordToHalfClosedAliasImpl(evo_test::AliasedHalfClosedGenericRecord<int32_t>& value) {
  auto pos = step_index_.get_step_offset("GenericRecordToHalfClosedAlias");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedHalfClosedGenericRecord<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadAliasedGenericRecordToAliasImpl(evo_test::AliasedOpenGenericRecord<int32_t, std::string>& value) {
  auto pos = step_index_.get_step_offset("AliasedGenericRecordToAlias");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedHalfClosedGenericRecord_v0<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadAliasedOpenGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericRecordToReversedImpl(evo_test::GenericRecordReversed<std::string, int32_t>& value) {
  auto pos = step_index_.get_step_offset("GenericRecordToReversed");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericRecordReversed<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadClosedGenericRecordToUnionImpl(std::variant<evo_test::GenericRecord<int32_t, std::string>, std::string>& value) {
  auto pos = step_index_.get_step_offset("ClosedGenericRecordToUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> closed_generic_record_to_union = {};
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, closed_generic_record_to_union);
    value = closed_generic_record_to_union;
    break;
  }
  default:
    ReadUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, std::string, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericRecordToAliasedUnionImpl(evo_test::AliasedGenericRecordOrString& value) {
  auto pos = step_index_.get_step_offset("GenericRecordToAliasedUnion");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::GenericRecord_v0<int32_t, std::string> generic_record_to_aliased_union = {};
    evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>(stream_, generic_record_to_aliased_union);
    value = generic_record_to_aliased_union;
    break;
  }
  default:
    evo_test::binary::ReadAliasedGenericRecordOrString(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericUnionToReversedImpl(evo_test::GenericUnionReversed<float, evo_test::GenericRecord<int32_t, std::string>>& value) {
  auto pos = step_index_.get_step_offset("GenericUnionToReversed");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::variant<evo_test::GenericRecord_v0<int32_t, std::string>, float> generic_union_to_reversed = {};
    ReadUnion<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, float, yardl::binary::ReadFloatingPoint>(stream_, generic_union_to_reversed);
    switch (generic_union_to_reversed.index()) {
      case 0: {
        value = std::get<0>(generic_union_to_reversed);
        break;
      }
      case 1: {
        value = std::get<1>(generic_union_to_reversed);
        break;
      }
      default: throw std::runtime_error("Invalid union index.");
    }
    break;
  }
  default:
    evo_test::binary::ReadGenericUnionReversed<float, yardl::binary::ReadFloatingPoint, evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericUnionOfChangedRecordImpl(evo_test::GenericUnion<evo_test::GenericRecord<int32_t, std::string>, float>& value) {
  auto pos = step_index_.get_step_offset("GenericUnionOfChangedRecord");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadAliasedClosedGenericUnion_v0(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericUnion<evo_test::GenericRecord<int32_t, std::string>, evo_test::binary::ReadGenericRecord<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>, float, yardl::binary::ReadFloatingPoint>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericParentRecordImpl(evo_test::GenericParentRecord<int32_t>& value) {
  auto pos = step_index_.get_step_offset("GenericParentRecord");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadGenericNestedRecordsImpl(evo_test::GenericRecord<evo_test::Unchanged, evo_test::Changed>& value) {
  auto pos = step_index_.get_step_offset("GenericNestedRecords");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    evo_test::binary::ReadGenericRecord_v0<evo_test::UnchangedGeneric_v0<int32_t>, evo_test::binary::ReadUnchangedGeneric_v0<int32_t, yardl::binary::ReadInteger>, evo_test::ChangedGeneric_v0<std::string, int32_t>, evo_test::binary::ReadChangedGeneric_v0<std::string, yardl::binary::ReadString, int32_t, yardl::binary::ReadInteger>>(stream_, value);
    break;
  }
  default:
    evo_test::binary::ReadGenericRecord<evo_test::Unchanged, evo_test::binary::ReadUnchanged, evo_test::Changed, evo_test::binary::ReadChanged>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesIndexedReader::ReadGenericRecordStreamImpl(evo_test::AliasedClosedGenericRecord& value) {
  if (!step_index_.offset_within_stream("GenericRecordStream", "GenericParentRecordStream", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("GenericRecordStream"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::AliasedClosedGenericRecord, evo_test::binary::ReadAliasedClosedGenericRecord>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadGenericRecordStreamImpl(std::vector<evo_test::AliasedClosedGenericRecord>& values) {
  if (!step_index_.offset_within_stream("GenericRecordStream", "GenericParentRecordStream", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("GenericRecordStream"));
  }
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::AliasedClosedGenericRecord, evo_test::binary::ReadAliasedClosedGenericRecord>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadGenericRecordStreamImpl(evo_test::AliasedClosedGenericRecord& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("GenericRecordStream", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::AliasedClosedGenericRecord, evo_test::binary::ReadAliasedClosedGenericRecord>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadGenericRecordStreamImpl(std::vector<evo_test::AliasedClosedGenericRecord>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("GenericRecordStream", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericRecord_v0<int32_t, std::string>, evo_test::binary::ReadGenericRecord_v0<int32_t, yardl::binary::ReadInteger, std::string, yardl::binary::ReadString>>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::AliasedClosedGenericRecord, evo_test::binary::ReadAliasedClosedGenericRecord>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountGenericRecordStreamImpl() {
  return step_index_.get_stream_count("GenericRecordStream");
}

bool ProtocolWithChangesIndexedReader::ReadGenericParentRecordStreamImpl(evo_test::GenericParentRecord<int32_t>& value) {
  if (!step_index_.offset_within_stream("GenericParentRecordStream", "VectorRecordWithChanges", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("GenericParentRecordStream"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericParentRecord<int32_t>, evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadGenericParentRecordStreamImpl(std::vector<evo_test::GenericParentRecord<int32_t>>& values) {
  if (!step_index_.offset_within_stream("GenericParentRecordStream", "VectorRecordWithChanges", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("GenericParentRecordStream"));
  }
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericParentRecord<int32_t>, evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadGenericParentRecordStreamImpl(evo_test::GenericParentRecord<int32_t>& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("GenericParentRecordStream", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::GenericParentRecord<int32_t>, evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadGenericParentRecordStreamImpl(std::vector<evo_test::GenericParentRecord<int32_t>>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("GenericParentRecordStream", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericParentRecord_v0<int32_t>, evo_test::binary::ReadGenericParentRecord_v0<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::GenericParentRecord<int32_t>, evo_test::binary::ReadGenericParentRecord<int32_t, yardl::binary::ReadInteger>>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountGenericParentRecordStreamImpl() {
  return step_index_.get_stream_count("GenericParentRecordStream");
}

void ProtocolWithChangesIndexedReader::ReadVectorRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges>& value) {
  auto pos = step_index_.get_step_offset("VectorRecordWithChanges");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadVector<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, value);
    break;
  }
  default:
    yardl::binary::ReadVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesIndexedReader::ReadStreamedRecordWithChangesImpl(evo_test::RecordWithChanges& value) {
  if (!step_index_.offset_within_stream("StreamedRecordWithChanges", "AddedOptional", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamedRecordWithChanges"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamedRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges>& values) {
  if (!step_index_.offset_within_stream("StreamedRecordWithChanges", "AddedOptional", stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("StreamedRecordWithChanges"));
  }
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadStreamedRecordWithChangesImpl(evo_test::RecordWithChanges& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamedRecordWithChanges", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, current_block_remaining_, value);
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadStreamedRecordWithChangesImpl(std::vector<evo_test::RecordWithChanges>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("StreamedRecordWithChanges", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges_v0, evo_test::binary::ReadRecordWithChanges_v0>(stream_, current_block_remaining_, values);
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountStreamedRecordWithChangesImpl() {
  return step_index_.get_stream_count("StreamedRecordWithChanges");
}

void ProtocolWithChangesIndexedReader::ReadAddedOptionalImpl(std::optional<evo_test::RecordWithChanges>& value) {
  auto pos = step_index_.get_step_offset("AddedOptional");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::optional<evo_test::RecordWithChanges> added_optional = {};
    value = std::move(added_optional);
    break;
  }
  default:
    yardl::binary::ReadOptional<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, value);
    break;
  }
}

void ProtocolWithChangesIndexedReader::ReadAddedMapImpl(std::unordered_map<std::string, std::string>& value) {
  auto pos = step_index_.get_step_offset("AddedMap");
  stream_.Seek(pos);
  switch (version_) {
  case Version::v0: {
    std::unordered_map<std::string, std::string> added_map = {};
    value = std::move(added_map);
    break;
  }
  default:
    yardl::binary::ReadMap<std::string, std::string, yardl::binary::ReadString, yardl::binary::ReadString>(stream_, value);
    break;
  }
}

bool ProtocolWithChangesIndexedReader::ReadAddedRecordStreamImpl(evo_test::RecordWithChanges& value) {
  if (!step_index_.offset_within_stream("AddedRecordStream", std::nullopt, stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("AddedRecordStream"));
  }
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges added_record_stream = {};
    value = std::move(added_record_stream);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadAddedRecordStreamImpl(std::vector<evo_test::RecordWithChanges>& values) {
  if (!step_index_.offset_within_stream("AddedRecordStream", std::nullopt, stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("AddedRecordStream"));
  }
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

bool ProtocolWithChangesIndexedReader::ReadAddedRecordStreamImpl(evo_test::RecordWithChanges& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("AddedRecordStream", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  switch (version_) {
  case Version::v0: {
    evo_test::RecordWithChanges added_record_stream = {};
    value = std::move(added_record_stream);
    return false;
    break;
  }
  default:
    read_block_successful = yardl::binary::ReadBlock<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, value);
    break;
  }
  return read_block_successful;
}

bool ProtocolWithChangesIndexedReader::ReadAddedRecordStreamImpl(std::vector<evo_test::RecordWithChanges>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("AddedRecordStream", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  switch (version_) {
  case Version::v0: {
    values.clear();
    break;
  }
  default:
    yardl::binary::ReadBlocksIntoVector<evo_test::RecordWithChanges, evo_test::binary::ReadRecordWithChanges>(stream_, current_block_remaining_, values);
    break;
  }
  return current_block_remaining_ != 0;
}

size_t ProtocolWithChangesIndexedReader::CountAddedRecordStreamImpl() {
  return step_index_.get_stream_count("AddedRecordStream");
}

void ProtocolWithChangesIndexedReader::CloseImpl() {
}

void UnusedProtocolWriter::WriteRecordsImpl(evo_test::UnchangedRecord const& value) {
  yardl::binary::WriteBlock<evo_test::UnchangedRecord, evo_test::binary::WriteUnchangedRecord>(stream_, value);
}

void UnusedProtocolWriter::WriteRecordsImpl(std::vector<evo_test::UnchangedRecord> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<evo_test::UnchangedRecord, evo_test::binary::WriteUnchangedRecord>(stream_, values);
  }
}

void UnusedProtocolWriter::EndRecordsImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void UnusedProtocolWriter::Flush() {
  stream_.Flush();
}

void UnusedProtocolWriter::CloseImpl() {
  stream_.Flush();
}

bool UnusedProtocolReader::ReadRecordsImpl(evo_test::UnchangedRecord& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<evo_test::UnchangedRecord, evo_test::binary::ReadUnchangedRecord>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool UnusedProtocolReader::ReadRecordsImpl(std::vector<evo_test::UnchangedRecord>& values) {
  yardl::binary::ReadBlocksIntoVector<evo_test::UnchangedRecord, evo_test::binary::ReadUnchangedRecord>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void UnusedProtocolReader::CloseImpl() {
  stream_.VerifyFinished();
}

void UnusedProtocolIndexedWriter::WriteRecordsImpl(evo_test::UnchangedRecord const& value) {
  step_index_.set_step_offset("Records", stream_.Pos());
  size_t item_offset = 0;
  yardl::binary::WriteBlockAndSaveOffset<evo_test::UnchangedRecord, evo_test::binary::WriteUnchangedRecord>(stream_, value, item_offset);
  step_index_.add_stream_offset("Records", item_offset);
}

void UnusedProtocolIndexedWriter::WriteRecordsImpl(std::vector<evo_test::UnchangedRecord> const& values) {
  step_index_.set_step_offset("Records", stream_.Pos());
  std::vector<size_t> item_offsets;
  item_offsets.reserve(values.size());
  if (!values.empty()) {
    yardl::binary::WriteVectorAndSaveOffsets<evo_test::UnchangedRecord, evo_test::binary::WriteUnchangedRecord>(stream_, values, item_offsets);
  }
  step_index_.add_stream_offsets("Records", item_offsets);
}

void UnusedProtocolIndexedWriter::EndRecordsImpl() {
  step_index_.set_step_offset("Records", stream_.Pos());
  step_index_.add_stream_offsets("Records", std::vector<size_t>{});
  yardl::binary::WriteInteger(stream_, 0U);
}

void UnusedProtocolIndexedWriter::Flush() {
  stream_.Flush();
}

void UnusedProtocolIndexedWriter::CloseImpl() {
  yardl::binary::WriteIndex(stream_, step_index_);
  stream_.Flush();
}

bool UnusedProtocolIndexedReader::ReadRecordsImpl(evo_test::UnchangedRecord& value) {
  if (!step_index_.offset_within_stream("Records", std::nullopt, stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("Records"));
  }
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<evo_test::UnchangedRecord, evo_test::binary::ReadUnchangedRecord>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool UnusedProtocolIndexedReader::ReadRecordsImpl(std::vector<evo_test::UnchangedRecord>& values) {
  if (!step_index_.offset_within_stream("Records", std::nullopt, stream_.Pos())) {
    stream_.Seek(step_index_.get_step_offset("Records"));
  }
  yardl::binary::ReadBlocksIntoVector<evo_test::UnchangedRecord, evo_test::binary::ReadUnchangedRecord>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

bool UnusedProtocolIndexedReader::ReadRecordsImpl(evo_test::UnchangedRecord& value, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("Records", idx, abs_offset, current_block_remaining_)) {
    return false;
  }
  stream_.Seek(abs_offset);
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<evo_test::UnchangedRecord, evo_test::binary::ReadUnchangedRecord>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool UnusedProtocolIndexedReader::ReadRecordsImpl(std::vector<evo_test::UnchangedRecord>& values, size_t idx) {
  size_t abs_offset = 0;
  if (!step_index_.find_stream_item("Records", idx, abs_offset, current_block_remaining_)) {
    values.clear();
    return false;
  }
  stream_.Seek(abs_offset);
  yardl::binary::ReadBlocksIntoVector<evo_test::UnchangedRecord, evo_test::binary::ReadUnchangedRecord>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

size_t UnusedProtocolIndexedReader::CountRecordsImpl() {
  return step_index_.get_stream_count("Records");
}

void UnusedProtocolIndexedReader::CloseImpl() {
}

} // namespace evo_test::binary

