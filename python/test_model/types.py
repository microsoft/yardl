# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import datetime
import enum
import types
import typing

import numpy as np
import numpy.typing as npt

from . import yardl_types as yardl
from . import _dtypes

from . import tuples
from . import basic_types
from . import image

T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)
T1 = typing.TypeVar("T1")
T1_NP = typing.TypeVar("T1_NP", bound=np.generic)
T2 = typing.TypeVar("T2")
T2_NP = typing.TypeVar("T2_NP", bound=np.generic)
U = typing.TypeVar("U")
U_NP = typing.TypeVar("U_NP", bound=np.generic)
K = typing.TypeVar("K")
K_NP = typing.TypeVar("K_NP", bound=np.generic)
V = typing.TypeVar("V")
V_NP = typing.TypeVar("V_NP", bound=np.generic)
A = typing.TypeVar("A")
A_NP = typing.TypeVar("A_NP", bound=np.generic)
B = typing.TypeVar("B")
B_NP = typing.TypeVar("B_NP", bound=np.generic)
W = typing.TypeVar("W")
W_NP = typing.TypeVar("W_NP", bound=np.generic)


class SmallBenchmarkRecord:
    a: yardl.Float64
    b: yardl.Float32
    c: yardl.Float32

    def __init__(self, *,
        a: yardl.Float64 = 0.0,
        b: yardl.Float32 = 0.0,
        c: yardl.Float32 = 0.0,
    ):
        self.a = a
        self.b = b
        self.c = c

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SmallBenchmarkRecord)
            and self.a == other.a
            and self.b == other.b
            and self.c == other.c
        )

    def __str__(self) -> str:
        return f"SmallBenchmarkRecord(a={self.a}, b={self.b}, c={self.c})"

    def __repr__(self) -> str:
        return f"SmallBenchmarkRecord(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)})"


class SimpleEncodingCounters:
    e1: typing.Optional[yardl.UInt32]
    e2: typing.Optional[yardl.UInt32]
    slice: typing.Optional[yardl.UInt32]
    repetition: typing.Optional[yardl.UInt32]

    def __init__(self, *,
        e1: typing.Optional[yardl.UInt32] = None,
        e2: typing.Optional[yardl.UInt32] = None,
        slice: typing.Optional[yardl.UInt32] = None,
        repetition: typing.Optional[yardl.UInt32] = None,
    ):
        self.e1 = e1
        self.e2 = e2
        self.slice = slice
        self.repetition = repetition

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SimpleEncodingCounters)
            and self.e1 == other.e1
            and self.e2 == other.e2
            and self.slice == other.slice
            and self.repetition == other.repetition
        )

    def __str__(self) -> str:
        return f"SimpleEncodingCounters(e1={self.e1}, e2={self.e2}, slice={self.slice}, repetition={self.repetition})"

    def __repr__(self) -> str:
        return f"SimpleEncodingCounters(e1={repr(self.e1)}, e2={repr(self.e2)}, slice={repr(self.slice)}, repetition={repr(self.repetition)})"


class SimpleAcquisition:
    flags: yardl.UInt64
    idx: SimpleEncodingCounters
    data: npt.NDArray[np.complex64]
    trajectory: npt.NDArray[np.float32]

    def __init__(self, *,
        flags: yardl.UInt64 = 0,
        idx: typing.Optional[SimpleEncodingCounters] = None,
        data: typing.Optional[npt.NDArray[np.complex64]] = None,
        trajectory: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.flags = flags
        self.idx = idx if idx is not None else SimpleEncodingCounters()
        self.data = data if data is not None else np.zeros((0, 0), dtype=np.dtype(np.complex64))
        self.trajectory = trajectory if trajectory is not None else np.zeros((0, 0), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SimpleAcquisition)
            and self.flags == other.flags
            and self.idx == other.idx
            and yardl.structural_equal(self.data, other.data)
            and yardl.structural_equal(self.trajectory, other.trajectory)
        )

    def __str__(self) -> str:
        return f"SimpleAcquisition(flags={self.flags}, idx={self.idx}, data={self.data}, trajectory={self.trajectory})"

    def __repr__(self) -> str:
        return f"SimpleAcquisition(flags={repr(self.flags)}, idx={repr(self.idx)}, data={repr(self.data)}, trajectory={repr(self.trajectory)})"


class SimpleRecord:
    x: yardl.Int32
    y: yardl.Int32
    z: yardl.Int32

    def __init__(self, *,
        x: yardl.Int32 = 0,
        y: yardl.Int32 = 0,
        z: yardl.Int32 = 0,
    ):
        self.x = x
        self.y = y
        self.z = z

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SimpleRecord)
            and self.x == other.x
            and self.y == other.y
            and self.z == other.z
        )

    def __str__(self) -> str:
        return f"SimpleRecord(x={self.x}, y={self.y}, z={self.z})"

    def __repr__(self) -> str:
        return f"SimpleRecord(x={repr(self.x)}, y={repr(self.y)}, z={repr(self.z)})"


class RecordWithPrimitives:
    bool_field: bool
    int8_field: yardl.Int8
    uint8_field: yardl.UInt8
    int16_field: yardl.Int16
    uint16_field: yardl.UInt16
    int32_field: yardl.Int32
    uint32_field: yardl.UInt32
    int64_field: yardl.Int64
    uint64_field: yardl.UInt64
    size_field: yardl.Size
    float32_field: yardl.Float32
    float64_field: yardl.Float64
    complexfloat32_field: yardl.ComplexFloat
    complexfloat64_field: yardl.ComplexDouble
    date_field: datetime.date
    time_field: yardl.Time
    datetime_field: yardl.DateTime

    def __init__(self, *,
        bool_field: bool = False,
        int8_field: yardl.Int8 = 0,
        uint8_field: yardl.UInt8 = 0,
        int16_field: yardl.Int16 = 0,
        uint16_field: yardl.UInt16 = 0,
        int32_field: yardl.Int32 = 0,
        uint32_field: yardl.UInt32 = 0,
        int64_field: yardl.Int64 = 0,
        uint64_field: yardl.UInt64 = 0,
        size_field: yardl.Size = 0,
        float32_field: yardl.Float32 = 0.0,
        float64_field: yardl.Float64 = 0.0,
        complexfloat32_field: yardl.ComplexFloat = 0j,
        complexfloat64_field: yardl.ComplexDouble = 0j,
        date_field: datetime.date = datetime.date(1970, 1, 1),
        time_field: yardl.Time = yardl.Time(),
        datetime_field: yardl.DateTime = yardl.DateTime(),
    ):
        self.bool_field = bool_field
        self.int8_field = int8_field
        self.uint8_field = uint8_field
        self.int16_field = int16_field
        self.uint16_field = uint16_field
        self.int32_field = int32_field
        self.uint32_field = uint32_field
        self.int64_field = int64_field
        self.uint64_field = uint64_field
        self.size_field = size_field
        self.float32_field = float32_field
        self.float64_field = float64_field
        self.complexfloat32_field = complexfloat32_field
        self.complexfloat64_field = complexfloat64_field
        self.date_field = date_field
        self.time_field = time_field
        self.datetime_field = datetime_field

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithPrimitives)
            and self.bool_field == other.bool_field
            and self.int8_field == other.int8_field
            and self.uint8_field == other.uint8_field
            and self.int16_field == other.int16_field
            and self.uint16_field == other.uint16_field
            and self.int32_field == other.int32_field
            and self.uint32_field == other.uint32_field
            and self.int64_field == other.int64_field
            and self.uint64_field == other.uint64_field
            and self.size_field == other.size_field
            and self.float32_field == other.float32_field
            and self.float64_field == other.float64_field
            and self.complexfloat32_field == other.complexfloat32_field
            and self.complexfloat64_field == other.complexfloat64_field
            and self.date_field == other.date_field
            and self.time_field == other.time_field
            and self.datetime_field == other.datetime_field
        )

    def __str__(self) -> str:
        return f"RecordWithPrimitives(boolField={self.bool_field}, int8Field={self.int8_field}, uint8Field={self.uint8_field}, int16Field={self.int16_field}, uint16Field={self.uint16_field}, int32Field={self.int32_field}, uint32Field={self.uint32_field}, int64Field={self.int64_field}, uint64Field={self.uint64_field}, sizeField={self.size_field}, float32Field={self.float32_field}, float64Field={self.float64_field}, complexfloat32Field={self.complexfloat32_field}, complexfloat64Field={self.complexfloat64_field}, dateField={self.date_field}, timeField={self.time_field}, datetimeField={self.datetime_field})"

    def __repr__(self) -> str:
        return f"RecordWithPrimitives(boolField={repr(self.bool_field)}, int8Field={repr(self.int8_field)}, uint8Field={repr(self.uint8_field)}, int16Field={repr(self.int16_field)}, uint16Field={repr(self.uint16_field)}, int32Field={repr(self.int32_field)}, uint32Field={repr(self.uint32_field)}, int64Field={repr(self.int64_field)}, uint64Field={repr(self.uint64_field)}, sizeField={repr(self.size_field)}, float32Field={repr(self.float32_field)}, float64Field={repr(self.float64_field)}, complexfloat32Field={repr(self.complexfloat32_field)}, complexfloat64Field={repr(self.complexfloat64_field)}, dateField={repr(self.date_field)}, timeField={repr(self.time_field)}, datetimeField={repr(self.datetime_field)})"


class RecordWithPrimitiveAliases:
    byte_field: yardl.UInt8
    int_field: yardl.Int32
    uint_field: yardl.UInt32
    long_field: yardl.Int64
    ulong_field: yardl.UInt64
    float_field: yardl.Float32
    double_field: yardl.Float64
    complexfloat_field: yardl.ComplexFloat
    complexdouble_field: yardl.ComplexDouble

    def __init__(self, *,
        byte_field: yardl.UInt8 = 0,
        int_field: yardl.Int32 = 0,
        uint_field: yardl.UInt32 = 0,
        long_field: yardl.Int64 = 0,
        ulong_field: yardl.UInt64 = 0,
        float_field: yardl.Float32 = 0.0,
        double_field: yardl.Float64 = 0.0,
        complexfloat_field: yardl.ComplexFloat = 0j,
        complexdouble_field: yardl.ComplexDouble = 0j,
    ):
        self.byte_field = byte_field
        self.int_field = int_field
        self.uint_field = uint_field
        self.long_field = long_field
        self.ulong_field = ulong_field
        self.float_field = float_field
        self.double_field = double_field
        self.complexfloat_field = complexfloat_field
        self.complexdouble_field = complexdouble_field

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithPrimitiveAliases)
            and self.byte_field == other.byte_field
            and self.int_field == other.int_field
            and self.uint_field == other.uint_field
            and self.long_field == other.long_field
            and self.ulong_field == other.ulong_field
            and self.float_field == other.float_field
            and self.double_field == other.double_field
            and self.complexfloat_field == other.complexfloat_field
            and self.complexdouble_field == other.complexdouble_field
        )

    def __str__(self) -> str:
        return f"RecordWithPrimitiveAliases(byteField={self.byte_field}, intField={self.int_field}, uintField={self.uint_field}, longField={self.long_field}, ulongField={self.ulong_field}, floatField={self.float_field}, doubleField={self.double_field}, complexfloatField={self.complexfloat_field}, complexdoubleField={self.complexdouble_field})"

    def __repr__(self) -> str:
        return f"RecordWithPrimitiveAliases(byteField={repr(self.byte_field)}, intField={repr(self.int_field)}, uintField={repr(self.uint_field)}, longField={repr(self.long_field)}, ulongField={repr(self.ulong_field)}, floatField={repr(self.float_field)}, doubleField={repr(self.double_field)}, complexfloatField={repr(self.complexfloat_field)}, complexdoubleField={repr(self.complexdouble_field)})"


class TupleWithRecords:
    a: SimpleRecord
    b: SimpleRecord

    def __init__(self, *,
        a: typing.Optional[SimpleRecord] = None,
        b: typing.Optional[SimpleRecord] = None,
    ):
        self.a = a if a is not None else SimpleRecord()
        self.b = b if b is not None else SimpleRecord()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TupleWithRecords)
            and self.a == other.a
            and self.b == other.b
        )

    def __str__(self) -> str:
        return f"TupleWithRecords(a={self.a}, b={self.b})"

    def __repr__(self) -> str:
        return f"TupleWithRecords(a={repr(self.a)}, b={repr(self.b)})"


class RecordWithVectors:
    default_vector: list[yardl.Int32]
    default_vector_fixed_length: list[yardl.Int32]
    vector_of_vectors: list[list[yardl.Int32]]

    def __init__(self, *,
        default_vector: typing.Optional[list[yardl.Int32]] = None,
        default_vector_fixed_length: typing.Optional[list[yardl.Int32]] = None,
        vector_of_vectors: typing.Optional[list[list[yardl.Int32]]] = None,
    ):
        self.default_vector = default_vector if default_vector is not None else []
        self.default_vector_fixed_length = default_vector_fixed_length if default_vector_fixed_length is not None else [0] * 3
        self.vector_of_vectors = vector_of_vectors if vector_of_vectors is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVectors)
            and self.default_vector == other.default_vector
            and self.default_vector_fixed_length == other.default_vector_fixed_length
            and self.vector_of_vectors == other.vector_of_vectors
        )

    def __str__(self) -> str:
        return f"RecordWithVectors(defaultVector={self.default_vector}, defaultVectorFixedLength={self.default_vector_fixed_length}, vectorOfVectors={self.vector_of_vectors})"

    def __repr__(self) -> str:
        return f"RecordWithVectors(defaultVector={repr(self.default_vector)}, defaultVectorFixedLength={repr(self.default_vector_fixed_length)}, vectorOfVectors={repr(self.vector_of_vectors)})"


class RecordWithVectorOfTimes:
    times: list[yardl.Time]

    def __init__(self, *,
        times: typing.Optional[list[yardl.Time]] = None,
    ):
        self.times = times if times is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVectorOfTimes)
            and self.times == other.times
        )

    def __str__(self) -> str:
        return f"RecordWithVectorOfTimes(times={self.times})"

    def __repr__(self) -> str:
        return f"RecordWithVectorOfTimes(times={repr(self.times)})"


class RecordWithArrays:
    default_array: npt.NDArray[np.int32]
    default_array_with_empty_dimension: npt.NDArray[np.int32]
    rank_1_array: npt.NDArray[np.int32]
    rank_2_array: npt.NDArray[np.int32]
    rank_2_array_with_named_dimensions: npt.NDArray[np.int32]
    rank_2_fixed_array: npt.NDArray[np.int32]
    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32]
    dynamic_array: npt.NDArray[np.int32]
    array_of_vectors: npt.NDArray[np.int32]

    def __init__(self, *,
        default_array: typing.Optional[npt.NDArray[np.int32]] = None,
        default_array_with_empty_dimension: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_1_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        dynamic_array: typing.Optional[npt.NDArray[np.int32]] = None,
        array_of_vectors: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.default_array = default_array if default_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.default_array_with_empty_dimension = default_array_with_empty_dimension if default_array_with_empty_dimension is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.rank_1_array = rank_1_array if rank_1_array is not None else np.zeros((0), dtype=np.dtype(np.int32))
        self.rank_2_array = rank_2_array if rank_2_array is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_array_with_named_dimensions = rank_2_array_with_named_dimensions if rank_2_array_with_named_dimensions is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array = rank_2_fixed_array if rank_2_fixed_array is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array_with_named_dimensions = rank_2_fixed_array_with_named_dimensions if rank_2_fixed_array_with_named_dimensions is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.dynamic_array = dynamic_array if dynamic_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.array_of_vectors = array_of_vectors if array_of_vectors is not None else np.zeros((5,), dtype=np.dtype(np.int32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithArrays)
            and yardl.structural_equal(self.default_array, other.default_array)
            and yardl.structural_equal(self.default_array_with_empty_dimension, other.default_array_with_empty_dimension)
            and yardl.structural_equal(self.rank_1_array, other.rank_1_array)
            and yardl.structural_equal(self.rank_2_array, other.rank_2_array)
            and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other.rank_2_array_with_named_dimensions)
            and yardl.structural_equal(self.rank_2_fixed_array, other.rank_2_fixed_array)
            and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other.rank_2_fixed_array_with_named_dimensions)
            and yardl.structural_equal(self.dynamic_array, other.dynamic_array)
            and yardl.structural_equal(self.array_of_vectors, other.array_of_vectors)
        )

    def __str__(self) -> str:
        return f"RecordWithArrays(defaultArray={self.default_array}, defaultArrayWithEmptyDimension={self.default_array_with_empty_dimension}, rank1Array={self.rank_1_array}, rank2Array={self.rank_2_array}, rank2ArrayWithNamedDimensions={self.rank_2_array_with_named_dimensions}, rank2FixedArray={self.rank_2_fixed_array}, rank2FixedArrayWithNamedDimensions={self.rank_2_fixed_array_with_named_dimensions}, dynamicArray={self.dynamic_array}, arrayOfVectors={self.array_of_vectors})"

    def __repr__(self) -> str:
        return f"RecordWithArrays(defaultArray={repr(self.default_array)}, defaultArrayWithEmptyDimension={repr(self.default_array_with_empty_dimension)}, rank1Array={repr(self.rank_1_array)}, rank2Array={repr(self.rank_2_array)}, rank2ArrayWithNamedDimensions={repr(self.rank_2_array_with_named_dimensions)}, rank2FixedArray={repr(self.rank_2_fixed_array)}, rank2FixedArrayWithNamedDimensions={repr(self.rank_2_fixed_array_with_named_dimensions)}, dynamicArray={repr(self.dynamic_array)}, arrayOfVectors={repr(self.array_of_vectors)})"


class RecordWithArraysSimpleSyntax:
    default_array: npt.NDArray[np.int32]
    default_array_with_empty_dimension: npt.NDArray[np.int32]
    rank_1_array: npt.NDArray[np.int32]
    rank_2_array: npt.NDArray[np.int32]
    rank_2_array_with_named_dimensions: npt.NDArray[np.int32]
    rank_2_fixed_array: npt.NDArray[np.int32]
    rank_2_fixed_array_with_named_dimensions: npt.NDArray[np.int32]
    dynamic_array: npt.NDArray[np.int32]
    array_of_vectors: npt.NDArray[np.int32]

    def __init__(self, *,
        default_array: typing.Optional[npt.NDArray[np.int32]] = None,
        default_array_with_empty_dimension: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_1_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array: typing.Optional[npt.NDArray[np.int32]] = None,
        rank_2_fixed_array_with_named_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        dynamic_array: typing.Optional[npt.NDArray[np.int32]] = None,
        array_of_vectors: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.default_array = default_array if default_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.default_array_with_empty_dimension = default_array_with_empty_dimension if default_array_with_empty_dimension is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.rank_1_array = rank_1_array if rank_1_array is not None else np.zeros((0), dtype=np.dtype(np.int32))
        self.rank_2_array = rank_2_array if rank_2_array is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_array_with_named_dimensions = rank_2_array_with_named_dimensions if rank_2_array_with_named_dimensions is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array = rank_2_fixed_array if rank_2_fixed_array is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.rank_2_fixed_array_with_named_dimensions = rank_2_fixed_array_with_named_dimensions if rank_2_fixed_array_with_named_dimensions is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.dynamic_array = dynamic_array if dynamic_array is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.array_of_vectors = array_of_vectors if array_of_vectors is not None else np.zeros((5,), dtype=np.dtype(np.int32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithArraysSimpleSyntax)
            and yardl.structural_equal(self.default_array, other.default_array)
            and yardl.structural_equal(self.default_array_with_empty_dimension, other.default_array_with_empty_dimension)
            and yardl.structural_equal(self.rank_1_array, other.rank_1_array)
            and yardl.structural_equal(self.rank_2_array, other.rank_2_array)
            and yardl.structural_equal(self.rank_2_array_with_named_dimensions, other.rank_2_array_with_named_dimensions)
            and yardl.structural_equal(self.rank_2_fixed_array, other.rank_2_fixed_array)
            and yardl.structural_equal(self.rank_2_fixed_array_with_named_dimensions, other.rank_2_fixed_array_with_named_dimensions)
            and yardl.structural_equal(self.dynamic_array, other.dynamic_array)
            and yardl.structural_equal(self.array_of_vectors, other.array_of_vectors)
        )

    def __str__(self) -> str:
        return f"RecordWithArraysSimpleSyntax(defaultArray={self.default_array}, defaultArrayWithEmptyDimension={self.default_array_with_empty_dimension}, rank1Array={self.rank_1_array}, rank2Array={self.rank_2_array}, rank2ArrayWithNamedDimensions={self.rank_2_array_with_named_dimensions}, rank2FixedArray={self.rank_2_fixed_array}, rank2FixedArrayWithNamedDimensions={self.rank_2_fixed_array_with_named_dimensions}, dynamicArray={self.dynamic_array}, arrayOfVectors={self.array_of_vectors})"

    def __repr__(self) -> str:
        return f"RecordWithArraysSimpleSyntax(defaultArray={repr(self.default_array)}, defaultArrayWithEmptyDimension={repr(self.default_array_with_empty_dimension)}, rank1Array={repr(self.rank_1_array)}, rank2Array={repr(self.rank_2_array)}, rank2ArrayWithNamedDimensions={repr(self.rank_2_array_with_named_dimensions)}, rank2FixedArray={repr(self.rank_2_fixed_array)}, rank2FixedArrayWithNamedDimensions={repr(self.rank_2_fixed_array_with_named_dimensions)}, dynamicArray={repr(self.dynamic_array)}, arrayOfVectors={repr(self.array_of_vectors)})"


class RecordWithOptionalFields:
    optional_int: typing.Optional[yardl.Int32]
    optional_int_alternate_syntax: typing.Optional[yardl.Int32]
    optional_time: typing.Optional[yardl.Time]

    def __init__(self, *,
        optional_int: typing.Optional[yardl.Int32] = None,
        optional_int_alternate_syntax: typing.Optional[yardl.Int32] = None,
        optional_time: typing.Optional[yardl.Time] = None,
    ):
        self.optional_int = optional_int
        self.optional_int_alternate_syntax = optional_int_alternate_syntax
        self.optional_time = optional_time

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalFields)
            and self.optional_int == other.optional_int
            and self.optional_int_alternate_syntax == other.optional_int_alternate_syntax
            and self.optional_time == other.optional_time
        )

    def __str__(self) -> str:
        return f"RecordWithOptionalFields(optionalInt={self.optional_int}, optionalIntAlternateSyntax={self.optional_int_alternate_syntax}, optionalTime={self.optional_time})"

    def __repr__(self) -> str:
        return f"RecordWithOptionalFields(optionalInt={repr(self.optional_int)}, optionalIntAlternateSyntax={repr(self.optional_int_alternate_syntax)}, optionalTime={repr(self.optional_time)})"


class RecordWithVlens:
    a: list[SimpleRecord]
    b: yardl.Int32
    c: yardl.Int32

    def __init__(self, *,
        a: typing.Optional[list[SimpleRecord]] = None,
        b: yardl.Int32 = 0,
        c: yardl.Int32 = 0,
    ):
        self.a = a if a is not None else []
        self.b = b
        self.c = c

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVlens)
            and self.a == other.a
            and self.b == other.b
            and self.c == other.c
        )

    def __str__(self) -> str:
        return f"RecordWithVlens(a={self.a}, b={self.b}, c={self.c})"

    def __repr__(self) -> str:
        return f"RecordWithVlens(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)})"


class RecordWithStrings:
    a: str
    b: str

    def __init__(self, *,
        a: str = "",
        b: str = "",
    ):
        self.a = a
        self.b = b

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithStrings)
            and self.a == other.a
            and self.b == other.b
        )

    def __str__(self) -> str:
        return f"RecordWithStrings(a={self.a}, b={self.b})"

    def __repr__(self) -> str:
        return f"RecordWithStrings(a={repr(self.a)}, b={repr(self.b)})"


class RecordWithOptionalVector:
    optional_vector: typing.Optional[list[yardl.Int32]]

    def __init__(self, *,
        optional_vector: typing.Optional[list[yardl.Int32]] = None,
    ):
        self.optional_vector = optional_vector

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalVector)
            and self.optional_vector == other.optional_vector
        )

    def __str__(self) -> str:
        return f"RecordWithOptionalVector(optionalVector={self.optional_vector})"

    def __repr__(self) -> str:
        return f"RecordWithOptionalVector(optionalVector={repr(self.optional_vector)})"


class RecordWithFixedVectors:
    fixed_int_vector: list[yardl.Int32]
    fixed_simple_record_vector: list[SimpleRecord]
    fixed_record_with_vlens_vector: list[RecordWithVlens]

    def __init__(self, *,
        fixed_int_vector: typing.Optional[list[yardl.Int32]] = None,
        fixed_simple_record_vector: typing.Optional[list[SimpleRecord]] = None,
        fixed_record_with_vlens_vector: typing.Optional[list[RecordWithVlens]] = None,
    ):
        self.fixed_int_vector = fixed_int_vector if fixed_int_vector is not None else [0] * 5
        self.fixed_simple_record_vector = fixed_simple_record_vector if fixed_simple_record_vector is not None else [SimpleRecord() for _ in range(3)]
        self.fixed_record_with_vlens_vector = fixed_record_with_vlens_vector if fixed_record_with_vlens_vector is not None else [RecordWithVlens() for _ in range(2)]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithFixedVectors)
            and self.fixed_int_vector == other.fixed_int_vector
            and self.fixed_simple_record_vector == other.fixed_simple_record_vector
            and self.fixed_record_with_vlens_vector == other.fixed_record_with_vlens_vector
        )

    def __str__(self) -> str:
        return f"RecordWithFixedVectors(fixedIntVector={self.fixed_int_vector}, fixedSimpleRecordVector={self.fixed_simple_record_vector}, fixedRecordWithVlensVector={self.fixed_record_with_vlens_vector})"

    def __repr__(self) -> str:
        return f"RecordWithFixedVectors(fixedIntVector={repr(self.fixed_int_vector)}, fixedSimpleRecordVector={repr(self.fixed_simple_record_vector)}, fixedRecordWithVlensVector={repr(self.fixed_record_with_vlens_vector)})"


class RecordWithFixedArrays:
    ints: npt.NDArray[np.int32]
    fixed_simple_record_array: npt.NDArray[np.void]
    fixed_record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        fixed_record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((2, 3,), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((3, 2,), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((2, 2,), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithFixedArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )

    def __str__(self) -> str:
        return f"RecordWithFixedArrays(ints={self.ints}, fixedSimpleRecordArray={self.fixed_simple_record_array}, fixedRecordWithVlensArray={self.fixed_record_with_vlens_array})"

    def __repr__(self) -> str:
        return f"RecordWithFixedArrays(ints={repr(self.ints)}, fixedSimpleRecordArray={repr(self.fixed_simple_record_array)}, fixedRecordWithVlensArray={repr(self.fixed_record_with_vlens_array)})"


IntArray = npt.NDArray[np.int32]

IntRank2Array = npt.NDArray[np.int32]

IntFixedArray = npt.NDArray[np.int32]

SimpleRecordFixedArray = npt.NDArray[np.void]

RecordWithVlensFixedArray = npt.NDArray[np.void]

class RecordWithNamedFixedArrays:
    ints: IntFixedArray
    fixed_simple_record_array: SimpleRecordFixedArray
    fixed_record_with_vlens_array: RecordWithVlensFixedArray

    def __init__(self, *,
        ints: typing.Optional[IntFixedArray] = None,
        fixed_simple_record_array: typing.Optional[SimpleRecordFixedArray] = None,
        fixed_record_with_vlens_array: typing.Optional[RecordWithVlensFixedArray] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((2, 3,), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((3, 2,), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((2, 2,), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithNamedFixedArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )

    def __str__(self) -> str:
        return f"RecordWithNamedFixedArrays(ints={self.ints}, fixedSimpleRecordArray={self.fixed_simple_record_array}, fixedRecordWithVlensArray={self.fixed_record_with_vlens_array})"

    def __repr__(self) -> str:
        return f"RecordWithNamedFixedArrays(ints={repr(self.ints)}, fixedSimpleRecordArray={repr(self.fixed_simple_record_array)}, fixedRecordWithVlensArray={repr(self.fixed_record_with_vlens_array)})"


class RecordWithNDArrays:
    ints: npt.NDArray[np.int32]
    fixed_simple_record_array: npt.NDArray[np.void]
    fixed_record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        fixed_record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((0, 0), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((0, 0), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithNDArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )

    def __str__(self) -> str:
        return f"RecordWithNDArrays(ints={self.ints}, fixedSimpleRecordArray={self.fixed_simple_record_array}, fixedRecordWithVlensArray={self.fixed_record_with_vlens_array})"

    def __repr__(self) -> str:
        return f"RecordWithNDArrays(ints={repr(self.ints)}, fixedSimpleRecordArray={repr(self.fixed_simple_record_array)}, fixedRecordWithVlensArray={repr(self.fixed_record_with_vlens_array)})"


class RecordWithNDArraysSingleDimension:
    ints: npt.NDArray[np.int32]
    fixed_simple_record_array: npt.NDArray[np.void]
    fixed_record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        fixed_record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((0), dtype=np.dtype(np.int32))
        self.fixed_simple_record_array = fixed_simple_record_array if fixed_simple_record_array is not None else np.zeros((0), dtype=get_dtype(SimpleRecord))
        self.fixed_record_with_vlens_array = fixed_record_with_vlens_array if fixed_record_with_vlens_array is not None else np.zeros((0), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithNDArraysSingleDimension)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.fixed_simple_record_array, other.fixed_simple_record_array)
            and yardl.structural_equal(self.fixed_record_with_vlens_array, other.fixed_record_with_vlens_array)
        )

    def __str__(self) -> str:
        return f"RecordWithNDArraysSingleDimension(ints={self.ints}, fixedSimpleRecordArray={self.fixed_simple_record_array}, fixedRecordWithVlensArray={self.fixed_record_with_vlens_array})"

    def __repr__(self) -> str:
        return f"RecordWithNDArraysSingleDimension(ints={repr(self.ints)}, fixedSimpleRecordArray={repr(self.fixed_simple_record_array)}, fixedRecordWithVlensArray={repr(self.fixed_record_with_vlens_array)})"


class RecordWithDynamicNDArrays:
    ints: IntArray
    simple_record_array: npt.NDArray[np.void]
    record_with_vlens_array: npt.NDArray[np.void]

    def __init__(self, *,
        ints: typing.Optional[IntArray] = None,
        simple_record_array: typing.Optional[npt.NDArray[np.void]] = None,
        record_with_vlens_array: typing.Optional[npt.NDArray[np.void]] = None,
    ):
        self.ints = ints if ints is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.simple_record_array = simple_record_array if simple_record_array is not None else np.zeros((), dtype=get_dtype(SimpleRecord))
        self.record_with_vlens_array = record_with_vlens_array if record_with_vlens_array is not None else np.zeros((), dtype=get_dtype(RecordWithVlens))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithDynamicNDArrays)
            and yardl.structural_equal(self.ints, other.ints)
            and yardl.structural_equal(self.simple_record_array, other.simple_record_array)
            and yardl.structural_equal(self.record_with_vlens_array, other.record_with_vlens_array)
        )

    def __str__(self) -> str:
        return f"RecordWithDynamicNDArrays(ints={self.ints}, simpleRecordArray={self.simple_record_array}, recordWithVlensArray={self.record_with_vlens_array})"

    def __repr__(self) -> str:
        return f"RecordWithDynamicNDArrays(ints={repr(self.ints)}, simpleRecordArray={repr(self.simple_record_array)}, recordWithVlensArray={repr(self.record_with_vlens_array)})"


NamedFixedNDArray = npt.NDArray[np.int32]

class RecordWithFixedCollections:
    fixed_vector: list[yardl.Int32]
    fixed_array: npt.NDArray[np.int32]

    def __init__(self, *,
        fixed_vector: typing.Optional[list[yardl.Int32]] = None,
        fixed_array: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.fixed_vector = fixed_vector if fixed_vector is not None else [0] * 3
        self.fixed_array = fixed_array if fixed_array is not None else np.zeros((2, 3,), dtype=np.dtype(np.int32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithFixedCollections)
            and self.fixed_vector == other.fixed_vector
            and yardl.structural_equal(self.fixed_array, other.fixed_array)
        )

    def __str__(self) -> str:
        return f"RecordWithFixedCollections(fixedVector={self.fixed_vector}, fixedArray={self.fixed_array})"

    def __repr__(self) -> str:
        return f"RecordWithFixedCollections(fixedVector={repr(self.fixed_vector)}, fixedArray={repr(self.fixed_array)})"


class RecordWithVlenCollections:
    vector: list[yardl.Int32]
    array: npt.NDArray[np.int32]

    def __init__(self, *,
        vector: typing.Optional[list[yardl.Int32]] = None,
        array: typing.Optional[npt.NDArray[np.int32]] = None,
    ):
        self.vector = vector if vector is not None else []
        self.array = array if array is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithVlenCollections)
            and self.vector == other.vector
            and yardl.structural_equal(self.array, other.array)
        )

    def __str__(self) -> str:
        return f"RecordWithVlenCollections(vector={self.vector}, array={self.array})"

    def __repr__(self) -> str:
        return f"RecordWithVlenCollections(vector={repr(self.vector)}, array={repr(self.array)})"


_T = typing.TypeVar('_T')

class MapOrScalar:
    Map: typing.ClassVar[type["MapOrScalarUnionCase[dict[str, yardl.Int32]]"]]
    Scalar: typing.ClassVar[type["MapOrScalarUnionCase[yardl.Int32]"]]

class MapOrScalarUnionCase(MapOrScalar, yardl.UnionCase[_T]):
    pass

MapOrScalar.Map = type("MapOrScalar.Map", (MapOrScalarUnionCase,), {"index": 0, "tag": "map"})
MapOrScalar.Scalar = type("MapOrScalar.Scalar", (MapOrScalarUnionCase,), {"index": 1, "tag": "scalar"})
del MapOrScalarUnionCase

class VectorOrScalar:
    Vector: typing.ClassVar[type["VectorOrScalarUnionCase[list[yardl.Int32]]"]]
    Scalar: typing.ClassVar[type["VectorOrScalarUnionCase[yardl.Int32]"]]

class VectorOrScalarUnionCase(VectorOrScalar, yardl.UnionCase[_T]):
    pass

VectorOrScalar.Vector = type("VectorOrScalar.Vector", (VectorOrScalarUnionCase,), {"index": 0, "tag": "vector"})
VectorOrScalar.Scalar = type("VectorOrScalar.Scalar", (VectorOrScalarUnionCase,), {"index": 1, "tag": "scalar"})
del VectorOrScalarUnionCase

class ArrayOrScalar:
    Array: typing.ClassVar[type["ArrayOrScalarUnionCase[npt.NDArray[np.int32]]"]]
    Scalar: typing.ClassVar[type["ArrayOrScalarUnionCase[yardl.Int32]"]]

class ArrayOrScalarUnionCase(ArrayOrScalar, yardl.UnionCase[_T]):
    pass

ArrayOrScalar.Array = type("ArrayOrScalar.Array", (ArrayOrScalarUnionCase,), {"index": 0, "tag": "array"})
ArrayOrScalar.Scalar = type("ArrayOrScalar.Scalar", (ArrayOrScalarUnionCase,), {"index": 1, "tag": "scalar"})
del ArrayOrScalarUnionCase

class RecordWithUnionsOfContainers:
    map_or_scalar: MapOrScalar
    vector_or_scalar: VectorOrScalar
    array_or_scalar: ArrayOrScalar

    def __init__(self, *,
        map_or_scalar: typing.Optional[MapOrScalar] = None,
        vector_or_scalar: typing.Optional[VectorOrScalar] = None,
        array_or_scalar: typing.Optional[ArrayOrScalar] = None,
    ):
        self.map_or_scalar = map_or_scalar if map_or_scalar is not None else MapOrScalar.Map({})
        self.vector_or_scalar = vector_or_scalar if vector_or_scalar is not None else VectorOrScalar.Vector([])
        self.array_or_scalar = array_or_scalar if array_or_scalar is not None else ArrayOrScalar.Array(np.zeros((), dtype=np.dtype(np.int32)))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithUnionsOfContainers)
            and self.map_or_scalar == other.map_or_scalar
            and self.vector_or_scalar == other.vector_or_scalar
            and yardl.structural_equal(self.array_or_scalar, other.array_or_scalar)
        )

    def __str__(self) -> str:
        return f"RecordWithUnionsOfContainers(mapOrScalar={self.map_or_scalar}, vectorOrScalar={self.vector_or_scalar}, arrayOrScalar={self.array_or_scalar})"

    def __repr__(self) -> str:
        return f"RecordWithUnionsOfContainers(mapOrScalar={repr(self.map_or_scalar)}, vectorOrScalar={repr(self.vector_or_scalar)}, arrayOrScalar={repr(self.array_or_scalar)})"


NamedNDArray = npt.NDArray[np.int32]

Fruits = basic_types.Fruits

class UInt64Enum(yardl.OutOfRangeEnum):
    A = 9223372036854775808

class Int64Enum(yardl.OutOfRangeEnum):
    B = -4611686018427387904

class SizeBasedEnum(yardl.OutOfRangeEnum):
    A = 0
    B = 1
    C = 2

DaysOfWeek = basic_types.DaysOfWeek

TextFormat = basic_types.TextFormat

class RecordWithEnums:
    enum: Fruits
    flags: DaysOfWeek
    flags_2: TextFormat

    def __init__(self, *,
        enum: Fruits = basic_types.Fruits.APPLE,
        flags: DaysOfWeek = basic_types.DaysOfWeek(0),
        flags_2: TextFormat = basic_types.TextFormat.REGULAR,
    ):
        self.enum = enum
        self.flags = flags
        self.flags_2 = flags_2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithEnums)
            and self.enum == other.enum
            and self.flags == other.flags
            and self.flags_2 == other.flags_2
        )

    def __str__(self) -> str:
        return f"RecordWithEnums(enum={self.enum}, flags={self.flags}, flags2={self.flags_2})"

    def __repr__(self) -> str:
        return f"RecordWithEnums(enum={repr(self.enum)}, flags={repr(self.flags)}, flags2={repr(self.flags_2)})"


Image = image.Image[T_NP]

class GenericRecord(typing.Generic[T1, T2, T2_NP]):
    scalar_1: T1
    scalar_2: T2
    vector_1: list[T1]
    image_2: Image[T2_NP]

    def __init__(self, *,
        scalar_1: T1,
        scalar_2: T2,
        vector_1: typing.Optional[list[T1]] = None,
        image_2: Image[T2_NP],
    ):
        self.scalar_1 = scalar_1
        self.scalar_2 = scalar_2
        self.vector_1 = vector_1 if vector_1 is not None else []
        self.image_2 = image_2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GenericRecord)
            and yardl.structural_equal(self.scalar_1, other.scalar_1)
            and yardl.structural_equal(self.scalar_2, other.scalar_2)
            and len(self.vector_1) == len(other.vector_1) and all(yardl.structural_equal(a, b) for a, b in zip(self.vector_1, other.vector_1))
            and yardl.structural_equal(self.image_2, other.image_2)
        )

    def __str__(self) -> str:
        return f"GenericRecord(scalar1={self.scalar_1}, scalar2={self.scalar_2}, vector1={self.vector_1}, image2={self.image_2})"

    def __repr__(self) -> str:
        return f"GenericRecord(scalar1={repr(self.scalar_1)}, scalar2={repr(self.scalar_2)}, vector1={repr(self.vector_1)}, image2={repr(self.image_2)})"


MyTuple = basic_types.MyTuple

AliasedTuple = MyTuple

class RecordWithAliasedGenerics:
    my_strings: MyTuple[str, str]
    aliased_strings: AliasedTuple[str, str]

    def __init__(self, *,
        my_strings: typing.Optional[MyTuple[str, str]] = None,
        aliased_strings: typing.Optional[AliasedTuple[str, str]] = None,
    ):
        self.my_strings = my_strings if my_strings is not None else tuples.Tuple(v1="", v2="")
        self.aliased_strings = aliased_strings if aliased_strings is not None else tuples.Tuple(v1="", v2="")

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithAliasedGenerics)
            and self.my_strings == other.my_strings
            and self.aliased_strings == other.aliased_strings
        )

    def __str__(self) -> str:
        return f"RecordWithAliasedGenerics(myStrings={self.my_strings}, aliasedStrings={self.aliased_strings})"

    def __repr__(self) -> str:
        return f"RecordWithAliasedGenerics(myStrings={repr(self.my_strings)}, aliasedStrings={repr(self.aliased_strings)})"


AliasedString = str

AliasedEnum = Fruits

AliasedSimpleRecord = SimpleRecord

AliasedOpenGeneric = AliasedTuple

AliasedClosedGeneric = AliasedTuple[AliasedString, AliasedEnum]

AliasedOptional = typing.Optional[yardl.Int32]

AliasedGenericOptional = typing.Optional[T]

class AliasedMultiGenericOptional(typing.Generic[T, U]):
    T: type["AliasedMultiGenericOptionalUnionCase[T, U, T]"]
    U: type["AliasedMultiGenericOptionalUnionCase[T, U, U]"]

class AliasedMultiGenericOptionalUnionCase(AliasedMultiGenericOptional[T, U], yardl.UnionCase[_T]):
    pass

AliasedMultiGenericOptional.T = type("AliasedMultiGenericOptional.T", (AliasedMultiGenericOptionalUnionCase,), {"index": 0, "tag": "T"})
AliasedMultiGenericOptional.U = type("AliasedMultiGenericOptional.U", (AliasedMultiGenericOptionalUnionCase,), {"index": 1, "tag": "U"})
del AliasedMultiGenericOptionalUnionCase

AliasedGenericUnion2 = basic_types.GenericUnion2[T1, T2]

AliasedGenericVector = basic_types.GenericVector[T]

AliasedGenericFixedVector = list[T]

AliasedGenericRank2Array = npt.NDArray[T_NP]

AliasedGenericFixedArray = npt.NDArray[T_NP]

AliasedGenericDynamicArray = npt.NDArray[T_NP]

AliasedMap = basic_types.AliasedMap[K, V]

VectorOfGenericRecords = list[GenericRecord[T1, T2, T2_NP]]

AliasedVectorOfGenericRecords = AliasedGenericVector[GenericRecord[T1, T2, T2_NP]]

class RecordWithGenericVectorOfRecords(typing.Generic[T, U, U_NP]):
    v: list[VectorOfGenericRecords[T, U, U_NP]]

    def __init__(self, *,
        v: typing.Optional[list[VectorOfGenericRecords[T, U, U_NP]]] = None,
    ):
        self.v = v if v is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithGenericVectorOfRecords)
            and len(self.v) == len(other.v) and all(len(a) == len(b) and all(a == b for a, b in zip(a, b)) for a, b in zip(self.v, other.v))
        )

    def __str__(self) -> str:
        return f"RecordWithGenericVectorOfRecords(v={self.v})"

    def __repr__(self) -> str:
        return f"RecordWithGenericVectorOfRecords(v={repr(self.v)})"


class RecordWithOptionalGenericField(typing.Generic[T]):
    v: typing.Optional[T]

    def __init__(self, *,
        v: typing.Optional[T] = None,
    ):
        self.v = v

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalGenericField)
            and (other.v is None if self.v is None else (other.v is not None and yardl.structural_equal(self.v, other.v)))
        )

    def __str__(self) -> str:
        return f"RecordWithOptionalGenericField(v={self.v})"

    def __repr__(self) -> str:
        return f"RecordWithOptionalGenericField(v={repr(self.v)})"


class RecordWithAliasedOptionalGenericField(typing.Generic[T]):
    v: AliasedGenericOptional[T]

    def __init__(self, *,
        v: AliasedGenericOptional[T] = None,
    ):
        self.v = v

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithAliasedOptionalGenericField)
            and (other.v is None if self.v is None else (other.v is not None and yardl.structural_equal(self.v, other.v)))
        )

    def __str__(self) -> str:
        return f"RecordWithAliasedOptionalGenericField(v={self.v})"

    def __repr__(self) -> str:
        return f"RecordWithAliasedOptionalGenericField(v={repr(self.v)})"


class UOrV(typing.Generic[U, V]):
    U: type["UOrVUnionCase[U, V, U]"]
    V: type["UOrVUnionCase[U, V, V]"]

class UOrVUnionCase(UOrV[U, V], yardl.UnionCase[_T]):
    pass

UOrV.U = type("UOrV.U", (UOrVUnionCase,), {"index": 0, "tag": "U"})
UOrV.V = type("UOrV.V", (UOrVUnionCase,), {"index": 1, "tag": "V"})
del UOrVUnionCase

class RecordWithOptionalGenericUnionField(typing.Generic[U, V]):
    v: typing.Optional[UOrV[U, V]]

    def __init__(self, *,
        v: typing.Optional[UOrV[U, V]] = None,
    ):
        self.v = v

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalGenericUnionField)
            and yardl.structural_equal(self.v, other.v)
        )

    def __str__(self) -> str:
        return f"RecordWithOptionalGenericUnionField(v={self.v})"

    def __repr__(self) -> str:
        return f"RecordWithOptionalGenericUnionField(v={repr(self.v)})"


class RecordWithAliasedOptionalGenericUnionField(typing.Generic[U, V]):
    v: typing.Optional[AliasedMultiGenericOptional[U, V]]

    def __init__(self, *,
        v: typing.Optional[AliasedMultiGenericOptional[U, V]] = None,
    ):
        self.v = v

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithAliasedOptionalGenericUnionField)
            and yardl.structural_equal(self.v, other.v)
        )

    def __str__(self) -> str:
        return f"RecordWithAliasedOptionalGenericUnionField(v={self.v})"

    def __repr__(self) -> str:
        return f"RecordWithAliasedOptionalGenericUnionField(v={repr(self.v)})"


class RecordWithGenericVectors(typing.Generic[T]):
    v: list[T]
    av: AliasedGenericVector[T]

    def __init__(self, *,
        v: typing.Optional[list[T]] = None,
        av: typing.Optional[AliasedGenericVector[T]] = None,
    ):
        self.v = v if v is not None else []
        self.av = av if av is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithGenericVectors)
            and len(self.v) == len(other.v) and all(yardl.structural_equal(a, b) for a, b in zip(self.v, other.v))
            and len(self.av) == len(other.av) and all(yardl.structural_equal(a, b) for a, b in zip(self.av, other.av))
        )

    def __str__(self) -> str:
        return f"RecordWithGenericVectors(v={self.v}, av={self.av})"

    def __repr__(self) -> str:
        return f"RecordWithGenericVectors(v={repr(self.v)}, av={repr(self.av)})"


class RecordWithGenericFixedVectors(typing.Generic[T]):
    fv: list[T]
    afv: AliasedGenericFixedVector[T]

    def __init__(self, *,
        fv: list[T],
        afv: AliasedGenericFixedVector[T],
    ):
        self.fv = fv
        self.afv = afv

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithGenericFixedVectors)
            and len(self.fv) == len(other.fv) and all(yardl.structural_equal(a, b) for a, b in zip(self.fv, other.fv))
            and len(self.afv) == len(other.afv) and all(yardl.structural_equal(a, b) for a, b in zip(self.afv, other.afv))
        )

    def __str__(self) -> str:
        return f"RecordWithGenericFixedVectors(fv={self.fv}, afv={self.afv})"

    def __repr__(self) -> str:
        return f"RecordWithGenericFixedVectors(fv={repr(self.fv)}, afv={repr(self.afv)})"


class RecordWithGenericArrays(typing.Generic[T_NP]):
    nd: npt.NDArray[T_NP]
    fixed_nd: npt.NDArray[T_NP]
    dynamic_nd: npt.NDArray[T_NP]
    aliased_nd: AliasedGenericRank2Array[T_NP]
    aliased_fixed_nd: AliasedGenericFixedArray[T_NP]
    aliased_dynamic_nd: AliasedGenericDynamicArray[T_NP]

    def __init__(self, *,
        nd: npt.NDArray[T_NP],
        fixed_nd: npt.NDArray[T_NP],
        dynamic_nd: npt.NDArray[T_NP],
        aliased_nd: AliasedGenericRank2Array[T_NP],
        aliased_fixed_nd: AliasedGenericFixedArray[T_NP],
        aliased_dynamic_nd: AliasedGenericDynamicArray[T_NP],
    ):
        self.nd = nd
        self.fixed_nd = fixed_nd
        self.dynamic_nd = dynamic_nd
        self.aliased_nd = aliased_nd
        self.aliased_fixed_nd = aliased_fixed_nd
        self.aliased_dynamic_nd = aliased_dynamic_nd

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithGenericArrays)
            and yardl.structural_equal(self.nd, other.nd)
            and yardl.structural_equal(self.fixed_nd, other.fixed_nd)
            and yardl.structural_equal(self.dynamic_nd, other.dynamic_nd)
            and yardl.structural_equal(self.aliased_nd, other.aliased_nd)
            and yardl.structural_equal(self.aliased_fixed_nd, other.aliased_fixed_nd)
            and yardl.structural_equal(self.aliased_dynamic_nd, other.aliased_dynamic_nd)
        )

    def __str__(self) -> str:
        return f"RecordWithGenericArrays(nd={self.nd}, fixedNd={self.fixed_nd}, dynamicNd={self.dynamic_nd}, aliasedNd={self.aliased_nd}, aliasedFixedNd={self.aliased_fixed_nd}, aliasedDynamicNd={self.aliased_dynamic_nd})"

    def __repr__(self) -> str:
        return f"RecordWithGenericArrays(nd={repr(self.nd)}, fixedNd={repr(self.fixed_nd)}, dynamicNd={repr(self.dynamic_nd)}, aliasedNd={repr(self.aliased_nd)}, aliasedFixedNd={repr(self.aliased_fixed_nd)}, aliasedDynamicNd={repr(self.aliased_dynamic_nd)})"


class RecordWithGenericMaps(typing.Generic[T, U]):
    m: dict[T, U]
    am: basic_types.AliasedMap[T, U]

    def __init__(self, *,
        m: typing.Optional[dict[T, U]] = None,
        am: typing.Optional[basic_types.AliasedMap[T, U]] = None,
    ):
        self.m = m if m is not None else {}
        self.am = am if am is not None else {}

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithGenericMaps)
            and yardl.structural_equal(self.m, other.m)
            and yardl.structural_equal(self.am, other.am)
        )

    def __str__(self) -> str:
        return f"RecordWithGenericMaps(m={self.m}, am={self.am})"

    def __repr__(self) -> str:
        return f"RecordWithGenericMaps(m={repr(self.m)}, am={repr(self.am)})"


class RecordContainingGenericRecords(typing.Generic[A, B, B_NP]):
    g1: RecordWithOptionalGenericField[A]
    g1a: RecordWithAliasedOptionalGenericField[A]
    g2: RecordWithOptionalGenericUnionField[A, B]
    g2a: RecordWithAliasedOptionalGenericUnionField[A, B]
    g3: MyTuple[A, B]
    g3a: AliasedTuple[A, B]
    g4: RecordWithGenericVectors[B]
    g5: RecordWithGenericFixedVectors[B]
    g6: RecordWithGenericArrays[B_NP]
    g7: RecordWithGenericMaps[A, B]

    def __init__(self, *,
        g1: typing.Optional[RecordWithOptionalGenericField[A]] = None,
        g1a: typing.Optional[RecordWithAliasedOptionalGenericField[A]] = None,
        g2: typing.Optional[RecordWithOptionalGenericUnionField[A, B]] = None,
        g2a: typing.Optional[RecordWithAliasedOptionalGenericUnionField[A, B]] = None,
        g3: MyTuple[A, B],
        g3a: AliasedTuple[A, B],
        g4: typing.Optional[RecordWithGenericVectors[B]] = None,
        g5: RecordWithGenericFixedVectors[B],
        g6: RecordWithGenericArrays[B_NP],
        g7: typing.Optional[RecordWithGenericMaps[A, B]] = None,
    ):
        self.g1 = g1 if g1 is not None else RecordWithOptionalGenericField()
        self.g1a = g1a if g1a is not None else RecordWithAliasedOptionalGenericField()
        self.g2 = g2 if g2 is not None else RecordWithOptionalGenericUnionField()
        self.g2a = g2a if g2a is not None else RecordWithAliasedOptionalGenericUnionField()
        self.g3 = g3
        self.g3a = g3a
        self.g4 = g4 if g4 is not None else RecordWithGenericVectors()
        self.g5 = g5
        self.g6 = g6
        self.g7 = g7 if g7 is not None else RecordWithGenericMaps()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordContainingGenericRecords)
            and self.g1 == other.g1
            and self.g1a == other.g1a
            and self.g2 == other.g2
            and self.g2a == other.g2a
            and self.g3 == other.g3
            and self.g3a == other.g3a
            and self.g4 == other.g4
            and self.g5 == other.g5
            and self.g6 == other.g6
            and self.g7 == other.g7
        )

    def __str__(self) -> str:
        return f"RecordContainingGenericRecords(g1={self.g1}, g1a={self.g1a}, g2={self.g2}, g2a={self.g2a}, g3={self.g3}, g3a={self.g3a}, g4={self.g4}, g5={self.g5}, g6={self.g6}, g7={self.g7})"

    def __repr__(self) -> str:
        return f"RecordContainingGenericRecords(g1={repr(self.g1)}, g1a={repr(self.g1a)}, g2={repr(self.g2)}, g2a={repr(self.g2a)}, g3={repr(self.g3)}, g3a={repr(self.g3a)}, g4={repr(self.g4)}, g5={repr(self.g5)}, g6={repr(self.g6)}, g7={repr(self.g7)})"


class RecordContainingNestedGenericRecords:
    f1: RecordWithOptionalGenericField[str]
    f1a: RecordWithAliasedOptionalGenericField[str]
    f2: RecordWithOptionalGenericUnionField[str, yardl.Int32]
    f2a: RecordWithAliasedOptionalGenericUnionField[str, yardl.Int32]
    nested: RecordContainingGenericRecords[str, yardl.Int32, np.int32]

    def __init__(self, *,
        f1: typing.Optional[RecordWithOptionalGenericField[str]] = None,
        f1a: typing.Optional[RecordWithAliasedOptionalGenericField[str]] = None,
        f2: typing.Optional[RecordWithOptionalGenericUnionField[str, yardl.Int32]] = None,
        f2a: typing.Optional[RecordWithAliasedOptionalGenericUnionField[str, yardl.Int32]] = None,
        nested: typing.Optional[RecordContainingGenericRecords[str, yardl.Int32, np.int32]] = None,
    ):
        self.f1 = f1 if f1 is not None else RecordWithOptionalGenericField()
        self.f1a = f1a if f1a is not None else RecordWithAliasedOptionalGenericField()
        self.f2 = f2 if f2 is not None else RecordWithOptionalGenericUnionField()
        self.f2a = f2a if f2a is not None else RecordWithAliasedOptionalGenericUnionField()
        self.nested = nested if nested is not None else RecordContainingGenericRecords(g3=tuples.Tuple(v1="", v2=0), g3a=tuples.Tuple(v1="", v2=0), g5=RecordWithGenericFixedVectors(fv=[0] * 3, afv=[0] * 3), g6=RecordWithGenericArrays(nd=np.zeros((0, 0), dtype=np.dtype(np.int32)), fixed_nd=np.zeros((16, 8,), dtype=np.dtype(np.int32)), dynamic_nd=np.zeros((), dtype=np.dtype(np.int32)), aliased_nd=np.zeros((0, 0), dtype=np.dtype(np.int32)), aliased_fixed_nd=np.zeros((16, 8,), dtype=np.dtype(np.int32)), aliased_dynamic_nd=np.zeros((), dtype=np.dtype(np.int32))))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordContainingNestedGenericRecords)
            and self.f1 == other.f1
            and self.f1a == other.f1a
            and self.f2 == other.f2
            and self.f2a == other.f2a
            and self.nested == other.nested
        )

    def __str__(self) -> str:
        return f"RecordContainingNestedGenericRecords(f1={self.f1}, f1a={self.f1a}, f2={self.f2}, f2a={self.f2a}, nested={self.nested})"

    def __repr__(self) -> str:
        return f"RecordContainingNestedGenericRecords(f1={repr(self.f1)}, f1a={repr(self.f1a)}, f2={repr(self.f2)}, f2a={repr(self.f2a)}, nested={repr(self.nested)})"


class AliasedIntOrSimpleRecord:
    Int32: typing.ClassVar[type["AliasedIntOrSimpleRecordUnionCase[yardl.Int32]"]]
    SimpleRecord: typing.ClassVar[type["AliasedIntOrSimpleRecordUnionCase[SimpleRecord]"]]

class AliasedIntOrSimpleRecordUnionCase(AliasedIntOrSimpleRecord, yardl.UnionCase[_T]):
    pass

AliasedIntOrSimpleRecord.Int32 = type("AliasedIntOrSimpleRecord.Int32", (AliasedIntOrSimpleRecordUnionCase,), {"index": 0, "tag": "int32"})
AliasedIntOrSimpleRecord.SimpleRecord = type("AliasedIntOrSimpleRecord.SimpleRecord", (AliasedIntOrSimpleRecordUnionCase,), {"index": 1, "tag": "SimpleRecord"})
del AliasedIntOrSimpleRecordUnionCase

class AliasedIntOrAliasedSimpleRecord:
    Int32: typing.ClassVar[type["AliasedIntOrAliasedSimpleRecordUnionCase[yardl.Int32]"]]
    AliasedSimpleRecord: typing.ClassVar[type["AliasedIntOrAliasedSimpleRecordUnionCase[AliasedSimpleRecord]"]]

class AliasedIntOrAliasedSimpleRecordUnionCase(AliasedIntOrAliasedSimpleRecord, yardl.UnionCase[_T]):
    pass

AliasedIntOrAliasedSimpleRecord.Int32 = type("AliasedIntOrAliasedSimpleRecord.Int32", (AliasedIntOrAliasedSimpleRecordUnionCase,), {"index": 0, "tag": "int32"})
AliasedIntOrAliasedSimpleRecord.AliasedSimpleRecord = type("AliasedIntOrAliasedSimpleRecord.AliasedSimpleRecord", (AliasedIntOrAliasedSimpleRecordUnionCase,), {"index": 1, "tag": "AliasedSimpleRecord"})
del AliasedIntOrAliasedSimpleRecordUnionCase

class AliasedNullableIntSimpleRecord:
    Int32: typing.ClassVar[type["AliasedNullableIntSimpleRecordUnionCase[yardl.Int32]"]]
    SimpleRecord: typing.ClassVar[type["AliasedNullableIntSimpleRecordUnionCase[SimpleRecord]"]]

class AliasedNullableIntSimpleRecordUnionCase(AliasedNullableIntSimpleRecord, yardl.UnionCase[_T]):
    pass

AliasedNullableIntSimpleRecord.Int32 = type("AliasedNullableIntSimpleRecord.Int32", (AliasedNullableIntSimpleRecordUnionCase,), {"index": 0, "tag": "int32"})
AliasedNullableIntSimpleRecord.SimpleRecord = type("AliasedNullableIntSimpleRecord.SimpleRecord", (AliasedNullableIntSimpleRecordUnionCase,), {"index": 1, "tag": "SimpleRecord"})
del AliasedNullableIntSimpleRecordUnionCase

RecordWithIntVectors = RecordWithGenericVectors[yardl.Int32]

RecordWithFloatArrays = RecordWithGenericArrays[np.float32]

class UnionOfContainerRecords:
    RecordWithIntVectors: typing.ClassVar[type["UnionOfContainerRecordsUnionCase[RecordWithIntVectors]"]]
    RecordWithFloatArrays: typing.ClassVar[type["UnionOfContainerRecordsUnionCase[RecordWithFloatArrays]"]]

class UnionOfContainerRecordsUnionCase(UnionOfContainerRecords, yardl.UnionCase[_T]):
    pass

UnionOfContainerRecords.RecordWithIntVectors = type("UnionOfContainerRecords.RecordWithIntVectors", (UnionOfContainerRecordsUnionCase,), {"index": 0, "tag": "RecordWithIntVectors"})
UnionOfContainerRecords.RecordWithFloatArrays = type("UnionOfContainerRecords.RecordWithFloatArrays", (UnionOfContainerRecordsUnionCase,), {"index": 1, "tag": "RecordWithFloatArrays"})
del UnionOfContainerRecordsUnionCase

class Int32OrFloat32:
    Int32: typing.ClassVar[type["Int32OrFloat32UnionCase[yardl.Int32]"]]
    Float32: typing.ClassVar[type["Int32OrFloat32UnionCase[yardl.Float32]"]]

class Int32OrFloat32UnionCase(Int32OrFloat32, yardl.UnionCase[_T]):
    pass

Int32OrFloat32.Int32 = type("Int32OrFloat32.Int32", (Int32OrFloat32UnionCase,), {"index": 0, "tag": "int32"})
Int32OrFloat32.Float32 = type("Int32OrFloat32.Float32", (Int32OrFloat32UnionCase,), {"index": 1, "tag": "float32"})
del Int32OrFloat32UnionCase

class IntOrGenericRecordWithComputedFields:
    Int: typing.ClassVar[type["IntOrGenericRecordWithComputedFieldsUnionCase[yardl.Int32]"]]
    GenericRecordWithComputedFields: typing.ClassVar[type["IntOrGenericRecordWithComputedFieldsUnionCase[basic_types.GenericRecordWithComputedFields[str, yardl.Float32]]"]]

class IntOrGenericRecordWithComputedFieldsUnionCase(IntOrGenericRecordWithComputedFields, yardl.UnionCase[_T]):
    pass

IntOrGenericRecordWithComputedFields.Int = type("IntOrGenericRecordWithComputedFields.Int", (IntOrGenericRecordWithComputedFieldsUnionCase,), {"index": 0, "tag": "int"})
IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields = type("IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields", (IntOrGenericRecordWithComputedFieldsUnionCase,), {"index": 1, "tag": "genericRecordWithComputedFields"})
del IntOrGenericRecordWithComputedFieldsUnionCase

class RecordWithComputedFields:
    array_field: npt.NDArray[np.int32]
    array_field_map_dimensions: npt.NDArray[np.int32]
    dynamic_array_field: npt.NDArray[np.int32]
    fixed_array_field: npt.NDArray[np.int32]
    int_field: yardl.Int32
    int8_field: yardl.Int8
    uint8_field: yardl.UInt8
    int16_field: yardl.Int16
    uint16_field: yardl.UInt16
    uint32_field: yardl.UInt32
    int64_field: yardl.Int64
    uint64_field: yardl.UInt64
    size_field: yardl.Size
    float32_field: yardl.Float32
    float64_field: yardl.Float64
    complexfloat32_field: yardl.ComplexFloat
    complexfloat64_field: yardl.ComplexDouble
    string_field: str
    tuple_field: MyTuple[yardl.Int32, yardl.Int32]
    vector_field: list[yardl.Int32]
    vector_of_vectors_field: list[list[yardl.Int32]]
    fixed_vector_field: list[yardl.Int32]
    fixed_vector_of_vectors_field: list[list[yardl.Int32]]
    optional_named_array: typing.Optional[NamedNDArray]
    int_float_union: Int32OrFloat32
    nullable_int_float_union: typing.Optional[Int32OrFloat32]
    union_with_nested_generic_union: IntOrGenericRecordWithComputedFields
    map_field: dict[str, str]

    def __init__(self, *,
        array_field: typing.Optional[npt.NDArray[np.int32]] = None,
        array_field_map_dimensions: typing.Optional[npt.NDArray[np.int32]] = None,
        dynamic_array_field: typing.Optional[npt.NDArray[np.int32]] = None,
        fixed_array_field: typing.Optional[npt.NDArray[np.int32]] = None,
        int_field: yardl.Int32 = 0,
        int8_field: yardl.Int8 = 0,
        uint8_field: yardl.UInt8 = 0,
        int16_field: yardl.Int16 = 0,
        uint16_field: yardl.UInt16 = 0,
        uint32_field: yardl.UInt32 = 0,
        int64_field: yardl.Int64 = 0,
        uint64_field: yardl.UInt64 = 0,
        size_field: yardl.Size = 0,
        float32_field: yardl.Float32 = 0.0,
        float64_field: yardl.Float64 = 0.0,
        complexfloat32_field: yardl.ComplexFloat = 0j,
        complexfloat64_field: yardl.ComplexDouble = 0j,
        string_field: str = "",
        tuple_field: typing.Optional[MyTuple[yardl.Int32, yardl.Int32]] = None,
        vector_field: typing.Optional[list[yardl.Int32]] = None,
        vector_of_vectors_field: typing.Optional[list[list[yardl.Int32]]] = None,
        fixed_vector_field: typing.Optional[list[yardl.Int32]] = None,
        fixed_vector_of_vectors_field: typing.Optional[list[list[yardl.Int32]]] = None,
        optional_named_array: typing.Optional[NamedNDArray] = None,
        int_float_union: Int32OrFloat32 = Int32OrFloat32.Int32(0),
        nullable_int_float_union: typing.Optional[Int32OrFloat32] = None,
        union_with_nested_generic_union: IntOrGenericRecordWithComputedFields = IntOrGenericRecordWithComputedFields.Int(0),
        map_field: typing.Optional[dict[str, str]] = None,
    ):
        self.array_field = array_field if array_field is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.array_field_map_dimensions = array_field_map_dimensions if array_field_map_dimensions is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.dynamic_array_field = dynamic_array_field if dynamic_array_field is not None else np.zeros((), dtype=np.dtype(np.int32))
        self.fixed_array_field = fixed_array_field if fixed_array_field is not None else np.zeros((3, 4,), dtype=np.dtype(np.int32))
        self.int_field = int_field
        self.int8_field = int8_field
        self.uint8_field = uint8_field
        self.int16_field = int16_field
        self.uint16_field = uint16_field
        self.uint32_field = uint32_field
        self.int64_field = int64_field
        self.uint64_field = uint64_field
        self.size_field = size_field
        self.float32_field = float32_field
        self.float64_field = float64_field
        self.complexfloat32_field = complexfloat32_field
        self.complexfloat64_field = complexfloat64_field
        self.string_field = string_field
        self.tuple_field = tuple_field if tuple_field is not None else tuples.Tuple(v1=0, v2=0)
        self.vector_field = vector_field if vector_field is not None else []
        self.vector_of_vectors_field = vector_of_vectors_field if vector_of_vectors_field is not None else []
        self.fixed_vector_field = fixed_vector_field if fixed_vector_field is not None else [0] * 3
        self.fixed_vector_of_vectors_field = fixed_vector_of_vectors_field if fixed_vector_of_vectors_field is not None else [[0] * 3 for _ in range(2)]
        self.optional_named_array = optional_named_array
        self.int_float_union = int_float_union
        self.nullable_int_float_union = nullable_int_float_union
        self.union_with_nested_generic_union = union_with_nested_generic_union
        self.map_field = map_field if map_field is not None else {}

    def int_literal(self) -> yardl.UInt8:
        return 42

    def large_negative_int64_literal(self) -> yardl.Int64:
        return -4611686018427387904

    def large_u_int64_literal(self) -> yardl.UInt64:
        return 9223372036854775808

    def string_literal(self) -> str:
        return "hello"

    def string_literal_2(self) -> str:
        return "hello"

    def string_literal_3(self) -> str:
        return "hello"

    def string_literal_4(self) -> str:
        return "hello"

    def access_other_computed_field(self) -> yardl.Int32:
        return self.int_field

    def access_int_field(self) -> yardl.Int32:
        return self.int_field

    def access_string_field(self) -> str:
        return self.string_field

    def access_tuple_field(self) -> MyTuple[yardl.Int32, yardl.Int32]:
        return self.tuple_field

    def access_nested_tuple_field(self) -> yardl.Int32:
        return self.tuple_field.v2

    def access_array_field(self) -> npt.NDArray[np.int32]:
        return self.array_field

    def access_array_field_element(self) -> yardl.Int32:
        return typing.cast(yardl.Int32, self.array_field[0, 1])

    def access_array_field_element_by_name(self) -> yardl.Int32:
        return typing.cast(yardl.Int32, self.array_field[0, 1])

    def access_vector_field(self) -> list[yardl.Int32]:
        return self.vector_field

    def access_vector_field_element(self) -> yardl.Int32:
        return self.vector_field[1]

    def access_vector_of_vectors_field(self) -> yardl.Int32:
        return self.vector_of_vectors_field[1][2]

    def access_fixed_vector_of_vectors_field(self) -> yardl.Int32:
        return self.fixed_vector_of_vectors_field[1][2]

    def array_size(self) -> yardl.Size:
        return self.array_field.size

    def array_x_size(self) -> yardl.Size:
        return self.array_field.shape[0]

    def array_y_size(self) -> yardl.Size:
        return self.array_field.shape[1]

    def array_0_size(self) -> yardl.Size:
        return self.array_field.shape[0]

    def array_1_size(self) -> yardl.Size:
        return self.array_field.shape[1]

    def array_size_from_int_field(self) -> yardl.Size:
        return self.array_field.shape[self.int_field]

    def array_size_from_string_field(self) -> yardl.Size:
        def _helper_0(dim_name: str) -> int:
            if dim_name == "x":
                return 0
            if dim_name == "y":
                return 1
            raise KeyError(f"Unknown dimension name: '{dim_name}'")

        return self.array_field.shape[_helper_0(self.string_field)]

    def array_size_from_nested_int_field(self) -> yardl.Size:
        return self.array_field.shape[self.tuple_field.v1]

    def array_field_map_dimensions_x_size(self) -> yardl.Size:
        return self.array_field_map_dimensions.shape[0]

    def fixed_array_size(self) -> yardl.Size:
        return 12

    def fixed_array_x_size(self) -> yardl.Size:
        return 3

    def fixed_array_0_size(self) -> yardl.Size:
        return 3

    def vector_size(self) -> yardl.Size:
        return len(self.vector_field)

    def fixed_vector_size(self) -> yardl.Size:
        return 3

    def fixed_vector_of_vectors_size(self) -> yardl.Size:
        return 2

    def array_dimension_x_index(self) -> yardl.Size:
        return 0

    def array_dimension_y_index(self) -> yardl.Size:
        return 1

    def array_dimension_index_from_string_field(self) -> yardl.Size:
        def _helper_0(dim_name: str) -> int:
            if dim_name == "x":
                return 0
            if dim_name == "y":
                return 1
            raise KeyError(f"Unknown dimension name: '{dim_name}'")

        return _helper_0(self.string_field)

    def array_dimension_count(self) -> yardl.Size:
        return 2

    def dynamic_array_dimension_count(self) -> yardl.Size:
        return self.dynamic_array_field.ndim

    def access_map(self) -> dict[str, str]:
        return self.map_field

    def map_size(self) -> yardl.Size:
        return len(self.map_field)

    def access_map_entry(self) -> str:
        return self.map_field["hello"]

    def string_computed_field(self) -> str:
        return "hello"

    def access_map_entry_with_computed_field(self) -> str:
        return self.map_field[self.string_computed_field()]

    def access_map_entry_with_computed_field_nested(self) -> str:
        return self.map_field[self.map_field[self.string_computed_field()]]

    def access_missing_map_entry(self) -> str:
        return self.map_field["missing"]

    def optional_named_array_length(self) -> yardl.Size:
        _var0 = self.optional_named_array
        if _var0 is not None:
            arr = _var0
            return arr.size
        return 0

    def optional_named_array_length_with_discard(self) -> yardl.Size:
        _var0 = self.optional_named_array
        if _var0 is not None:
            arr = _var0
            return arr.size
        return 0

    def int_float_union_as_float(self) -> yardl.Float32:
        _var0 = self.int_float_union
        if isinstance(_var0, Int32OrFloat32.Int32):
            i_foo = _var0.value
            return float(i_foo)
        if isinstance(_var0, Int32OrFloat32.Float32):
            f = _var0.value
            return f
        raise RuntimeError("Unexpected union case")

    def nullable_int_float_union_string(self) -> str:
        _var0 = self.nullable_int_float_union
        if _var0 is None:
            return "null"
        if isinstance(_var0, Int32OrFloat32.Int32):
            return "int"
        return "float"
        raise RuntimeError("Unexpected union case")

    def nested_switch(self) -> yardl.Int16:
        _var0 = self.union_with_nested_generic_union
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.Int):
            return -1
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields):
            rec = _var0.value
            _var1 = rec.f1
            if isinstance(_var1, basic_types.T0OrT1.T1):
                return int(20)
            if isinstance(_var1, basic_types.T0OrT1.T0):
                return int(10)
            raise RuntimeError("Unexpected union case")
        raise RuntimeError("Unexpected union case")

    def use_nested_computed_field(self) -> yardl.Int16:
        _var0 = self.union_with_nested_generic_union
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.Int):
            return -1
        if isinstance(_var0, IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields):
            rec = _var0.value
            return int(rec.type_index())
        raise RuntimeError("Unexpected union case")

    def switch_over_single_value(self) -> yardl.Int32:
        _var0 = self.int_field
        i = _var0
        return i

    def arithmetic_1(self) -> yardl.Int32:
        return 1 + 2

    def arithmetic_2(self) -> yardl.Int32:
        return 1 + 2 * 3 + 4

    def arithmetic_3(self) -> yardl.Int32:
        return (1 + 2) * 3 + 4

    def arithmetic_4(self) -> yardl.Size:
        return self.array_size_from_int_field() + 2

    def arithmetic_5(self) -> yardl.Size:
        return self.array_field.shape[2 - 1]

    def arithmetic_6(self) -> yardl.Int32:
        return 7 // 2

    def arithmetic_7(self) -> yardl.Float64:
        return float(7) ** float(2)

    def arithmetic8(self) -> yardl.ComplexFloat:
        return self.complexfloat32_field * complex(float(3))

    def arithmetic_9(self) -> yardl.Float64:
        return 1.2 + float(1)

    def arithmetic_10(self) -> yardl.Float64:
        return 1e10 + 9e9

    def arithmetic_11(self) -> yardl.Float64:
        return -(4.3 + float(1))

    def cast_int_to_float(self) -> yardl.Float32:
        return float(self.int_field)

    def cast_float_to_int(self) -> yardl.Int32:
        return int(self.float32_field)

    def cast_power(self) -> yardl.Int32:
        return int(float(7) ** float(2))

    def cast_complex32_to_complex64(self) -> yardl.ComplexDouble:
        return complex(self.complexfloat32_field)

    def cast_complex64_to_complex32(self) -> yardl.ComplexFloat:
        return complex(self.complexfloat64_field)

    def cast_float_to_complex(self) -> yardl.ComplexFloat:
        return complex(66.6)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithComputedFields)
            and yardl.structural_equal(self.array_field, other.array_field)
            and yardl.structural_equal(self.array_field_map_dimensions, other.array_field_map_dimensions)
            and yardl.structural_equal(self.dynamic_array_field, other.dynamic_array_field)
            and yardl.structural_equal(self.fixed_array_field, other.fixed_array_field)
            and self.int_field == other.int_field
            and self.int8_field == other.int8_field
            and self.uint8_field == other.uint8_field
            and self.int16_field == other.int16_field
            and self.uint16_field == other.uint16_field
            and self.uint32_field == other.uint32_field
            and self.int64_field == other.int64_field
            and self.uint64_field == other.uint64_field
            and self.size_field == other.size_field
            and self.float32_field == other.float32_field
            and self.float64_field == other.float64_field
            and self.complexfloat32_field == other.complexfloat32_field
            and self.complexfloat64_field == other.complexfloat64_field
            and self.string_field == other.string_field
            and self.tuple_field == other.tuple_field
            and self.vector_field == other.vector_field
            and self.vector_of_vectors_field == other.vector_of_vectors_field
            and self.fixed_vector_field == other.fixed_vector_field
            and self.fixed_vector_of_vectors_field == other.fixed_vector_of_vectors_field
            and (other.optional_named_array is None if self.optional_named_array is None else (other.optional_named_array is not None and yardl.structural_equal(self.optional_named_array, other.optional_named_array)))
            and self.int_float_union == other.int_float_union
            and self.nullable_int_float_union == other.nullable_int_float_union
            and self.union_with_nested_generic_union == other.union_with_nested_generic_union
            and self.map_field == other.map_field
        )

    def __str__(self) -> str:
        return f"RecordWithComputedFields(arrayField={self.array_field}, arrayFieldMapDimensions={self.array_field_map_dimensions}, dynamicArrayField={self.dynamic_array_field}, fixedArrayField={self.fixed_array_field}, intField={self.int_field}, int8Field={self.int8_field}, uint8Field={self.uint8_field}, int16Field={self.int16_field}, uint16Field={self.uint16_field}, uint32Field={self.uint32_field}, int64Field={self.int64_field}, uint64Field={self.uint64_field}, sizeField={self.size_field}, float32Field={self.float32_field}, float64Field={self.float64_field}, complexfloat32Field={self.complexfloat32_field}, complexfloat64Field={self.complexfloat64_field}, stringField={self.string_field}, tupleField={self.tuple_field}, vectorField={self.vector_field}, vectorOfVectorsField={self.vector_of_vectors_field}, fixedVectorField={self.fixed_vector_field}, fixedVectorOfVectorsField={self.fixed_vector_of_vectors_field}, optionalNamedArray={self.optional_named_array}, intFloatUnion={self.int_float_union}, nullableIntFloatUnion={self.nullable_int_float_union}, unionWithNestedGenericUnion={self.union_with_nested_generic_union}, mapField={self.map_field})"

    def __repr__(self) -> str:
        return f"RecordWithComputedFields(arrayField={repr(self.array_field)}, arrayFieldMapDimensions={repr(self.array_field_map_dimensions)}, dynamicArrayField={repr(self.dynamic_array_field)}, fixedArrayField={repr(self.fixed_array_field)}, intField={repr(self.int_field)}, int8Field={repr(self.int8_field)}, uint8Field={repr(self.uint8_field)}, int16Field={repr(self.int16_field)}, uint16Field={repr(self.uint16_field)}, uint32Field={repr(self.uint32_field)}, int64Field={repr(self.int64_field)}, uint64Field={repr(self.uint64_field)}, sizeField={repr(self.size_field)}, float32Field={repr(self.float32_field)}, float64Field={repr(self.float64_field)}, complexfloat32Field={repr(self.complexfloat32_field)}, complexfloat64Field={repr(self.complexfloat64_field)}, stringField={repr(self.string_field)}, tupleField={repr(self.tuple_field)}, vectorField={repr(self.vector_field)}, vectorOfVectorsField={repr(self.vector_of_vectors_field)}, fixedVectorField={repr(self.fixed_vector_field)}, fixedVectorOfVectorsField={repr(self.fixed_vector_of_vectors_field)}, optionalNamedArray={repr(self.optional_named_array)}, intFloatUnion={repr(self.int_float_union)}, nullableIntFloatUnion={repr(self.nullable_int_float_union)}, unionWithNestedGenericUnion={repr(self.union_with_nested_generic_union)}, mapField={repr(self.map_field)})"


class GenericUnionWithRepeatedTypeParameters(typing.Generic[T, T_NP]):
    T: type["GenericUnionWithRepeatedTypeParametersUnionCase[T, T_NP, T]"]
    Tv: type["GenericUnionWithRepeatedTypeParametersUnionCase[T, T_NP, list[T]]"]
    Ta: type["GenericUnionWithRepeatedTypeParametersUnionCase[T, T_NP, npt.NDArray[T_NP]]"]

class GenericUnionWithRepeatedTypeParametersUnionCase(GenericUnionWithRepeatedTypeParameters[T, T_NP], yardl.UnionCase[_T]):
    pass

GenericUnionWithRepeatedTypeParameters.T = type("GenericUnionWithRepeatedTypeParameters.T", (GenericUnionWithRepeatedTypeParametersUnionCase,), {"index": 0, "tag": "t"})
GenericUnionWithRepeatedTypeParameters.Tv = type("GenericUnionWithRepeatedTypeParameters.Tv", (GenericUnionWithRepeatedTypeParametersUnionCase,), {"index": 1, "tag": "tv"})
GenericUnionWithRepeatedTypeParameters.Ta = type("GenericUnionWithRepeatedTypeParameters.Ta", (GenericUnionWithRepeatedTypeParametersUnionCase,), {"index": 2, "tag": "ta"})
del GenericUnionWithRepeatedTypeParametersUnionCase

class GenericUnion3(typing.Generic[T, U, V]):
    T: type["GenericUnion3UnionCase[T, U, V, T]"]
    U: type["GenericUnion3UnionCase[T, U, V, U]"]
    V: type["GenericUnion3UnionCase[T, U, V, V]"]

class GenericUnion3UnionCase(GenericUnion3[T, U, V], yardl.UnionCase[_T]):
    pass

GenericUnion3.T = type("GenericUnion3.T", (GenericUnion3UnionCase,), {"index": 0, "tag": "T"})
GenericUnion3.U = type("GenericUnion3.U", (GenericUnion3UnionCase,), {"index": 1, "tag": "U"})
GenericUnion3.V = type("GenericUnion3.V", (GenericUnion3UnionCase,), {"index": 2, "tag": "V"})
del GenericUnion3UnionCase

class GenericUnion3Alternate(typing.Generic[U, V, W]):
    U: type["GenericUnion3AlternateUnionCase[U, V, W, U]"]
    V: type["GenericUnion3AlternateUnionCase[U, V, W, V]"]
    W: type["GenericUnion3AlternateUnionCase[U, V, W, W]"]

class GenericUnion3AlternateUnionCase(GenericUnion3Alternate[U, V, W], yardl.UnionCase[_T]):
    pass

GenericUnion3Alternate.U = type("GenericUnion3Alternate.U", (GenericUnion3AlternateUnionCase,), {"index": 0, "tag": "U"})
GenericUnion3Alternate.V = type("GenericUnion3Alternate.V", (GenericUnion3AlternateUnionCase,), {"index": 1, "tag": "V"})
GenericUnion3Alternate.W = type("GenericUnion3Alternate.W", (GenericUnion3AlternateUnionCase,), {"index": 2, "tag": "W"})
del GenericUnion3AlternateUnionCase

class RecordNotUsedInProtocol:
    u1: GenericUnion3[yardl.Int32, yardl.Float32, str]
    u2: GenericUnion3Alternate[yardl.Int32, yardl.Float32, str]

    def __init__(self, *,
        u1: GenericUnion3[yardl.Int32, yardl.Float32, str] = GenericUnion3[yardl.Int32, yardl.Float32, str].T(0),
        u2: GenericUnion3Alternate[yardl.Int32, yardl.Float32, str] = GenericUnion3Alternate[yardl.Int32, yardl.Float32, str].U(0),
    ):
        self.u1 = u1
        self.u2 = u2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordNotUsedInProtocol)
            and self.u1 == other.u1
            and self.u2 == other.u2
        )

    def __str__(self) -> str:
        return f"RecordNotUsedInProtocol(u1={self.u1}, u2={self.u2})"

    def __repr__(self) -> str:
        return f"RecordNotUsedInProtocol(u1={repr(self.u1)}, u2={repr(self.u2)})"


ArrayWithKeywordDimensionNames = npt.NDArray[np.int32]

class EnumWithKeywordSymbols(yardl.OutOfRangeEnum):
    TRY = 2
    CATCH = 1

class RecordWithKeywordFields:
    int_: str
    sizeof: ArrayWithKeywordDimensionNames
    if_: EnumWithKeywordSymbols

    def __init__(self, *,
        int_: str = "",
        sizeof: typing.Optional[ArrayWithKeywordDimensionNames] = None,
        if_: EnumWithKeywordSymbols,
    ):
        self.int_ = int_
        self.sizeof = sizeof if sizeof is not None else np.zeros((0, 0), dtype=np.dtype(np.int32))
        self.if_ = if_

    def float_(self) -> str:
        return self.int_

    def double(self) -> str:
        return self.float_()

    def return_(self) -> yardl.Int32:
        return self.sizeof[1, 2]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithKeywordFields)
            and self.int_ == other.int_
            and yardl.structural_equal(self.sizeof, other.sizeof)
            and self.if_ == other.if_
        )

    def __str__(self) -> str:
        return f"RecordWithKeywordFields(int={self.int_}, sizeof={self.sizeof}, if={self.if_})"

    def __repr__(self) -> str:
        return f"RecordWithKeywordFields(int={repr(self.int_)}, sizeof={repr(self.sizeof)}, if={repr(self.if_)})"


class RecordWithOptionalDate:
    date_field: typing.Optional[datetime.date]

    def __init__(self, *,
        date_field: typing.Optional[datetime.date] = None,
    ):
        self.date_field = date_field

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithOptionalDate)
            and self.date_field == other.date_field
        )

    def __str__(self) -> str:
        return f"RecordWithOptionalDate(dateField={self.date_field})"

    def __repr__(self) -> str:
        return f"RecordWithOptionalDate(dateField={repr(self.date_field)})"


class AcquisitionOrImage:
    Acquisition: typing.ClassVar[type["AcquisitionOrImageUnionCase[SimpleAcquisition]"]]
    Image: typing.ClassVar[type["AcquisitionOrImageUnionCase[image.Image[np.float32]]"]]

class AcquisitionOrImageUnionCase(AcquisitionOrImage, yardl.UnionCase[_T]):
    pass

AcquisitionOrImage.Acquisition = type("AcquisitionOrImage.Acquisition", (AcquisitionOrImageUnionCase,), {"index": 0, "tag": "acquisition"})
AcquisitionOrImage.Image = type("AcquisitionOrImage.Image", (AcquisitionOrImageUnionCase,), {"index": 1, "tag": "image"})
del AcquisitionOrImageUnionCase

class StringOrInt32:
    String: typing.ClassVar[type["StringOrInt32UnionCase[str]"]]
    Int32: typing.ClassVar[type["StringOrInt32UnionCase[yardl.Int32]"]]

class StringOrInt32UnionCase(StringOrInt32, yardl.UnionCase[_T]):
    pass

StringOrInt32.String = type("StringOrInt32.String", (StringOrInt32UnionCase,), {"index": 0, "tag": "string"})
StringOrInt32.Int32 = type("StringOrInt32.Int32", (StringOrInt32UnionCase,), {"index": 1, "tag": "int32"})
del StringOrInt32UnionCase

class Int32OrSimpleRecord:
    Int32: typing.ClassVar[type["Int32OrSimpleRecordUnionCase[yardl.Int32]"]]
    SimpleRecord: typing.ClassVar[type["Int32OrSimpleRecordUnionCase[SimpleRecord]"]]

class Int32OrSimpleRecordUnionCase(Int32OrSimpleRecord, yardl.UnionCase[_T]):
    pass

Int32OrSimpleRecord.Int32 = type("Int32OrSimpleRecord.Int32", (Int32OrSimpleRecordUnionCase,), {"index": 0, "tag": "int32"})
Int32OrSimpleRecord.SimpleRecord = type("Int32OrSimpleRecord.SimpleRecord", (Int32OrSimpleRecordUnionCase,), {"index": 1, "tag": "SimpleRecord"})
del Int32OrSimpleRecordUnionCase

class Int32OrRecordWithVlens:
    Int32: typing.ClassVar[type["Int32OrRecordWithVlensUnionCase[yardl.Int32]"]]
    RecordWithVlens: typing.ClassVar[type["Int32OrRecordWithVlensUnionCase[RecordWithVlens]"]]

class Int32OrRecordWithVlensUnionCase(Int32OrRecordWithVlens, yardl.UnionCase[_T]):
    pass

Int32OrRecordWithVlens.Int32 = type("Int32OrRecordWithVlens.Int32", (Int32OrRecordWithVlensUnionCase,), {"index": 0, "tag": "int32"})
Int32OrRecordWithVlens.RecordWithVlens = type("Int32OrRecordWithVlens.RecordWithVlens", (Int32OrRecordWithVlensUnionCase,), {"index": 1, "tag": "RecordWithVlens"})
del Int32OrRecordWithVlensUnionCase

class ImageFloatOrImageDouble:
    ImageFloat: typing.ClassVar[type["ImageFloatOrImageDoubleUnionCase[image.FloatImage]"]]
    ImageDouble: typing.ClassVar[type["ImageFloatOrImageDoubleUnionCase[Image[np.float64]]"]]

class ImageFloatOrImageDoubleUnionCase(ImageFloatOrImageDouble, yardl.UnionCase[_T]):
    pass

ImageFloatOrImageDouble.ImageFloat = type("ImageFloatOrImageDouble.ImageFloat", (ImageFloatOrImageDoubleUnionCase,), {"index": 0, "tag": "imageFloat"})
ImageFloatOrImageDouble.ImageDouble = type("ImageFloatOrImageDouble.ImageDouble", (ImageFloatOrImageDoubleUnionCase,), {"index": 1, "tag": "imageDouble"})
del ImageFloatOrImageDoubleUnionCase

def _mk_get_dtype():
    dtype_map: dict[typing.Union[type, types.GenericAlias], typing.Union[np.dtype[typing.Any], typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map.setdefault(tuples.Tuple, lambda type_args: np.dtype([('v1', get_dtype(type_args[0])), ('v2', get_dtype(type_args[1]))], align=True))
    dtype_map.setdefault(basic_types.Fruits, np.dtype(np.int32))
    dtype_map.setdefault(basic_types.DaysOfWeek, np.dtype(np.int32))
    dtype_map.setdefault(basic_types.TextFormat, np.dtype(np.uint64))
    dtype_map.setdefault(basic_types.MyTuple, lambda type_args: get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],))))
    dtype_map.setdefault(basic_types.GenericUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(basic_types.GenericNullableUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(basic_types.GenericNullableUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(basic_types.RecordWithUnions, np.dtype([('null_or_int_or_string', np.dtype(np.object_)), ('date_or_datetime', np.dtype(np.object_)), ('null_or_fruits_or_days_of_week', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(basic_types.Int32OrString, np.dtype(np.object_))
    dtype_map.setdefault(basic_types.Int32OrString.Int32, np.dtype(np.int32))
    dtype_map.setdefault(basic_types.Int32OrString.String, np.dtype(np.object_))
    dtype_map.setdefault(basic_types.TimeOrDatetime, np.dtype(np.object_))
    dtype_map.setdefault(basic_types.TimeOrDatetime.Time, np.dtype(np.timedelta64))
    dtype_map.setdefault(basic_types.TimeOrDatetime.Datetime, np.dtype(np.datetime64))
    dtype_map.setdefault(basic_types.GenericRecordWithComputedFields, lambda type_args: np.dtype([('f1', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(basic_types.T0OrT1, np.dtype(np.object_))
    dtype_map.setdefault(SmallBenchmarkRecord, np.dtype([('a', np.dtype(np.float64)), ('b', np.dtype(np.float32)), ('c', np.dtype(np.float32))], align=True))
    dtype_map.setdefault(SimpleEncodingCounters, np.dtype([('e1', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('e2', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('slice', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True)), ('repetition', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.uint32))], align=True))], align=True))
    dtype_map.setdefault(SimpleAcquisition, np.dtype([('flags', np.dtype(np.uint64)), ('idx', get_dtype(SimpleEncodingCounters)), ('data', np.dtype(np.object_)), ('trajectory', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(SimpleRecord, np.dtype([('x', np.dtype(np.int32)), ('y', np.dtype(np.int32)), ('z', np.dtype(np.int32))], align=True))
    dtype_map.setdefault(RecordWithPrimitives, np.dtype([('bool_field', np.dtype(np.bool_)), ('int8_field', np.dtype(np.int8)), ('uint8_field', np.dtype(np.uint8)), ('int16_field', np.dtype(np.int16)), ('uint16_field', np.dtype(np.uint16)), ('int32_field', np.dtype(np.int32)), ('uint32_field', np.dtype(np.uint32)), ('int64_field', np.dtype(np.int64)), ('uint64_field', np.dtype(np.uint64)), ('size_field', np.dtype(np.uint64)), ('float32_field', np.dtype(np.float32)), ('float64_field', np.dtype(np.float64)), ('complexfloat32_field', np.dtype(np.complex64)), ('complexfloat64_field', np.dtype(np.complex128)), ('date_field', np.dtype(np.datetime64)), ('time_field', np.dtype(np.timedelta64)), ('datetime_field', np.dtype(np.datetime64))], align=True))
    dtype_map.setdefault(RecordWithPrimitiveAliases, np.dtype([('byte_field', np.dtype(np.uint8)), ('int_field', np.dtype(np.int32)), ('uint_field', np.dtype(np.uint32)), ('long_field', np.dtype(np.int64)), ('ulong_field', np.dtype(np.uint64)), ('float_field', np.dtype(np.float32)), ('double_field', np.dtype(np.float64)), ('complexfloat_field', np.dtype(np.complex64)), ('complexdouble_field', np.dtype(np.complex128))], align=True))
    dtype_map.setdefault(TupleWithRecords, np.dtype([('a', get_dtype(SimpleRecord)), ('b', get_dtype(SimpleRecord))], align=True))
    dtype_map.setdefault(RecordWithVectors, np.dtype([('default_vector', np.dtype(np.object_)), ('default_vector_fixed_length', np.dtype(np.int32), (3,)), ('vector_of_vectors', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithVectorOfTimes, np.dtype([('times', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithArrays, np.dtype([('default_array', np.dtype(np.object_)), ('default_array_with_empty_dimension', np.dtype(np.object_)), ('rank_1_array', np.dtype(np.object_)), ('rank_2_array', np.dtype(np.object_)), ('rank_2_array_with_named_dimensions', np.dtype(np.object_)), ('rank_2_fixed_array', np.dtype(np.int32), (3, 4,)), ('rank_2_fixed_array_with_named_dimensions', np.dtype(np.int32), (3, 4,)), ('dynamic_array', np.dtype(np.object_)), ('array_of_vectors', np.dtype(np.int32), (5,))], align=True))
    dtype_map.setdefault(RecordWithArraysSimpleSyntax, np.dtype([('default_array', np.dtype(np.object_)), ('default_array_with_empty_dimension', np.dtype(np.object_)), ('rank_1_array', np.dtype(np.object_)), ('rank_2_array', np.dtype(np.object_)), ('rank_2_array_with_named_dimensions', np.dtype(np.object_)), ('rank_2_fixed_array', np.dtype(np.int32), (3, 4,)), ('rank_2_fixed_array_with_named_dimensions', np.dtype(np.int32), (3, 4,)), ('dynamic_array', np.dtype(np.object_)), ('array_of_vectors', np.dtype(np.int32), (5,))], align=True))
    dtype_map.setdefault(RecordWithOptionalFields, np.dtype([('optional_int', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optional_int_alternate_syntax', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True)), ('optional_time', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.timedelta64))], align=True))], align=True))
    dtype_map.setdefault(RecordWithVlens, np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.int32)), ('c', np.dtype(np.int32))], align=True))
    dtype_map.setdefault(RecordWithStrings, np.dtype([('a', np.dtype(np.object_)), ('b', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithOptionalVector, np.dtype([('optional_vector', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(RecordWithFixedVectors, np.dtype([('fixed_int_vector', np.dtype(np.int32), (5,)), ('fixed_simple_record_vector', get_dtype(SimpleRecord), (3,)), ('fixed_record_with_vlens_vector', get_dtype(RecordWithVlens), (2,))], align=True))
    dtype_map.setdefault(RecordWithFixedArrays, np.dtype([('ints', np.dtype(np.int32), (2, 3,)), ('fixed_simple_record_array', get_dtype(SimpleRecord), (3, 2,)), ('fixed_record_with_vlens_array', get_dtype(RecordWithVlens), (2, 2,))], align=True))
    dtype_map.setdefault(RecordWithNamedFixedArrays, np.dtype([('ints', np.dtype(np.int32), (2, 3,)), ('fixed_simple_record_array', get_dtype(SimpleRecord), (3, 2,)), ('fixed_record_with_vlens_array', get_dtype(RecordWithVlens), (2, 2,))], align=True))
    dtype_map.setdefault(RecordWithNDArrays, np.dtype([('ints', np.dtype(np.object_)), ('fixed_simple_record_array', np.dtype(np.object_)), ('fixed_record_with_vlens_array', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithNDArraysSingleDimension, np.dtype([('ints', np.dtype(np.object_)), ('fixed_simple_record_array', np.dtype(np.object_)), ('fixed_record_with_vlens_array', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithDynamicNDArrays, np.dtype([('ints', np.dtype(np.object_)), ('simple_record_array', np.dtype(np.object_)), ('record_with_vlens_array', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithFixedCollections, np.dtype([('fixed_vector', np.dtype(np.int32), (3,)), ('fixed_array', np.dtype(np.int32), (2, 3,))], align=True))
    dtype_map.setdefault(RecordWithVlenCollections, np.dtype([('vector', np.dtype(np.object_)), ('array', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithUnionsOfContainers, np.dtype([('map_or_scalar', np.dtype(np.object_)), ('vector_or_scalar', np.dtype(np.object_)), ('array_or_scalar', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(MapOrScalar, np.dtype(np.object_))
    dtype_map.setdefault(MapOrScalar.Map, np.dtype(np.object_))
    dtype_map.setdefault(MapOrScalar.Scalar, np.dtype(np.int32))
    dtype_map.setdefault(VectorOrScalar, np.dtype(np.object_))
    dtype_map.setdefault(VectorOrScalar.Vector, np.dtype(np.object_))
    dtype_map.setdefault(VectorOrScalar.Scalar, np.dtype(np.int32))
    dtype_map.setdefault(ArrayOrScalar, np.dtype(np.object_))
    dtype_map.setdefault(ArrayOrScalar.Array, np.dtype(np.object_))
    dtype_map.setdefault(ArrayOrScalar.Scalar, np.dtype(np.int32))
    dtype_map.setdefault(Fruits, get_dtype(basic_types.Fruits))
    dtype_map.setdefault(UInt64Enum, np.dtype(np.uint64))
    dtype_map.setdefault(Int64Enum, np.dtype(np.int64))
    dtype_map.setdefault(SizeBasedEnum, np.dtype(np.uint64))
    dtype_map.setdefault(DaysOfWeek, get_dtype(basic_types.DaysOfWeek))
    dtype_map.setdefault(TextFormat, get_dtype(basic_types.TextFormat))
    dtype_map.setdefault(RecordWithEnums, np.dtype([('enum', get_dtype(basic_types.Fruits)), ('flags', get_dtype(basic_types.DaysOfWeek)), ('flags_2', get_dtype(basic_types.TextFormat))], align=True))
    dtype_map.setdefault(GenericRecord, lambda type_args: np.dtype([('scalar_1', get_dtype(type_args[0])), ('scalar_2', get_dtype(type_args[1])), ('vector_1', np.dtype(np.object_)), ('image_2', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(MyTuple, lambda type_args: get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],))))
    dtype_map.setdefault(AliasedTuple, lambda type_args: get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],))))
    dtype_map.setdefault(RecordWithAliasedGenerics, np.dtype([('my_strings', get_dtype(types.GenericAlias(tuples.Tuple, (str, str,)))), ('aliased_strings', get_dtype(types.GenericAlias(tuples.Tuple, (str, str,))))], align=True))
    dtype_map.setdefault(AliasedString, np.dtype(np.object_))
    dtype_map.setdefault(AliasedEnum, get_dtype(basic_types.Fruits))
    dtype_map.setdefault(AliasedSimpleRecord, get_dtype(SimpleRecord))
    dtype_map.setdefault(AliasedOpenGeneric, lambda type_args: get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],))))
    dtype_map.setdefault(AliasedClosedGeneric, get_dtype(types.GenericAlias(tuples.Tuple, (AliasedString, AliasedEnum,))))
    dtype_map.setdefault(AliasedOptional, np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.int32))], align=True))
    dtype_map.setdefault(AliasedGenericOptional, lambda type_args: np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(type_args[0]))], align=True))
    dtype_map.setdefault(AliasedMultiGenericOptional, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(AliasedMultiGenericOptional, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(AliasedGenericUnion2, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(RecordWithGenericVectorOfRecords, lambda type_args: np.dtype([('v', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithOptionalGenericField, lambda type_args: np.dtype([('v', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(type_args[0]))], align=True))], align=True))
    dtype_map.setdefault(RecordWithAliasedOptionalGenericField, lambda type_args: np.dtype([('v', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(type_args[0]))], align=True))], align=True))
    dtype_map.setdefault(RecordWithOptionalGenericUnionField, lambda type_args: np.dtype([('v', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(UOrV, np.dtype(np.object_))
    dtype_map.setdefault(RecordWithAliasedOptionalGenericUnionField, lambda type_args: np.dtype([('v', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithGenericVectors, lambda type_args: np.dtype([('v', np.dtype(np.object_)), ('av', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithGenericFixedVectors, lambda type_args: np.dtype([('fv', get_dtype(type_args[0]), (3,)), ('afv', get_dtype(type_args[0]), (3,))], align=True))
    dtype_map.setdefault(RecordWithGenericArrays, lambda type_args: np.dtype([('nd', np.dtype(np.object_)), ('fixed_nd', get_dtype(type_args[0]), (16, 8,)), ('dynamic_nd', np.dtype(np.object_)), ('aliased_nd', np.dtype(np.object_)), ('aliased_fixed_nd', get_dtype(type_args[0]), (16, 8,)), ('aliased_dynamic_nd', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordWithGenericMaps, lambda type_args: np.dtype([('m', np.dtype(np.object_)), ('am', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(RecordContainingGenericRecords, lambda type_args: np.dtype([('g1', get_dtype(types.GenericAlias(RecordWithOptionalGenericField, (type_args[0],)))), ('g1a', get_dtype(types.GenericAlias(RecordWithAliasedOptionalGenericField, (type_args[0],)))), ('g2', get_dtype(types.GenericAlias(RecordWithOptionalGenericUnionField, (type_args[0], type_args[1],)))), ('g2a', get_dtype(types.GenericAlias(RecordWithAliasedOptionalGenericUnionField, (type_args[0], type_args[1],)))), ('g3', get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],)))), ('g3a', get_dtype(types.GenericAlias(tuples.Tuple, (type_args[0], type_args[1],)))), ('g4', get_dtype(types.GenericAlias(RecordWithGenericVectors, (type_args[1],)))), ('g5', get_dtype(types.GenericAlias(RecordWithGenericFixedVectors, (type_args[1],)))), ('g6', get_dtype(types.GenericAlias(RecordWithGenericArrays, (type_args[1],)))), ('g7', get_dtype(types.GenericAlias(RecordWithGenericMaps, (type_args[0], type_args[1],))))], align=True))
    dtype_map.setdefault(RecordContainingNestedGenericRecords, np.dtype([('f1', get_dtype(types.GenericAlias(RecordWithOptionalGenericField, (str,)))), ('f1a', get_dtype(types.GenericAlias(RecordWithAliasedOptionalGenericField, (str,)))), ('f2', get_dtype(types.GenericAlias(RecordWithOptionalGenericUnionField, (str, yardl.Int32,)))), ('f2a', get_dtype(types.GenericAlias(RecordWithAliasedOptionalGenericUnionField, (str, yardl.Int32,)))), ('nested', get_dtype(types.GenericAlias(RecordContainingGenericRecords, (str, yardl.Int32,))))], align=True))
    dtype_map.setdefault(AliasedIntOrSimpleRecord, np.dtype(np.object_))
    dtype_map.setdefault(AliasedIntOrAliasedSimpleRecord, np.dtype(np.object_))
    dtype_map.setdefault(typing.Optional[AliasedNullableIntSimpleRecord], np.dtype(np.object_))
    dtype_map.setdefault(AliasedNullableIntSimpleRecord, np.dtype(np.object_))
    dtype_map.setdefault(AliasedNullableIntSimpleRecord.Int32, np.dtype(np.int32))
    dtype_map.setdefault(AliasedNullableIntSimpleRecord.SimpleRecord, get_dtype(SimpleRecord))
    dtype_map.setdefault(RecordWithIntVectors, get_dtype(types.GenericAlias(RecordWithGenericVectors, (yardl.Int32,))))
    dtype_map.setdefault(RecordWithFloatArrays, get_dtype(types.GenericAlias(RecordWithGenericArrays, (yardl.Float32,))))
    dtype_map.setdefault(UnionOfContainerRecords, np.dtype(np.object_))
    dtype_map.setdefault(RecordWithComputedFields, np.dtype([('array_field', np.dtype(np.object_)), ('array_field_map_dimensions', np.dtype(np.object_)), ('dynamic_array_field', np.dtype(np.object_)), ('fixed_array_field', np.dtype(np.int32), (3, 4,)), ('int_field', np.dtype(np.int32)), ('int8_field', np.dtype(np.int8)), ('uint8_field', np.dtype(np.uint8)), ('int16_field', np.dtype(np.int16)), ('uint16_field', np.dtype(np.uint16)), ('uint32_field', np.dtype(np.uint32)), ('int64_field', np.dtype(np.int64)), ('uint64_field', np.dtype(np.uint64)), ('size_field', np.dtype(np.uint64)), ('float32_field', np.dtype(np.float32)), ('float64_field', np.dtype(np.float64)), ('complexfloat32_field', np.dtype(np.complex64)), ('complexfloat64_field', np.dtype(np.complex128)), ('string_field', np.dtype(np.object_)), ('tuple_field', get_dtype(types.GenericAlias(tuples.Tuple, (yardl.Int32, yardl.Int32,)))), ('vector_field', np.dtype(np.object_)), ('vector_of_vectors_field', np.dtype(np.object_)), ('fixed_vector_field', np.dtype(np.int32), (3,)), ('fixed_vector_of_vectors_field', np.dtype(np.int32), (2,)), ('optional_named_array', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('int_float_union', np.dtype(np.object_)), ('nullable_int_float_union', np.dtype(np.object_)), ('union_with_nested_generic_union', np.dtype(np.object_)), ('map_field', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(Int32OrFloat32, np.dtype(np.object_))
    dtype_map.setdefault(Int32OrFloat32.Int32, np.dtype(np.int32))
    dtype_map.setdefault(Int32OrFloat32.Float32, np.dtype(np.float32))
    dtype_map.setdefault(IntOrGenericRecordWithComputedFields, np.dtype(np.object_))
    dtype_map.setdefault(IntOrGenericRecordWithComputedFields.Int, np.dtype(np.int32))
    dtype_map.setdefault(IntOrGenericRecordWithComputedFields.GenericRecordWithComputedFields, get_dtype(types.GenericAlias(basic_types.GenericRecordWithComputedFields, (str, yardl.Float32,))))
    dtype_map.setdefault(GenericUnionWithRepeatedTypeParameters, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(GenericUnion3, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(GenericUnion3Alternate, lambda type_args: np.dtype(np.object_))
    dtype_map.setdefault(RecordNotUsedInProtocol, np.dtype([('u1', np.dtype(np.object_)), ('u2', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(EnumWithKeywordSymbols, np.dtype(np.int32))
    dtype_map.setdefault(RecordWithKeywordFields, np.dtype([('int_', np.dtype(np.object_)), ('sizeof', np.dtype(np.object_)), ('if_', get_dtype(EnumWithKeywordSymbols))], align=True))
    dtype_map.setdefault(RecordWithOptionalDate, np.dtype([('date_field', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.datetime64))], align=True))], align=True))
    dtype_map.setdefault(AcquisitionOrImage, np.dtype(np.object_))
    dtype_map.setdefault(AcquisitionOrImage.Acquisition, get_dtype(SimpleAcquisition))
    dtype_map.setdefault(AcquisitionOrImage.Image, np.dtype(np.object_))
    dtype_map.setdefault(StringOrInt32, np.dtype(np.object_))
    dtype_map.setdefault(StringOrInt32.String, np.dtype(np.object_))
    dtype_map.setdefault(StringOrInt32.Int32, np.dtype(np.int32))
    dtype_map.setdefault(Int32OrSimpleRecord, np.dtype(np.object_))
    dtype_map.setdefault(Int32OrSimpleRecord.Int32, np.dtype(np.int32))
    dtype_map.setdefault(Int32OrSimpleRecord.SimpleRecord, get_dtype(SimpleRecord))
    dtype_map.setdefault(Int32OrRecordWithVlens, np.dtype(np.object_))
    dtype_map.setdefault(Int32OrRecordWithVlens.Int32, np.dtype(np.int32))
    dtype_map.setdefault(Int32OrRecordWithVlens.RecordWithVlens, get_dtype(RecordWithVlens))
    dtype_map.setdefault(ImageFloatOrImageDouble, np.dtype(np.object_))
    dtype_map.setdefault(ImageFloatOrImageDouble.ImageFloat, np.dtype(np.object_))
    dtype_map.setdefault(ImageFloatOrImageDouble.ImageDouble, np.dtype(np.object_))

    return get_dtype

get_dtype = _mk_get_dtype()

