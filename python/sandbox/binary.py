# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedClass=false

import collections.abc
import datetime
import io
import typing
import numpy as np
import numpy.typing as npt

from . import *
from . import _binary
from . import yardl_types as yardl

T = typing.TypeVar('T')
T_NP = typing.TypeVar('T_NP', bound=np.generic)

class BinaryPWriter(_binary.BinaryProtocolWriter, PWriterBase):
    """Binary writer for the P protocol."""


    def __init__(self, stream: typing.BinaryIO | str) -> None:
        PWriterBase.__init__(self)
        _binary.BinaryProtocolWriter.__init__(self, stream, PWriterBase.schema)

    def _write_a(self, value: Line[yardl.Int32]) -> None:
        _LineSerializer(_binary.int32_serializer).write(self._stream, value)


class BinaryPReader(_binary.BinaryProtocolReader, PReaderBase):
    """Binary writer for the P protocol."""


    def __init__(self, stream: io.BufferedReader | str, read_as_numpy: Types) -> None:
        PReaderBase.__init__(self, read_as_numpy)
        _binary.BinaryProtocolReader.__init__(self, stream, PReaderBase.schema)

    def _read_a(self) -> Line[yardl.Int32]:
        return _LineSerializer(_binary.int32_serializer).read(self._stream, self._read_as_numpy)

class _PTSerializer(typing.Generic[T, T_NP], _binary.RecordSerializer[PT[T]]):
    def __init__(self, t_serializer: _binary.TypeSerializer[T, T_NP]) -> None:
        super().__init__([("x", t_serializer), ("y", t_serializer)])

    def write(self, stream: _binary.CodedOutputStream, value: PT[T]) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.x, value.y)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['x'], value['y'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> PT[T]:
        field_values = self._read(stream, read_as_numpy)
        return PT[T](x=field_values[0], y=field_values[1])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        if not isinstance(value, PT):
            return False
        return (
            self._field_serializers[0][1].is_value_supported(value.x)
            and self._field_serializers[1][1].is_value_supported(value.y)
        )


class _PFloatSerializer(_binary.RecordSerializer[PFloat]):
    def __init__(self) -> None:
        super().__init__([("x", _binary.float32_serializer), ("y", _binary.float32_serializer)])

    def write(self, stream: _binary.CodedOutputStream, value: PFloat) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.x, value.y)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['x'], value['y'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> PFloat:
        field_values = self._read(stream, read_as_numpy)
        return PFloat(x=field_values[0], y=field_values[1])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        return isinstance(value, PFloat)


class _PIntSerializer(_binary.RecordSerializer[PInt]):
    def __init__(self) -> None:
        super().__init__([("x", _binary.int32_serializer), ("y", _binary.int32_serializer)])

    def write(self, stream: _binary.CodedOutputStream, value: PInt) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.x, value.y)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['x'], value['y'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> PInt:
        field_values = self._read(stream, read_as_numpy)
        return PInt(x=field_values[0], y=field_values[1])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        return isinstance(value, PInt)


class _ASerializer(_binary.RecordSerializer[A]):
    def __init__(self) -> None:
        super().__init__([("pi", _binary.int32_serializer)])

    def write(self, stream: _binary.CodedOutputStream, value: A) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.pi)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['pi'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> A:
        field_values = self._read(stream, read_as_numpy)
        return A(pi=field_values[0])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        return isinstance(value, A)


class _LineSerializer(typing.Generic[T, T_NP], _binary.RecordSerializer[Line[T]]):
    def __init__(self, t_serializer: _binary.TypeSerializer[T, T_NP]) -> None:
        super().__init__([("start", _PTSerializer(t_serializer)), ("end", _PTSerializer(t_serializer))])

    def write(self, stream: _binary.CodedOutputStream, value: Line[T]) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.start, value.end)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['start'], value['end'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> Line[T]:
        field_values = self._read(stream, read_as_numpy)
        return Line[T](start=field_values[0], end=field_values[1])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        if not isinstance(value, Line):
            return False
        return (
            self._field_serializers[0][1].is_value_supported(value.start)
            and self._field_serializers[1][1].is_value_supported(value.end)
        )


class _FooSerializer(_binary.RecordSerializer[Foo]):
    def __init__(self) -> None:
        super().__init__([("a", _binary.int32_serializer), ("b", _binary.NDArraySerializer(_binary.float32_serializer, 2))])

    def write(self, stream: _binary.CodedOutputStream, value: Foo) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.a, value.b)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['a'], value['b'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> Foo:
        field_values = self._read(stream, read_as_numpy)
        return Foo(a=field_values[0], b=field_values[1])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        return isinstance(value, Foo)


class _PersonSerializer(_binary.RecordSerializer[Person]):
    def __init__(self) -> None:
        super().__init__([("numbers", _binary.FixedNDArraySerializer(_PTSerializer(_binary.int32_serializer), (2, 2,))), ("d", _binary.datetime_serializer)])

    def write(self, stream: _binary.CodedOutputStream, value: Person) -> None:
        if isinstance(value, np.void):
            self.write_numpy(stream, value)
            return
        self._write(stream, value.numbers, value.d)

    def write_numpy(self, stream: _binary.CodedOutputStream, value: np.void) -> None:
        self._write(stream, value['numbers'], value['d'])

    def read(self, stream: _binary.CodedInputStream, read_as_numpy: Types) -> Person:
        field_values = self._read(stream, read_as_numpy)
        return Person(numbers=field_values[0], d=field_values[1])

    def is_value_supported(self, value: Any) -> bool:
        if isinstance(value, np.void) and value.dtype == self.overall_dtype():
            return True

        return isinstance(value, Person)


