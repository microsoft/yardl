// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include <array>
#include <complex>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "../yardl/detail/binary/reader_writer.h"
#include "../protocols.h"
#include "../types.h"

namespace test_model::binary {
// Binary writer for the BenchmarkFloat256x256 protocol.
class BenchmarkFloat256x256Writer : public test_model::BenchmarkFloat256x256WriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  BenchmarkFloat256x256Writer(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteFloat256x256Impl(yardl::FixedNDArray<float, 256, 256> const& value) override;
  void WriteFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>> const& values) override;
  void EndFloat256x256Impl() override;
  void CloseImpl() override;
};

// Binary reader for the BenchmarkFloat256x256 protocol.
class BenchmarkFloat256x256Reader : public test_model::BenchmarkFloat256x256ReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  BenchmarkFloat256x256Reader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadFloat256x256Impl(yardl::FixedNDArray<float, 256, 256>& value) override;
  bool ReadFloat256x256Impl(std::vector<yardl::FixedNDArray<float, 256, 256>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the BenchmarkFloatVlen protocol.
class BenchmarkFloatVlenWriter : public test_model::BenchmarkFloatVlenWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  BenchmarkFloatVlenWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteFloatArrayImpl(yardl::NDArray<float, 2> const& value) override;
  void WriteFloatArrayImpl(std::vector<yardl::NDArray<float, 2>> const& values) override;
  void EndFloatArrayImpl() override;
  void CloseImpl() override;
};

// Binary reader for the BenchmarkFloatVlen protocol.
class BenchmarkFloatVlenReader : public test_model::BenchmarkFloatVlenReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  BenchmarkFloatVlenReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadFloatArrayImpl(yardl::NDArray<float, 2>& value) override;
  bool ReadFloatArrayImpl(std::vector<yardl::NDArray<float, 2>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the BenchmarkSmallRecord protocol.
class BenchmarkSmallRecordWriter : public test_model::BenchmarkSmallRecordWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  BenchmarkSmallRecordWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteSmallRecordImpl(test_model::SmallBenchmarkRecord const& value) override;
  void WriteSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord> const& values) override;
  void EndSmallRecordImpl() override;
  void CloseImpl() override;
};

// Binary reader for the BenchmarkSmallRecord protocol.
class BenchmarkSmallRecordReader : public test_model::BenchmarkSmallRecordReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  BenchmarkSmallRecordReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadSmallRecordImpl(test_model::SmallBenchmarkRecord& value) override;
  bool ReadSmallRecordImpl(std::vector<test_model::SmallBenchmarkRecord>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the BenchmarkSmallRecordWithOptionals protocol.
class BenchmarkSmallRecordWithOptionalsWriter : public test_model::BenchmarkSmallRecordWithOptionalsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  BenchmarkSmallRecordWithOptionalsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteSmallRecordImpl(test_model::SimpleEncodingCounters const& value) override;
  void WriteSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters> const& values) override;
  void EndSmallRecordImpl() override;
  void CloseImpl() override;
};

// Binary reader for the BenchmarkSmallRecordWithOptionals protocol.
class BenchmarkSmallRecordWithOptionalsReader : public test_model::BenchmarkSmallRecordWithOptionalsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  BenchmarkSmallRecordWithOptionalsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadSmallRecordImpl(test_model::SimpleEncodingCounters& value) override;
  bool ReadSmallRecordImpl(std::vector<test_model::SimpleEncodingCounters>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the BenchmarkSimpleMrd protocol.
class BenchmarkSimpleMrdWriter : public test_model::BenchmarkSimpleMrdWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  BenchmarkSimpleMrdWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteDataImpl(std::variant<test_model::SimpleAcquisition, test_model::Image<float>> const& value) override;
  void WriteDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>> const& values) override;
  void EndDataImpl() override;
  void CloseImpl() override;
};

// Binary reader for the BenchmarkSimpleMrd protocol.
class BenchmarkSimpleMrdReader : public test_model::BenchmarkSimpleMrdReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  BenchmarkSimpleMrdReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadDataImpl(std::variant<test_model::SimpleAcquisition, test_model::Image<float>>& value) override;
  bool ReadDataImpl(std::vector<std::variant<test_model::SimpleAcquisition, test_model::Image<float>>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the Scalars protocol.
class ScalarsWriter : public test_model::ScalarsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  ScalarsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteInt32Impl(int32_t const& value) override;
  void WriteRecordImpl(test_model::RecordWithPrimitives const& value) override;
  void CloseImpl() override;
};

// Binary reader for the Scalars protocol.
class ScalarsReader : public test_model::ScalarsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  ScalarsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadInt32Impl(int32_t& value) override;
  void ReadRecordImpl(test_model::RecordWithPrimitives& value) override;
  void CloseImpl() override;
};

// Binary writer for the ScalarOptionals protocol.
class ScalarOptionalsWriter : public test_model::ScalarOptionalsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  ScalarOptionalsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteOptionalIntImpl(std::optional<int32_t> const& value) override;
  void WriteOptionalRecordImpl(std::optional<test_model::SimpleRecord> const& value) override;
  void WriteRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields const& value) override;
  void WriteOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields> const& value) override;
  void CloseImpl() override;
};

// Binary reader for the ScalarOptionals protocol.
class ScalarOptionalsReader : public test_model::ScalarOptionalsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  ScalarOptionalsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadOptionalIntImpl(std::optional<int32_t>& value) override;
  void ReadOptionalRecordImpl(std::optional<test_model::SimpleRecord>& value) override;
  void ReadRecordWithOptionalFieldsImpl(test_model::RecordWithOptionalFields& value) override;
  void ReadOptionalRecordWithOptionalFieldsImpl(std::optional<test_model::RecordWithOptionalFields>& value) override;
  void CloseImpl() override;
};

// Binary writer for the NestedRecords protocol.
class NestedRecordsWriter : public test_model::NestedRecordsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  NestedRecordsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteTupleWithRecordsImpl(test_model::TupleWithRecords const& value) override;
  void CloseImpl() override;
};

// Binary reader for the NestedRecords protocol.
class NestedRecordsReader : public test_model::NestedRecordsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  NestedRecordsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadTupleWithRecordsImpl(test_model::TupleWithRecords& value) override;
  void CloseImpl() override;
};

// Binary writer for the Vlens protocol.
class VlensWriter : public test_model::VlensWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  VlensWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntVectorImpl(std::vector<int32_t> const& value) override;
  void WriteComplexVectorImpl(std::vector<std::complex<float>> const& value) override;
  void WriteRecordWithVlensImpl(test_model::RecordWithVlens const& value) override;
  void WriteVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens> const& value) override;
  void CloseImpl() override;
};

// Binary reader for the Vlens protocol.
class VlensReader : public test_model::VlensReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  VlensReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntVectorImpl(std::vector<int32_t>& value) override;
  void ReadComplexVectorImpl(std::vector<std::complex<float>>& value) override;
  void ReadRecordWithVlensImpl(test_model::RecordWithVlens& value) override;
  void ReadVlenOfRecordWithVlensImpl(std::vector<test_model::RecordWithVlens>& value) override;
  void CloseImpl() override;
};

// Binary writer for the Strings protocol.
class StringsWriter : public test_model::StringsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  StringsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteSingleStringImpl(std::string const& value) override;
  void WriteRecWithStringImpl(test_model::RecordWithStrings const& value) override;
  void CloseImpl() override;
};

// Binary reader for the Strings protocol.
class StringsReader : public test_model::StringsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  StringsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadSingleStringImpl(std::string& value) override;
  void ReadRecWithStringImpl(test_model::RecordWithStrings& value) override;
  void CloseImpl() override;
};

// Binary writer for the OptionalVectors protocol.
class OptionalVectorsWriter : public test_model::OptionalVectorsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  OptionalVectorsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector const& value) override;
  void CloseImpl() override;
};

// Binary reader for the OptionalVectors protocol.
class OptionalVectorsReader : public test_model::OptionalVectorsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  OptionalVectorsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadRecordWithOptionalVectorImpl(test_model::RecordWithOptionalVector& value) override;
  void CloseImpl() override;
};

// Binary writer for the FixedVectors protocol.
class FixedVectorsWriter : public test_model::FixedVectorsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  FixedVectorsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteFixedIntVectorImpl(std::array<int32_t, 5> const& value) override;
  void WriteFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3> const& value) override;
  void WriteFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2> const& value) override;
  void WriteRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors const& value) override;
  void CloseImpl() override;
};

// Binary reader for the FixedVectors protocol.
class FixedVectorsReader : public test_model::FixedVectorsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  FixedVectorsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadFixedIntVectorImpl(std::array<int32_t, 5>& value) override;
  void ReadFixedSimpleRecordVectorImpl(std::array<test_model::SimpleRecord, 3>& value) override;
  void ReadFixedRecordWithVlensVectorImpl(std::array<test_model::RecordWithVlens, 2>& value) override;
  void ReadRecordWithFixedVectorsImpl(test_model::RecordWithFixedVectors& value) override;
  void CloseImpl() override;
};

// Binary writer for the Streams protocol.
class StreamsWriter : public test_model::StreamsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  StreamsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntDataImpl(int32_t const& value) override;
  void WriteIntDataImpl(std::vector<int32_t> const& values) override;
  void EndIntDataImpl() override;
  void WriteOptionalIntDataImpl(std::optional<int32_t> const& value) override;
  void WriteOptionalIntDataImpl(std::vector<std::optional<int32_t>> const& values) override;
  void EndOptionalIntDataImpl() override;
  void WriteRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector const& value) override;
  void WriteRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector> const& values) override;
  void EndRecordWithOptionalVectorDataImpl() override;
  void WriteFixedVectorImpl(std::array<int32_t, 3> const& value) override;
  void WriteFixedVectorImpl(std::vector<std::array<int32_t, 3>> const& values) override;
  void EndFixedVectorImpl() override;
  void CloseImpl() override;
};

// Binary reader for the Streams protocol.
class StreamsReader : public test_model::StreamsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  StreamsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadIntDataImpl(int32_t& value) override;
  bool ReadIntDataImpl(std::vector<int32_t>& values) override;
  bool ReadOptionalIntDataImpl(std::optional<int32_t>& value) override;
  bool ReadOptionalIntDataImpl(std::vector<std::optional<int32_t>>& values) override;
  bool ReadRecordWithOptionalVectorDataImpl(test_model::RecordWithOptionalVector& value) override;
  bool ReadRecordWithOptionalVectorDataImpl(std::vector<test_model::RecordWithOptionalVector>& values) override;
  bool ReadFixedVectorImpl(std::array<int32_t, 3>& value) override;
  bool ReadFixedVectorImpl(std::vector<std::array<int32_t, 3>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the FixedArrays protocol.
class FixedArraysWriter : public test_model::FixedArraysWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  FixedArraysWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntsImpl(yardl::FixedNDArray<int32_t, 2, 3> const& value) override;
  void WriteFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2> const& value) override;
  void WriteFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2> const& value) override;
  void WriteRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays const& value) override;
  void WriteNamedArrayImpl(test_model::NamedFixedNDArray const& value) override;
  void CloseImpl() override;
};

// Binary reader for the FixedArrays protocol.
class FixedArraysReader : public test_model::FixedArraysReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  FixedArraysReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntsImpl(yardl::FixedNDArray<int32_t, 2, 3>& value) override;
  void ReadFixedSimpleRecordArrayImpl(yardl::FixedNDArray<test_model::SimpleRecord, 3, 2>& value) override;
  void ReadFixedRecordWithVlensArrayImpl(yardl::FixedNDArray<test_model::RecordWithVlens, 2, 2>& value) override;
  void ReadRecordWithFixedArraysImpl(test_model::RecordWithFixedArrays& value) override;
  void ReadNamedArrayImpl(test_model::NamedFixedNDArray& value) override;
  void CloseImpl() override;
};

// Binary writer for the NDArrays protocol.
class NDArraysWriter : public test_model::NDArraysWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  NDArraysWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntsImpl(yardl::NDArray<int32_t, 2> const& value) override;
  void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2> const& value) override;
  void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2> const& value) override;
  void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArrays const& value) override;
  void WriteNamedArrayImpl(test_model::NamedNDArray const& value) override;
  void CloseImpl() override;
};

// Binary reader for the NDArrays protocol.
class NDArraysReader : public test_model::NDArraysReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  NDArraysReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntsImpl(yardl::NDArray<int32_t, 2>& value) override;
  void ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 2>& value) override;
  void ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 2>& value) override;
  void ReadRecordWithNDArraysImpl(test_model::RecordWithNDArrays& value) override;
  void ReadNamedArrayImpl(test_model::NamedNDArray& value) override;
  void CloseImpl() override;
};

// Binary writer for the NDArraysSingleDimension protocol.
class NDArraysSingleDimensionWriter : public test_model::NDArraysSingleDimensionWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  NDArraysSingleDimensionWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntsImpl(yardl::NDArray<int32_t, 1> const& value) override;
  void WriteSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1> const& value) override;
  void WriteRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1> const& value) override;
  void WriteRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension const& value) override;
  void CloseImpl() override;
};

// Binary reader for the NDArraysSingleDimension protocol.
class NDArraysSingleDimensionReader : public test_model::NDArraysSingleDimensionReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  NDArraysSingleDimensionReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntsImpl(yardl::NDArray<int32_t, 1>& value) override;
  void ReadSimpleRecordArrayImpl(yardl::NDArray<test_model::SimpleRecord, 1>& value) override;
  void ReadRecordWithVlensArrayImpl(yardl::NDArray<test_model::RecordWithVlens, 1>& value) override;
  void ReadRecordWithNDArraysImpl(test_model::RecordWithNDArraysSingleDimension& value) override;
  void CloseImpl() override;
};

// Binary writer for the DynamicNDArrays protocol.
class DynamicNDArraysWriter : public test_model::DynamicNDArraysWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  DynamicNDArraysWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntsImpl(yardl::DynamicNDArray<int32_t> const& value) override;
  void WriteSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord> const& value) override;
  void WriteRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens> const& value) override;
  void WriteRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays const& value) override;
  void CloseImpl() override;
};

// Binary reader for the DynamicNDArrays protocol.
class DynamicNDArraysReader : public test_model::DynamicNDArraysReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  DynamicNDArraysReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntsImpl(yardl::DynamicNDArray<int32_t>& value) override;
  void ReadSimpleRecordArrayImpl(yardl::DynamicNDArray<test_model::SimpleRecord>& value) override;
  void ReadRecordWithVlensArrayImpl(yardl::DynamicNDArray<test_model::RecordWithVlens>& value) override;
  void ReadRecordWithDynamicNDArraysImpl(test_model::RecordWithDynamicNDArrays& value) override;
  void CloseImpl() override;
};

// Binary writer for the Maps protocol.
class MapsWriter : public test_model::MapsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  MapsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteStringToIntImpl(std::unordered_map<std::string, int32_t> const& value) override;
  void WriteStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>> const& value) override;
  void WriteAliasedGenericImpl(test_model::AliasedMap<std::string, int32_t> const& value) override;
  void CloseImpl() override;
};

// Binary reader for the Maps protocol.
class MapsReader : public test_model::MapsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  MapsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadStringToIntImpl(std::unordered_map<std::string, int32_t>& value) override;
  void ReadStringToUnionImpl(std::unordered_map<std::string, std::variant<std::string, int32_t>>& value) override;
  void ReadAliasedGenericImpl(test_model::AliasedMap<std::string, int32_t>& value) override;
  void CloseImpl() override;
};

// Binary writer for the Unions protocol.
class UnionsWriter : public test_model::UnionsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  UnionsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) override;
  void WriteIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens> const& value) override;
  void WriteMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override;
  void CloseImpl() override;
};

// Binary reader for the Unions protocol.
class UnionsReader : public test_model::UnionsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  UnionsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) override;
  void ReadIntOrRecordWithVlensImpl(std::variant<int32_t, test_model::RecordWithVlens>& value) override;
  void ReadMonosotateOrIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) override;
  void CloseImpl() override;
};

// Binary writer for the StreamsOfUnions protocol.
class StreamsOfUnionsWriter : public test_model::StreamsOfUnionsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  StreamsOfUnionsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord> const& value) override;
  void WriteIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>> const& values) override;
  void EndIntOrSimpleRecordImpl() override;
  void WriteNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord> const& value) override;
  void WriteNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>> const& values) override;
  void EndNullableIntOrSimpleRecordImpl() override;
  void CloseImpl() override;
};

// Binary reader for the StreamsOfUnions protocol.
class StreamsOfUnionsReader : public test_model::StreamsOfUnionsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  StreamsOfUnionsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadIntOrSimpleRecordImpl(std::variant<int32_t, test_model::SimpleRecord>& value) override;
  bool ReadIntOrSimpleRecordImpl(std::vector<std::variant<int32_t, test_model::SimpleRecord>>& values) override;
  bool ReadNullableIntOrSimpleRecordImpl(std::variant<std::monostate, int32_t, test_model::SimpleRecord>& value) override;
  bool ReadNullableIntOrSimpleRecordImpl(std::vector<std::variant<std::monostate, int32_t, test_model::SimpleRecord>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the Enums protocol.
class EnumsWriter : public test_model::EnumsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  EnumsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteSingleImpl(test_model::Fruits const& value) override;
  void WriteVecImpl(std::vector<test_model::Fruits> const& value) override;
  void WriteSizeImpl(test_model::SizeBasedEnum const& value) override;
  void CloseImpl() override;
};

// Binary reader for the Enums protocol.
class EnumsReader : public test_model::EnumsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  EnumsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadSingleImpl(test_model::Fruits& value) override;
  void ReadVecImpl(std::vector<test_model::Fruits>& value) override;
  void ReadSizeImpl(test_model::SizeBasedEnum& value) override;
  void CloseImpl() override;
};

// Binary writer for the StateTest protocol.
class StateTestWriter : public test_model::StateTestWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  StateTestWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteAnIntImpl(int32_t const& value) override;
  void WriteAStreamImpl(int32_t const& value) override;
  void WriteAStreamImpl(std::vector<int32_t> const& values) override;
  void EndAStreamImpl() override;
  void WriteAnotherIntImpl(int32_t const& value) override;
  void CloseImpl() override;
};

// Binary reader for the StateTest protocol.
class StateTestReader : public test_model::StateTestReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  StateTestReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadAnIntImpl(int32_t& value) override;
  bool ReadAStreamImpl(int32_t& value) override;
  bool ReadAStreamImpl(std::vector<int32_t>& values) override;
  void ReadAnotherIntImpl(int32_t& value) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the SimpleGenerics protocol.
class SimpleGenericsWriter : public test_model::SimpleGenericsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  SimpleGenericsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteFloatImageImpl(test_model::Image<float> const& value) override;
  void WriteIntImageImpl(test_model::Image<int32_t> const& value) override;
  void WriteIntImageAlternateSyntaxImpl(test_model::Image<int32_t> const& value) override;
  void WriteStringImageImpl(test_model::Image<std::string> const& value) override;
  void WriteIntFloatTupleImpl(test_model::MyTuple<int32_t, float> const& value) override;
  void WriteFloatFloatTupleImpl(test_model::MyTuple<float, float> const& value) override;
  void WriteIntFloatTupleAlternateSyntaxImpl(test_model::MyTuple<int32_t, float> const& value) override;
  void WriteIntStringTupleImpl(test_model::MyTuple<int32_t, std::string> const& value) override;
  void WriteStreamOfTypeVariantsImpl(std::variant<test_model::Image<float>, test_model::Image<double>> const& value) override;
  void WriteStreamOfTypeVariantsImpl(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>> const& values) override;
  void EndStreamOfTypeVariantsImpl() override;
  void CloseImpl() override;
};

// Binary reader for the SimpleGenerics protocol.
class SimpleGenericsReader : public test_model::SimpleGenericsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  SimpleGenericsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadFloatImageImpl(test_model::Image<float>& value) override;
  void ReadIntImageImpl(test_model::Image<int32_t>& value) override;
  void ReadIntImageAlternateSyntaxImpl(test_model::Image<int32_t>& value) override;
  void ReadStringImageImpl(test_model::Image<std::string>& value) override;
  void ReadIntFloatTupleImpl(test_model::MyTuple<int32_t, float>& value) override;
  void ReadFloatFloatTupleImpl(test_model::MyTuple<float, float>& value) override;
  void ReadIntFloatTupleAlternateSyntaxImpl(test_model::MyTuple<int32_t, float>& value) override;
  void ReadIntStringTupleImpl(test_model::MyTuple<int32_t, std::string>& value) override;
  bool ReadStreamOfTypeVariantsImpl(std::variant<test_model::Image<float>, test_model::Image<double>>& value) override;
  bool ReadStreamOfTypeVariantsImpl(std::vector<std::variant<test_model::Image<float>, test_model::Image<double>>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the AdvancedGenerics protocol.
class AdvancedGenericsWriter : public test_model::AdvancedGenericsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  AdvancedGenericsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntImageImageImpl(test_model::Image<test_model::Image<float>> const& value) override;
  void WriteGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string> const& value) override;
  void WriteTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override;
  void WriteTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>> const& value) override;
  void WriteTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>> const& value) override;
  void CloseImpl() override;
};

// Binary reader for the AdvancedGenerics protocol.
class AdvancedGenericsReader : public test_model::AdvancedGenericsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  AdvancedGenericsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadIntImageImageImpl(test_model::Image<test_model::Image<float>>& value) override;
  void ReadGenericRecord1Impl(test_model::GenericRecord<int32_t, std::string>& value) override;
  void ReadTupleOfOptionalsImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) override;
  void ReadTupleOfOptionalsAlternateSyntaxImpl(test_model::MyTuple<std::optional<int32_t>, std::optional<std::string>>& value) override;
  void ReadTupleOfVectorsImpl(test_model::MyTuple<std::vector<int32_t>, std::vector<float>>& value) override;
  void CloseImpl() override;
};

// Binary writer for the Aliases protocol.
class AliasesWriter : public test_model::AliasesWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  AliasesWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteAliasedStringImpl(test_model::AliasedString const& value) override;
  void WriteAliasedEnumImpl(test_model::AliasedEnum const& value) override;
  void WriteAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum> const& value) override;
  void WriteAliasedClosedGenericImpl(test_model::AliasedClosedGeneric const& value) override;
  void WriteAliasedOptionalImpl(test_model::AliasedOptional const& value) override;
  void WriteAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float> const& value) override;
  void WriteAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override;
  void WriteAliasedGenericVectorImpl(test_model::AliasedGenericVector<float> const& value) override;
  void WriteAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float> const& value) override;
  void WriteStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum> const& value) override;
  void WriteStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>> const& values) override;
  void EndStreamOfAliasedGenericUnion2Impl() override;
  void CloseImpl() override;
};

// Binary reader for the Aliases protocol.
class AliasesReader : public test_model::AliasesReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  AliasesReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadAliasedStringImpl(test_model::AliasedString& value) override;
  void ReadAliasedEnumImpl(test_model::AliasedEnum& value) override;
  void ReadAliasedOpenGenericImpl(test_model::AliasedOpenGeneric<test_model::AliasedString, test_model::AliasedEnum>& value) override;
  void ReadAliasedClosedGenericImpl(test_model::AliasedClosedGeneric& value) override;
  void ReadAliasedOptionalImpl(test_model::AliasedOptional& value) override;
  void ReadAliasedGenericOptionalImpl(test_model::AliasedGenericOptional<float>& value) override;
  void ReadAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) override;
  void ReadAliasedGenericVectorImpl(test_model::AliasedGenericVector<float>& value) override;
  void ReadAliasedGenericFixedVectorImpl(test_model::AliasedGenericFixedVector<float>& value) override;
  bool ReadStreamOfAliasedGenericUnion2Impl(test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>& value) override;
  bool ReadStreamOfAliasedGenericUnion2Impl(std::vector<test_model::AliasedGenericUnion2<test_model::AliasedString, test_model::AliasedEnum>>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the StreamsOfAliasedUnions protocol.
class StreamsOfAliasedUnionsWriter : public test_model::StreamsOfAliasedUnionsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  StreamsOfAliasedUnionsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord const& value) override;
  void WriteIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord> const& values) override;
  void EndIntOrSimpleRecordImpl() override;
  void WriteNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord const& value) override;
  void WriteNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord> const& values) override;
  void EndNullableIntOrSimpleRecordImpl() override;
  void CloseImpl() override;
};

// Binary reader for the StreamsOfAliasedUnions protocol.
class StreamsOfAliasedUnionsReader : public test_model::StreamsOfAliasedUnionsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  StreamsOfAliasedUnionsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadIntOrSimpleRecordImpl(test_model::AliasedIntOrSimpleRecord& value) override;
  bool ReadIntOrSimpleRecordImpl(std::vector<test_model::AliasedIntOrSimpleRecord>& values) override;
  bool ReadNullableIntOrSimpleRecordImpl(test_model::AliasedNullableIntSimpleRecord& value) override;
  bool ReadNullableIntOrSimpleRecordImpl(std::vector<test_model::AliasedNullableIntSimpleRecord>& values) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

// Binary writer for the ProtocolWithComputedFields protocol.
class ProtocolWithComputedFieldsWriter : public test_model::ProtocolWithComputedFieldsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  ProtocolWithComputedFieldsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields const& value) override;
  void CloseImpl() override;
};

// Binary reader for the ProtocolWithComputedFields protocol.
class ProtocolWithComputedFieldsReader : public test_model::ProtocolWithComputedFieldsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  ProtocolWithComputedFieldsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  void ReadRecordWithComputedFieldsImpl(test_model::RecordWithComputedFields& value) override;
  void CloseImpl() override;
};

// Binary writer for the ProtocolWithKeywordSteps protocol.
class ProtocolWithKeywordStepsWriter : public test_model::ProtocolWithKeywordStepsWriterBase, yardl::binary::BinaryWriter {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::ostream.
  template <typename TStreamArg>
  ProtocolWithKeywordStepsWriter(TStreamArg&& stream_arg)
      : yardl::binary::BinaryWriter(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  void Flush() override;

  protected:
  void WriteIntImpl(test_model::RecordWithKeywordFields const& value) override;
  void WriteIntImpl(std::vector<test_model::RecordWithKeywordFields> const& values) override;
  void EndIntImpl() override;
  void WriteFloatImpl(test_model::EnumWithKeywordSymbols const& value) override;
  void CloseImpl() override;
};

// Binary reader for the ProtocolWithKeywordSteps protocol.
class ProtocolWithKeywordStepsReader : public test_model::ProtocolWithKeywordStepsReaderBase, yardl::binary::BinaryReader {
  public:
  // The stream_arg parameter can either be a std::string filename
  // or a reference, std::unique_ptr, or std::shared_ptr to a stream-like object, such as std::istream.
  template <typename TStreamArg>
  ProtocolWithKeywordStepsReader(TStreamArg&& stream_arg)
      : yardl::binary::BinaryReader(std::forward<TStreamArg>(stream_arg), schema_) {
  }

  protected:
  bool ReadIntImpl(test_model::RecordWithKeywordFields& value) override;
  bool ReadIntImpl(std::vector<test_model::RecordWithKeywordFields>& values) override;
  void ReadFloatImpl(test_model::EnumWithKeywordSymbols& value) override;
  void CloseImpl() override;

  private:
  size_t current_block_remaining_ = 0;
};

}
