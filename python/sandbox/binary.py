# This file was generated by the "yardl" tool. DO NOT EDIT.


import abc
import collections.abc
import datetime
import typing
import numpy as np

from . import *
from . import _binary
from . import yardl_types as yardl

class BinaryP1Writer(P1WriterBase, _binary.BinaryProtocolWriter):
    """Binary writer for the P1 protocol."""

    def __init__(self, stream: typing.BinaryIO | str) -> None:
        P1WriterBase.__init__(self)
        _binary.BinaryProtocolWriter.__init__(self, stream, P1WriterBase.schema)

    def _write_an_int(self, value: yardl.UInt32) -> None:
        _binary.write_uint32(self._stream, value)

    def _write_a_stream(self, value: collections.abc.Iterable[yardl.Int32]) -> None:
        _binary.StreamWriter(_binary.write_int32)(self._stream, value)

    def _write_optional(self, value: yardl.Int32 | None) -> None:
        _binary.OptionalWriter(_binary.write_int32)(self._stream, value)

    def _write_union(self, value: yardl.Int32 | yardl.UInt32 | None) -> None:
        _binary.UnionWriter([(None.__class__, _binary.write_none), (yardl.Int32, _binary.write_int32), (yardl.UInt32, _binary.write_uint32)])(self._stream, value)

    def _write_date(self, value: yardl.Date) -> None:
        _binary.write_date(self._stream, value)

    def _write_flag(self, value: MyFlags) -> None:
        _binary.EnumWriter(_binary.write_uint32)(self._stream, value)


class BinaryP1Reader(P1ReaderBase):
    """Binary writer for the P1 protocol."""

    def _read_an_int(self) -> yardl.UInt32:
        raise NotImplementedError()

    def _read_a_stream(self) -> collections.abc.Iterable[yardl.Int32]:
        raise NotImplementedError()

    def _read_optional(self) -> yardl.Int32 | None:
        raise NotImplementedError()

    def _read_union(self) -> yardl.Int32 | yardl.UInt32 | None:
        raise NotImplementedError()

    def _read_date(self) -> yardl.Date:
        raise NotImplementedError()

    def _read_flag(self) -> MyFlags:
        raise NotImplementedError()

