# This file was generated by the "yardl" tool. DO NOT EDIT.

import datetime
import enum
import types
import typing

import numpy as np
import numpy.typing as npt

from .. import yardl_types as yardl
from .. import _dtypes

from .. import tuples
from ..tuples.types import *

K = typing.TypeVar("K")
K_NP = typing.TypeVar("K_NP", bound=np.generic)
V = typing.TypeVar("V")
V_NP = typing.TypeVar("V_NP", bound=np.generic)
T1 = typing.TypeVar("T1")
T1_NP = typing.TypeVar("T1_NP", bound=np.generic)
T2 = typing.TypeVar("T2")
T2_NP = typing.TypeVar("T2_NP", bound=np.generic)
T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)
T0 = typing.TypeVar("T0")
T0_NP = typing.TypeVar("T0_NP", bound=np.generic)


class Fruits(yardl.OutOfRangeEnum):
    APPLE = 0
    BANANA = 1
    PEAR = 2

class DaysOfWeek(enum.IntFlag):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 4
    THURSDAY = 8
    FRIDAY = 16
    SATURDAY = 32
    SUNDAY = 64

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DaysOfWeek) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

    __str__ = enum.Flag.__str__ # type: ignore

class TextFormat(enum.IntFlag):
    REGULAR = 0
    BOLD = 1
    ITALIC = 2
    UNDERLINE = 4
    STRIKETHROUGH = 8

    def __eq__(self, other: object) -> bool:
        return isinstance(other, TextFormat) and self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)

    __str__ = enum.Flag.__str__ # type: ignore

AliasedMap = dict[K, V]

MyTuple = tuples.Tuple[T1, T2]

_T = typing.TypeVar('_T')

class GenericUnion2(typing.Generic[T1, T2]):
    T1: type["GenericUnion2UnionCase[T1, T2, T1]"]
    T2: type["GenericUnion2UnionCase[T1, T2, T2]"]

class GenericUnion2UnionCase(GenericUnion2[T1, T2], yardl.UnionCase[_T]):
    pass

GenericUnion2.T1 = type("GenericUnion2.T1", (GenericUnion2UnionCase,), {"_index": 0, "_tag": "T1"})
GenericUnion2.T2 = type("GenericUnion2.T2", (GenericUnion2UnionCase,), {"_index": 1, "_tag": "T2"})
del GenericUnion2UnionCase

GenericVector = list[T]

class Int32OrString:
    Int32: typing.ClassVar[type["Int32OrStringUnionCase[yardl.Int32]"]]
    String: typing.ClassVar[type["Int32OrStringUnionCase[str]"]]

class Int32OrStringUnionCase(Int32OrString, yardl.UnionCase[_T]):
    pass

Int32OrString.Int32 = type("Int32OrString.Int32", (Int32OrStringUnionCase,), {"_index": 0, "_tag": "int32"})
Int32OrString.String = type("Int32OrString.String", (Int32OrStringUnionCase,), {"_index": 1, "_tag": "string"})
del Int32OrStringUnionCase

class TimeOrDatetime:
    Time: typing.ClassVar[type["TimeOrDatetimeUnionCase[yardl.Time]"]]
    Datetime: typing.ClassVar[type["TimeOrDatetimeUnionCase[yardl.DateTime]"]]

class TimeOrDatetimeUnionCase(TimeOrDatetime, yardl.UnionCase[_T]):
    pass

TimeOrDatetime.Time = type("TimeOrDatetime.Time", (TimeOrDatetimeUnionCase,), {"_index": 0, "_tag": "time"})
TimeOrDatetime.Datetime = type("TimeOrDatetime.Datetime", (TimeOrDatetimeUnionCase,), {"_index": 1, "_tag": "datetime"})
del TimeOrDatetimeUnionCase

class RecordWithUnions:
    null_or_int_or_string: typing.Optional[Int32OrString]
    date_or_datetime: TimeOrDatetime

    def __init__(self, *,
        null_or_int_or_string: typing.Optional[Int32OrString] = None,
        date_or_datetime: TimeOrDatetime = TimeOrDatetime.Time(yardl.Time()),
    ):
        self.null_or_int_or_string = null_or_int_or_string
        self.date_or_datetime = date_or_datetime

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RecordWithUnions)
            and self.null_or_int_or_string == other.null_or_int_or_string
            and self.date_or_datetime == other.date_or_datetime
        )

    def __str__(self) -> str:
        return f"RecordWithUnions(nullOrIntOrString={self.null_or_int_or_string}, dateOrDatetime={self.date_or_datetime})"

    def __repr__(self) -> str:
        return f"RecordWithUnions(nullOrIntOrString={repr(self.null_or_int_or_string)}, dateOrDatetime={repr(self.date_or_datetime)})"


class T0OrT1(typing.Generic[T0, T1]):
    T0: type["T0OrT1UnionCase[T0, T1, T0]"]
    T1: type["T0OrT1UnionCase[T0, T1, T1]"]

class T0OrT1UnionCase(T0OrT1[T0, T1], yardl.UnionCase[_T]):
    pass

T0OrT1.T0 = type("T0OrT1.T0", (T0OrT1UnionCase,), {"_index": 0, "_tag": "T0"})
T0OrT1.T1 = type("T0OrT1.T1", (T0OrT1UnionCase,), {"_index": 1, "_tag": "T1"})
del T0OrT1UnionCase

class GenericRecordWithComputedFields(typing.Generic[T0, T1]):
    f1: T0OrT1[T0, T1]

    def __init__(self, *,
        f1: T0OrT1[T0, T1],
    ):
        self.f1 = f1

    def type_index(self) -> yardl.UInt8:
        _var0 = self.f1
        if isinstance(_var0, T0OrT1.T0):
            return 0
        if isinstance(_var0, T0OrT1.T1):
            return 1
        raise RuntimeError("Unexpected union case")

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GenericRecordWithComputedFields)
            and yardl.structural_equal(self.f1, other.f1)
        )

    def __str__(self) -> str:
        return f"GenericRecordWithComputedFields(f1={self.f1})"

    def __repr__(self) -> str:
        return f"GenericRecordWithComputedFields(f1={repr(self.f1)})"


